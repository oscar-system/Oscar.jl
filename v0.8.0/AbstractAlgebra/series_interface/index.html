<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Series Ring Interface · Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to Oscar</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6" type="checkbox"/><label class="tocitem" for="menuitem-3-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Quadratic and hermitian spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Quadratic and hermitian lattices</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/serialization/">Saving and loading</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/visualization/">Visualization</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/free_modules/">Free Modules Over Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/modules/">Modules Over Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/affine_algebras/">Affine Algebras</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/binomial_ideals/">Binomial Primary Decomposition</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/localizations/">Localizations of commutative rings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-10-2" type="checkbox"/><label class="tocitem" for="menuitem-10-2"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-3" type="checkbox"/><label class="tocitem" for="menuitem-10-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ToricVarieties/intro/">Toric geometry in Julia</a></li><li><a class="tocitem" href="../../ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-4" type="checkbox"/><label class="tocitem" for="menuitem-10-4"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/AffineSchemes/">General schemes</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/build_documentation/">Building the OSCAR documentation</a></li><li><input class="collapse-toggle" id="menuitem-15-3" type="checkbox"/><label class="tocitem" for="menuitem-15-3"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Series Ring Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Series Ring Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/AbstractAlgebra/series_interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Series-Ring-Interface"><a class="docs-heading-anchor" href="#Series-Ring-Interface">Series Ring Interface</a><a id="Series-Ring-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Series-Ring-Interface" title="Permalink"></a></h1><p>Univariate power series rings are supported in AbstractAlgebra in a variety of different forms, including absolute and relative precision models and Laurent series.</p><p>In addition to the standard Ring interface, numerous additional functions are required to be present for power series rings.</p><h2 id="Types-and-parents"><a class="docs-heading-anchor" href="#Types-and-parents">Types and parents</a><a id="Types-and-parents-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-parents" title="Permalink"></a></h2><p>AbstractAlgebra provides two abstract types for power series rings and their elements:</p><ul><li><code>SeriesRing{T}</code> is the abstract type for all power series ring parent types</li><li><code>SeriesElem{T}</code> is the abstract type for all power series types</li></ul><p>We have that <code>SeriesRing{T} &lt;: Ring</code> and <code>SeriesElem{T} &lt;: RingElem</code>.</p><p>Note that both abstract types are parameterised. The type <code>T</code> should usually be the type of elements of the coefficient ring of the power series ring. For example, in the case of <span>$\mathbb{Z}[[x]]$</span> the type <code>T</code> would be the type of an integer, e.g. <code>BigInt</code>.</p><p>Within the <code>SeriesElem{T}</code> abstract type is the abstract type <code>RelSeriesElem{T}</code> for relative power series, and <code>AbsSeriesElem{T}</code> for absolute power series.</p><p>Relative series are typically stored with a valuation and a series that is either zero or that has nonzero constant term. Absolute series are stored starting from the constant term, even if it is zero.</p><p>If the parent object for a relative series ring over the bignum integers has type <code>MySeriesRing</code> and series in that ring have type <code>MySeries</code> then one would have:</p><ul><li><code>MySeriesRing &lt;: SeriesRing{BigInt}</code></li><li><code>MySeries &lt;: RelSeriesElem{BigInt}</code></li></ul><p>Series rings should be made unique on the system by caching parent objects (unless an optional <code>cache</code> parameter is set to <code>false</code>). Series rings should at least be distinguished based on their base (coefficient) ring. But if they have the same base ring and symbol (for their variable/generator) and same default precision, they should certainly have the same parent object.</p><p>See <code>src/generic/GenericTypes.jl</code> for an example of how to implement such a cache (which usually makes use of a dictionary).</p><h2 id="Required-functionality-for-series"><a class="docs-heading-anchor" href="#Required-functionality-for-series">Required functionality for series</a><a id="Required-functionality-for-series-1"></a><a class="docs-heading-anchor-permalink" href="#Required-functionality-for-series" title="Permalink"></a></h2><p>In addition to the required functionality for the Ring interface the Series Ring interface has the following required functions.</p><p>We suppose that <code>R</code> is a fictitious base ring (coefficient ring) and that <code>S</code> is a series ring over <code>R</code> (e.g. <span>$S = R[[x]]$</span>) with parent object <code>S</code> of type <code>MySeriesRing{T}</code>. We also assume the series in the ring have type <code>MySeries{T}</code>, where <code>T</code> is the type of elements of the base (coefficient) ring.</p><p>Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.</p><p>Note that the type <code>T</code> must (transitively) belong to the abstract type <code>RingElem</code>.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><p>In addition to the standard constructors, the following constructors, taking an array of coefficients, must be available.</p><p>For relative power series and Laurent series we have:</p><pre><code class="language-julia hljs">(S::MySeriesRing{T})(A::Vector{T}, len::Int, prec::Int, val::Int) where T &lt;: RingElem</code></pre><p>Create the series in the given ring whose valuation is <code>val</code>, whose absolute precision is given by <code>prec</code> and the coefficients of which are given by <code>A</code>, starting from the first nonzero term. Only <code>len</code> terms of the array are used, the remaining terms being ignored. The value <code>len</code> cannot exceed the length of the supplied array.</p><p>It is permitted to have trailing zeros in the array, but it is not needed, even if the precision minus the valuation is bigger than the length of the array.</p><pre><code class="language-julia hljs">(S::MySeriesRing{T})(A::Vector{U}, len::Int, prec::Int, val::Int) where {T &lt;: RingElem, U &lt;: RingElem}</code></pre><p>As above, but where the array is an array of coefficient that can be coerced into the base ring of the series ring.</p><pre><code class="language-julia hljs">(S::MySeriesRing{T})(A::Vector{U}, len::Int, prec::Int, val::Int) where {T &lt;: RingElem, U &lt;: Integer}</code></pre><p>As above, but where the array is an array of integers that can be coerced into the base ring of the series ring.</p><p>It may be desirable to implement an addition version which accepts an array of Julia <code>Int</code> values if this can be done more efficiently.</p><p>For absolute power series we have:</p><pre><code class="language-julia hljs">(S::MySeriesRing{T})(A::Vector{T}, len::Int, prec::Int) where T &lt;: RingElem</code></pre><p>Create the series in the given ring whose absolute precision is given by <code>prec</code> and the coefficients of which are given by <code>A</code>, starting from the constant term. Only <code>len</code> terms of the array are used, the remaining terms being ignored.</p><p>Note that <code>len</code> is usually maintained separately of any polynomial that is underlying the power series. This allows for easy trucation of a power series without actually modifying the polynomial underlying it.</p><p>It is permitted to have trailing zeros in the array, but it is not needed, even if the precision is bigger than the length of the array.</p><p>It is also possible to create series directly without having to create the corresponding series ring.</p><pre><code class="language-julia hljs">abs_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, var::AbstractString=&quot;x&quot;; max_precision::Int=prec, cached::Bool=true) where T
rel_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, val::Int, var::AbstractString=&quot;x&quot;; max_precision::Int=prec, cached::Bool=true) where T</code></pre><p>Create the power series over the given base ring <code>R</code> with coefficients specified by <code>arr</code> with the given absolute precision <code>prec</code> and in the case of relative series with the given valuation <code>val</code>.</p><p>Note that more coefficients may be specified than are actually used. Only the first <code>len</code> coefficients are made part of the series, the remainder being stored internally but ignored.</p><p>In the case of absolute series one must have <code>prec &gt;= len</code> and in the case of relative series one must have <code>prec &gt;= len + val</code>.</p><p>By default the series are created in a ring with variable <code>x</code> and <code>max_precision</code> equal to <code>prec</code>, however one may specify these directly to override the defaults. Note that series are only compatible if they have the same coefficient ring <code>R</code>, <code>max_precision</code> and variable string <code>var</code>.</p><p>Also by default any parent ring created is cached. If this behaviour is not desired, set <code>cached=false</code>. However, this means that subsequent series created in the same way will not be compatible. Instead, one should use the parent object of the first series to create subsequent series instead of calling this function repeatedly with cached=false.</p><h3 id="Data-type-and-parent-object-methods"><a class="docs-heading-anchor" href="#Data-type-and-parent-object-methods">Data type and parent object methods</a><a id="Data-type-and-parent-object-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Data-type-and-parent-object-methods" title="Permalink"></a></h3><pre><code class="language-julia hljs">var(S::MySeriesRing{T}) where T &lt;: RingElem</code></pre><p>Return a <code>Symbol</code> representing the variable (generator) of the series ring. Note that this is a <code>Symbol</code> not a <code>String</code>, though its string value will usually be used when printing series.</p><p>Custom series types over a given ring should define one of the following functions which return the type of an absolute or relative series object over that ring.</p><pre><code class="language-julia hljs">abs_series_type(::Type{T}) where T &lt;: RingElement
rel_series_type(::Type{T}) where T &lt;: RingElement</code></pre><p>Return the type of a series whose coefficients have the given type.</p><p>This function is defined for generic series and only needs to be defined for custom series rings, e.g. ones defined by a C implementation.</p><pre><code class="language-julia hljs">max_precision(S::MySeriesRing{T}) where T &lt;: RingElem</code></pre><p>Return the (default) maximum precision of the power series ring. This is the precision that the output of an operation will be if it cannot be represented to full precision (e.g. because it mathematically has infinite precision).</p><p>This value is usually supplied upon creation of the series ring and stored in the ring. It is independent of the precision which each series in the ring actually has. Those are stored on a per element basis in the actual series elements.</p><h3 id="Basic-manipulation-of-rings-and-elements"><a class="docs-heading-anchor" href="#Basic-manipulation-of-rings-and-elements">Basic manipulation of rings and elements</a><a id="Basic-manipulation-of-rings-and-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation-of-rings-and-elements" title="Permalink"></a></h3><pre><code class="language-julia hljs">pol_length(f::MySeries{T}) where T &lt;: RingElem</code></pre><p>Return the length of the polynomial underlying the given power series. This is not generally useful to the user, but is used internally.</p><pre><code class="language-julia hljs">set_length!(f::MySeries{T}, n::Int) where T &lt;: RingElem</code></pre><p>This function sets the effective length of the polynomial underlying the given series. The function doesn&#39;t modify the actual polynomial, but simply changes the number of terms of the polynomial which are considered to belong to the power series. The remaining terms are ignored.</p><p>This function cannot set the length to a value greater than the length of any underlying polynomial.</p><p>The function mutates the series in-place but does not return the mutated series.</p><pre><code class="language-julia hljs">precision(f::MySeries{T})</code></pre><p>Return the absolute precision of <span>$f$</span>.</p><pre><code class="language-julia hljs">set_precision!(f::MySeries{T}, prec::Int)</code></pre><p>Set the absolute precision of the given series to the given value.</p><p>This return the updated series.</p><pre><code class="language-julia hljs">valuation(f::MySeries{T})</code></pre><p>Return the valuation of the given series.</p><pre><code class="language-julia hljs">set_valuation!(f::MySeries{T}, val::Int)</code></pre><p>For relative series and Laurent series only, this function alters the valuation of the given series to the given value.</p><p>This function returns the updated series.</p><pre><code class="language-julia hljs">polcoeff(f::MySeries{T}, n::Int)</code></pre><p>Return the coefficient of degree <code>n</code> of the polynomial underlying the series. If <code>n</code> is larger than the degree of this polynomial, zero is returned. This function is not generally of use to the user but is used internally.</p><pre><code class="language-julia hljs">setcoeff!(f::MySeries{T}, n::Int, a::T) where T &lt;: RingElem</code></pre><p>Set the degree <span>$n$</span> coefficient of the polynomial underlying <span>$f$</span> to <span>$a$</span>. This mutates the polynomial in-place if possible and returns the mutated series (so that immutable types can also be supported). The function must not assume that the polynomial already has space for <span>$n + 1$</span> coefficients. The polynomial must be resized if this is not the case.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is not required to normalise the polynomial and is not necessarily useful to the user, but is used extensively by the generic functionality in AbstractAlgebra.jl. It is for setting raw coefficients in the representation.</p></div></div><pre><code class="language-julia hljs">normalise(f::MySeries{T}, n::Int)</code></pre><p>Given a series <span>$f$</span> represented by a polynomial of at least the given length, return the normalised length of the underlying polynomial assuming it has length at most <span>$n$</span>. This function does not actually normalise the polynomial and is not particularly useful to the user. It is used internally.</p><pre><code class="language-julia hljs">renormalize!(f::MySeries{T}) where T &lt;: RingElem</code></pre><p>Given a relative series or Laurent series whose underlying polynomial has zero constant term, say as the result of some internal computation, renormalise the series so that the polynomial has nonzero constant term. The precision and valuation of the series are adjusted to compensate. This function is not intended to be useful to the user, but is used internally.</p><pre><code class="language-julia hljs">fit!(f::MySeries{T}, n::Int) where T &lt;: RingElem</code></pre><p>Ensure that the polynomial underlying <span>$f$</span> internally has space for <span>$n$</span> coefficients. This function must mutate the series in-place if it is mutable. It does not return the mutated series. Immutable types can still be supported by defining this function to do nothing.</p><p>Some interfaces for C polynomial types automatically manage the internal allocation of polynomials in every function that can be called on them. Explicit adjustment by the generic code in AbstractAlgebra.jl is not required. In such cases, this function can also be defined to do nothing.</p><pre><code class="language-julia hljs">gen(R::MySeriesRing{T}) where T &lt;: RingElem</code></pre><p>Return the generator <code>x</code> of the series ring.</p><h2 id="Optional-functionality-for-series"><a class="docs-heading-anchor" href="#Optional-functionality-for-series">Optional functionality for series</a><a id="Optional-functionality-for-series-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-functionality-for-series" title="Permalink"></a></h2><h3 id="Similar-and-zero"><a class="docs-heading-anchor" href="#Similar-and-zero">Similar and zero</a><a id="Similar-and-zero-1"></a><a class="docs-heading-anchor-permalink" href="#Similar-and-zero" title="Permalink"></a></h3><p>The following functions are available for all absolute and relative series types. The functions <code>similar</code> and <code>zero</code> do the same thing, but are provided for uniformity with other parts of the interface.</p><pre><code class="language-julia hljs">similar(x::MySeries, R::Ring, max_prec::Int, var::Symbol=var(parent(x)); cached::Bool=true)
zero(a::MySeries, R::Ring, max_prec::Int, var::Symbol=var(parent(a)); cached::Bool=true)</code></pre><p>Construct the zero series with the given variable (if specified), coefficients in the specified coefficient ring and with relative/absolute precision cap on its parent ring as given by <code>max_prec</code>.</p><pre><code class="language-julia hljs">similar(x::MySeries, R::Ring, var::Symbol=var(parent(x)); cached::Bool=true)
similar(x::MySeries, max_prec::Int, var::Symbol=var(parent(x)); cached::Bool=true)
similar(x::MySeries, var::Symbol=var(parent(x)); cached::Bool=true)
similar(x::MySeries, R::Ring, max_prec::Int, var::String; cached::Bool=true)
similar(x::MySeries, R::Ring, var::String; cached::Bool=true)
similar(x::MySeries, max_prec::Int, var::String; cached::Bool=true)
similar(x::MySeries, var::String; cached::Bool=true)
zero(x::MySeries, R::Ring, var::Symbol=var(parent(x)); cached::Bool=true)
zero(x::MySeries, max_prec::Int, var::Symbol=var(parent(x)); cached::Bool=true)
zero(x::MySeries, var::Symbol=var(parent(x)); cached::Bool=true)
zero(x::MySeries, R::Ring, max_prec::Int, var::String; cached::Bool=true)
zero(x::MySeries, R::Ring, var::String; cached::Bool=true)
zero(x::MySeries, max_prec::Int, var::String; cached::Bool=true)
zero(x::MySeries, var::String; cached::Bool=true)</code></pre><p>As above, but use the precision cap of the parent ring of <code>x</code> and the <code>base_ring</code> of <code>x</code> if these are not specified.</p><p>Custom series rings may choose which series type is best-suited to return for the given coefficient ring, precision cap and variable, however they should return a series with the same model as <code>x</code>, i.e. relative or series.</p><p>If custom implementations don&#39;t specialise these function the default return type is a <code>Generic.AbsSeries</code> or <code>Generic.RelSeries</code>.</p><p>The default implementation of zero calls out to similar, so it&#39;s generally sufficient to specialise only similar. For both similar and zero only the most general method has to be implemented as all other methods call out to this more general method.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Saturday 5 February 2022 15:47">Saturday 5 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
