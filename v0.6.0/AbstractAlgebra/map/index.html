<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Maps · Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to Oscar</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6" type="checkbox"/><label class="tocitem" for="menuitem-3-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Basics</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Quadratic and hermitian lattices</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/pg/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/pg_polyhedra_intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/pg_polyhedra_constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/pg_polyhedra_polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/pg_polyhedra_serialization/">Saving and loading</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/pg_cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/pg_fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/pg_linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/pg_subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/ca/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_rings/">Creating Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_ideals/">Ideals in Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_modules/">Modules Over Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_quotient_rings/">Quotient Rings of Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_affine_algebras/">Affine Algebras</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/it/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/it_fg/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/it_lrg/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Maps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Maps</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/AbstractAlgebra/map.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Maps"><a class="docs-heading-anchor" href="#Maps">Maps</a><a id="Maps-1"></a><a class="docs-heading-anchor-permalink" href="#Maps" title="Permalink"></a></h1><p>Maps in AbstractAlgebra can be constructed from Julia functions, or they can be represented by some other kind of data, e.g. a matrix, or built up from other maps.</p><p>In the following, we will always use the word &quot;function&quot; to mean a Julia function, and reserve the word &quot;map&quot; for a map on sets, whether mathematically, or as an object in the system.</p><h2 id="Parent-objects"><a class="docs-heading-anchor" href="#Parent-objects">Parent objects</a><a id="Parent-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-objects" title="Permalink"></a></h2><p>Maps in AbstractAlgebra currently don&#39;t have parents.</p><h2 id="Map-classes"><a class="docs-heading-anchor" href="#Map-classes">Map classes</a><a id="Map-classes-1"></a><a class="docs-heading-anchor-permalink" href="#Map-classes" title="Permalink"></a></h2><p>Each map in AbstractAlgebra has a map class. Currently the supported map classes are <code>SetMap</code> which is at the root of the tree of map classes and <code>FunctionalMap</code> for maps which are built on Julia functions and <code>IdentityMap</code>.</p><p>Other map classes can be added by inheriting from one of these. A map class is in practice nothing more than a Julia abstract type.</p><p>One might naturally assume that map types belong directly to these classes in the way that types of other objects in the system belong to abstract types in the AbstractAlgebra type hierarchy. However, in order to provide an extensible system, this is not the case.</p><p>Instead, a map type <code>MyMap</code> say will belong to an abstract type of the form <code>Map{D, C, T, MyMap}</code>, where <code>D</code> is the type of the object representing the domain of the map type (this can also be an abstract type, such as <code>Group</code>), <code>C</code> is the type of the object representing the codomain of the map type and <code>T</code> is the map class.</p><p>Firstly note that all maps in the system belong to the abstract type <code>Map</code>. Moreover, maps from a domain of type <code>D</code> to a codomain of type <code>C</code> all belong to <code>Map{D, C}</code>.</p><p>However, because a four parameter type system becomes quite cumbersome to use, we provide a number of functions for referring to maps by their map class or by their specific map type.</p><p>Maps with map class <code>FunctionalMap</code> all belong to <code>Map(FunctionalMap))</code>. One can also restrict the domain and codomain by writing <code>Map(FunctionalMap){D, C}</code>.</p><p>Finally, if a function should only work for a map of a the very specific map type <code>MyMap</code>, one writes <code>M::Map(MyMap))</code> or <code>M::Map(MyMap){D, C}</code> if one wishes to restrict the domain and codomain types.</p><h2 id="Implementing-new-map-types"><a class="docs-heading-anchor" href="#Implementing-new-map-types">Implementing new map types</a><a id="Implementing-new-map-types-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-new-map-types" title="Permalink"></a></h2><p>There are two common kinds of map type that developers will need to write. The first has a fixed domain and codomain, and the second is a type parameterised by the types of the domain and codomain. We give two simple examples here of how this might look.</p><p>In the case of fixed domain and codomain, e.g. <code>Integers{BigInt}</code>, we would write it as follows:</p><pre><code class="language-julia hljs">mutable struct MyMap &lt;: Map{Integers{BigInt}, Integers{BigInt}, SetMap, MyMap}
   # some data fields
end</code></pre><p>In the case of parameterisation by the type of the domain and codomain:</p><pre><code class="language-julia hljs">mutable struct MyMap{D, C} &lt;: Map{D, C, SetMap, MyMap}
   # some data fields
end</code></pre><h2 id="Getters-and-setters"><a class="docs-heading-anchor" href="#Getters-and-setters">Getters and setters</a><a id="Getters-and-setters-1"></a><a class="docs-heading-anchor-permalink" href="#Getters-and-setters" title="Permalink"></a></h2><p>When writing new map types, it is very important to define getters and setters of the fields of the new map type, rather than to access them directly.</p><p>Let us suppose that the <code>MyMap</code> type has a field called <code>foo</code>. Rather than access this field by writing <code>M.foo</code>, one must access it using <code>foo(M)</code>.</p><p>If such a getter only needs to access the field <code>foo</code> of <code>M</code>, there is a standard way of defining such a getter and setter when defining a new map type.</p><pre><code class="language-julia hljs">foo(M::Map(MyMap)) = get_field(M, :foo)</code></pre><p>To set a field of a map, one needs a setter, which can be implemented as follows:</p><pre><code class="language-julia hljs">set_foo!(M::Map(MyMap), a) = set_field(M, :foo, a)</code></pre><h2 id="Map-functions"><a class="docs-heading-anchor" href="#Map-functions">Map functions</a><a id="Map-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Map-functions" title="Permalink"></a></h2><pre><code class="language-julia hljs">domain(M::Map(MyMap))
codomain(M::Map(MyMap))</code></pre><p>Return the domain and codomain parent objects respectively, for the map <span>$M$</span>.</p><p>All maps can be applied to elements in the domain.</p><pre><code class="language-julia hljs">(M::Map(MyMap)(a))</code></pre><p>Apply the map <code>M</code> to the element <code>a</code> of the domain of <code>M</code>.</p><h3 id="Identity-maps"><a class="docs-heading-anchor" href="#Identity-maps">Identity maps</a><a id="Identity-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Identity-maps" title="Permalink"></a></h3><p>There is a concrete map type <code>Generic.IdentityMap{D}</code> for the identity map on a given domain. Here <code>D</code> is the type of the object representing that domain.</p><p><code>Generic.IdentityMap</code> belongs to the map type <code>Map{D, C, AbstractAlgebra.IdentityMap, IdentityMap}</code>.</p><p>An identity map has the property that when composed with any map whose domain or codomain is compatible, that map will be returned as the composition. Identity maps can therefore serve as a starting point when building up a composition of maps, starting an identity map.</p><p>To construct an identity map for a given domain, specified by a parent object <code>R</code>, say, we have the following function.</p><pre><code class="language-julia hljs">identity_map(R::Set)</code></pre><h3 id="Composition-of-maps"><a class="docs-heading-anchor" href="#Composition-of-maps">Composition of maps</a><a id="Composition-of-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Composition-of-maps" title="Permalink"></a></h3><p>Any two compatible maps in AbstractAlgebra can be composed and any composition can be applied.</p><p>To construct a composition map from two existing maps, we have the following function:</p><pre><code class="language-julia hljs">compose(f::Map{D, U}, g::Map{U, C}) where {D, U, C}</code></pre><p>As a shortcut for this function we have the following operator:</p><pre><code class="language-julia hljs">*(f::Map{D, U}, g::Map{U, C}) where {D, U, C} = compose(f, g)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Observe the order of composition. If we have maps <span>$f : X \to Y$</span>, <span>$g : Y \to Z$</span> the correct order of the maps in this operator is <code>f*g</code>, so that <code>(f*g)(x) = g(f(x))</code>.</p><p>This is chosen so that for left <span>$R$</span>-module morphisms represented by a matrix, the order of matrix multiplication will match the order of composition of the corresponding morphisms.</p></div></div></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Friday 13 August 2021 11:11">Friday 13 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
