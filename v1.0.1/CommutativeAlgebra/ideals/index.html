<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ideals in Multivariate Rings · Oscar.jl</title><meta name="title" content="Ideals in Multivariate Rings · Oscar.jl"/><meta property="og:title" content="Ideals in Multivariate Rings · Oscar.jl"/><meta property="twitter:title" content="Ideals in Multivariate Rings · Oscar.jl"/><meta name="description" content="Documentation for Oscar.jl."/><meta property="og:description" content="Documentation for Oscar.jl."/><meta property="twitter:description" content="Documentation for Oscar.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li><li><a class="tocitem" href="../../Nemo/algebraic/">Algebraic numbers</a></li><li><a class="tocitem" href="../../Fields/algebraic_closure_fp/">Algebraic closure of finite prime fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../NumberTheory/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox" checked/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../rings/">Creating Multivariate Rings</a></li><li class="is-active"><a class="tocitem" href>Ideals in Multivariate Rings</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Data-Associated-to-Ideals"><span>Data Associated to Ideals</span></a></li><li><a class="tocitem" href="#Operations-on-Ideals"><span>Operations on Ideals</span></a></li><li><a class="tocitem" href="#Tests-on-Ideals"><span>Tests on Ideals</span></a></li><li><a class="tocitem" href="#Decomposition-of-Ideals"><span>Decomposition of Ideals</span></a></li><li><a class="tocitem" href="#Homogenization-and-Dehomogenization"><span>Homogenization and Dehomogenization</span></a></li><li><a class="tocitem" href="#Ideals-as-Modules"><span>Ideals as Modules</span></a></li><li><a class="tocitem" href="#Generating-Special-Ideals"><span>Generating Special Ideals</span></a></li></ul></li><li><a class="tocitem" href="../affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li></ul></li><li><a class="tocitem" href="../homological_algebra/">Homological Algebra</a></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Gröbner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../GroebnerBases/groebner_bases/">Gröbner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../GroebnerBases/groebner_bases_integers/">Gröbner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-10" type="checkbox"/><label class="tocitem" for="menuitem-9-10"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/tori/">Invariants of Tori</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveringsAndGluings/">Coverings</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/">Morphisms of covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ProjectiveSchemes/">Projective schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/">Morphisms of projective schemes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Sheaf Cohomology</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/SheafCohomology/sheaf_cohomology/">Sheaves on Projective Space</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Algebraic Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/">Affine Algebraic Sets</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/">Projective Algebraic Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Algebraic Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/AlgebraicVarieties/AffineVariety/">Affine Varieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/">Projective Varieties</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Rational Points</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/RationalPoints/Affine/">Affine</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/RationalPoints/Projective/">Projective</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricSchemes/">Toric Schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricIdealSheaves/">Toric Ideal Sheaves (Experimental)</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/BlowdownMorphisms/">Toric Blowdown Morphisms (Experimental)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-8" type="checkbox"/><label class="tocitem" for="menuitem-11-8"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/AffinePlaneCurves/">Affine plane curves</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/ProjectiveCurves/">Projective Curves</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/ProjectivePlaneCurves/">Projective Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-9" type="checkbox"/><label class="tocitem" for="menuitem-11-9"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/K3Surfaces/">Automorphism Groups of  K3 surfaces</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/SurfacesP4/">Nongeneral Type Surfaces in <span>$\mathbb P^4$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-10" type="checkbox"/><label class="tocitem" for="menuitem-11-10"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Miscellaneous/miscellaneous/">Some Special Ideals</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../TropicalGeometry/semiring/">Tropical semirings, matrices, and polynomials</a></li><li><a class="tocitem" href="../../TropicalGeometry/semiring_map/">Tropical semiring maps</a></li><li><a class="tocitem" href="../../TropicalGeometry/variety/">Tropical varieties</a></li><li><a class="tocitem" href="../../TropicalGeometry/hypersurface/">Tropical hypersurfaces</a></li><li><a class="tocitem" href="../../TropicalGeometry/curve/">Tropical curves</a></li><li><a class="tocitem" href="../../TropicalGeometry/linear_space/">Tropical linear spaces</a></li><li><a class="tocitem" href="../../TropicalGeometry/groebner_theory/">Groebner theory</a></li><li><a class="tocitem" href="../../TropicalGeometry/tropicalization/">Tropicalization of polynomial ideals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Noncommutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-13-2" type="checkbox"/><label class="tocitem" for="menuitem-13-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li><li><a class="tocitem" href="../../Combinatorics/phylogenetic_trees/">Phylogenetic Trees</a></li><li><input class="collapse-toggle" id="menuitem-14-5" type="checkbox"/><label class="tocitem" for="menuitem-14-5"><span class="docs-label">Enumerative combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/EnumerativeCombinatorics/partitions/">Partitions</a></li><li><a class="tocitem" href="../../Combinatorics/EnumerativeCombinatorics/tableaux/">Tableaux</a></li><li><a class="tocitem" href="../../Combinatorics/EnumerativeCombinatorics/schur_polynomials/">Schur polynomials</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-18" type="checkbox"/><label class="tocitem" for="menuitem-18"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/printing_details/">Details on printing in Oscar</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/serialization/">Serialization</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/gap_integration/">GAP Integration</a></li><li><input class="collapse-toggle" id="menuitem-18-9" type="checkbox"/><label class="tocitem" for="menuitem-18-9"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-19" type="checkbox"/><label class="tocitem" for="menuitem-19"><span class="docs-label">Experimental</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/intro/">Adding new projects to experimental</a></li><li><input class="collapse-toggle" id="menuitem-19-2" type="checkbox"/><label class="tocitem" for="menuitem-19-2"><span class="docs-label">Double complexes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/DoubleAndHyperComplexes/user_interface/">Double complexes – the user&#39;s interface</a></li><li><a class="tocitem" href="../../Experimental/DoubleAndHyperComplexes/advice_for_the_programmer/">Advice for the programmer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-3" type="checkbox"/><label class="tocitem" for="menuitem-19-3"><span class="docs-label">F-Theory Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/FTheoryTools/introduction/">Welcome to FTheoryTools</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/generalities/">Functionality for all F-theory models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/weierstrass/">Weierstrass models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/tate/">Global Tate models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/hypersurface/">Hypersurface models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/literature/">Literature constructions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-4" type="checkbox"/><label class="tocitem" for="menuitem-19-4"><span class="docs-label">Linear Quotients</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/LinearQuotients/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/LinearQuotients/linear_quotients/">Construction and basic functionality</a></li><li><a class="tocitem" href="../../Experimental/LinearQuotients/cox_rings/">Cox rings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-5" type="checkbox"/><label class="tocitem" for="menuitem-19-5"><span class="docs-label">Matroid Realization Spaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/MatroidRealizationSpaces/introduction/">Matroid Realization Spaces</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-6" type="checkbox"/><label class="tocitem" for="menuitem-19-6"><span class="docs-label">Orthogonal discriminants</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/OrthogonalDiscriminants/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/OrthogonalDiscriminants/access/">Access to precomputed OD data</a></li><li><a class="tocitem" href="../../Experimental/OrthogonalDiscriminants/compute/">Criteria for computing orthogonal discriminants</a></li><li><a class="tocitem" href="../../Experimental/OrthogonalDiscriminants/misc/">Miscellaneous functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-7" type="checkbox"/><label class="tocitem" for="menuitem-19-7"><span class="docs-label">Quadratic forms and isometries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/introduction/">Quadratic forms and isometries</a></li><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/spacewithisom/">Quadratic spaces with isometry</a></li><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/latwithisom/">Lattices with isometry</a></li><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/enumeration/">Enumeration of isometries</a></li><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/primembed/">Nikulin&#39;s theory on primitive embeddings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-8" type="checkbox"/><label class="tocitem" for="menuitem-19-8"><span class="docs-label">Standard Finite Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/StandardFiniteFields/introduction/">-</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-9" type="checkbox"/><label class="tocitem" for="menuitem-19-9"><span class="docs-label">Lie Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/LieAlgebras/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/lie_algebras/">Lie algebras</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/ideals_and_subalgebras/">Ideals and Lie subalgebras</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/lie_algebra_homs/">Lie algebra homomorphisms</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/modules/">Lie algebra modules</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/module_homs/">Lie algebra module homomorphisms</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/cartan_matrix/">Cartan Matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-10" type="checkbox"/><label class="tocitem" for="menuitem-19-10"><span class="docs-label">Bases for highest weight modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/BasisLieHighestWeight/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/BasisLieHighestWeight/user_functions/">User-facing functions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Commutative Algebra</a></li><li class="is-active"><a href>Ideals in Multivariate Rings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ideals in Multivariate Rings</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/oscar-system/Oscar.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/CommutativeAlgebra/ideals.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Ideals-in-Multivariate-Rings"><a class="docs-heading-anchor" href="#Ideals-in-Multivariate-Rings">Ideals in Multivariate Rings</a><a id="Ideals-in-Multivariate-Rings-1"></a><a class="docs-heading-anchor-permalink" href="#Ideals-in-Multivariate-Rings" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>The OSCAR type for ideals in multivariate polynomial rings is of parametrized form <code>MPolyIdeal{T}</code>, where <code>T</code> is the element type of the polynomial ring.</p><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ideal-Tuple{MPolyRing, Vector}" href="#ideal-Tuple{MPolyRing, Vector}"><code>ideal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ideal(R::MPolyRing, V::Vector)</code></pre><p>Given a vector <code>V</code> of polynomials in <code>R</code>, return the ideal of <code>R</code> generated by these polynomials.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the graded case, the entries of <code>V</code> must be homogeneous.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = ideal(R, [x*y-3*x,y^3-2*x^2*y])
Ideal generated by
  x*y - 3*x
  -2*x^2*y + y^3

julia&gt; typeof(I)
MPolyIdeal{QQMPolyRingElem}

julia&gt; S, (x, y) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;],  [1, 2])
(Graded multivariate polynomial ring in 2 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y])

julia&gt; J = ideal(S, [(x^2+y)^2])
Ideal generated by
  x^4 + 2*x^2*y + y^2

julia&gt; typeof(J)
MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L4-L35">source</a></section></article><h2 id="Data-Associated-to-Ideals"><a class="docs-heading-anchor" href="#Data-Associated-to-Ideals">Data Associated to Ideals</a><a id="Data-Associated-to-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Associated-to-Ideals" title="Permalink"></a></h2><h3 id="Basic-Data"><a class="docs-heading-anchor" href="#Basic-Data">Basic Data</a><a id="Basic-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Data" title="Permalink"></a></h3><p>If <code>I</code> is an ideal of a multivariate polynomial ring  <code>R</code>, then</p><ul><li><code>base_ring(I)</code> refers to <code>R</code>,</li><li><code>gens(I)</code> to the generators of <code>I</code>,</li><li><code>number_of_generators(I)</code> / <code>ngens(I)</code> to the number of these generators, and</li><li><code>gen(I, k)</code> as well as <code>I[k]</code> to the <code>k</code>-th such generator.</li></ul><h6 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia&gt; base_ring(I)
Multivariate polynomial ring in 2 variables x, y
  over rational field

julia&gt; gens(I)
3-element Vector{QQMPolyRingElem}:
 x^2
 x*y
 y^2

julia&gt; number_of_generators(I)
3

julia&gt; gen(I, 2)
x*y
</code></pre><h3 id="Dimension"><a class="docs-heading-anchor" href="#Dimension">Dimension</a><a id="Dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Dimension" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="dim-Tuple{MPolyIdeal}" href="#dim-Tuple{MPolyIdeal}"><code>dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim(I::MPolyIdeal)</code></pre><p>Return the Krull dimension of <code>I</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; I = ideal(R, [y-x^2, x-z^3])
Ideal generated by
  -x^2 + y
  x - z^3

julia&gt; dim(I)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1657-L1675">source</a></section></article><h3 id="Codimension"><a class="docs-heading-anchor" href="#Codimension">Codimension</a><a id="Codimension-1"></a><a class="docs-heading-anchor-permalink" href="#Codimension" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="codim-Tuple{MPolyIdeal}" href="#codim-Tuple{MPolyIdeal}"><code>codim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">codim(TropV::TropicalVariety)</code></pre><p>Return the codimension of <code>TropV</code>.  Requires <code>TropV</code> to be embedded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/TropicalGeometry/variety_supertype.jl#L53-L57">source</a></section></article><p>In the graded case, we additionally have:</p><h3 id="Minimal-Sets-of-Generators"><a class="docs-heading-anchor" href="#Minimal-Sets-of-Generators">Minimal Sets of Generators</a><a id="Minimal-Sets-of-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-Sets-of-Generators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="minimal_generating_set-Tuple{MPolyIdeal{&lt;:MPolyDecRingElem}}" href="#minimal_generating_set-Tuple{MPolyIdeal{&lt;:MPolyDecRingElem}}"><code>minimal_generating_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimal_generating_set(I::MPolyIdeal{&lt;:MPolyDecRingElem})</code></pre><p>Given a (homogeneous) ideal <code>I</code> in a graded multivariate polynomial ring over a field, return an array containing a minimal set of generators of <code>I</code>. If <code>I</code> is the zero ideal, an empty list is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; V = [x, z^2, x^3+y^3, y^4, y*z^5];

julia&gt; I = ideal(R, V)
Ideal generated by
  x
  z^2
  x^3 + y^3
  y^4
  y*z^5

julia&gt; minimal_generating_set(I)
3-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x
 z^2
 y^3

julia&gt; I = ideal(R, zero(R))
Ideal generated by
  0

julia&gt; minimal_generating_set(I)
MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-graded.jl#L2269-L2303">source</a></section></article><h3 id="Castelnuovo-Mumford-Regularity"><a class="docs-heading-anchor" href="#Castelnuovo-Mumford-Regularity">Castelnuovo-Mumford Regularity</a><a id="Castelnuovo-Mumford-Regularity-1"></a><a class="docs-heading-anchor-permalink" href="#Castelnuovo-Mumford-Regularity" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="cm_regularity-Tuple{MPolyIdeal}" href="#cm_regularity-Tuple{MPolyIdeal}"><code>cm_regularity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cm_regularity(I::MPolyIdeal)</code></pre><p>Given a (homogeneous) ideal <code>I</code> in a standard <span>$\mathbb Z$</span>-graded multivariate polynomial ring with coefficients in a field, return the Castelnuovo-Mumford regularity of I.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; I = ideal(R, [y^2*z − x^2*w, z^4 − x*w^3]);

julia&gt; cm_regularity(I)
6

julia&gt; minimal_betti_table(I);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-graded.jl#L2332-L2349">source</a></section></article><h3 id="Degree"><a class="docs-heading-anchor" href="#Degree">Degree</a><a id="Degree-1"></a><a class="docs-heading-anchor-permalink" href="#Degree" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="degree-Tuple{MPolyIdeal}" href="#degree-Tuple{MPolyIdeal}"><code>degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree(I::MPolyIdeal)</code></pre><p>Given a (homogeneous) ideal <code>I</code> in a standard <span>$\mathbb Z$</span>-graded multivariate polynomial ring, return the degree of <code>I</code> (that is, the degree of the quotient of <code>base_ring(I)</code> modulo <code>I</code>). Otherwise, return the degree of the homogenization of <code>I</code> with respect to the standard <span>$\mathbb Z$</span>-grading.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Geometrically, the degree of a homogeneous ideal as above is the number of intersection points of its projective variety with a generic linear subspace of complementary dimension (counted with multiplicities). See also [<a href="../../references/#MS21">MS21</a>].</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; I = ideal(R, [y-x^2, x-z^3])
Ideal generated by
  -x^2 + y
  x - z^3

julia&gt; degree(I)
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-graded.jl#L2360-L2387">source</a></section></article><h2 id="Operations-on-Ideals"><a class="docs-heading-anchor" href="#Operations-on-Ideals">Operations on Ideals</a><a id="Operations-on-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-Ideals" title="Permalink"></a></h2><h3 id="Simple-Ideal-Operations"><a class="docs-heading-anchor" href="#Simple-Ideal-Operations">Simple Ideal Operations</a><a id="Simple-Ideal-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Ideal-Operations" title="Permalink"></a></h3><h4 id="Powers-of-Ideal"><a class="docs-heading-anchor" href="#Powers-of-Ideal">Powers of Ideal</a><a id="Powers-of-Ideal-1"></a><a class="docs-heading-anchor-permalink" href="#Powers-of-Ideal" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="^-Tuple{MPolyIdeal, Int64}" href="#^-Tuple{MPolyIdeal, Int64}"><code>^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">^(I::MPolyIdeal, m::Int)</code></pre><p>Return the <code>m</code>-th power of <code>I</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; I = ideal(R, [x, y])
Ideal generated by
  x
  y

julia&gt; I^3
Ideal generated by
  x^3
  x^2*y
  x*y^2
  y^3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L82-L104">source</a></section></article><h4 id="Sum-of-Ideals"><a class="docs-heading-anchor" href="#Sum-of-Ideals">Sum of Ideals</a><a id="Sum-of-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Sum-of-Ideals" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="+-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T" href="#+-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T"><code>+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T</code></pre><p>Return the sum of <code>I</code> and <code>J</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; I = ideal(R, [x, y])
Ideal generated by
  x
  y

julia&gt; J = ideal(R, [z^2])
Ideal generated by
  z^2

julia&gt; I+J
Ideal generated by
  x
  y
  z^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L109-L134">source</a></section></article><h4 id="Product-of-Ideals"><a class="docs-heading-anchor" href="#Product-of-Ideals">Product of Ideals</a><a id="Product-of-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Product-of-Ideals" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="*-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T" href="#*-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T"><code>*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T</code></pre><p>Return the product of <code>I</code> and <code>J</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; I = ideal(R, [x, y])
Ideal generated by
  x
  y

julia&gt; J = ideal(R, [z^2])
Ideal generated by
  z^2

julia&gt; I*J
Ideal generated by
  x*z^2
  y*z^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L144-L168">source</a></section></article><h3 id="Intersection-of-Ideals"><a class="docs-heading-anchor" href="#Intersection-of-Ideals">Intersection of Ideals</a><a id="Intersection-of-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Intersection-of-Ideals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="intersect-Union{Tuple{T}, Tuple{MPolyIdeal{T}, Vararg{MPolyIdeal{T}}}} where T" href="#intersect-Union{Tuple{T}, Tuple{MPolyIdeal{T}, Vararg{MPolyIdeal{T}}}} where T"><code>intersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersect(I::MPolyIdeal{T}, Js::MPolyIdeal{T}...) where T
intersect(V::Vector{MPolyIdeal{T}}) where T</code></pre><p>Return the intersection of two or more ideals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = ideal(R, [x, y])^2;

julia&gt; J = ideal(R, [y^2-x^3+x]);

julia&gt; intersect(I, J)
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia&gt; intersect([I, J])
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L188-L213">source</a></section></article><h3 id="Ideal-Quotients"><a class="docs-heading-anchor" href="#Ideal-Quotients">Ideal Quotients</a><a id="Ideal-Quotients-1"></a><a class="docs-heading-anchor-permalink" href="#Ideal-Quotients" title="Permalink"></a></h3><p>Given two ideals <span>$I, J$</span> of a ring <span>$R$</span>, the ideal quotient of <span>$I$</span> by <span>$J$</span> is the ideal</p><p class="math-container">\[I:J= \bigl\{f \in R\:\big|\: f J \subset I\bigr\}\subset R.\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="quotient-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T" href="#quotient-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T"><code>quotient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quotient(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T</code></pre><p>Return the ideal quotient of <code>I</code> by <code>J</code>. Alternatively, use <code>I:J</code>.</p><pre><code class="nohighlight hljs">quotient(I::MPolyIdeal{T}, f::MPolyRingElem{T}) where T</code></pre><p>Return the ideal quotient of <code>I</code> by the ideal generated by <code>f</code>. Alternatively, use <code>I:f</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; I = ideal(R, [x^4+x^2*y*z+y^3*z, y^4+x^3*z+x*y^2*z, x^3*y+x*y^3])
Ideal generated by
  x^4 + x^2*y*z + y^3*z
  x^3*z + x*y^2*z + y^4
  x^3*y + x*y^3

julia&gt; J = ideal(R, [x, y, z])^2
Ideal generated by
  x^2
  x*y
  x*z
  y^2
  y*z
  z^2

julia&gt; L = quotient(I, J)
Ideal generated by
  x^3*z + x*y^2*z + y^4
  x^3*y + x*y^3
  x^4 + x^2*y*z + y^3*z
  x^3*z^2 - x^2*y*z^2 + x*y^2*z^2 - y^3*z^2
  x^2*y^2*z - x^2*y*z^2 - y^3*z^2
  x^3*z^2 + x^2*y^3 - x^2*y^2*z + x*y^2*z^2

julia&gt; I:J
Ideal generated by
  x^3*z + x*y^2*z + y^4
  x^3*y + x*y^3
  x^4 + x^2*y*z + y^3*z
  x^3*z^2 - x^2*y*z^2 + x*y^2*z^2 - y^3*z^2
  x^2*y^2*z - x^2*y*z^2 - y^3*z^2
  x^3*z^2 + x^2*y^3 - x^2*y^2*z + x*y^2*z^2

julia&gt; I:x
Ideal generated by
  x^2*y + y^3
  x^3*z + x*y^2*z + y^4
  x^2*z^2 + x*y^3 - x*y^2*z + y^2*z^2
  x^4
  x^3*z^2 - x^2*z^3 + 2*x*y^2*z^2 - y^2*z^3
  -x^2*z^4 + x*y^2*z^3 - y^2*z^4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L230-L286">source</a></section></article><h3 id="Saturation"><a class="docs-heading-anchor" href="#Saturation">Saturation</a><a id="Saturation-1"></a><a class="docs-heading-anchor-permalink" href="#Saturation" title="Permalink"></a></h3><p>Given two ideals <span>$I, J$</span> of a ring <span>$R$</span>, the saturation of <span>$I$</span> with respect to <span>$J$</span> is the ideal</p><p class="math-container">\[I:J^{\infty} = \bigl\{ f \in R \:\big|\: f J^k \!\subset I {\text{ for some }}k\geq 1 \bigr\} = \textstyle{\bigcup\limits_{k=1}^{\infty} (I:J^k)}.\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="saturation-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T" href="#saturation-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T"><code>saturation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saturation(I::MPolyIdeal{T}, J::MPolyIdeal{T} = ideal(base_ring(I), gens(base_ring(I)))) where T</code></pre><p>Return the saturation of <code>I</code> with respect to <code>J</code>. If the second ideal <code>J</code> is not given, the ideal generated by the generators (variables) of <code>base_ring(I)</code> is used.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; I = ideal(R, [z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y])
Ideal generated by
  z^3
  y*z^2
  x*z^2
  y^2*z
  x*y*z
  x^2*z
  x*y^2
  x^2*y

julia&gt; J = ideal(R, [x, y, z])
Ideal generated by
  x
  y
  z

julia&gt; K = saturation(I, J)
Ideal generated by
  z
  x*y

julia&gt; K = saturation(I)
Ideal generated by
  z
  x*y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L303-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="saturation_with_index-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T" href="#saturation_with_index-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T"><code>saturation_with_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saturation_with_index(I::MPolyIdeal{T}, J::MPolyIdeal{T} = ideal(base_ring(I), gens(base_ring(I)))) where T</code></pre><p>Return <span>$I:J^{\infty}$</span> together with the smallest integer <span>$m$</span> such that <span>$I:J^m = I:J^{\infty}$</span>. If the second ideal <code>J</code> is not given, the ideal generated by the generators (variables) of <code>base_ring(I)</code> is used.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; I = ideal(R, [z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y])
Ideal generated by
  z^3
  y*z^2
  x*z^2
  y^2*z
  x*y*z
  x^2*z
  x*y^2
  x^2*y

julia&gt; J = ideal(R, [x, y, z])
Ideal generated by
  x
  y
  z

julia&gt; K, m = saturation_with_index(I, J)
(Ideal (z, x*y), 2)

julia&gt; K, m = saturation_with_index(I)
(Ideal (z, x*y), 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L355-L389">source</a></section></article><h3 id="Elimination"><a class="docs-heading-anchor" href="#Elimination">Elimination</a><a id="Elimination-1"></a><a class="docs-heading-anchor-permalink" href="#Elimination" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="eliminate-Union{Tuple{T}, Tuple{MPolyIdeal{T}, Vector{T}}} where T&lt;:MPolyRingElem" href="#eliminate-Union{Tuple{T}, Tuple{MPolyIdeal{T}, Vector{T}}} where T&lt;:MPolyRingElem"><code>eliminate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eliminate(I::MPolyIdeal{T}, V::Vector{T}) where T &lt;: MPolyRingElem</code></pre><p>Given a vector <code>V</code> of polynomials which are variables, these variables are eliminated from <code>I</code>. That is, return the ideal generated by all polynomials in <code>I</code> which only involve the remaining variables.</p><pre><code class="nohighlight hljs">eliminate(I::MPolyIdeal, V::AbstractVector{Int})</code></pre><p>Given a vector <code>V</code> of indices which specify variables, these variables are eliminated from <code>I</code>. That is, return the ideal generated by all polynomials in <code>I</code> which only involve the remaining variables.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The return value is an ideal of the original ring.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (t, x, y, z) = polynomial_ring(QQ, [&quot;t&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[t, x, y, z])

julia&gt; I = ideal(R, [t-x, t^2-y, t^3-z])
Ideal generated by
  t - x
  t^2 - y
  t^3 - z

julia&gt; A = [t]
1-element Vector{QQMPolyRingElem}:
 t

julia&gt; TC = eliminate(I, A)
Ideal generated by
  -x*z + y^2
  x*y - z
  x^2 - y

julia&gt; A = [1]
1-element Vector{Int64}:
 1

julia&gt; TC = eliminate(I, A)
Ideal generated by
  -x*z + y^2
  x*y - z
  x^2 - y

julia&gt; base_ring(TC)
Multivariate polynomial ring in 4 variables t, x, y, z
  over rational field</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L396-L445">source</a></section></article><h3 id="Truncation"><a class="docs-heading-anchor" href="#Truncation">Truncation</a><a id="Truncation-1"></a><a class="docs-heading-anchor-permalink" href="#Truncation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="truncate-Tuple{MPolyIdeal, FinGenAbGroupElem}" href="#truncate-Tuple{MPolyIdeal, FinGenAbGroupElem}"><code>truncate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truncate(I::MPolyIdeal, g::FinGenAbGroupElem)</code></pre><p>Given a (homogeneous) ideal <code>I</code> in a <span>$\mathbb Z$</span>-graded multivariate polynomial ring with positive weights, return the truncation of <code>I</code> at degree <code>g</code>.</p><pre><code class="nohighlight hljs">truncate(I::MPolyIdeal, d::Int)</code></pre><p>Given an ideal <code>I</code> as above, and given an integer <code>d</code>, convert <code>d</code> into an element <code>g</code> of the grading group of <code>base_ring(I)</code> and proceed as above.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; I = ideal(R, [x, y^4, z^6])
Ideal generated by
  x
  y^4
  z^6

julia&gt; truncate(I, 3)
Ideal generated by
  x*z^2
  x*y*z
  x*y^2
  x^2*z
  x^2*y
  x^3
  y^4
  z^6</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [3,2,1]);

julia&gt; I = ideal(R, [x, y^4, z^6])
Ideal generated by
  x
  y^4
  z^6

julia&gt; truncate(I, 3)
Ideal generated by
  x
  y^4
  z^6

julia&gt; truncate(I, 4)
Ideal generated by
  x*z
  z^6
  y^4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-graded.jl#L2172-L2226">source</a></section></article><h2 id="Tests-on-Ideals"><a class="docs-heading-anchor" href="#Tests-on-Ideals">Tests on Ideals</a><a id="Tests-on-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-on-Ideals" title="Permalink"></a></h2><h3 id="Basic-Tests"><a class="docs-heading-anchor" href="#Basic-Tests">Basic Tests</a><a id="Basic-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Tests" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_zero-Tuple{MPolyIdeal}" href="#is_zero-Tuple{MPolyIdeal}"><code>is_zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_zero(I::MPolyIdeal)</code></pre><p>Return <code>true</code> if <code>I</code> is the zero ideal, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = ideal(R, y-x^2)
Ideal generated by
  -x^2 + y

julia&gt; is_zero(I)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1719-L1735">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_one-Tuple{MPolyIdeal}" href="#is_one-Tuple{MPolyIdeal}"><code>is_one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_one(I::MPolyIdeal)</code></pre><p>Return <code>true</code> if <code>I</code> is generated by <code>1</code>, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = ideal(R, [x, x + y, y - 1])
Ideal generated by
  x
  x + y
  y - 1

julia&gt; is_one(I)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1741-L1759">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_monomial-Tuple{MPolyRingElem}" href="#is_monomial-Tuple{MPolyRingElem}"><code>is_monomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_monomial(f::MPolyRingElem)</code></pre><p>Return <code>true</code> if <code>f</code> is a monomial, <code>false</code> otherwise.</p><pre><code class="nohighlight hljs">is_monomial(I::MPolyIdeal)</code></pre><p>Return <code>true</code> if <code>I</code> can be generated by monomials, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; f = 2*x+y
2*x + y

julia&gt; g = y
y

julia&gt; is_monomial(f)
false

julia&gt; is_monomial(g)
true

julia&gt; is_monomial(ideal(R, [f, g]))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1778-L1807">source</a></section></article><h3 id="Containment-of-Ideals"><a class="docs-heading-anchor" href="#Containment-of-Ideals">Containment of Ideals</a><a id="Containment-of-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Containment-of-Ideals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_subset-Tuple{MPolyIdeal, MPolyIdeal}" href="#is_subset-Tuple{MPolyIdeal, MPolyIdeal}"><code>is_subset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_subset(I::MPolyIdeal, J::MPolyIdeal)</code></pre><p>Return <code>true</code> if <code>I</code> is contained in <code>J</code>, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = ideal(R, [x^2])
Ideal generated by
  x^2

julia&gt; J = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia&gt; is_subset(I, J)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1391-L1414">source</a></section></article><h3 id="Equality-of-Ideals"><a class="docs-heading-anchor" href="#Equality-of-Ideals">Equality of Ideals</a><a id="Equality-of-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Equality-of-Ideals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="==-Tuple{MPolyIdeal, MPolyIdeal}" href="#==-Tuple{MPolyIdeal, MPolyIdeal}"><code>==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(I::MPolyIdeal, J::MPolyIdeal)</code></pre><p>Return <code>true</code> if <code>I</code> is equal to <code>J</code>, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = ideal(R, [x^2])
Ideal generated by
  x^2

julia&gt; J = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia&gt; I == J
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1357-L1380">source</a></section></article><h3 id="Ideal-Membership"><a class="docs-heading-anchor" href="#Ideal-Membership">Ideal Membership</a><a id="Ideal-Membership-1"></a><a class="docs-heading-anchor-permalink" href="#Ideal-Membership" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ideal_membership-Union{Tuple{T}, Tuple{T, MPolyIdeal{T}}} where T" href="#ideal_membership-Union{Tuple{T}, Tuple{T, MPolyIdeal{T}}} where T"><code>ideal_membership</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ideal_membership(f::T, I::MPolyIdeal{T}) where T</code></pre><p>Return <code>true</code> if <code>f</code> is contained in <code>I</code>, <code>false</code> otherwise. Alternatively, use <code>f in I</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; f = x^2
x^2

julia&gt; I = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia&gt; ideal_membership(f, I)
true

julia&gt; g = x
x

julia&gt; g in I
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1424-L1452">source</a></section></article><h3 id="Radical-Membership"><a class="docs-heading-anchor" href="#Radical-Membership">Radical Membership</a><a id="Radical-Membership-1"></a><a class="docs-heading-anchor-permalink" href="#Radical-Membership" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="radical_membership-Union{Tuple{T}, Tuple{T, MPolyIdeal{T}}} where T" href="#radical_membership-Union{Tuple{T}, Tuple{T, MPolyIdeal{T}}} where T"><code>radical_membership</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radical_membership(f::T, I::MPolyIdeal{T}) where T</code></pre><p>Return <code>true</code> if <code>f</code> is contained in the radical of <code>I</code>, <code>false</code> otherwise. Alternatively, use <code>inradical(f, I)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x,) = polynomial_ring(QQ, [&quot;x&quot;])
(Multivariate polynomial ring in 1 variable over QQ, QQMPolyRingElem[x])

julia&gt; f = x
x

julia&gt; I = ideal(R,  [x^2])
Ideal generated by
  x^2

julia&gt; radical_membership(f, I)
true

julia&gt; g = x+1
x + 1

julia&gt; inradical(g, I)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1459-L1486">source</a></section></article><h3 id="Primality-Test"><a class="docs-heading-anchor" href="#Primality-Test">Primality Test</a><a id="Primality-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Primality-Test" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_prime-Tuple{MPolyIdeal}" href="#is_prime-Tuple{MPolyIdeal}"><code>is_prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_prime(I::MPolyIdeal)</code></pre><p>Return <code>true</code> if <code>I</code> is prime, <code>false</code> otherwise.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The function computes the minimal associated primes of <code>I</code>. This may take some time.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia&gt; is_prime(I)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1493-L1515">source</a></section></article><h3 id="Primary-Test"><a class="docs-heading-anchor" href="#Primary-Test">Primary Test</a><a id="Primary-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Primary-Test" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_primary-Tuple{MPolyIdeal}" href="#is_primary-Tuple{MPolyIdeal}"><code>is_primary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_primary(I::MPolyIdeal)</code></pre><p>Return <code>true</code> if <code>I</code> is primary, <code>false</code> otherwise.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The function computes a primary decomposition of <code>I</code>. This may take some time.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia&gt; is_primary(I)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1522-L1544">source</a></section></article><h2 id="Decomposition-of-Ideals"><a class="docs-heading-anchor" href="#Decomposition-of-Ideals">Decomposition of Ideals</a><a id="Decomposition-of-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Decomposition-of-Ideals" title="Permalink"></a></h2><p>We discuss various decomposition techniques. They are implemented for polynomial rings over fields and, if explicitly mentioned, also for polynomial rings over the integers. See [<a href="../../references/#DGP99">DGP99</a>] for a survey.</p><h3 id="Radical"><a class="docs-heading-anchor" href="#Radical">Radical</a><a id="Radical-1"></a><a class="docs-heading-anchor-permalink" href="#Radical" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="radical-Tuple{MPolyIdeal}" href="#radical-Tuple{MPolyIdeal}"><code>radical</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radical(I::MPolyIdeal)</code></pre><p>Return the radical of <code>I</code>.</p><p><strong>Implemented Algorithms</strong></p><p>If the base ring of <code>I</code> is a polynomial ring over a field, a combination of the algorithms of Krick and Logar (with modifications by Laplagne) and Kemper is used. For polynomial rings over the integers, the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel. See [<a href="../../references/#KL91">KL91</a>], [<a href="../../references/#Kem02">Kem02</a>], and [<a href="../../references/#PSS11">PSS11</a>].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia&gt; I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia&gt; RI = radical(I)
Ideal generated by
  x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (a, b, c, d) = polynomial_ring(ZZ, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])
(Multivariate polynomial ring in 4 variables over ZZ, ZZMPolyRingElem[a, b, c, d])

julia&gt; I = intersect(ideal(R, [9,a,b]), ideal(R, [3,c]))
Ideal generated by
  9
  3*b
  3*a
  b*c
  a*c

julia&gt; I = intersect(I, ideal(R, [11,2a,7b]))
Ideal generated by
  99
  3*b
  3*a
  b*c
  a*c

julia&gt; I = intersect(I, ideal(R, [13a^2,17b^4]))
Ideal generated by
  39*a^2
  13*a^2*c
  51*b^4
  17*b^4*c
  3*a^2*b^4
  a^2*b^4*c

julia&gt; I = intersect(I, ideal(R, [9c^5,6d^5]))
Ideal generated by
  78*a^2*d^5
  117*a^2*c^5
  102*b^4*d^5
  153*b^4*c^5
  6*a^2*b^4*d^5
  9*a^2*b^4*c^5
  39*a^2*c^5*d^5
  51*b^4*c^5*d^5
  3*a^2*b^4*c^5*d^5

julia&gt; I = intersect(I, ideal(R, [17,a^15,b^15,c^15,d^15]))
Ideal generated by
  1326*a^2*d^5
  1989*a^2*c^5
  102*b^4*d^5
  153*b^4*c^5
  663*a^2*c^5*d^5
  51*b^4*c^5*d^5
  78*a^2*d^15
  117*a^2*c^15
  78*a^15*d^5
  117*a^15*c^5
  6*a^2*b^4*d^15
  9*a^2*b^4*c^15
  39*a^2*c^5*d^15
  39*a^2*c^15*d^5
  6*a^2*b^15*d^5
  9*a^2*b^15*c^5
  6*a^15*b^4*d^5
  9*a^15*b^4*c^5
  39*a^15*c^5*d^5
  3*a^2*b^4*c^5*d^15
  3*a^2*b^4*c^15*d^5
  3*a^2*b^15*c^5*d^5
  3*a^15*b^4*c^5*d^5

julia&gt; RI = radical(I)
Ideal generated by
  102*b*d
  78*a*d
  51*b*c
  39*a*c
  6*a*b*d
  3*a*b*c</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L464-L573">source</a></section></article><h3 id="Primary-Decomposition"><a class="docs-heading-anchor" href="#Primary-Decomposition">Primary Decomposition</a><a id="Primary-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Primary-Decomposition" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="primary_decomposition-Tuple{MPolyIdeal}" href="#primary_decomposition-Tuple{MPolyIdeal}"><code>primary_decomposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primary_decomposition(I::MPolyIdeal; algorithm = :GTZ, cache=true)</code></pre><p>Return a minimal primary decomposition of <code>I</code>.</p><p>The decomposition is returned as a vector of tuples <span>$(Q_1, P_1), \dots, (Q_t, P_t)$</span>, say, where each <span>$Q_i$</span> is a primary ideal with associated prime <span>$P_i$</span>, and where the intersection of the <span>$Q_i$</span> is <code>I</code>.</p><p><strong>Implemented Algorithms</strong></p><p>If the base ring of <code>I</code> is a polynomial ring over a field, the algorithm of Gianni, Trager, and Zacharias is used by default (<code>algorithm = :GTZ</code>). Alternatively, the algorithm by Shimoyama and Yokoyama can be used by specifying <code>algorithm = :SY</code>.  For polynomial rings over the integers, the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel. See [<a href="../../references/#GTZ88">GTZ88</a>], [<a href="../../references/#SY96">SY96</a>], and [<a href="../../references/#PSS11">PSS11</a>].</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The algorithm of Gianni, Trager, and Zacharias may not terminate over a small finite field. If it terminates, the result is correct.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If computations are done in a ring over a number field, then the output may contain redundant components.</p></div></div><p>If <code>cache=false</code> is set, the primary decomposition is recomputed and not cached.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia&gt; I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia&gt; L = primary_decomposition(I)
3-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}}}:
 (Ideal (x^3 - x - y^2), Ideal (x^3 - x - y^2))
 (Ideal (x^2 - 2*x*y - 2*x + y^2 + 2*y + 1), Ideal (x - y - 1))
 (Ideal (y, x^2), Ideal (x, y))

julia&gt; L = primary_decomposition(I, algorithm = :SY, cache=false)
3-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}}}:
 (Ideal (x^3 - x - y^2), Ideal (x^3 - x - y^2))
 (Ideal (x^2 - 2*x*y - 2*x + y^2 + 2*y + 1), Ideal (x - y - 1))
 (Ideal (y, x^2), Ideal (y, x))</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (a, b, c, d) = polynomial_ring(ZZ, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])
(Multivariate polynomial ring in 4 variables over ZZ, ZZMPolyRingElem[a, b, c, d])

julia&gt; I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,
       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,
       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,
       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,
       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,
       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])
Ideal generated by
  1326*a^2*d^5
  1989*a^2*c^5
  102*b^4*d^5
  153*b^4*c^5
  663*a^2*c^5*d^5
  51*b^4*c^5*d^5
  78*a^2*d^15
  117*a^2*c^15
  78*a^15*d^5
  117*a^15*c^5
  6*a^2*b^4*d^15
  9*a^2*b^4*c^15
  39*a^2*c^5*d^15
  39*a^2*c^15*d^5
  6*a^2*b^15*d^5
  9*a^2*b^15*c^5
  6*a^15*b^4*d^5
  9*a^15*b^4*c^5
  39*a^15*c^5*d^5
  3*a^2*b^4*c^5*d^15
  3*a^2*b^4*c^15*d^5
  3*a^2*b^15*c^5*d^5
  3*a^15*b^4*c^5*d^5

julia&gt; L = primary_decomposition(I)
8-element Vector{Tuple{MPolyIdeal{ZZMPolyRingElem}, MPolyIdeal{ZZMPolyRingElem}}}:
 (Ideal (d^5, c^5), Ideal (d, c))
 (Ideal (a^2, b^4), Ideal (b, a))
 (Ideal (2, c^5), Ideal (2, c))
 (Ideal (3), Ideal (3))
 (Ideal (13, b^4), Ideal (13, b))
 (Ideal (17, a^2), Ideal (17, a))
 (Ideal (17, d^15, c^15, b^15, a^15), Ideal (17, d, c, b, a))
 (Ideal (9, 3*d^5, d^10), Ideal (3, d))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L612-L709">source</a></section></article><h3 id="Absolute-Primary-Decomposition"><a class="docs-heading-anchor" href="#Absolute-Primary-Decomposition">Absolute Primary Decomposition</a><a id="Absolute-Primary-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Absolute-Primary-Decomposition" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="absolute_primary_decomposition-Tuple{MPolyIdeal{QQMPolyRingElem}}" href="#absolute_primary_decomposition-Tuple{MPolyIdeal{QQMPolyRingElem}}"><code>absolute_primary_decomposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absolute_primary_decomposition(I::MPolyIdeal{&lt;:MPolyRingElem{QQFieldElem}})</code></pre><p>Given an ideal <code>I</code> in a multivariate polynomial ring over the rationals, return an absolute minimal primary decomposition of <code>I</code>.</p><p>Return the decomposition as a vector of tuples <span>$(Q_i, P_i, P_{ij}, d_{ij})$</span>, say, where <span>$(Q_i, P_i)$</span> is a (primary, prime) tuple as returned by <code>primary_decomposition(I)</code>, and <span>$P_{ij}$</span> represents a corresponding class of conjugated absolute associated primes defined over a number field of degree <span>$d_{ij}$</span> whose generator prints as <code>_a</code>.</p><p><strong>Implemented Algorithms</strong></p><p>The implementation combines the algorithm of Gianni, Trager, and Zacharias for primary decomposition with absolute polynomial factorization.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Over number fields this proceduce might return redundant output.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (y, z) = polynomial_ring(QQ, [&quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[y, z])

julia&gt; p = z^2+1
z^2 + 1

julia&gt; q = z^3+2
z^3 + 2

julia&gt; I = ideal(R, [p*q^2, y-z^2])
Ideal generated by
  z^8 + z^6 + 4*z^5 + 4*z^3 + 4*z^2 + 4
  y - z^2

julia&gt; L = primary_decomposition(I)
2-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}}}:
 (Ideal (z^2 + 1, y - z^2), Ideal (z^2 + 1, y - z^2))
 (Ideal (z^6 + 4*z^3 + 4, y - z^2), Ideal (z^3 + 2, y - z^2))

julia&gt; AL = absolute_primary_decomposition(I)
2-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}, Int64}}:
 (Ideal (z^2 + 1, y + 1), Ideal (z^2 + 1, y + 1), Ideal (z - _a, y + 1), 2)
 (Ideal (z^6 + 4*z^3 + 4, y - z^2), Ideal (z^3 + 2, y - z^2), Ideal (z - _a, y - _a^2), 3)

julia&gt; AP = AL[1][3]
Ideal generated by
  z - _a
  y + 1

julia&gt; RAP = base_ring(AP)
Multivariate polynomial ring in 2 variables y, z
  over number field of degree 2 over QQ

julia&gt; NF = coefficient_ring(RAP)
Number field with defining polynomial x^2 + 1
  over rational field

julia&gt; a = gen(NF)
_a

julia&gt; minpoly(a)
x^2 + 1</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Graded multivariate polynomial ring in 2 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y])

julia&gt; I = ideal(R, [x^2+y^2])
Ideal generated by
  x^2 + y^2

julia&gt; AL = absolute_primary_decomposition(I)
1-element Vector{Tuple{MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}, MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}, MPolyIdeal{MPolyDecRingElem{AbsSimpleNumFieldElem, AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}}, Int64}}:
 (Ideal (x^2 + y^2), Ideal (x^2 + y^2), Ideal (x + _a*y), 2)

julia&gt; AP = AL[1][3]
Ideal generated by
  x + _a*y

julia&gt; RAP = base_ring(AP)
Multivariate polynomial ring in 2 variables over number field graded by 
  x -&gt; [1]
  y -&gt; [1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L769-L855">source</a></section></article><h3 id="Minimal-Associated-Primes"><a class="docs-heading-anchor" href="#Minimal-Associated-Primes">Minimal Associated Primes</a><a id="Minimal-Associated-Primes-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-Associated-Primes" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="minimal_primes-Tuple{MPolyIdeal}" href="#minimal_primes-Tuple{MPolyIdeal}"><code>minimal_primes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimal_primes(I::MPolyIdeal; algorithm::Symbol = :GTZ)</code></pre><p>Return a vector containing the minimal associated prime ideals of <code>I</code>.</p><p><strong>Implemented Algorithms</strong></p><p>If the base ring of <code>I</code> is a polynomial ring over a field, the algorithm of Gianni, Trager, and Zacharias is used by default (<code>algorithm = :GTZ</code>). Alternatively, characteristic sets can be used by specifying <code>algorithm = :charSets</code>. For polynomial rings over the integers, the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel. See [<a href="../../references/#GTZ88">GTZ88</a>] and [<a href="../../references/#PSS11">PSS11</a>].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia&gt; I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia&gt; L = minimal_primes(I)
2-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (x - y - 1)
 Ideal (x^3 - x - y^2)

julia&gt; L = minimal_primes(I, algorithm = :charSets)
2-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (x - y - 1)
 Ideal (x^3 - x - y^2)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (a, b, c, d) = polynomial_ring(ZZ, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])
(Multivariate polynomial ring in 4 variables over ZZ, ZZMPolyRingElem[a, b, c, d])

julia&gt; I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,
       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,
       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,
       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,
       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,
       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])
Ideal generated by
  1326*a^2*d^5
  1989*a^2*c^5
  102*b^4*d^5
  153*b^4*c^5
  663*a^2*c^5*d^5
  51*b^4*c^5*d^5
  78*a^2*d^15
  117*a^2*c^15
  78*a^15*d^5
  117*a^15*c^5
  6*a^2*b^4*d^15
  9*a^2*b^4*c^15
  39*a^2*c^5*d^15
  39*a^2*c^15*d^5
  6*a^2*b^15*d^5
  9*a^2*b^15*c^5
  6*a^15*b^4*d^5
  9*a^15*b^4*c^5
  39*a^15*c^5*d^5
  3*a^2*b^4*c^5*d^15
  3*a^2*b^4*c^15*d^5
  3*a^2*b^15*c^5*d^5
  3*a^15*b^4*c^5*d^5

julia&gt; L = minimal_primes(I)
6-element Vector{MPolyIdeal{ZZMPolyRingElem}}:
 Ideal (d, c)
 Ideal (b, a)
 Ideal (2, c)
 Ideal (3)
 Ideal (13, b)
 Ideal (17, a)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L940-L1022">source</a></section></article><h3 id="Weak-Equidimensional-Decomposition"><a class="docs-heading-anchor" href="#Weak-Equidimensional-Decomposition">Weak Equidimensional Decomposition</a><a id="Weak-Equidimensional-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-Equidimensional-Decomposition" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="equidimensional_decomposition_weak-Tuple{MPolyIdeal}" href="#equidimensional_decomposition_weak-Tuple{MPolyIdeal}"><code>equidimensional_decomposition_weak</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equidimensional_decomposition_weak(I::MPolyIdeal)</code></pre><p>Return a vector of equidimensional ideals where the last entry is the equidimensional hull of <code>I</code>, that is, the intersection of the primary components of <code>I</code> of maximal dimension. Each of the previous entries is an ideal of lower dimension whose associated primes are exactly the associated primes of <code>I</code> of that dimension.</p><p><strong>Implemented Algorithms</strong></p><p>The implementation relies on ideas of Eisenbud, Huneke, and Vasconcelos. See [<a href="../../references/#EHV92">EHV92</a>].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia&gt; I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia&gt; L = equidimensional_decomposition_weak(I)
2-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (y, x)
 Ideal with 1 generator</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1079-L1112">source</a></section></article><h3 id="Equidimensional-Decomposition-of-radical"><a class="docs-heading-anchor" href="#Equidimensional-Decomposition-of-radical">Equidimensional Decomposition of radical</a><a id="Equidimensional-Decomposition-of-radical-1"></a><a class="docs-heading-anchor-permalink" href="#Equidimensional-Decomposition-of-radical" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="equidimensional_decomposition_radical-Tuple{MPolyIdeal}" href="#equidimensional_decomposition_radical-Tuple{MPolyIdeal}"><code>equidimensional_decomposition_radical</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equidimensional_decomposition_radical(I::MPolyIdeal)</code></pre><p>Return a vector of equidimensional radical ideals increasingly ordered by dimension. For each dimension, the returned radical ideal is the intersection of the associated primes of <code>I</code> of that dimension. </p><p><strong>Implemented Algorithms</strong></p><p>The implementation combines the algorithms of Krick and Logar (with modifications by Laplagne) and Kemper. See [<a href="../../references/#KL91">KL91</a>] and [<a href="../../references/#Kem02">Kem02</a>].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia&gt; I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia&gt; L = equidimensional_decomposition_radical(I)
2-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (y, x)
 Ideal (x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1142-L1173">source</a></section></article><h3 id="Equidimensional-Hull"><a class="docs-heading-anchor" href="#Equidimensional-Hull">Equidimensional Hull</a><a id="Equidimensional-Hull-1"></a><a class="docs-heading-anchor-permalink" href="#Equidimensional-Hull" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="equidimensional_hull-Tuple{MPolyIdeal}" href="#equidimensional_hull-Tuple{MPolyIdeal}"><code>equidimensional_hull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equidimensional_hull(I::MPolyIdeal)</code></pre><p>If the base ring of <code>I</code> is a polynomial ring over a field, return the intersection of the primary components of <code>I</code> of maximal dimension. In the case of polynomials over the integers, return the intersection of the primary components of I of minimal height.  If <code>I</code> is the unit ideal, return <code>[ideal(1)]</code>.</p><p><strong>Implemented Algorithms</strong></p><p>For polynomial rings over a field, the implementation relies on ideas as used by Gianni, Trager, and Zacharias or Krick and Logar. For polynomial rings over the integers, the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel. See [<a href="../../references/#GTZ88">GTZ88</a>], [<a href="../../references/#KL91">KL91</a>],  and [<a href="../../references/#PSS11">PSS11</a>].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia&gt; I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia&gt; L = equidimensional_hull(I)
Ideal generated by
  x^5 - 2*x^4*y - 2*x^4 + x^3*y^2 + 2*x^3*y - x^2*y^2 + 2*x^2*y + 2*x^2 + 2*x*y^3 + x*y^2 - 2*x*y - x - y^4 - 2*y^3 - y^2</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (a, b, c, d) = polynomial_ring(ZZ, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])
(Multivariate polynomial ring in 4 variables over ZZ, ZZMPolyRingElem[a, b, c, d])

julia&gt; I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,
       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,
       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,
       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,
       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,
       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])
Ideal generated by
  1326*a^2*d^5
  1989*a^2*c^5
  102*b^4*d^5
  153*b^4*c^5
  663*a^2*c^5*d^5
  51*b^4*c^5*d^5
  78*a^2*d^15
  117*a^2*c^15
  78*a^15*d^5
  117*a^15*c^5
  6*a^2*b^4*d^15
  9*a^2*b^4*c^15
  39*a^2*c^5*d^15
  39*a^2*c^15*d^5
  6*a^2*b^15*d^5
  9*a^2*b^15*c^5
  6*a^15*b^4*d^5
  9*a^15*b^4*c^5
  39*a^15*c^5*d^5
  3*a^2*b^4*c^5*d^15
  3*a^2*b^4*c^15*d^5
  3*a^2*b^15*c^5*d^5
  3*a^15*b^4*c^5*d^5

julia&gt; L = equidimensional_hull(I)
Ideal generated by
  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1201-L1274">source</a></section></article><h3 id="Radical-of-the-Equidimensional-Hull"><a class="docs-heading-anchor" href="#Radical-of-the-Equidimensional-Hull">Radical of the Equidimensional Hull</a><a id="Radical-of-the-Equidimensional-Hull-1"></a><a class="docs-heading-anchor-permalink" href="#Radical-of-the-Equidimensional-Hull" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="equidimensional_hull_radical-Tuple{MPolyIdeal}" href="#equidimensional_hull_radical-Tuple{MPolyIdeal}"><code>equidimensional_hull_radical</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equidimensional_hull_radical(I::MPolyIdeal)</code></pre><p>Return the intersection of the associated primes of <code>I</code> of maximal dimension. If <code>I</code> is the unit ideal, return <code>[ideal(1)]</code>.</p><p><strong>Implemented Algorithms</strong></p><p>The implementation relies on a combination of the algorithms of Krick and Logar (with modifications by Laplagne) and Kemper. See [<a href="../../references/#KL91">KL91</a>] and [<a href="../../references/#Kem02">Kem02</a>].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia&gt; I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia&gt; L = equidimensional_hull_radical(I)
Ideal generated by
  x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L1303-L1333">source</a></section></article><h2 id="Homogenization-and-Dehomogenization"><a class="docs-heading-anchor" href="#Homogenization-and-Dehomogenization">Homogenization and Dehomogenization</a><a id="Homogenization-and-Dehomogenization-1"></a><a class="docs-heading-anchor-permalink" href="#Homogenization-and-Dehomogenization" title="Permalink"></a></h2><p>Referring to [<a href="../../references/#KR05">KR05</a>] for definitions and technical details, we discuss homogenization and dehomogenization in the context of <span>$\mathbb Z^m$</span>-gradings. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="homogenizer-Union{Tuple{T}, Tuple{MPolyRing{T}, Union{Char, AbstractString, Symbol}}} where T" href="#homogenizer-Union{Tuple{T}, Tuple{MPolyRing{T}, Union{Char, AbstractString, Symbol}}} where T"><code>homogenizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">homogenizer(P::MPolyRing, h::VarName;  pos::Int=1+ngens(P))</code></pre><p>Create a &quot;homogenizing operator&quot; assuming a standard grading; <code>h</code> is the name of the homogenizing variable; <code>pos</code> indicates where to put the homogenizing variable in the list of generators of the graded polynomial ring (default is after all the other variables).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P, (x,y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; H = homogenizer(P, &quot;h&quot;);

julia&gt; H(x^2+y)
x^2 + y*h

julia&gt; V = H.([x^2+y, x+y^2]);

julia&gt; parent(V[1]) == parent(V[2])
true

julia&gt; H(ideal([x^2+y]))
Ideal generated by
  x^2 + y*h</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-graded.jl#L1634-L1657">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="homogenizer-Union{Tuple{T}, Tuple{MPolyRing{T}, Union{ZZMatrix, Matrix{&lt;:Union{Integer, ZZRingElem}}}, Union{Char, AbstractString, Symbol}}} where T" href="#homogenizer-Union{Tuple{T}, Tuple{MPolyRing{T}, Union{ZZMatrix, Matrix{&lt;:Union{Integer, ZZRingElem}}}, Union{Char, AbstractString, Symbol}}} where T"><code>homogenizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">homogenizer(P::MPolyRing, W::Union{ZZMatrix, Matrix{&lt;:IntegerUnion}}, h::VarName;  pos::Int=1+ngens(P))</code></pre><p>Create a &quot;homogenizing operator&quot; using the grading specified by the columns of <code>W</code>; <code>h</code> is the prefix for the homogenizing variables; <code>pos</code> indicates where to put the homogenizing variables in the list of generators of the graded polynomial ring (default is after all the other variables).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P, (x,y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; W = ZZMatrix(2,2, [2,3,5,7]);

julia&gt; H = homogenizer(P, W, &quot;h&quot;);

julia&gt; H(x^2+y)
x^2 + y*h[1]*h[2]^3

julia&gt; V = H.([x^2+y, x+y^2]);

julia&gt; parent(V[1]) == parent(V[2])
true

julia&gt; H(ideal([x^2+y]))
Ideal generated by
  x^2 + y*h[1]*h[2]^3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-graded.jl#L1663-L1688">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="dehomogenizer-Tuple{Oscar.Homogenizer}" href="#dehomogenizer-Tuple{Oscar.Homogenizer}"><code>dehomogenizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dehomogenizer(H::Homogenizer)</code></pre><p>Create a &quot;dehomogenizing operator&quot; from a <code>Homogenizer</code>; it is effectively a polynomial ring homomorphism mapping all homogenizing variables to 1.  A <code>Dehomogenizer</code> is a post-inverse for the <code>Homogenizer</code> it was created from.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P, (x,y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; H = homogenizer(P, &quot;h&quot;);

julia&gt; DH = dehomogenizer(H);

julia&gt; F = H(x^2+y)
x^2 + y*h

julia&gt; DH(F)
x^2 + y

julia&gt; V = [x^2+y, x*y+y^2]; HV = H.(V);

julia&gt; parent(DH(HV[1])) == P  &amp;&amp;  parent(DH(HV[2])) == P
true

julia&gt; DH(H(ideal(V)))
Ideal generated by
  x*y + y^2
  x^2 + y
  y^3 + y^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-graded.jl#L1720-L1750">source</a></section></article><pre><code class="language-julia-repl hljs">julia&gt; P, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; I = ideal([x^2+y, x*y+y^2]);

julia&gt; H = homogenizer(P, &quot;h&quot;);

julia&gt; Ih = H(I)     # homogenization of ideal I
Ideal generated by
  x*y + y^2
  x^2 + y*h
  y^3 + y^2*h

julia&gt; DH = dehomogenizer(H);

julia&gt; DH(Ih) == I   # dehomogenization of Ih
true</code></pre><h2 id="Ideals-as-Modules"><a class="docs-heading-anchor" href="#Ideals-as-Modules">Ideals as Modules</a><a id="Ideals-as-Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Ideals-as-Modules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ideal_as_module-Tuple{MPolyIdeal}" href="#ideal_as_module-Tuple{MPolyIdeal}"><code>ideal_as_module</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ideal_as_module(I::MPolyIdeal)</code></pre><p>Return <code>I</code> considered as an object of type <code>SubquoModule</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; I = ideal(R, [x^2, y^3])
Ideal generated by
  x^2
  y^3

julia&gt; ideal_as_module(I)
Submodule with 2 generators
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
represented as subquotient with no relations.</code></pre><pre><code class="language-julia-repl hljs">julia&gt; S, (x, y) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; I = ideal(S, [x^2, y^3])
Ideal generated by
  x^2
  y^3

julia&gt; ideal_as_module(I)
Graded submodule of S^1
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
represented as subquotient with no relations</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Modules/ModulesGraded.jl#L2922-L2956">source</a></section></article><h2 id="Generating-Special-Ideals"><a class="docs-heading-anchor" href="#Generating-Special-Ideals">Generating Special Ideals</a><a id="Generating-Special-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-Special-Ideals" title="Permalink"></a></h2><h3 id="Katsura-n"><a class="docs-heading-anchor" href="#Katsura-n">Katsura-n</a><a id="Katsura-n-1"></a><a class="docs-heading-anchor-permalink" href="#Katsura-n" title="Permalink"></a></h3><p>These systems appeared in a problem of magnetism in physics. For a given <span>$n$</span> <code>katsura(n)</code> has <span>$2^n$</span> solutions and is defined in a polynomial ring with <span>$n+1$</span> variables over the rational numbers. For a given polynomial ring <code>R</code> with <span>$n$</span> variables <code>katsura(R)</code> defines the corresponding system with <span>$2^{n-1}$</span> solutions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="katsura-Tuple{Int64}" href="#katsura-Tuple{Int64}"><code>katsura</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">katsura(n::Int)</code></pre><p>Given a natural number <code>n</code> return the Katsura ideal over the rational numbers generated by <span>$u_m - \sum_{l=-n}^n u_{l-m} u_l$</span>, <span>$1 - \sum_{l = -n}^n u_l$</span> where <span>$u_{-i} = u_i$</span>, and <span>$u_i = 0$</span> for <span>$i &gt; n$</span> and <span>$m \in \{-n, \ldots, n\}$</span>.</p><p>Note that indices have been shifted to start from 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; I = katsura(2)
Ideal generated by
  x1 + 2*x2 + 2*x3 - 1
  x1^2 - x1 + 2*x2^2 + 2*x3^2
  2*x1*x2 + 2*x2*x3 - x2
julia&gt; base_ring(I)
Multivariate polynomial ring in 3 variables x1, x2, x3
  over rational field</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/special_ideals.jl#L13-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="katsura-Tuple{MPolyRing}" href="#katsura-Tuple{MPolyRing}"><code>katsura</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">katsura(R::MPolyRing)</code></pre><p>Return the Katsura ideal in the given polynomial ring <code>R</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, _ = QQ[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; katsura(R)
Ideal generated by
  x + 2*y + 2*z - 1
  x^2 - x + 2*y^2 + 2*z^2
  2*x*y + 2*y*z - y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/special_ideals.jl#L39-L55">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../rings/">« Creating Multivariate Rings</a><a class="docs-footer-nextpage" href="../affine_algebras/">Affine Algebras and Their Ideals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Wednesday 17 April 2024 13:28">Wednesday 17 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
