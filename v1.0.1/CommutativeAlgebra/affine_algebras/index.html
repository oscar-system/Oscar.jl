<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Affine Algebras and Their Ideals · Oscar.jl</title><meta name="title" content="Affine Algebras and Their Ideals · Oscar.jl"/><meta property="og:title" content="Affine Algebras and Their Ideals · Oscar.jl"/><meta property="twitter:title" content="Affine Algebras and Their Ideals · Oscar.jl"/><meta name="description" content="Documentation for Oscar.jl."/><meta property="og:description" content="Documentation for Oscar.jl."/><meta property="twitter:description" content="Documentation for Oscar.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li><li><a class="tocitem" href="../../Nemo/algebraic/">Algebraic numbers</a></li><li><a class="tocitem" href="../../Fields/algebraic_closure_fp/">Algebraic closure of finite prime fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../NumberTheory/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox" checked/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../ideals/">Ideals in Multivariate Rings</a></li><li class="is-active"><a class="tocitem" href>Affine Algebras and Their Ideals</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Data-Associated-to-Affine-Algebras"><span>Data Associated to Affine Algebras</span></a></li><li><a class="tocitem" href="#Elements-of-Affine-Algebras"><span>Elements of Affine Algebras</span></a></li><li><a class="tocitem" href="#Ideals-in-Affine-Algebras"><span>Ideals in Affine Algebras</span></a></li><li><a class="tocitem" href="#Homomorphisms-From-Affine-Algebras"><span>Homomorphisms From Affine Algebras</span></a></li><li><a class="tocitem" href="#Homomorphisms-of-Affine-Algebras"><span>Homomorphisms of Affine Algebras</span></a></li><li><a class="tocitem" href="#Algebraic-Independence"><span>Algebraic Independence</span></a></li><li><a class="tocitem" href="#Subalgebras"><span>Subalgebras</span></a></li><li><a class="tocitem" href="#Noether-Normalization"><span>Noether Normalization</span></a></li><li><a class="tocitem" href="#Normalization"><span>Normalization</span></a></li><li><a class="tocitem" href="#Integral-Bases"><span>Integral Bases</span></a></li><li><a class="tocitem" href="#Tests-on-Affine-Algebras"><span>Tests on Affine Algebras</span></a></li><li><a class="tocitem" href="#Hilbert-Series-and-Hilbert-Polynomial"><span>Hilbert Series and Hilbert Polynomial</span></a></li><li><a class="tocitem" href="#Affine-Algebras-as-Modules"><span>Affine Algebras as Modules</span></a></li></ul></li><li><a class="tocitem" href="../localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li></ul></li><li><a class="tocitem" href="../homological_algebra/">Homological Algebra</a></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Gröbner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../GroebnerBases/groebner_bases/">Gröbner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../GroebnerBases/groebner_bases_integers/">Gröbner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-10" type="checkbox"/><label class="tocitem" for="menuitem-9-10"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/tori/">Invariants of Tori</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveringsAndGluings/">Coverings</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/">Morphisms of covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ProjectiveSchemes/">Projective schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/">Morphisms of projective schemes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Sheaf Cohomology</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/SheafCohomology/sheaf_cohomology/">Sheaves on Projective Space</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Algebraic Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/">Affine Algebraic Sets</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/">Projective Algebraic Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Algebraic Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/AlgebraicVarieties/AffineVariety/">Affine Varieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/">Projective Varieties</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Rational Points</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/RationalPoints/Affine/">Affine</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/RationalPoints/Projective/">Projective</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricSchemes/">Toric Schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricIdealSheaves/">Toric Ideal Sheaves (Experimental)</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/BlowdownMorphisms/">Toric Blowdown Morphisms (Experimental)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-8" type="checkbox"/><label class="tocitem" for="menuitem-11-8"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/AffinePlaneCurves/">Affine plane curves</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/ProjectiveCurves/">Projective Curves</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/ProjectivePlaneCurves/">Projective Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-9" type="checkbox"/><label class="tocitem" for="menuitem-11-9"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/K3Surfaces/">Automorphism Groups of  K3 surfaces</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/SurfacesP4/">Nongeneral Type Surfaces in <span>$\mathbb P^4$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-10" type="checkbox"/><label class="tocitem" for="menuitem-11-10"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Miscellaneous/miscellaneous/">Some Special Ideals</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../TropicalGeometry/semiring/">Tropical semirings, matrices, and polynomials</a></li><li><a class="tocitem" href="../../TropicalGeometry/semiring_map/">Tropical semiring maps</a></li><li><a class="tocitem" href="../../TropicalGeometry/variety/">Tropical varieties</a></li><li><a class="tocitem" href="../../TropicalGeometry/hypersurface/">Tropical hypersurfaces</a></li><li><a class="tocitem" href="../../TropicalGeometry/curve/">Tropical curves</a></li><li><a class="tocitem" href="../../TropicalGeometry/linear_space/">Tropical linear spaces</a></li><li><a class="tocitem" href="../../TropicalGeometry/groebner_theory/">Groebner theory</a></li><li><a class="tocitem" href="../../TropicalGeometry/tropicalization/">Tropicalization of polynomial ideals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Noncommutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-13-2" type="checkbox"/><label class="tocitem" for="menuitem-13-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li><li><a class="tocitem" href="../../Combinatorics/phylogenetic_trees/">Phylogenetic Trees</a></li><li><input class="collapse-toggle" id="menuitem-14-5" type="checkbox"/><label class="tocitem" for="menuitem-14-5"><span class="docs-label">Enumerative combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/EnumerativeCombinatorics/partitions/">Partitions</a></li><li><a class="tocitem" href="../../Combinatorics/EnumerativeCombinatorics/tableaux/">Tableaux</a></li><li><a class="tocitem" href="../../Combinatorics/EnumerativeCombinatorics/schur_polynomials/">Schur polynomials</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-18" type="checkbox"/><label class="tocitem" for="menuitem-18"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/printing_details/">Details on printing in Oscar</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/serialization/">Serialization</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/gap_integration/">GAP Integration</a></li><li><input class="collapse-toggle" id="menuitem-18-9" type="checkbox"/><label class="tocitem" for="menuitem-18-9"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-19" type="checkbox"/><label class="tocitem" for="menuitem-19"><span class="docs-label">Experimental</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/intro/">Adding new projects to experimental</a></li><li><input class="collapse-toggle" id="menuitem-19-2" type="checkbox"/><label class="tocitem" for="menuitem-19-2"><span class="docs-label">Double complexes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/DoubleAndHyperComplexes/user_interface/">Double complexes – the user&#39;s interface</a></li><li><a class="tocitem" href="../../Experimental/DoubleAndHyperComplexes/advice_for_the_programmer/">Advice for the programmer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-3" type="checkbox"/><label class="tocitem" for="menuitem-19-3"><span class="docs-label">F-Theory Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/FTheoryTools/introduction/">Welcome to FTheoryTools</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/generalities/">Functionality for all F-theory models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/weierstrass/">Weierstrass models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/tate/">Global Tate models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/hypersurface/">Hypersurface models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/literature/">Literature constructions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-4" type="checkbox"/><label class="tocitem" for="menuitem-19-4"><span class="docs-label">Linear Quotients</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/LinearQuotients/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/LinearQuotients/linear_quotients/">Construction and basic functionality</a></li><li><a class="tocitem" href="../../Experimental/LinearQuotients/cox_rings/">Cox rings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-5" type="checkbox"/><label class="tocitem" for="menuitem-19-5"><span class="docs-label">Matroid Realization Spaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/MatroidRealizationSpaces/introduction/">Matroid Realization Spaces</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-6" type="checkbox"/><label class="tocitem" for="menuitem-19-6"><span class="docs-label">Orthogonal discriminants</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/OrthogonalDiscriminants/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/OrthogonalDiscriminants/access/">Access to precomputed OD data</a></li><li><a class="tocitem" href="../../Experimental/OrthogonalDiscriminants/compute/">Criteria for computing orthogonal discriminants</a></li><li><a class="tocitem" href="../../Experimental/OrthogonalDiscriminants/misc/">Miscellaneous functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-7" type="checkbox"/><label class="tocitem" for="menuitem-19-7"><span class="docs-label">Quadratic forms and isometries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/introduction/">Quadratic forms and isometries</a></li><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/spacewithisom/">Quadratic spaces with isometry</a></li><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/latwithisom/">Lattices with isometry</a></li><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/enumeration/">Enumeration of isometries</a></li><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/primembed/">Nikulin&#39;s theory on primitive embeddings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-8" type="checkbox"/><label class="tocitem" for="menuitem-19-8"><span class="docs-label">Standard Finite Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/StandardFiniteFields/introduction/">-</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-9" type="checkbox"/><label class="tocitem" for="menuitem-19-9"><span class="docs-label">Lie Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/LieAlgebras/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/lie_algebras/">Lie algebras</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/ideals_and_subalgebras/">Ideals and Lie subalgebras</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/lie_algebra_homs/">Lie algebra homomorphisms</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/modules/">Lie algebra modules</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/module_homs/">Lie algebra module homomorphisms</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/cartan_matrix/">Cartan Matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-10" type="checkbox"/><label class="tocitem" for="menuitem-19-10"><span class="docs-label">Bases for highest weight modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/BasisLieHighestWeight/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/BasisLieHighestWeight/user_functions/">User-facing functions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Commutative Algebra</a></li><li class="is-active"><a href>Affine Algebras and Their Ideals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Affine Algebras and Their Ideals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/oscar-system/Oscar.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/CommutativeAlgebra/affine_algebras.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="affine_algebras"><a class="docs-heading-anchor" href="#affine_algebras">Affine Algebras and Their Ideals</a><a id="affine_algebras-1"></a><a class="docs-heading-anchor-permalink" href="#affine_algebras" title="Permalink"></a></h1><p>With regard to notation, we use <em>affine algebra</em> as a synonym for <em>quotient of a multivariate polynomial ring by an ideal</em>. More specifically, if <span>$R$</span> is a multivariate polynomial ring with coefficient ring <span>$C$</span>, and <span>$A=R/I$</span> is the quotient of <span>$R$</span> by an ideal <span>$I$</span> of <span>$R$</span>, we refer to <span>$A$</span> as an <em>affine algebra over <span>$C$</span></em>, or an <em>affine <span>$C$</span>-algebra</em>. In this section, we discuss functionality for handling such algebras in OSCAR.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To emphasize this point: In this section, we view <span>$R/I$</span> together with its ring structure. Realizing <span>$R/I$</span> as an <span>$R$</span>-module means to implement it as the quotient of a free <span>$R$</span>-module of rank 1. See the section on <a href="../ModulesOverMultivariateRings/intro/#modules_multivariate">modules</a>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Most functions discussed here rely on Gröbner basis techniques. In particular, they typically make use of a Gröbner basis for the modulus of the quotient. Nevertheless, the construction of quotients is lazy in the sense that the computation of such a Gröbner basis is delayed until the user performs an operation that indeed requires it (the Gröbner basis is then computed with respect to the monomial ordering entered by the user when creating the quotient; if no such ordering is entered, OSCAR will use the <code>default_ordering</code> on the underlying polynomial ring; see the section on <a href="../GroebnerBases/groebner_bases/#gb_fields">Gröbner/Standard Bases</a> for default orderings in OSCAR). Once computed, the Gröbner basis is cached for later reuse.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Recall that Gröbner basis methods are implemented for multivariate polynomial rings over fields (exact fields supported by OSCAR) and, where not indicated otherwise, for multivariate polynomial rings over the integers.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In OSCAR, elements of a quotient <span>$A = R/I$</span> are not necessarily represented by polynomials which are reduced with regard to <span>$I$</span>. That is, if <span>$f\in R$</span> is the internal polynomial representative of an element of <span>$A$</span>, then <span>$f$</span> may not be the normal form mod <span>$I$</span> with respect to the default ordering on <span>$R$</span> (see the section on <a href="../GroebnerBases/groebner_bases/#gb_fields">Gröbner/Standard Bases</a> for normal forms). Operations involving Gröbner basis computations may lead to (partial) reductions. The function <code>simplify</code> discussed in this section computes fully reduced representatives.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Each grading on a multivariate polynomial ring <code>R</code>  in OSCAR  descends to a grading on the affine algebra <code>A = R/I</code> (recall that OSCAR ideals of graded polynomial rings are required to be homogeneous). Functionality for dealing with such gradings and our notation for describing this functionality descend accordingly. This applies, in particular, to the functions <a href="../ModulesOverMultivariateRings/free_modules/#is_graded-Tuple{FreeModuleHom}"><code>is_graded</code></a>,  <a href="../rings/#is_standard_graded-Tuple{MPolyDecRing}"><code>is_standard_graded</code></a>, <a href="../rings/#is_z_graded-Tuple{MPolyDecRing}"><code>is_z_graded</code></a>, <a href="../rings/#is_zm_graded-Tuple{MPolyDecRing}"><code>is_zm_graded</code></a>, and <a href="../rings/#is_positively_graded-Tuple{MPolyDecRing}"><code>is_positively_graded</code></a> which will not be discussed again here.</p></div></div><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>The OSCAR type for quotients of  multivariate polynomial rings is of parametrized form <code>MPolyQuoRing{T}</code>, with elements of type <code>MPolyQuoRingElem{T}</code>. Here, <code>T</code> is the element type of the polynomial ring.</p><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="quo-Tuple{MPolyRing, MPolyIdeal}" href="#quo-Tuple{MPolyRing, MPolyIdeal}"><code>quo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quo(R::MPolyRing, I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(R)) -&gt; MPolyQuoRing, Map</code></pre><p>Create the quotient ring <code>R/I</code> and return the new ring as well as the projection map <code>R</code> <span>$\to$</span> <code>R/I</code>.</p><pre><code class="nohighlight hljs">quo(R::MPolyRing, V::Vector{MPolyRingElem}; ordering::MonomialOrdering = default_ordering(R)) -&gt; MPolyQuoRing, Map</code></pre><p>As above, where <code>I</code> is the ideal of <code>R</code> generated by the polynomials in <code>V</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Once <code>R/I</code> is created,  all computations within <code>R/I</code> relying on division with remainder and/or Gröbner bases are done with respect to <code>ordering</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, p = quo(R, ideal(R, [x^2-y^3, x-y]));

julia&gt; A
Quotient
  of multivariate polynomial ring in 2 variables x, y
    over rational field
  by ideal (x^2 - y^3, x - y)

julia&gt; typeof(A)
MPolyQuoRing{QQMPolyRingElem}

julia&gt; typeof(x)
QQMPolyRingElem

julia&gt; p
Map defined by a julia-function with inverse
  from multivariate polynomial ring in 2 variables over QQ
  to quotient of multivariate polynomial ring by ideal (x^2 - y^3, x - y)

julia&gt; p(x)
x

julia&gt; typeof(p(x))
MPolyQuoRingElem{QQMPolyRingElem}</code></pre><pre><code class="language-julia-repl hljs">julia&gt; S, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; B, _ = quo(S, ideal(S, [x^2*z-y^3, x-y]))
(Quotient of multivariate polynomial ring by ideal (x^2*z - y^3, x - y), Map: S -&gt; B)

julia&gt; typeof(B)
MPolyQuoRing{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L947-L997">source</a></section></article><h2 id="Data-Associated-to-Affine-Algebras"><a class="docs-heading-anchor" href="#Data-Associated-to-Affine-Algebras">Data Associated to Affine Algebras</a><a id="Data-Associated-to-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Associated-to-Affine-Algebras" title="Permalink"></a></h2><h3 id="Basic-Data"><a class="docs-heading-anchor" href="#Basic-Data">Basic Data</a><a id="Basic-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Data" title="Permalink"></a></h3><p>If <code>A=R/I</code> is the quotient of a multivariate polynomial ring <code>R</code> modulo an ideal <code>I</code> of <code>R</code>, then</p><ul><li><code>base_ring(A)</code> refers to <code>R</code>,</li><li><code>modulus(A)</code> to <code>I</code>,</li><li><code>gens(A)</code> to the generators of <code>A</code>,</li><li><code>number_of_generators(A)</code> / <code>ngens(A)</code> to the number of these generators, and</li><li><code>gen(A, i)</code> as well as <code>A[i]</code> to the <code>i</code>-th such generator.</li></ul><h6 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));

julia&gt; base_ring(A)
Multivariate polynomial ring in 3 variables x, y, z
  over rational field

julia&gt; modulus(A)
Ideal generated by
  -x^2 + y
  -x^3 + z

julia&gt; gens(A)
3-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:
 x
 y
 z

julia&gt; number_of_generators(A)
3

julia&gt; gen(A, 2)
y
</code></pre><p>In the graded case, we additionally have:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="grading_group-Tuple{MPolyQuoRing{&lt;:MPolyDecRingElem}}" href="#grading_group-Tuple{MPolyQuoRing{&lt;:MPolyDecRingElem}}"><code>grading_group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grading_group(A::MPolyQuoRing{&lt;:MPolyDecRingElem})</code></pre><p>If <code>A</code> is, say, <code>G</code>-graded, return <code>G</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^2*z-y^3, x-y]));

julia&gt; grading_group(A)
Z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L1457-L1471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="monomial_basis-Tuple{MPolyQuoRing, FinGenAbGroupElem}" href="#monomial_basis-Tuple{MPolyQuoRing, FinGenAbGroupElem}"><code>monomial_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">monomial_basis(A::MPolyQuoRing, g::FinGenAbGroupElem)</code></pre><p>Given an affine algebra <code>A</code> over a field which is graded by a free group of type <code>FinGenAbGroup</code>, and given an element <code>g</code> of that group, return a vector of monomials of <code>R</code> such that the residue classes of  these monomials form a <code>K</code>-basis of the graded part of <code>A</code> of degree <code>g</code>.</p><pre><code class="nohighlight hljs">monomial_basis(A::MPolyQuoRing, W::Vector{&lt;:IntegerUnion})</code></pre><p>Given a <span>$\mathbb  Z^m$</span>-graded affine algebra <code>A</code> over a field and a vector <code>W</code> of <span>$m$</span> integers, convert <code>W</code> into an element <code>g</code> of the grading group of <code>A</code> and proceed as above.</p><pre><code class="nohighlight hljs">monomial_basis(A::MPolyQuoRing, d::IntegerUnion)</code></pre><p>Given a <span>$\mathbb  Z$</span>-graded  affine algebra <code>A</code> over a field and an integer <code>d</code>, convert <code>d</code> into an element <code>g</code> of the grading group of <code>A</code> and proceed as above.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the component of the given degree is not finite dimensional, an error message will be thrown.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; I = ideal(R, [x^2])
Ideal generated by
  x^2

julia&gt; A, _ = quo(R, I)
(Quotient of multivariate polynomial ring by ideal (x^2), Map: R -&gt; A)

julia&gt; L = monomial_basis(A, 3)
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 y^3
 x*y^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L109-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="homogeneous_component-Tuple{MPolyQuoRing{&lt;:MPolyDecRingElem}, FinGenAbGroupElem}" href="#homogeneous_component-Tuple{MPolyQuoRing{&lt;:MPolyDecRingElem}, FinGenAbGroupElem}"><code>homogeneous_component</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">homogeneous_component(A::MPolyQuoRing{&lt;:MPolyDecRingElem}, g::FinGenAbGroupElem)</code></pre><p>Given a graded quotient <code>A</code> of a multivariate polynomial ring over a field,  where the grading group is free of type <code>FinGenAbGroup</code>, and given an element <code>g</code> of  that group, return the homogeneous component of <code>A</code> of degree <code>g</code>. Additionally, return the embedding of the component into <code>A</code>.</p><pre><code class="nohighlight hljs">homogeneous_component(A::MPolyQuoRing{&lt;:MPolyDecRingElem}, g::Vector{&lt;:IntegerUnion})</code></pre><p>Given a <span>$\mathbb  Z^m$</span>-graded quotient <code>A</code> of a multivariate polynomial ring over a field,  and given a vector <code>g</code> of <span>$m$</span> integers, convert <code>g</code> into an element of the grading group of <code>A</code>, and return the homogeneous component of <code>A</code> whose degree  is that element. Additionally, return the embedding of the component into <code>A</code>.</p><pre><code class="nohighlight hljs">homogeneous_component(A::MPolyQuoRing{&lt;:MPolyDecRingElem}, g::IntegerUnion)</code></pre><p>Given a <span>$\mathbb  Z$</span>-graded quotient <code>A</code> of a multivariate polynomial ring over a field,  and given an integer <code>g</code>, convert <code>g</code> into an element of the grading group of <code>A</code>,  and return the homogeneous component of <code>A</code> whose degree is that element. Additionally, return the embedding of the component into <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the component is not finite dimensional, an error message will be thrown.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Graded multivariate polynomial ring in 4 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[w, x, y, z])

julia&gt; L = homogeneous_component(R, 2);

julia&gt; HC = gens(L[1]);

julia&gt; EMB = L[2]
Map defined by a julia-function with inverse
  from R_[2] of dim 10
  to graded multivariate polynomial ring in 4 variables over QQ

julia&gt; for i in 1:length(HC) println(EMB(HC[i])) end
z^2
y*z
y^2
x*z
x*y
x^2
w*z
w*y
w*x
w^2

julia&gt; PTC = ideal(R, [-x*z + y^2, -w*z + x*y, -w*y + x^2]);

julia&gt; A, _ = quo(R, PTC);

julia&gt; L = homogeneous_component(A, 2);

julia&gt; HC = gens(L[1]);

julia&gt; EMB = L[2]
Map defined by a julia-function with inverse
  from quotient space over:
  Rational field with 7 generators and no relations
  to quotient of multivariate polynomial ring by ideal (-x*z + y^2, -w*z + x*y, -w*y + x^2)

julia&gt; for i in 1:length(HC) println(EMB(HC[i])) end
z^2
y*z
x*z
w*z
w*y
w*x
w^2</code></pre><pre><code class="language-julia-repl hljs">julia&gt; G = abelian_group([0, 0])
Z^2

julia&gt; W = [G[1], G[1], G[2], G[2], G[2]];

julia&gt; S, x, y = graded_polynomial_ring(QQ, &quot;x&quot; =&gt; 1:2, &quot;y&quot; =&gt; 1:3; weights = W);

julia&gt; L = homogeneous_component(S, [2,1]);

julia&gt; HC = gens(L[1]);

julia&gt; EMB = L[2]
Map defined by a julia-function with inverse
  from S_[2 1] of dim 9
  to graded multivariate polynomial ring in 5 variables over QQ

julia&gt; for i in 1:length(HC) println(EMB(HC[i])) end
x[2]^2*y[3]
x[2]^2*y[2]
x[2]^2*y[1]
x[1]*x[2]*y[3]
x[1]*x[2]*y[2]
x[1]*x[2]*y[1]
x[1]^2*y[3]
x[1]^2*y[2]
x[1]^2*y[1]

julia&gt; I = ideal(S, [x[1]*y[1]-x[2]*y[2]]);

julia&gt; A, = quo(S, I);

julia&gt; L = homogeneous_component(A, [2,1]);

julia&gt; HC = gens(L[1]);

julia&gt; EMB = L[2]
Map defined by a julia-function with inverse
  from quotient space over:
  Rational field with 7 generators and no relations
  to quotient of multivariate polynomial ring by ideal (x[1]*y[1] - x[2]*y[2])

julia&gt; for i in 1:length(HC) println(EMB(HC[i])) end
x[2]^2*y[3]
x[2]^2*y[2]
x[2]^2*y[1]
x[1]*x[2]*y[3]
x[1]*x[2]*y[2]
x[1]^2*y[3]
x[1]^2*y[2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L1496-L1622">source</a></section></article><h3 id="Dimension"><a class="docs-heading-anchor" href="#Dimension">Dimension</a><a id="Dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Dimension" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="dim-Tuple{MPolyQuoRing}" href="#dim-Tuple{MPolyQuoRing}"><code>dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim(A::MPolyQuoRing)</code></pre><p>Return the Krull dimension of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));

julia&gt; dim(A)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="vector_space_dimension-Tuple{MPolyQuoRing}" href="#vector_space_dimension-Tuple{MPolyQuoRing}"><code>vector_space_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_space_dimension(A::MPolyQuoRing)</code></pre><p>If, say, <code>A = R/I</code>, where <code>R</code> is a multivariate polynomial ring over a field <code>K</code>, and <code>I</code> is a zero-dimensional ideal of <code>R</code>, return the dimension of <code>A</code>  as a <code>K</code>-vector space.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^3+y^3+z^3-1, x^2+y^2+z^2-1, x+y+z-1]));

julia&gt; vector_space_dimension(A)
6

julia&gt; I = modulus(A)
Ideal generated by
  x^3 + y^3 + z^3 - 1
  x^2 + y^2 + z^2 - 1
  x + y + z - 1

julia&gt; groebner_basis(I, ordering = lex(base_ring(I)))
Gröbner basis with elements
1 -&gt; z^3 - z^2
2 -&gt; y^2 + y*z - y + z^2 - z
3 -&gt; x + y + z - 1
with respect to the ordering
lex([x, y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L28-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="monomial_basis-Tuple{MPolyQuoRing}" href="#monomial_basis-Tuple{MPolyQuoRing}"><code>monomial_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">monomial_basis(A::MPolyQuoRing)</code></pre><p>If, say, <code>A = R/I</code>, where <code>R</code> is a multivariate polynomial ring over a field <code>K</code>, and <code>I</code> is a zero-dimensional ideal of <code>R</code>, return a vector of monomials of <code>R</code>  such that the residue classes of these monomials form a basis of <code>A</code> as a <code>K</code>-vector space.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; I = ideal(R, [x^2, y^3])
Ideal generated by
  x^2
  y^3

julia&gt; A, _ = quo(R, I)
(Quotient of multivariate polynomial ring by ideal (x^2, y^3), Map: R -&gt; A)

julia&gt; L = monomial_basis(A)
6-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x*y^2
 y^2
 x*y
 y
 x
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L69-L98">source</a></section></article><h2 id="Elements-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Elements-of-Affine-Algebras">Elements of Affine Algebras</a><a id="Elements-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Elements-of-Affine-Algebras" title="Permalink"></a></h2><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><p>The OSCAR type for elements of quotients of  multivariate polynomial rings is of parametrized form <code>MPolyQuoRing{T}</code>, where <code>T</code> is the element type of the polynomial ring.</p><h3 id="Creating-Elements-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Creating-Elements-of-Affine-Algebras">Creating Elements of Affine Algebras</a><a id="Creating-Elements-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Elements-of-Affine-Algebras" title="Permalink"></a></h3><p>Elements of an affine algebra <code>A=R/I</code> are created as images of elements of <code>R</code> under the projection map or by directly coercing elements of <code>R</code> into <code>A</code>.</p><h6 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, p = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));

julia&gt; f = p(x^3*y^2-y^3*x^2+x*y)
x^3*y^2 - x^2*y^3 + x*y

julia&gt; typeof(f)
MPolyQuoRingElem{QQMPolyRingElem}

julia&gt; g = A(x^3*y^2-y^3*x^2+x*y)
x^3*y^2 - x^2*y^3 + x*y

julia&gt; f == g
true
</code></pre><h3 id="Reducing-Polynomial-Representatives"><a class="docs-heading-anchor" href="#Reducing-Polynomial-Representatives">Reducing Polynomial Representatives</a><a id="Reducing-Polynomial-Representatives-1"></a><a class="docs-heading-anchor-permalink" href="#Reducing-Polynomial-Representatives" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="simplify-Tuple{MPolyQuoRingElem}" href="#simplify-Tuple{MPolyQuoRingElem}"><code>simplify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify(f::MPolyQuoRingElem)</code></pre><p>If <code>f</code> is an element of the quotient of a multivariate polynomial ring <code>R</code> by an ideal <code>I</code> of <code>R</code>, say, replace the internal polynomial representative of <code>f</code> by its normal form mod <code>I</code> with respect to  the <code>default_ordering</code> on <code>R</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>Since this method only has a computational backend for quotients of polynomial rings  over a field, it is not implemented generically.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x,) = polynomial_ring(QQ, [&quot;x&quot;]);

julia&gt; A, p = quo(R, ideal(R, [x^4]));

julia&gt; f = p(2*x^6 + x^3 + x)
2*x^6 + x^3 + x

julia&gt; simplify(f)
x^3 + x

julia&gt; f
x^3 + x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L825-L851">source</a></section></article><h3 id="Tests-on-Elements-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Tests-on-Elements-of-Affine-Algebras">Tests on Elements of Affine Algebras</a><a id="Tests-on-Elements-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-on-Elements-of-Affine-Algebras" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="==-Union{Tuple{T}, Tuple{MPolyQuoRingElem{T}, MPolyQuoRingElem{T}}} where T" href="#==-Union{Tuple{T}, Tuple{MPolyQuoRingElem{T}, MPolyQuoRingElem{T}}} where T"><code>==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(f::MPolyQuoRingElem{T}, g::MPolyQuoRingElem{T}) where T</code></pre><p>Return <code>true</code> if <code>f</code> is equal to <code>g</code>, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x,) = polynomial_ring(QQ, [&quot;x&quot;]);

julia&gt; A, p = quo(R, ideal(R, [x^4]));

julia&gt; f = p(x-x^6)
-x^6 + x

julia&gt; g = p(x)
x

julia&gt; f == g
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L901-L921">source</a></section></article><p>In the graded case, we additionally have:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_homogeneous-Tuple{MPolyQuoRingElem{&lt;:MPolyDecRingElem}}" href="#is_homogeneous-Tuple{MPolyQuoRingElem{&lt;:MPolyDecRingElem}}"><code>is_homogeneous</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_homogeneous(f::MPolyQuoRingElem{&lt;:MPolyDecRingElem})</code></pre><p>Given an element <code>f</code> of a graded affine algebra, return <code>true</code> if <code>f</code> is homogeneous, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, p = quo(R, ideal(R, [y-x, z^3-x^3]));

julia&gt; f = p(y^2-x^2+z^4)
-x^2 + y^2 + z^4

julia&gt; is_homogeneous(f)
true

julia&gt; f
z^4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L1431-L1451">source</a></section></article><h3 id="Data-associated-to-Elements-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Data-associated-to-Elements-of-Affine-Algebras">Data associated to Elements of Affine Algebras</a><a id="Data-associated-to-Elements-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Data-associated-to-Elements-of-Affine-Algebras" title="Permalink"></a></h3><p>Given an element <code>f</code> of an affine algebra <code>A</code>,</p><ul><li><code>parent(f)</code> refers to <code>A</code>.</li></ul><p>In the graded case,  we also have:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="homogeneous_components-Tuple{MPolyQuoRingElem{&lt;:MPolyDecRingElem}}" href="#homogeneous_components-Tuple{MPolyQuoRingElem{&lt;:MPolyDecRingElem}}"><code>homogeneous_components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">homogeneous_components(f::MPolyQuoRingElem{&lt;:MPolyDecRingElem})</code></pre><p>Given an element <code>f</code> of a graded affine algebra, return the homogeneous components of <code>f</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, p = quo(R, ideal(R, [y-x, z^3-x^3]));

julia&gt; f = p(y^2-x^2+x*y*z+z^4)
-x^2 + x*y*z + y^2 + z^4

julia&gt; homogeneous_components(f)
Dict{FinGenAbGroupElem, MPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}} with 2 entries:
  [4] =&gt; z^4
  [3] =&gt; y^2*z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L1405-L1424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="homogeneous_component-Tuple{MPolyQuoRingElem{&lt;:MPolyDecRingElem}, FinGenAbGroupElem}" href="#homogeneous_component-Tuple{MPolyQuoRingElem{&lt;:MPolyDecRingElem}, FinGenAbGroupElem}"><code>homogeneous_component</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">homogeneous_component(f::MPolyQuoRingElem{&lt;:MPolyDecRingElem}, g::FinGenAbGroupElem)</code></pre><p>Given an element <code>f</code> of a graded affine algebra, and given an element <code>g</code> of the grading group of that algebra, return the homogeneous component of <code>f</code> of degree <code>g</code>.</p><pre><code class="nohighlight hljs">homogeneous_component(f::MPolyQuoRingElem{&lt;:MPolyDecRingElem}, g::Vector{&lt;:IntegerUnion})</code></pre><p>Given an element <code>f</code> of a <span>$\mathbb  Z^m$</span>-graded affine algebra <code>A</code>, say, and given a vector <code>g</code> of <span>$m$</span> integers, convert <code>g</code> into an element of the grading group of <code>A</code>, and return the homogeneous component of <code>f</code> whose degree is that element.</p><pre><code class="nohighlight hljs">homogeneous_component(f::MPolyQuoRingElem{&lt;:MPolyDecRingElem}, g::IntegerUnion)</code></pre><p>Given an element <code>f</code> of a <span>$\mathbb  Z$</span>-graded affine algebra <code>A</code>, say, and given an integer <code>g</code>, convert <code>g</code> into an element of the grading group of <code>A</code>, and return the homogeneous component of <code>f</code> whose degree is that element.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, p = quo(R, ideal(R, [y-x, z^3-x^3]));

julia&gt; f = p(y^2-x^2+x*y*z+z^4)
-x^2 + x*y*z + y^2 + z^4

julia&gt; homogeneous_component(f, 4)
z^4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L1359-L1389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="degree-Tuple{MPolyQuoRingElem{&lt;:MPolyDecRingElem}}" href="#degree-Tuple{MPolyQuoRingElem{&lt;:MPolyDecRingElem}}"><code>degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree(f::MPolyQuoRingElem{&lt;:MPolyDecRingElem})</code></pre><p>Given a homogeneous element <code>f</code> of a graded affine algebra, return the degree of <code>f</code>.</p><pre><code class="nohighlight hljs">degree(::Type{Vector{Int}}, f::MPolyQuoRingElem{&lt;:MPolyDecRingElem})</code></pre><p>Given a homogeneous element <code>f</code> of a <span>$\mathbb Z^m$</span>-graded affine algebra, return the degree of <code>f</code>, converted to a vector of integer numbers.</p><pre><code class="nohighlight hljs">degree(::Type{Int}, f::MPolyQuoRingElem{&lt;:MPolyDecRingElem})</code></pre><p>Given a homogeneous element <code>f</code> of a <span>$\mathbb Z$</span>-graded affine algebra, return the degree of <code>f</code>, converted to an integer number.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] );

julia&gt; A, p = quo(R, ideal(R, [y-x, z^3-x^3]))
(Quotient of multivariate polynomial ring by ideal (-x + y, -x^3 + z^3), Map: R -&gt; A)

julia&gt; f = p(y^2-x^2+z^4)
-x^2 + y^2 + z^4

julia&gt; degree(f)
[4]

julia&gt; typeof(degree(f))
FinGenAbGroupElem

julia&gt; degree(Int, f)
4

julia&gt; typeof(degree(Int, f))
Int64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L1298-L1333">source</a></section></article><h2 id="Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Ideals-in-Affine-Algebras">Ideals in Affine Algebras</a><a id="Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Ideals-in-Affine-Algebras" title="Permalink"></a></h2><h3 id="Constructors-2"><a class="docs-heading-anchor" href="#Constructors-2">Constructors</a><a class="docs-heading-anchor-permalink" href="#Constructors-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ideal-Union{Tuple{T}, Tuple{MPolyQuoRing{T}, Vector{T}}} where T&lt;:MPolyRingElem" href="#ideal-Union{Tuple{T}, Tuple{MPolyQuoRing{T}, Vector{T}}} where T&lt;:MPolyRingElem"><code>ideal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ideal(A::MPolyQuoRing{T}, V::Vector{T}) where T &lt;: MPolyRingElem</code></pre><p>Given a (graded) quotient ring <code>A=R/I</code> and a vector <code>V</code> of (homogeneous) polynomials in <code>R</code>, create the ideal of <code>A</code> which is generated by the images of the entries of <code>V</code>.</p><pre><code class="nohighlight hljs">ideal(A::MPolyQuoRing{T}, V::Vector{MPolyQuoRingElem{T}}) where T &lt;: MPolyRingElem</code></pre><p>Given a (graded) quotient ring <code>A</code> and a vector <code>V</code> of (homogeneous) elements of <code>A</code>, create the ideal of <code>A</code> which is generated by the entries of <code>V</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));

julia&gt; I = ideal(A, [x^2-y])
ideal(x^2 - y)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; S, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; B, _ = quo(S, ideal(S, [x^2*z-y^3, x-y]));

julia&gt; J = ideal(B, [x^2-y^2])
ideal(x^2 - y^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L579-L607">source</a></section></article><h3 id="Reducing-Polynomial-Representatives-of-Generators"><a class="docs-heading-anchor" href="#Reducing-Polynomial-Representatives-of-Generators">Reducing Polynomial Representatives of Generators</a><a id="Reducing-Polynomial-Representatives-of-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Reducing-Polynomial-Representatives-of-Generators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="simplify-Tuple{MPolyQuoIdeal}" href="#simplify-Tuple{MPolyQuoIdeal}"><code>simplify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify(a::MPolyQuoIdeal)</code></pre><p>If <code>a</code> is an ideal of the quotient of a multivariate polynomial ring <code>R</code> by an ideal <code>I</code> of <code>R</code>, say, replace the internal polynomial representative of each generator of <code>a</code> by its normal form  mod <code>I</code> with respect to the <code>default_ordering</code> on <code>R</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));

julia&gt; a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])
ideal(x^3*y^4 - x + y, x*y^2 + x*y)

julia&gt; gens(a)
2-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:
 x^3*y^4 - x + y
 x*y^2 + x*y

julia&gt; simplify(a)
ideal(x^2*y^3 - x + y, x*y^2 + x*y)

julia&gt; gens(a)
2-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:
 x^2*y^3 - x + y
 x*y^2 + x*y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L697-L726">source</a></section></article><h3 id="Data-Associated-to-Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Data-Associated-to-Ideals-in-Affine-Algebras">Data Associated to Ideals in Affine Algebras</a><a id="Data-Associated-to-Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Associated-to-Ideals-in-Affine-Algebras" title="Permalink"></a></h3><h4 id="Basic-Data-2"><a class="docs-heading-anchor" href="#Basic-Data-2">Basic Data</a><a class="docs-heading-anchor-permalink" href="#Basic-Data-2" title="Permalink"></a></h4><p>If <code>a</code> is an ideal of the affine algebra <code>A</code>, then</p><ul><li><code>base_ring(a)</code> refers to <code>A</code>,</li><li><code>gens(a)</code> to the generators of <code>a</code>,</li><li><code>number_of_generators(a)</code> / <code>ngens(a)</code> to the number of these generators,  and</li><li><code>gen(a, i)</code> as well as <code>a[i]</code> to the <code>i</code>-th such generator.</li></ul><h6 id="Examples-3"><a class="docs-heading-anchor" href="#Examples-3">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-3" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));

julia&gt; a = ideal(A, [x-y, z^4])
ideal(x - y, z^4)

julia&gt; base_ring(a)
Quotient
  of multivariate polynomial ring in 3 variables x, y, z
    over rational field
  by ideal (-x^2 + y, -x^3 + z)

julia&gt; gens(a)
2-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:
 x - y
 z^4

julia&gt; number_of_generators(a)
2

julia&gt; gen(a, 2)
z^4
</code></pre><h4 id="Dimension-of-Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Dimension-of-Ideals-in-Affine-Algebras">Dimension of Ideals in Affine Algebras</a><a id="Dimension-of-Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Dimension-of-Ideals-in-Affine-Algebras" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="dim-Tuple{MPolyQuoIdeal}" href="#dim-Tuple{MPolyQuoIdeal}"><code>dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim(a::MPolyQuoIdeal)</code></pre><p>Return the Krull dimension of <code>a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));

julia&gt; a = ideal(A, [x-y])
ideal(x - y)

julia&gt; dim(a)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L1663-L1680">source</a></section></article><h4 id="Minimal-Sets-of-Generators"><a class="docs-heading-anchor" href="#Minimal-Sets-of-Generators">Minimal Sets of Generators</a><a id="Minimal-Sets-of-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-Sets-of-Generators" title="Permalink"></a></h4><p>In the graded case, we have:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="minimal_generating_set-Tuple{MPolyQuoIdeal{&lt;:MPolyDecRingElem}}" href="#minimal_generating_set-Tuple{MPolyQuoIdeal{&lt;:MPolyDecRingElem}}"><code>minimal_generating_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimal_generating_set(I::MPolyQuoIdeal{&lt;:MPolyDecRingElem})</code></pre><p>Given a homogeneous ideal <code>I</code> of a graded affine algebra over a field, return an array containing a minimal set of generators of <code>I</code>. If <code>I</code> is the zero ideal an empty list is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, p = quo(R, ideal(R, [x-y]));

julia&gt; V = [x, z^2, x^3+y^3, y^4, y*z^5];

julia&gt; a = ideal(A, V);

julia&gt; minimal_generating_set(a)
2-element Vector{MPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:
 y
 z^2

julia&gt; a = ideal(A, [x-y])
ideal(x - y)

julia&gt; minimal_generating_set(a)
MPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L1711-L1739">source</a></section></article><h3 id="Operations-on-Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Operations-on-Ideals-in-Affine-Algebras">Operations on Ideals in Affine Algebras</a><a id="Operations-on-Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-Ideals-in-Affine-Algebras" title="Permalink"></a></h3><h4 id="Simple-Ideal-Operations-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Simple-Ideal-Operations-in-Affine-Algebras">Simple Ideal Operations in Affine Algebras</a><a id="Simple-Ideal-Operations-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Ideal-Operations-in-Affine-Algebras" title="Permalink"></a></h4><h5 id="Powers-of-Ideal"><a class="docs-heading-anchor" href="#Powers-of-Ideal">Powers of Ideal</a><a id="Powers-of-Ideal-1"></a><a class="docs-heading-anchor-permalink" href="#Powers-of-Ideal" title="Permalink"></a></h5><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="^-Tuple{MPolyQuoIdeal, Int64}" href="#^-Tuple{MPolyQuoIdeal, Int64}"><code>^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:^(a::MPolyQuoIdeal, m::Int)</code></pre><p>Return the <code>m</code>-th power of <code>a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, [x^2-y, y^2-x+y]);

julia&gt; a = ideal(A, [x+y])
ideal(x + y)

julia&gt; a^2
ideal(x^2 + 2*x*y + y^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L379-L396">source</a></section></article><h5 id="Sum-of-Ideals"><a class="docs-heading-anchor" href="#Sum-of-Ideals">Sum of Ideals</a><a id="Sum-of-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Sum-of-Ideals" title="Permalink"></a></h5><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="+-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T" href="#+-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T"><code>+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:+(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T</code></pre><p>Return the sum of <code>a</code> and <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, [x^2-y, y^2-x+y]);

julia&gt; a = ideal(A, [x+y])
ideal(x + y)

julia&gt; b = ideal(A, [x^2+y^2, x+y])
ideal(x^2 + y^2, x + y)

julia&gt; a+b
ideal(x + y, x^2 + y^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L401-L421">source</a></section></article><h5 id="Product-of-Ideals"><a class="docs-heading-anchor" href="#Product-of-Ideals">Product of Ideals</a><a id="Product-of-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Product-of-Ideals" title="Permalink"></a></h5><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="*-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T" href="#*-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T"><code>*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:*(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T</code></pre><p>Return the product of <code>a</code> and <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, [x^2-y, y^2-x+y]);

julia&gt; a = ideal(A, [x+y])
ideal(x + y)

julia&gt; b = ideal(A, [x^2+y^2, x+y])
ideal(x^2 + y^2, x + y)

julia&gt; a*b
ideal(x^3 + x^2*y + x*y^2 + y^3, x^2 + 2*x*y + y^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L427-L447">source</a></section></article><h4 id="Intersection-of-Ideals"><a class="docs-heading-anchor" href="#Intersection-of-Ideals">Intersection of Ideals</a><a id="Intersection-of-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Intersection-of-Ideals" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="intersect-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, Vararg{MPolyQuoIdeal{T}}}} where T" href="#intersect-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, Vararg{MPolyQuoIdeal{T}}}} where T"><code>intersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersect(a::MPolyQuoIdeal{T}, bs::MPolyQuoIdeal{T}...) where T
intersect(V::Vector{MPolyQuoIdeal{T}}) where T</code></pre><p>Return the intersection of two or more ideals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));

julia&gt; a = ideal(A, [y^2])
ideal(y^2)

julia&gt; b = ideal(A, [x])
ideal(x)

julia&gt; intersect(a,b)
ideal(x*y)

julia&gt; intersect([a,b])
ideal(x*y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L453-L477">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="intersect-Union{Tuple{Array{MPolyQuoIdeal{T}, 1}}, Tuple{T}} where T" href="#intersect-Union{Tuple{Array{MPolyQuoIdeal{T}, 1}}, Tuple{T}} where T"><code>intersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersect(a::AlgAssAbsOrdIdl, b::AlgAssAbsOrdIdl) -&gt; AlgAssAbsOrdIdl</code></pre><p>Returns <span>$a \cap b$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.30.9/src/AlgAssAbsOrd/Ideal.jl#L569-L573">source</a></section><section><div><pre><code class="language-julia hljs">intersect(a::AlgAssRelOrdIdl, b::AlgAssRelOrdIdl) -&gt; AlgAssRelOrdIdl</code></pre><p>Returns <span>$a \cap b$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.30.9/src/AlgAssRelOrd/Ideal.jl#L585-L589">source</a></section><section><div><pre><code class="language-julia hljs">intersect(I::MPolyIdeal{T}, Js::MPolyIdeal{T}...) where T
intersect(V::Vector{MPolyIdeal{T}}) where T</code></pre><p>Return the intersection of two or more ideals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = ideal(R, [x, y])^2;

julia&gt; J = ideal(R, [y^2-x^3+x]);

julia&gt; intersect(I, J)
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia&gt; intersect([I, J])
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-ideals.jl#L188-L213">source</a></section><section><div><pre><code class="language-julia hljs">intersect(a::MPolyQuoIdeal{T}, bs::MPolyQuoIdeal{T}...) where T
intersect(V::Vector{MPolyQuoIdeal{T}}) where T</code></pre><p>Return the intersection of two or more ideals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));

julia&gt; a = ideal(A, [y^2])
ideal(y^2)

julia&gt; b = ideal(A, [x])
ideal(x)

julia&gt; intersect(a,b)
ideal(x*y)

julia&gt; intersect([a,b])
ideal(x*y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L453-L477">source</a></section><section><div><pre><code class="language-julia hljs">intersect(I::PBWAlgIdeal{D, T, S}, Js::PBWAlgIdeal{D, T, S}...) where {D, T, S}
intersect(V::Vector{PBWAlgIdeal{D, T, S}}) where {D, T, S}</code></pre><p>Return the intersection of two or more ideals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D, (x, y, dx, dy) = weyl_algebra(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; I = intersect(left_ideal(D, [x^2, x*dy, dy^2])+left_ideal(D, [dx]), left_ideal(D, [dy^2-x^3+x]))
left_ideal(-x^3 + dy^2 + x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/PBWAlgebra.jl#L918-L931">source</a></section><section><div><pre><code class="language-julia hljs">intersect(M::SubquoModule{T}, N::SubquoModule{T}) where T</code></pre><p>Given subquotients <code>M</code> and <code>N</code> such that <code>ambient_module(M) == ambient_module(N)</code>, return the intersection of <code>M</code> and <code>N</code> regarded as submodules of the common ambient module.</p><p>Additionally, return the inclusion maps <code>M</code> <span>$\cap$</span> <code>N</code> <span>$\to$</span> <code>M</code> and <code>M</code> <span>$\cap$</span> <code>N</code> <span>$\to$</span> <code>N</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; F = free_module(R, 1)
Free module of rank 1 over Multivariate polynomial ring in 3 variables over QQ

julia&gt; AM = R[x;]
[x]

julia&gt; BM = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia&gt; M = SubquoModule(F, AM, BM)
Subquotient of Submodule with 1 generator
1 -&gt; x*e[1]
by Submodule with 3 generators
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
3 -&gt; z^4*e[1]

julia&gt; AN = R[y;]
[y]

julia&gt; BN = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia&gt; N = SubquoModule(F, AN, BN)
Subquotient of Submodule with 1 generator
1 -&gt; y*e[1]
by Submodule with 3 generators
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
3 -&gt; z^4*e[1]

julia&gt; intersect(M, N)
(Subquotient of Submodule with 2 generators
1 -&gt; -x*y*e[1]
2 -&gt; x*z^4*e[1]
by Submodule with 3 generators
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
3 -&gt; z^4*e[1], Map with following data
Domain:
=======
Subquotient of Submodule with 2 generators
1 -&gt; -x*y*e[1]
2 -&gt; x*z^4*e[1]
by Submodule with 3 generators
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
3 -&gt; z^4*e[1]
Codomain:
=========
Subquotient of Submodule with 1 generator
1 -&gt; x*e[1]
by Submodule with 3 generators
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
3 -&gt; z^4*e[1], Map with following data
Domain:
=======
Subquotient of Submodule with 2 generators
1 -&gt; -x*y*e[1]
2 -&gt; x*z^4*e[1]
by Submodule with 3 generators
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
3 -&gt; z^4*e[1]
Codomain:
=========
Subquotient of Submodule with 1 generator
1 -&gt; y*e[1]
by Submodule with 3 generators
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
3 -&gt; z^4*e[1])</code></pre><pre><code class="language-julia-repl hljs">julia&gt; Rg, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; F = graded_free_module(Rg, 1);

julia&gt; AM = Rg[x;];

julia&gt; BM = Rg[x^2; y^3; z^4];

julia&gt; M = SubquoModule(F, AM, BM)
Graded subquotient of submodule of F generated by
1 -&gt; x*e[1]
by submodule of F generated by
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
3 -&gt; z^4*e[1]

julia&gt; AN = Rg[y;];

julia&gt; BN = Rg[x^2; y^3; z^4];

julia&gt; N = SubquoModule(F, AN, BN)
Graded subquotient of submodule of F generated by
1 -&gt; y*e[1]
by submodule of F generated by
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
3 -&gt; z^4*e[1]

julia&gt; intersect(M, N)
(Graded subquotient of submodule of F generated by
1 -&gt; -x*y*e[1]
2 -&gt; x*z^4*e[1]
by submodule of F generated by
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
3 -&gt; z^4*e[1], Graded subquotient of submodule of F generated by
1 -&gt; -x*y*e[1]
2 -&gt; x*z^4*e[1]
by submodule of F generated by
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
3 -&gt; z^4*e[1] -&gt; M
-x*y*e[1] -&gt; -x*y*e[1]
x*z^4*e[1] -&gt; x*z^4*e[1]
Homogeneous module homomorphism, Graded subquotient of submodule of F generated by
1 -&gt; -x*y*e[1]
2 -&gt; x*z^4*e[1]
by submodule of F generated by
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
3 -&gt; z^4*e[1] -&gt; N
-x*y*e[1] -&gt; x*y*e[1]
x*z^4*e[1] -&gt; 0
Homogeneous module homomorphism)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Modules/UngradedModules/SubquoModule.jl#L1438-L1588">source</a></section></article><h4 id="Ideal-Quotients"><a class="docs-heading-anchor" href="#Ideal-Quotients">Ideal Quotients</a><a id="Ideal-Quotients-1"></a><a class="docs-heading-anchor-permalink" href="#Ideal-Quotients" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="quotient-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T" href="#quotient-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T"><code>quotient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quotient(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T</code></pre><p>Return the ideal quotient of <code>a</code> by <code>b</code>. Alternatively, use <code>a:b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));

julia&gt; a = ideal(A, [y^2])
ideal(y^2)

julia&gt; b = ideal(A, [x])
ideal(x)

julia&gt; a:b
ideal(y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L495-L515">source</a></section></article><h3 id="Tests-on-Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Tests-on-Ideals-in-Affine-Algebras">Tests on Ideals in Affine Algebras</a><a id="Tests-on-Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-on-Ideals-in-Affine-Algebras" title="Permalink"></a></h3><h4 id="Basic-Tests"><a class="docs-heading-anchor" href="#Basic-Tests">Basic Tests</a><a id="Basic-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Tests" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_zero-Tuple{MPolyQuoIdeal}" href="#is_zero-Tuple{MPolyQuoIdeal}"><code>is_zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_zero(a::MPolyQuoIdeal)</code></pre><p>Return <code>true</code> if <code>a</code> is the zero ideal, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, [x^2-y, y^2-x+y]);

julia&gt; a = ideal(A, [x^2+y^2, x+y])
ideal(x^2 + y^2, x + y)

julia&gt; is_zero(a)
false

julia&gt; b = ideal(A, [x^2-y])
ideal(x^2 - y)

julia&gt; is_zero(b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L550-L573">source</a></section></article><h4 id="Containment-of-Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Containment-of-Ideals-in-Affine-Algebras">Containment of Ideals in Affine Algebras</a><a id="Containment-of-Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Containment-of-Ideals-in-Affine-Algebras" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_subset-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T" href="#is_subset-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T"><code>is_subset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_subset(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T</code></pre><p>Return <code>true</code> if <code>a</code> is contained in <code>b</code>, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));

julia&gt; a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])
ideal(x^3*y^4 - x + y, x*y^2 + x*y)

julia&gt; b = ideal(A, [x^3*y^3-x+y, x^2*y+y^2*x])
ideal(x^3*y^3 - x + y, x^2*y + x*y^2)

julia&gt; is_subset(a,b)
false

julia&gt; is_subset(b,a)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L770-L793">source</a></section></article><h4 id="Equality-of-Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Equality-of-Ideals-in-Affine-Algebras">Equality of Ideals in Affine Algebras</a><a id="Equality-of-Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Equality-of-Ideals-in-Affine-Algebras" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="==-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T" href="#==-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T"><code>==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T</code></pre><p>Return <code>true</code> if <code>a</code> is equal to <code>b</code>, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));

julia&gt; a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])
ideal(x^3*y^4 - x + y, x*y^2 + x*y)

julia&gt; b = ideal(A, [x^3*y^3-x+y, x^2*y+y^2*x])
ideal(x^3*y^3 - x + y, x^2*y + x*y^2)

julia&gt; a == b
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L800-L820">source</a></section></article><h4 id="Ideal-Membership"><a class="docs-heading-anchor" href="#Ideal-Membership">Ideal Membership</a><a id="Ideal-Membership-1"></a><a class="docs-heading-anchor-permalink" href="#Ideal-Membership" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ideal_membership-Union{Tuple{T}, Tuple{MPolyQuoRingElem{T}, MPolyQuoIdeal{T}}} where T" href="#ideal_membership-Union{Tuple{T}, Tuple{MPolyQuoRingElem{T}, MPolyQuoIdeal{T}}} where T"><code>ideal_membership</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ideal_membership(f::MPolyQuoRingElem{T}, a::MPolyQuoIdeal{T}) where T</code></pre><p>Return <code>true</code> if <code>f</code> is contained in <code>a</code>, <code>false</code> otherwise. Alternatively, use <code>f in a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));

julia&gt; a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])
ideal(x^3*y^4 - x + y, x*y^2 + x*y)

julia&gt; f = A(x^2*y^3-x+y)
x^2*y^3 - x + y

julia&gt; f in a
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyQuo.jl#L740-L760">source</a></section></article><h2 id="Homomorphisms-From-Affine-Algebras"><a class="docs-heading-anchor" href="#Homomorphisms-From-Affine-Algebras">Homomorphisms From Affine Algebras</a><a id="Homomorphisms-From-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Homomorphisms-From-Affine-Algebras" title="Permalink"></a></h2><p>If <span>$A=R/I$</span> is an affine <span>$C$</span>-algebra, and <span>$S$</span> is any ring, then defining a ring homomorphism <span>$\overline{\phi}: A \to S$</span> means to define a ring homomorphism <span>$\phi: R \to S$</span> such that <span>$I\subset \ker(\phi)$</span>. Thus, <span>$\overline{\phi} $ is determined by specifying its restriction to $C$</span>, and by assigning an image to each generator of <span>$A$</span>. In OSCAR, such homomorphisms are created as follows:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="hom-Tuple{MPolyQuoRing, NCRing, Any, Vector}" href="#hom-Tuple{MPolyQuoRing, NCRing, Any, Vector}"><code>hom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hom(A::MPolyQuoRing, S::NCRing, coeff_map, images::Vector; check::Bool = true)

hom(A::MPolyQuoRing, S::NCRing, images::Vector; check::Bool = true)</code></pre><p>Given a homomorphism <code>coeff_map</code> from <code>C</code> to <code>S</code>, where <code>C</code> is the  coefficient ring of the base ring of <code>A</code>, and given a vector <code>images</code> of <code>ngens(A)</code>  elements of <code>S</code>, return the homomorphism <code>A</code> <span>$\to$</span> <code>S</code> whose restriction  to <code>C</code> is <code>coeff_map</code>, and which sends the <code>i</code>-th generator of <code>A</code> to the  <code>i</code>-th entry of <code>images</code>.</p><p>If no coefficient map is entered, invoke a canonical homomorphism of <code>C</code> to <code>S</code>, if such a homomorphism exists, and throw an error, otherwise.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function returns a well-defined homomorphism <code>A</code> <span>$\to$</span> <code>S</code> iff the given data defines a homomorphism from the base ring of <code>A</code> to <code>S</code> whose kernel contains the modulus of <code>A</code>. This condition is checked by the  function in case <code>check = true</code> (default).</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In case <code>check = true</code> (default), the function also checks the conditions below:</p><ul><li>If <code>S</code> is graded, the assigned images must be homogeneous with respect to the given grading.</li><li>If <code>S</code> is noncommutative, the assigned images must pairwise commute. </li></ul></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] );

julia&gt; A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));

julia&gt; S, (s, t) = polynomial_ring(QQ, [&quot;s&quot;, &quot;t&quot;]);

julia&gt; F = hom(A, S, [s, s^2, s^3])
Ring homomorphism
  from quotient of multivariate polynomial ring by ideal (-x^2 + y, -x^3 + z)
  to multivariate polynomial ring in 2 variables over QQ
defined by
  x -&gt; s
  y -&gt; s^2
  z -&gt; s^3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyMap/MPolyQuo.jl#L35-L77">source</a></section></article><p>Given a ring homomorphism <code>F</code> : <code>R</code> <span>$\to$</span> <code>S</code> as above, <code>domain(F)</code> and <code>codomain(F)</code> refer to <code>R</code> and <code>S</code>, respectively. Given ring homomorphisms <code>F</code> : <code>R</code> <span>$\to$</span> <code>S</code> and <code>G</code> : <code>S</code> <span>$\to$</span> <code>T</code> as above, <code>compose(F, G)</code> refers to their composition.</p><h2 id="Homomorphisms-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Homomorphisms-of-Affine-Algebras">Homomorphisms of Affine Algebras</a><a id="Homomorphisms-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Homomorphisms-of-Affine-Algebras" title="Permalink"></a></h2><p>The OSCAR homomorphism type <code>AffAlgHom</code> models ring homomorphisms <code>R</code> <span>$\to$</span> <code>S</code> such that the type of both <code>R</code> and <code>S</code>  is a subtype of <code>Union{MPolyRing{T}, MPolyQuoRing{U}}</code>, where <code>T &lt;: FieldElem</code> and <code>U &lt;: MPolyRingElem{T}</code>. Functionality for these homomorphism is discussed in what follows.</p><h3 id="Data-Associated-to-Homomorphisms-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Data-Associated-to-Homomorphisms-of-Affine-Algebras">Data Associated to Homomorphisms of Affine Algebras</a><a id="Data-Associated-to-Homomorphisms-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Associated-to-Homomorphisms-of-Affine-Algebras" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="preimage-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}, MPolyIdeal}" href="#preimage-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}, MPolyIdeal}"><code>preimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preimage(F::AffAlgHom, I::U) where U &lt;: Union{MPolyIdeal, MPolyQuoIdeal}</code></pre><p>Return the preimage of the ideal <code>I</code> under <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyMap/AffineAlgebras.jl#L214-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="kernel-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}" href="#kernel-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}"><code>kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kernel(F::AffAlgHom)</code></pre><p>Return the kernel of <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyMap/AffineAlgebras.jl#L45-L49">source</a></section></article><h6 id="Examples-4"><a class="docs-heading-anchor" href="#Examples-4">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-4" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; D1, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; C1, (s,t) = graded_polynomial_ring(QQ, [&quot;s&quot;, &quot;t&quot;]);

julia&gt; V1 = [s^3, s^2*t, s*t^2, t^3];

julia&gt; para = hom(D1, C1, V1)
Ring homomorphism
  from graded multivariate polynomial ring in 4 variables over QQ
  to graded multivariate polynomial ring in 2 variables over QQ
defined by
  w -&gt; s^3
  x -&gt; s^2*t
  y -&gt; s*t^2
  z -&gt; t^3

julia&gt; twistedCubic = kernel(para)
Ideal generated by
  -x*z + y^2
  -w*z + x*y
  -w*y + x^2

julia&gt; C2, p2 = quo(D1, twistedCubic);

julia&gt; D2, (a, b, c) = graded_polynomial_ring(QQ, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);

julia&gt; V2 = [p2(w-y), p2(x), p2(z)];

julia&gt; proj = hom(D2, C2, V2)
Ring homomorphism
  from graded multivariate polynomial ring in 3 variables over QQ
  to quotient of multivariate polynomial ring by ideal (-x*z + y^2, -w*z + x*y, -w*y + x^2)
defined by
  a -&gt; w - y
  b -&gt; x
  c -&gt; z

julia&gt; nodalCubic = kernel(proj)
Ideal generated by
  -a^2*c + b^3 - 2*b^2*c + b*c^2
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; D3,y = polynomial_ring(QQ, &quot;y&quot; =&gt; 1:3);

julia&gt; C3, x = polynomial_ring(QQ, &quot;x&quot; =&gt; 1:3);

julia&gt; V3 = [x[1]*x[2], x[1]*x[3], x[2]*x[3]];

julia&gt; F3 = hom(D3, C3, V3)
Ring homomorphism
  from multivariate polynomial ring in 3 variables over QQ
  to multivariate polynomial ring in 3 variables over QQ
defined by
  y[1] -&gt; x[1]*x[2]
  y[2] -&gt; x[1]*x[3]
  y[3] -&gt; x[2]*x[3]

julia&gt; sphere = ideal(C3, [x[1]^3 + x[2]^3  + x[3]^3 - 1])
Ideal generated by
  x[1]^3 + x[2]^3 + x[3]^3 - 1

julia&gt; steinerRomanSurface = preimage(F3, sphere)
Ideal generated by
  y[1]^6*y[2]^6 + 2*y[1]^6*y[2]^3*y[3]^3 + y[1]^6*y[3]^6 + 2*y[1]^3*y[2]^6*y[3]^3 + 2*y[1]^3*y[2]^3*y[3]^6 - y[1]^3*y[2]^3*y[3]^3 + y[2]^6*y[3]^6
</code></pre><h3 id="Tests-on-Homomorphisms-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Tests-on-Homomorphisms-of-Affine-Algebras">Tests on Homomorphisms of Affine Algebras</a><a id="Tests-on-Homomorphisms-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-on-Homomorphisms-of-Affine-Algebras" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_injective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}" href="#is_injective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}"><code>is_injective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_injective(F::AffAlgHom)</code></pre><p>Return <code>true</code> if <code>F</code> is injective, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyMap/AffineAlgebras.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_surjective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}" href="#is_surjective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}"><code>is_surjective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_surjective(F::AffAlgHom)</code></pre><p>Return <code>true</code> if <code>F</code> is surjective, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyMap/AffineAlgebras.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_bijective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}" href="#is_bijective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}"><code>is_bijective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_bijective(F::AffAlgHom)</code></pre><p>Return <code>true</code> if <code>F</code> is bijective, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyMap/AffineAlgebras.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_finite-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}" href="#is_finite-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}"><code>is_finite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_finite(F::AffAlgHom)</code></pre><p>Return <code>true</code> if <code>F</code> is finite, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyMap/AffineAlgebras.jl#L108-L112">source</a></section></article><h6 id="Examples-5"><a class="docs-heading-anchor" href="#Examples-5">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-5" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; D, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; S, (a, b, c) = polynomial_ring(QQ, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);

julia&gt; C, p = quo(S, ideal(S, [c-b^3]));

julia&gt; V = [p(2*a + b^6), p(7*b - a^2), p(c^2)];

julia&gt; F = hom(D, C, V)
Ring homomorphism
  from multivariate polynomial ring in 3 variables over QQ
  to quotient of multivariate polynomial ring by ideal (-b^3 + c)
defined by
  x -&gt; 2*a + c^2
  y -&gt; -a^2 + 7*b
  z -&gt; c^2

julia&gt; is_surjective(F)
true

julia&gt; D1, _ = quo(D, kernel(F));

julia&gt; F1 = hom(D1, C, V);

julia&gt; is_bijective(F1)
true
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [ &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; C, (s, t) = polynomial_ring(QQ, [&quot;s&quot;, &quot;t&quot;]);

julia&gt; V = [s*t, t, s^2];

julia&gt; paraWhitneyUmbrella = hom(R, C, V)
Ring homomorphism
  from multivariate polynomial ring in 3 variables over QQ
  to multivariate polynomial ring in 2 variables over QQ
defined by
  x -&gt; s*t
  y -&gt; t
  z -&gt; s^2

julia&gt; D, _ = quo(R, kernel(paraWhitneyUmbrella));

julia&gt; is_finite(hom(D, C, V))
true</code></pre><h3 id="Inverting-Homomorphisms-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Inverting-Homomorphisms-of-Affine-Algebras">Inverting Homomorphisms of Affine Algebras</a><a id="Inverting-Homomorphisms-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Inverting-Homomorphisms-of-Affine-Algebras" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="inverse-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}" href="#inverse-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing} where {T&lt;:FieldElem, U1&lt;:MPolyRingElem{T}, U2&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U1}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U2}}}}"><code>inverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse(F::AffAlgHom)</code></pre><p>If <code>F</code> is bijective, return its inverse.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D1, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; D, _ = quo(D1, [y-x^2, z-x^3]);

julia&gt; C, (t,) = polynomial_ring(QQ, [&quot;t&quot;]);

julia&gt; F = hom(D, C, [t, t^2, t^3]);

julia&gt; is_bijective(F)
true

julia&gt; G = inverse(F)
Ring homomorphism
  from multivariate polynomial ring in 1 variable over QQ
  to quotient of multivariate polynomial ring by ideal (-x^2 + y, -x^3 + z)
defined by
  t -&gt; x

julia&gt; G(t)
x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/MPolyMap/AffineAlgebras.jl#L140-L168">source</a></section></article><h2 id="Algebraic-Independence"><a class="docs-heading-anchor" href="#Algebraic-Independence">Algebraic Independence</a><a id="Algebraic-Independence-1"></a><a class="docs-heading-anchor-permalink" href="#Algebraic-Independence" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_algebraically_independent-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{MPolyRingElem, MPolyQuoRingElem}" href="#is_algebraically_independent-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{MPolyRingElem, MPolyQuoRingElem}"><code>is_algebraically_independent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_algebraically_independent(V::Vector{T}) where T &lt;: Union{MPolyRingElem, MPolyQuoRingElem}</code></pre><p>Given a vector <code>V</code> of elements of a multivariate polynomial ring over a field <code>K</code>, say, or of a quotient of such a ring,  return if the elements of <code>V</code> are algebraically independent over <code>K</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; V = [x, y, x^2+y^3]
3-element Vector{QQMPolyRingElem}:
 x
 y
 x^2 + y^3

julia&gt; is_algebraically_independent(V)
false

julia&gt; A, p = quo(R, [x*y]);

julia&gt; is_algebraically_independent([p(x), p(y)])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L1064-L1088">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_algebraically_independent_with_relations-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{MPolyRingElem, MPolyQuoRingElem}" href="#is_algebraically_independent_with_relations-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{MPolyRingElem, MPolyQuoRingElem}"><code>is_algebraically_independent_with_relations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_algebraically_independent_with_relations(V::Vector{T}) where T &lt;: Union{MPolyRingElem, MPolyQuoRingElem}</code></pre><p>Given a vector <code>V</code> of elements of a multivariate polynomial ring over a field <code>K</code>, say, or of a quotient of such a ring,  return <code>(true, ideal(0))</code> if the elements of <code>V</code> are algebraically independent over <code>K</code>. Otherwise, return <code>false</code> together with the ideal of <code>K</code>-algebra relations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; V = [x, y, x^2+y^3]
3-element Vector{QQMPolyRingElem}:
 x
 y
 x^2 + y^3

julia&gt; is_algebraically_independent_with_relations(V)
(false, Ideal (t1^2 + t2^3 - t3))

julia&gt; A, p = quo(R, [x*y]);

julia&gt; is_algebraically_independent_with_relations([p(x), p(y)])
(false, Ideal (t1*t2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L1093-L1118">source</a></section></article><h2 id="Subalgebras"><a class="docs-heading-anchor" href="#Subalgebras">Subalgebras</a><a id="Subalgebras-1"></a><a class="docs-heading-anchor-permalink" href="#Subalgebras" title="Permalink"></a></h2><h3 id="Subalgebra-Membership"><a class="docs-heading-anchor" href="#Subalgebra-Membership">Subalgebra Membership</a><a id="Subalgebra-Membership-1"></a><a class="docs-heading-anchor-permalink" href="#Subalgebra-Membership" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="subalgebra_membership-Union{Tuple{T}, Tuple{T, Vector{T}}} where T&lt;:Union{MPolyRingElem, MPolyQuoRingElem}" href="#subalgebra_membership-Union{Tuple{T}, Tuple{T, Vector{T}}} where T&lt;:Union{MPolyRingElem, MPolyQuoRingElem}"><code>subalgebra_membership</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subalgebra_membership(f::T, V::Vector{T}) where T &lt;: Union{MPolyRingElem, MPolyQuoRingElem}</code></pre><p>Given an element <code>f</code> of a multivariate polynomial ring over a field, or of a quotient of such a ring, and given a vector <code>V</code> of further elements of that ring, consider the subalgebra generated by the entries of <code>V</code> in the given ring. If <code>f</code> is contained in the subalgebra, return <code>(true, h)</code>, where <code>h</code> is giving the polynomial relation. Return, <code>(false, 0)</code>, otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, x = polynomial_ring(QQ, &quot;x&quot; =&gt; 1:3);

julia&gt; f = x[1]^6*x[2]^6-x[1]^6*x[3]^6;

julia&gt; V = [x[1]^3*x[2]^3-x[1]^3*x[3]^3, x[1]^3*x[2]^3+x[1]^3*x[3]^3]
2-element Vector{QQMPolyRingElem}:
 x[1]^3*x[2]^3 - x[1]^3*x[3]^3
 x[1]^3*x[2]^3 + x[1]^3*x[3]^3

julia&gt; subalgebra_membership(f, V)
(true, t1*t2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L952-L975">source</a></section></article><h3 id="Minimal-Subalgebra-Generators"><a class="docs-heading-anchor" href="#Minimal-Subalgebra-Generators">Minimal Subalgebra Generators</a><a id="Minimal-Subalgebra-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-Subalgebra-Generators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="minimal_subalgebra_generators-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{MPolyDecRingElem, MPolyQuoRingElem{&lt;:MPolyDecRingElem}}" href="#minimal_subalgebra_generators-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{MPolyDecRingElem, MPolyQuoRingElem{&lt;:MPolyDecRingElem}}"><code>minimal_subalgebra_generators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimal_subalgebra_generators(V::Vector{T}; check::Bool = true) where T &lt;: Union{MPolyRingElem, MPolyQuoRingElem}</code></pre><p>Given a vector <code>V</code> of homogeneous elements of a positively graded multivariate polynomial ring, or of a quotient of such a ring, return a minimal subset of the elements in <code>V</code> which, in the given ring, generate the same subalgebra as all elements in <code>V</code>.</p><p>If <code>check</code> is <code>true</code> (default), the conditions on <code>V</code> and the given ring are checked.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; V = [x, y, x^2+y^2]
3-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x
 y
 x^2 + y^2

julia&gt; minimal_subalgebra_generators(V)
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x
 y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L1136-L1162">source</a></section></article><h2 id="Noether-Normalization"><a class="docs-heading-anchor" href="#Noether-Normalization">Noether Normalization</a><a id="Noether-Normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Noether-Normalization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="noether_normalization-Tuple{MPolyQuoRing}" href="#noether_normalization-Tuple{MPolyQuoRing}"><code>noether_normalization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noether_normalization(A::MPolyQuoRing)</code></pre><p>Given an affine algebra <span>$A=R/I$</span> over a field <span>$K$</span>, return a triple <span>$(V,F,G)$</span> such that:</p><ul><li><span>$V$</span> is a vector of <span>$d=\dim A$</span> elements of <span>$A$</span>, represented by linear forms <span>$l_i\in R$</span>, and such that <span>$K[V]\hookrightarrow A$</span> is a Noether normalization for <span>$A$</span>; </li><li><span>$F: A=R/I \to B = R/\phi(I)$</span> is an isomorphism, induced by a linear change <span>$\phi$</span> of coordinates of <span>$R$</span> which maps the <span>$l_i$</span> to the the last <span>$d$</span> variables of <span>$R$</span>; </li><li><span>$G = F^{-1}.$</span></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The algorithm may not terminate over a small finite field. If it terminates, the result is correct.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L1413-L1424">source</a></section></article><h6 id="Examples-6"><a class="docs-heading-anchor" href="#Examples-6">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-6" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x*y, x*z]));

julia&gt; L = noether_normalization(A);

julia&gt; L[1]
2-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:
 -2*x + y
 -5*y + z

julia&gt; L[2]
Ring homomorphism
  from quotient of multivariate polynomial ring by ideal (x*y, x*z)
  to quotient of multivariate polynomial ring by ideal (2*x^2 + x*y, 10*x^2 + 5*x*y + x*z)
defined by
  x -&gt; x
  y -&gt; 2*x + y
  z -&gt; 10*x + 5*y + z

julia&gt; L[3]
Ring homomorphism
  from quotient of multivariate polynomial ring by ideal (2*x^2 + x*y, 10*x^2 + 5*x*y + x*z)
  to quotient of multivariate polynomial ring by ideal (x*y, x*z)
defined by
  x -&gt; x
  y -&gt; -2*x + y
  z -&gt; -5*y + z
</code></pre><h2 id="Normalization"><a class="docs-heading-anchor" href="#Normalization">Normalization</a><a id="Normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Normalization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="normalization-Tuple{MPolyQuoRing}" href="#normalization-Tuple{MPolyQuoRing}"><code>normalization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalization(A::MPolyQuoRing; algorithm = :equidimDec)</code></pre><p>Find the normalization of a reduced affine algebra over a perfect field <span>$K$</span>. That is, given the quotient <span>$A=R/I$</span> of a multivariate polynomial ring <span>$R$</span> over <span>$K$</span> modulo a radical ideal <span>$I$</span>, compute the integral closure <span>$\overline{A}$</span>  of <span>$A$</span> in its total ring of fractions <span>$Q(A)$</span>, together with the embedding  <span>$f: A \to \overline{A}$</span>. </p><p><strong>Implemented Algorithms and how to Read the Output</strong></p><p>The function relies on the algorithm  of Greuel, Laplagne, and Seelisch which proceeds by finding a suitable decomposition  <span>$I=I_1\cap\dots\cap I_r$</span> into radical ideals <span>$I_k$</span>, together with maps <span>$A = R/I \to A_k=\overline{R/I_k}$</span> which give rise to the normalization map of <span>$A$</span>:</p><p class="math-container">\[A\hookrightarrow A_1\times \dots\times A_r=\overline{A}\]</p><p>For each <span>$k$</span>, the function specifies two representations of <span>$A_k$</span>: It returns an array of triples <span>$(A_k, f_k, \mathfrak a_k)$</span>, where <span>$A_k$</span> is represented as an affine <span>$K$</span>-algebra, and <span>$f_k$</span> as a map of affine <span>$K$</span>-algebras. The third entry <span>$\mathfrak a_k$</span> is a tuple <span>$(d_k, J_k)$</span>, consisting of an element <span>$d_k\in A$</span> and an ideal <span>$J_k\subset A$</span>, such that <span>$\frac{1}{d_k}J_k = A_k$</span>  as <span>$A$</span>-submodules of the total ring of fractions of <span>$A$</span>.</p><p>By default (<code>algorithm = :equidimDec</code>), as a first step on its way to find the decomposition <span>$I=I_1\cap\dots\cap I_r$</span>,  the algorithm computes an equidimensional decomposition of the radical ideal <span>$I$</span>. Alternatively, if specified by <code>algorithm = :primeDec</code>, the algorithm computes <span>$I=I_1\cap\dots\cap I_r$</span> as the prime decomposition of the radical ideal <span>$I$</span>.</p><p>See [<a href="../../references/#GLS10">GLS10</a>].</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The function does not check whether <span>$A$</span> is reduced. Use <code>is_reduced(A)</code> in case you are unsure (this may take some time).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [(x^2-y^3)*(x^2+y^2)*x]));

julia&gt; L = normalization(A);

julia&gt; size(L)
(2,)

julia&gt; LL = normalization(A, algorithm = :primeDec);

julia&gt; size(LL)
(3,)

julia&gt; LL[1][1]
Quotient
  of multivariate polynomial ring in 3 variables T(1), x, y
    over rational field
  by ideal (-T(1)*y + x, -T(1)*x + y^2, T(1)^2 - y, -x^2 + y^3)

julia&gt; LL[1][2]
Ring homomorphism
  from quotient of multivariate polynomial ring by ideal (x^5 - x^3*y^3 + x^3*y^2 - x*y^5)
  to quotient of multivariate polynomial ring by ideal (-T(1)*y + x, -T(1)*x + y^2, T(1)^2 - y, -x^2 + y^3)
defined by
  x -&gt; x
  y -&gt; y

julia&gt; LL[1][3]
(y, ideal(x, y))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L1270-L1338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="normalization_with_delta-Tuple{MPolyQuoRing}" href="#normalization_with_delta-Tuple{MPolyQuoRing}"><code>normalization_with_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalization_with_delta(A::MPolyQuoRing; algorithm::Symbol = :equidimDec)</code></pre><p>Compute the normalization</p><p class="math-container">\[A\hookrightarrow A_1\times \dots\times A_r=\overline{A}\]</p><p>of <span>$A$</span> as does <code>normalize(A)</code>, but return additionally the <code>delta invariant</code> of <span>$A$</span>, that is, the dimension </p><p class="math-container">\[\dim_K(\overline{A}/A)\]</p><p>. </p><p><strong>How to Read the Output</strong></p><p>The return value is a tuple whose first element is <code>normalize(A)</code>, whose second element is an array containing the delta invariants of the <span>$A_k$</span>, and whose third element is the (total) delta invariant of <span>$A$</span>. The return value -1 in the third element indicates that the delta invariant is infinite.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [(x^2-y^3)*(x^2+y^2)*x]));

julia&gt; L = normalization_with_delta(A);

julia&gt; L[2]
3-element Vector{Int64}:
 1
 1
 0

julia&gt; L[3]
13</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [z^3-x*y^4]));

julia&gt; L = normalization_with_delta(A);

julia&gt; L[3]
-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L1349-L1395">source</a></section></article><h2 id="Integral-Bases"><a class="docs-heading-anchor" href="#Integral-Bases">Integral Bases</a><a id="Integral-Bases-1"></a><a class="docs-heading-anchor-permalink" href="#Integral-Bases" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="integral_basis-Tuple{MPolyRingElem, Int64}" href="#integral_basis-Tuple{MPolyRingElem, Int64}"><code>integral_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integral_basis(f::MPolyRingElem, i::Int; algorithm::Symbol = :normal_local)</code></pre><p>Given a polynomial <span>$f$</span> in two variables with coefficients in a perfect field <span>$K$</span>, and given an integer <span>$i\in\{1,2\}$</span> specifying one of the variables, <span>$f$</span> must be irreducible and monic in the specified variable: Say, <span>$f\in\mathbb K[x,y]$</span> is monic in <span>$y$</span>. Then the normalization of <span>$A = K[x,y]/\langle f \rangle$</span>, that is, the integral closure <span>$\overline{A}$</span> of <span>$A$</span> in its quotient field, is a free module over <span>$K[x]$</span> of finite rank, and any set of free generators for <span>$\overline{A}$</span> over <span>$K[x]$</span> is called an <em>integral basis</em> for <span>$\overline{A}$</span> over <span>$K[x]$</span>. The function returns a pair <span>$(d, V)$</span>, where <span>$d$</span> is an element of <span>$A$</span>, and <span>$V$</span> is a vector of elements in <span>$A$</span>, such that the fractions <span>$v/d, v\in V$</span>, form an integral basis for <span>$\overline{A}$</span> over <span>$K[x]$</span>.</p><p>By default (<code>algorithm = :normal_local</code>), the function relies on the local-to-global approach to normalization presented in [<a href="../../references/#BDLPSS13">BDLPSS13</a>]. Alternatively, if specified by <code>algorithm = :normal_global</code>, the global normalization algorithm in [<a href="../../references/#GLS10">GLS10</a>] is used. If <span>$K = \mathbb Q$</span>, it is recommended to apply the algorithm in [<a href="../../references/#BDLP19">BDLP19</a>], which makes use of Puiseux expansions and Hensel lifting (<code>algorithm = :hensel</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The conditions on <span>$f$</span> are automatically checked.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; f = (y^2-2)^2 + x^5
x^5 + y^4 - 4*y^2 + 4

julia&gt; integral_basis(f, 2)
(x^2, MPolyQuoRingElem{QQMPolyRingElem}[x^2, x^2*y, y^2 - 2, y^3 - 2*y])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L1456-L1490">source</a></section></article><h2 id="Tests-on-Affine-Algebras"><a class="docs-heading-anchor" href="#Tests-on-Affine-Algebras">Tests on Affine Algebras</a><a id="Tests-on-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-on-Affine-Algebras" title="Permalink"></a></h2><h3 id="Reducedness-Test"><a class="docs-heading-anchor" href="#Reducedness-Test">Reducedness Test</a><a id="Reducedness-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Reducedness-Test" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_reduced-Tuple{MPolyQuoRing}" href="#is_reduced-Tuple{MPolyQuoRing}"><code>is_reduced</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_reduced(A::MPolyQuoRing)</code></pre><p>Given an affine algebra <code>A</code>, return <code>true</code> if <code>A</code> is reduced, <code>false</code> otherwise.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The function computes the radical of the modulus of <code>A</code>. This may take some time.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x,) = polynomial_ring(QQ, [&quot;x&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^4]));

julia&gt; is_reduced(A)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L848-L865">source</a></section></article><h3 id="Normality-Test"><a class="docs-heading-anchor" href="#Normality-Test">Normality Test</a><a id="Normality-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Normality-Test" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_normal-Tuple{MPolyQuoRing}" href="#is_normal-Tuple{MPolyQuoRing}"><code>is_normal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_normal(A::MPolyQuoRing)</code></pre><p>Given an affine algebra <code>A</code> over a perfect field, return <code>true</code> if <code>A</code> is normal, <code>false</code> otherwise.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function performs the first step of the normalization algorithm of Greuel, Laplagne, and Seelisch [<a href="../../references/#GLS10">GLS10</a>] and may, thus, be more efficient than computing the full normalization of <code>A</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [z^2-x*y]));

julia&gt; is_normal(A)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L871-L889">source</a></section></article><h3 id="Cohen-Macaulayness-Test"><a class="docs-heading-anchor" href="#Cohen-Macaulayness-Test">Cohen-Macaulayness Test</a><a id="Cohen-Macaulayness-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Cohen-Macaulayness-Test" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_cohen_macaulay-Tuple{MPolyQuoRing}" href="#is_cohen_macaulay-Tuple{MPolyQuoRing}"><code>is_cohen_macaulay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> is_cohen_macaulay(A::MPolyQuoRing)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <code>A = R/I</code> over a field, say, <code>K</code>, where the grading  is inherited from the standard <span>$\mathbb Z$</span>-grading on the polynomial ring <code>R</code>, return <code>true</code> if <code>A</code> is a Cohen-Macaulay ring, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; I = ideal(R, [x*z-y^2, w*z-x*y, w*y-x^2]);

julia&gt; A, _ = quo(R, I);

julia&gt; is_cohen_macaulay(A)
true</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; I = ideal(R, [x*z, y*z]);

julia&gt; A, _ = quo(R, I);

julia&gt; is_cohen_macaulay(A)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L904-L933">source</a></section></article><h2 id="Hilbert-Series-and-Hilbert-Polynomial"><a class="docs-heading-anchor" href="#Hilbert-Series-and-Hilbert-Polynomial">Hilbert Series and Hilbert Polynomial</a><a id="Hilbert-Series-and-Hilbert-Polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#Hilbert-Series-and-Hilbert-Polynomial" title="Permalink"></a></h2><p>Given a multivariate polynomial ring <span>$R$</span> over a field <span>$K$</span> together with a (multi)grading on <span>$R$</span> by a finitely generated abelian group <span>$G$</span>, let <span>$I$</span> be an ideal of <span>$R$</span> which is homogeneous with respect to this grading. Then the affine <span>$K-$</span>algebra <span>$A=R/I$</span> inherits the grading: <span>$A = \bigoplus_{g\in G} A_g$</span>. Suppose now that <span>$R$</span> is positively graded by <span>$G$</span>. That is, <span>$G$</span> is free and each graded piece <span>$R_g$</span> has finite dimension. Then also <span>$A_g$</span> is a finite dimensional <span>$K$</span>-vector space for each <span>$g$</span>, and we have the well-defined <em>Hilbert function</em> of <span>$A$</span>,</p><p class="math-container">\[H(A, \underline{\phantom{d}}): G \to \N, \; g\mapsto \dim_K(A_g).\]</p><p>The <em>Hilbert series</em> of <span>$A$</span> is the generating function</p><p class="math-container">\[H_A(\mathbb t)=\sum_{g\in G} H(A, g) \mathbb t^g\]</p><p>(see  Section 8.2 in [<a href="../../references/#MS05">MS05</a>] for a formal discussion extending the classical case of <span>$\mathbb Z$</span>-gradings with positive weights to the more general case of multigradings). As in the classical case, the infinitely many values of the Hilbert function can be expressed in finite terms by representing the Hilbert series as a rational function (see Theorem 8.20 in [<a href="../../references/#MS05">MS05</a>] for a precise statement).</p><p>By a result of Macaulay, if <span>$A = R/I$</span> is an affine algebra, and <span>$L_{&gt;}(I)$</span> is the leading ideal of <span>$I$</span> with respect to a global monomial ordering <span>$&gt;$</span>, then the Hilbert function of <span>$A$</span> equals that of <span>$R/L_{&gt;}(I)$</span> (see Theorem 15.26 in [<a href="../../references/#Eis95">Eis95</a>]). Thus, using Gröbner bases, the computation of Hilbert series can be reduced to the case where the modulus of the affine algebra is a monomial ideal. In the latter case, we face a problem of combinatorial nature, and there are various strategies of how to proceed (see [<a href="../../references/#KR05">KR05</a>]). The functions <code>hilbert_series</code>, <code>hilbert_series_reduced</code>, <code>hilbert_series_expanded</code>, <code>hilbert_function</code>, <code>hilbert_polynomial</code>, and <code>degree</code> address the case of <span>$\mathbb Z$</span>-gradings with positive weights, relying on corresponding Singular functionality. The functions <code>multi_hilbert_series</code>, <code>multi_hilbert_series_reduced</code>, and <code>multi_hilbert_function</code> offer a variety of different strategies and allow one to handle positive gradings in general.</p><h3 id="\\mathbb-Z-Gradings-With-Positive-Weights"><a class="docs-heading-anchor" href="#\\mathbb-Z-Gradings-With-Positive-Weights"><span>$\mathbb Z$</span>-Gradings With Positive Weights</a><a id="\\mathbb-Z-Gradings-With-Positive-Weights-1"></a><a class="docs-heading-anchor-permalink" href="#\\mathbb-Z-Gradings-With-Positive-Weights" title="Permalink"></a></h3><p>Let <span>$R=K[x_1, \dots x_n]$</span> be a polynomial ring in <span>$n$</span> variables over a field <span>$K$</span>. Assign positive integer weights <span>$w_i$</span> to the variables <span>$x_i$</span>, and grade <span>$R=\bigoplus_{d\in \mathbb Z} R_d=\bigoplus_{d\geq 0} R_d$</span> according to the corresponding weighted degree. Let <span>$I$</span> be an ideal of <span>$R$</span> which is homogeneous with respect to this grading. Then the affine <span>$K$</span>-algebra <span>$A=R/I$</span> inherits the grading: <span>$A = \bigoplus_{d\geq 0} A_d$</span>, where each graded piece <span>$A_d$</span> is a finite dimensional <span>$K$</span>-vector space. In this situation, the <em>Hilbert function</em> of <span>$A$</span> is of type</p><p class="math-container">\[H(A, \underline{\phantom{d}}): \N \to \N, \;d \mapsto \dim_K(d),\]</p><p>and the <em>Hilbert series</em> of <span>$A$</span> is the formal power series</p><p class="math-container">\[H_A(t)=\sum_{d\geq 0} H(A, d) t^d\in\mathbb Z[[t]].\]</p><p>The Hilbert series can be written as a rational function <span>$p(t)/q(t)$</span>, with denominator</p><p class="math-container">\[q(t) = (1-t^{w_1})\cdots (1-t^{w_n}).\]</p><p>In the standard <span>$\mathbb Z$</span>-graded case, where the weights on the variables are all 1, the Hilbert function is of polynomial nature: There exists  a unique polynomial <span>$P_A(t)\in\mathbb{Q}[t]$</span>, the <em>Hilbert polynomial</em>, which satisfies <span>$H(M,d)=P_M(d)$</span> for all <span>$d \gg 0$</span>. Furthermore, the <em>degree</em> of <span>$A$</span> is defined as the dimension of <span>$A$</span> over <span>$K$</span> if this dimension is finite, and as the integer <span>$d$</span> such that the leading term of the Hilbert polynomial has the form <span>$d t^e/e!$</span>, otherwise.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="hilbert_series-Tuple{MPolyQuoRing}" href="#hilbert_series-Tuple{MPolyQuoRing}"><code>hilbert_series</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hilbert_series(A::MPolyQuoRing; backend::Symbol=:Singular, algorithm::Symbol=:BayerStillmanA)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <span>$A = R/I$</span> over a field <span>$K$</span>, where the grading  is inherited from a <span>$\mathbb Z$</span>-grading on the polynomial ring <span>$R$</span> defined by assigning  positive integer weights to the variables, return a pair <span>$(p,q)$</span>, say, of univariate  polynomials <span>$p, q\in\mathbb Z[t]$</span> such that <span>$p/q$</span> represents the Hilbert series of <span>$A$</span> as  a rational function with denominator </p><p class="math-container">\[q = (1-t^{w_1})\cdots (1-t^{w_n}),\]</p><p>where <span>$n$</span> is the number of variables of <span>$R$</span>, and <span>$w_1, \dots, w_n$</span> are the assigned weights.</p><p>See also <code>hilbert_series_reduced</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The advanced user can select different backends for the computation (<code>:Singular</code> and  <code>:Abbott</code> for the moment), as well as different algorithms. The latter might be  ignored for certain backends. </p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; hilbert_series(A)
(2*t^3 - 3*t^2 + 1, (-t + 1)^4)

julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [1, 2, 3]);

julia&gt; A, _ = quo(R, ideal(R, [x*y*z]));

julia&gt; hilbert_series(A)
(-t^6 + 1, (-t^2 + 1)^1*(-t + 1)^1*(-t^3 + 1)^1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L186-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="hilbert_series_reduced-Tuple{MPolyQuoRing}" href="#hilbert_series_reduced-Tuple{MPolyQuoRing}"><code>hilbert_series_reduced</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hilbert_series_reduced(A::MPolyQuoRing)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <span>$A = R/I$</span> over a field <span>$K$</span>, where the grading  is inherited from a <span>$\mathbb Z$</span>-grading on the polynomial ring <span>$R$</span> defined by assigning  positive integer weights to the variables, return a pair <span>$(p,q)$</span>, say, of univariate  polynomials <span>$p, q\in\mathbb Z[t]$</span> such that <span>$p/q$</span> represents the Hilbert series of  <span>$A$</span> as a rational function written in lowest terms. </p><p>See also <code>hilbert_series</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; hilbert_series_reduced(A)
(2*t + 1, t^2 - 2*t + 1)

julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [1, 2, 3]);

julia&gt; A, _ = quo(R, ideal(R, [x*y*z]));

julia&gt; hilbert_series(A)
(-t^6 + 1, (-t^2 + 1)^1*(-t + 1)^1*(-t^3 + 1)^1)

julia&gt; hilbert_series_reduced(A)
(t^2 - t + 1, t^2 - 2*t + 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L243-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="hilbert_series_expanded-Tuple{MPolyQuoRing, Int64}" href="#hilbert_series_expanded-Tuple{MPolyQuoRing, Int64}"><code>hilbert_series_expanded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hilbert_series_expanded(A::MPolyQuoRing, d::Int)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <span>$A = R/I$</span> over a field <span>$K$</span>, where the grading  is inherited from a <span>$\mathbb Z$</span>-grading on the polynomial ring <span>$R$</span> defined by assigning  positive integer weights to the variables, return the Hilbert series of <span>$A$</span> to precision <span>$d$</span>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; hilbert_series_expanded(A, 7)
1 + 4*t + 7*t^2 + 10*t^3 + 13*t^4 + 16*t^5 + 19*t^6 + 22*t^7 + O(t^8)

julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [1, 2, 3]);

julia&gt; A, _ = quo(R, ideal(R, [x*y*z]));

julia&gt; hilbert_series_expanded(A, 5)
1 + t + 2*t^2 + 3*t^3 + 4*t^4 + 5*t^5 + O(t^6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L282-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="hilbert_function-Tuple{MPolyQuoRing, Int64}" href="#hilbert_function-Tuple{MPolyQuoRing, Int64}"><code>hilbert_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hilbert_function(A::MPolyQuoRing, d::Int)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <span>$A = R/I$</span> over a field <span>$K$</span>, where the grading  is inherited from a <span>$\mathbb Z$</span>-grading on the polynomial ring <span>$R$</span> defined by assigning  positive integer weights to the variables, return the value <span>$H(A, d),$</span> where </p><p class="math-container">\[H(A, \underline{\phantom{d}}): \N \to \N, \; d  \mapsto \dim_K A_d,\]</p><p>is the Hilbert function of <span>$A$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; hilbert_function(A,7)
22

julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [1, 2, 3]);

julia&gt; A, _ = quo(R, ideal(R, [x*y*z]));

julia&gt; hilbert_function(A, 5)
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L321-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="hilbert_polynomial-Tuple{MPolyQuoRing}" href="#hilbert_polynomial-Tuple{MPolyQuoRing}"><code>hilbert_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> hilbert_polynomial(A::MPolyQuoRing)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <span>$A = R/I$</span> over a field <span>$K$</span>, where the grading  is inherited from the standard <span>$\mathbb Z$</span>-grading on the polynomial ring <span>$R$</span>, return the Hilbert polynomial of <span>$A$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; hilbert_polynomial(A)
3*t + 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L359-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="degree-Tuple{MPolyQuoRing}" href="#degree-Tuple{MPolyQuoRing}"><code>degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree(A::MPolyQuoRing)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <span>$A = R/I$</span> over a field <span>$K$</span>, where the grading  is inherited from the standard <span>$\mathbb Z$</span>-grading on the polynomial ring <span>$R$</span>, return the degree of <span>$A$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; degree(A)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L393-L409">source</a></section></article><h3 id="Positive-Gradings-in-General"><a class="docs-heading-anchor" href="#Positive-Gradings-in-General">Positive Gradings in General</a><a id="Positive-Gradings-in-General-1"></a><a class="docs-heading-anchor-permalink" href="#Positive-Gradings-in-General" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="multi_hilbert_series-Tuple{MPolyQuoRing}" href="#multi_hilbert_series-Tuple{MPolyQuoRing}"><code>multi_hilbert_series</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multi_hilbert_series(A::MPolyQuoRing; algorithm::Symbol=:BayerStillmanA, parent::Union{Nothing,Ring}=nothing)</code></pre><p>Return the Hilbert series of the graded affine algebra <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The advanced user can select an <code>algorithm</code> for the computation;  see the code for details.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W = [1 1 1; 0 0 -1];

julia&gt; R, x = graded_polynomial_ring(QQ, [&quot;x[1]&quot;, &quot;x[2]&quot;, &quot;x[3]&quot;], W)
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3]])

julia&gt; I = ideal(R, [x[1]^3*x[2], x[2]*x[3]^2, x[2]^2*x[3], x[3]^4]);

julia&gt; A, _ = quo(R, I);

julia&gt; H = multi_hilbert_series(A);

julia&gt; H[1][1]
-t[1]^7*t[2]^-2 + t[1]^6*t[2]^-1 + t[1]^6*t[2]^-2 + t[1]^5*t[2]^-4 - t[1]^4 + t[1]^4*t[2]^-2 - t[1]^4*t[2]^-4 - t[1]^3*t[2]^-1 - t[1]^3*t[2]^-2 + 1

julia&gt; H[1][2]
(-t[1] + 1)^2*(-t[1]*t[2]^-1 + 1)^1

julia&gt; H[2][1]
Z^2

julia&gt; H[2][2]
Identity map
  of Z^2

julia&gt; G = abelian_group(ZZMatrix([1 -1]));

julia&gt; g = gen(G, 1)
Abelian group element [0, 1]

julia&gt; W = [g, g, g, g];

julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;], W);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; (num, den), (H, iso) = multi_hilbert_series(A);

julia&gt; num
2*t^3 - 3*t^2 + 1

julia&gt; den
(-t + 1)^4

julia&gt; H
Z

julia&gt; iso
Map
  from Z
  to finitely generated abelian group with 2 generators and 1 relation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L468-L530">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="multi_hilbert_series_reduced-Tuple{MPolyQuoRing}" href="#multi_hilbert_series_reduced-Tuple{MPolyQuoRing}"><code>multi_hilbert_series_reduced</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multi_hilbert_series_reduced(A::MPolyQuoRing; algorithm::Symbol=:BayerStillmanA)</code></pre><p>Return the reduced Hilbert series of the positively graded affine algebra <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The advanced user can select a <code>algorithm</code> for the computation;  see the code for details.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W = [1 1 1; 0 0 -1];

julia&gt; R, x = graded_polynomial_ring(QQ, [&quot;x[1]&quot;, &quot;x[2]&quot;, &quot;x[3]&quot;], W)
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3]])

julia&gt; I = ideal(R, [x[1]^3*x[2], x[2]*x[3]^2, x[2]^2*x[3], x[3]^4]);

julia&gt; A, _ = quo(R, I);

julia&gt; H = multi_hilbert_series_reduced(A);


julia&gt; H[1][1]
-t[1]^5*t[2]^-1 + t[1]^3 + t[1]^3*t[2]^-3 + t[1]^2 + t[1]^2*t[2]^-1 + t[1]^2*t[2]^-2 + t[1] + t[1]*t[2]^-1 + 1

julia&gt; H[1][2]
-t[1] + 1

julia&gt; H[2][1]
Z^2

julia&gt; H[2][2]
Identity map
  of Z^2

julia&gt; G = abelian_group(ZZMatrix([1 -1]));

julia&gt; g = gen(G, 1)
Abelian group element [0, 1]

julia&gt; W = [g, g, g, g];

julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;], W);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; H = multi_hilbert_series_reduced(A);

julia&gt; H[1][1]
2*t + 1

julia&gt; H[1][2]
t^2 - 2*t + 1

julia&gt; H[2][1]
Z

julia&gt; H[2][2]
Map
  from Z
  to finitely generated abelian group with 2 generators and 1 relation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L660-L723">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="multi_hilbert_function-Tuple{MPolyQuoRing, FinGenAbGroupElem}" href="#multi_hilbert_function-Tuple{MPolyQuoRing, FinGenAbGroupElem}"><code>multi_hilbert_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multi_hilbert_function(A::MPolyQuoRing, g::FinGenAbGroupElem)</code></pre><p>Given a positively graded affine algebra <span>$A$</span> over a field <span>$K$</span> with grading group <span>$G$</span>, say, and given an element <span>$g$</span> of <span>$G$</span>, return the value <span>$H(A, g)$</span> of the Hilbert function</p><p class="math-container">\[H(A, \underline{\phantom{d}}): G \to \N, \; g\mapsto \dim_K(A_g).\]</p><pre><code class="nohighlight hljs">multi_hilbert_function(A::MPolyQuoRing, g::Vector{&lt;:IntegerUnion})</code></pre><p>Given a positively <span>$\mathbb  Z^m$</span>-graded affine algebra <span>$A$</span> over a field <span>$K$</span>, and given a vector <span>$g$</span> of <span>$m$</span> integers, convert <span>$g$</span> into an element  of the grading group of <span>$A$</span>, and return the value <span>$H(A, g)$</span> as above.</p><pre><code class="nohighlight hljs">multi_hilbert_function(A::MPolyQuoRing, g::IntegerUnion)</code></pre><p>Given a positively <span>$\mathbb  Z$</span>-graded affine algebra <span>$A$</span> over a field <span>$K$</span>, and given an integer <span>$g$</span>, convert <span>$g$</span> into an element of the grading group  of <span>$A$</span>, and return the value <span>$H(A, g)$</span> as above.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W = [1 1 1; 0 0 -1];

julia&gt; R, x = graded_polynomial_ring(QQ, [&quot;x[1]&quot;, &quot;x[2]&quot;, &quot;x[3]&quot;], W)
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3]])

julia&gt; I = ideal(R, [x[1]^3*x[2], x[2]*x[3]^2, x[2]^2*x[3], x[3]^4]);

julia&gt; A, _ = quo(R, I);

julia&gt; multi_hilbert_function(A::MPolyQuoRing, [1, 0])
2</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [-1, -1, -1, -1]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; multi_hilbert_function(A, -7)
22</code></pre><pre><code class="language-julia-repl hljs">julia&gt; G = abelian_group(ZZMatrix([1 -1]));

julia&gt; g = gen(G, 1);

julia&gt; W = [g, g, g, g];

julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;], W);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; multi_hilbert_function(A, 7*g)
22</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Rings/mpoly-affine-algebras.jl#L749-L808">source</a></section></article><h2 id="Affine-Algebras-as-Modules"><a class="docs-heading-anchor" href="#Affine-Algebras-as-Modules">Affine Algebras as Modules</a><a id="Affine-Algebras-as-Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Affine-Algebras-as-Modules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="quotient_ring_as_module-Tuple{MPolyQuoRing}" href="#quotient_ring_as_module-Tuple{MPolyQuoRing}"><code>quotient_ring_as_module</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quotient_ring_as_module(A::MPolyQuoRing)</code></pre><p>Return <code>A</code> considered as an object of type <code>SubquoModule</code>.</p><pre><code class="nohighlight hljs">quotient_ring_as_module(I::MPolyIdeal)</code></pre><p>As above, where <code>A</code> is the quotient of <code>base_ring(I)</code> modulo <code>I</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; I = ideal(R, [x^2, y^3])
Ideal generated by
  x^2
  y^3

julia&gt; quotient_ring_as_module(I)
Subquotient of Submodule with 1 generator
1 -&gt; e[1]
by Submodule with 2 generators
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; S, (x, y) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; I = ideal(S, [x^2, y^3])
Ideal generated by
  x^2
  y^3

julia&gt; quotient_ring_as_module(I)
Graded subquotient of submodule of S^1 generated by
1 -&gt; e[1]
by submodule of S^1 generated by
1 -&gt; x^2*e[1]
2 -&gt; y^3*e[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/e0e8ed9e99ce6b7eab969ecb3a4e720cd227831a/src/Modules/ModulesGraded.jl#L2867-L2908">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ideals/">« Ideals in Multivariate Rings</a><a class="docs-footer-nextpage" href="../localizations/">Localized Rings and Their Ideals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Wednesday 17 April 2024 13:28">Wednesday 17 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
