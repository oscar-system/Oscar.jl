@doc raw"""
    homogeneity_space(I::MPolyIdeal)

Computes a basis for the homogeneity space of the ideal `I` which is the lineality space of the cones in the Groebner fan of `I`. 

## Examples

```jldoctest
julia> R, x = polynomial_ring(QQ, :x => (1:2, 1:2))
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x[1, 1] x[1, 2]; x[2, 1] x[2, 2]])

julia> I = ideal([x[1,1]*x[2,2] - x[1,2]*x[2,1]])
Ideal generated by
  x[1, 1]*x[2, 2] - x[2, 1]*x[1, 2]

julia> Oscar.homogeneity_space(I)
[1   0   0   -1]
[0   1   0    1]
[0   0   1    1]
```
"""
function homogeneity_space(I::MPolyIdeal)
  n = ngens(base_ring(I))
  homogeneity_eqs = zero_matrix(ZZ, 1, n)

  for f in gens(I)
    exps = [exponent_vector(f,i) for i in 1:length(f)]
    eqs = matrix(ZZ, vcat([exps[1] - exps[i] for i in 2:length(exps)]))
    homogeneity_eqs = vcat(homogeneity_eqs, eqs)
  end
  
  return rref(transpose(nullspace(homogeneity_eqs)[2]))[2]
end

@doc raw"""
    max_grade_domain(phi::MPolyAnyMap)

Computes the maximal rank grading on the kernel of $\phi: \mathbb{K}[x_1, \ldots, x_n] \to \mathbb{K}[t_1, \ldots, t_m]$ which can be induced by grading the codomain of `phi`. 
The first $m$ columns of the resulting matrix correspond to the degrees of the codomain while the last $n$ columns are the resulting degrees on the domain. 

## Examples

```jldoctest
julia> R, x = polynomial_ring(QQ, :x => (1:2, 1:2))
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x[1, 1] x[1, 2]; x[2, 1] x[2, 2]])

julia> S, s, t = polynomial_ring(QQ, :s => 1:2, :t => 1:2)
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[s[1], s[2]], QQMPolyRingElem[t[1], t[2]])

julia> phi = hom(R, S, [s[1]*t[1], s[1]*t[2], s[2]*t[1], s[2]*t[2]])
Ring homomorphism
  from multivariate polynomial ring in 4 variables over QQ
  to multivariate polynomial ring in 4 variables over QQ
defined by
  x[1, 1] -> s[1]*t[1]
  x[2, 1] -> s[1]*t[2]
  x[1, 2] -> s[2]*t[1]
  x[2, 2] -> s[2]*t[2]

julia> Oscar.max_grade_domain(phi)
Multivariate polynomial ring in 4 variables over QQ graded by
  x[1, 1] -> [1 0 1 0]
  x[2, 1] -> [1 0 0 1]
  x[1, 2] -> [0 1 1 0]
  x[2, 2] -> [0 1 0 1]
```
"""
function max_grade_domain(phi::MPolyAnyMap)
  codom = codomain(phi)
  dom = domain(phi)
  elim_ring, z = polynomial_ring(QQ, vcat(symbols(codom), symbols(dom)); cached=false)
  lift_codom = hom(codom, elim_ring, gens(elim_ring)[1:ngens(codom)])
  lift_dom = hom(dom, elim_ring, z[ngens(codom) + 1:ngens(elim_ring)])

  A = homogeneity_space(ideal([lift_dom(x) - lift_codom(phi(x)) for x in gens(dom)]))
  
  # grade the domain
  graded_dom = grade(domain(phi), A[:, ngens(codomain(phi)) + 1:end])[1]
end

function max_grade_domain(phi::MPolyAnyMap{<:MPolyDecRing})
  error("domain is already graded")
end

@doc raw"""
    jacobian(phi::MPolyAnyMap{<:MPolyRing, <:MPolyRing})

Computes the Jacobian of a polynomial map $\phi: \mathbb{K}[x_1, \ldots, x_n] \to \mathbb{K}[t_1, \ldots, t_m]$ such that $(i, j)$ entry is $\frac{d \phi(x_j)}{d t_i}$.

## Examples

```jldoctest
julia> R, x = polynomial_ring(QQ, :x => (1:2, 1:2))
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x[1, 1] x[1, 2]; x[2, 1] x[2, 2]])

julia> S, s, t = polynomial_ring(QQ, :s => 1:2, :t => 1:2)
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[s[1], s[2]], QQMPolyRingElem[t[1], t[2]])

julia> phi = hom(R, S, [s[1]*t[1], s[1]*t[2], s[2]*t[1], s[2]*t[2]])
Ring homomorphism
  from multivariate polynomial ring in 4 variables over QQ
  to multivariate polynomial ring in 4 variables over QQ
defined by
  x[1, 1] -> s[1]*t[1]
  x[2, 1] -> s[1]*t[2]
  x[1, 2] -> s[2]*t[1]
  x[2, 2] -> s[2]*t[2]

julia> jacobian(phi)
[t[1]   t[2]      0      0]
[   0      0   t[1]   t[2]]
[s[1]      0   s[2]      0]
[   0   s[1]      0   s[2]]
```
"""
function jacobian(phi::MPolyAnyMap{<:MPolyRing, <:MPolyRing})
  jacobian_matrix(codomain(phi), _images_of_generators(phi))
end

# compute the jacobian at a random point with parameters sampled from a finite field
function jacobian_at_rand_point(phi::MPolyAnyMap; char::UInt=UInt(32003))
  K = fpField(char)
  
  # randomly sample parameter values in the finite field
  pt = rand(K, ngens(codomain(phi)))

  for f in jacobian(phi)
    if any(is_zero(K(denominator(c))) for c in AbstractAlgebra.coefficients(f))
      return jacobian_at_rand_point(phi; char=next_prime(char))
    end
  end

  # is it possible we only need numerator here?
  dirty_eval(c) = K(numerator(c))*inv(K(denominator(c)))
  fin_field_jac = map_coefficients.(dirty_eval, jacobian(phi))
  eval_at_pt = Base.Fix2(evaluate, pt)
  return eval_at_pt.(fin_field_jac)
end

# find the indices of the variable support of all monomials in mon_basis
function component_support(mon_basis::Vector{<: MPolyDecRingElem})
  findall(!iszero, eachcol(matrix(first.(AbstractAlgebra.exponent_vectors.(mon_basis)))))
end

@doc raw"""
    compute_kernel_component(mon_basis::Vector{<:MPolyDecRingElem}, phi::MPolyAnyMap)

Computes a basis for the elements in the kernel of a polynomial map
$\phi: \mathbb{K}[x_1, \ldots, x_n] \to \mathbb{K}[t_1, \ldots, t_m]$ which
lie in the homogeneous component corresponding to `mon_basis`. 
"""
function compute_kernel_component(mon_basis::Vector{<:MPolyDecRingElem}, phi::MPolyAnyMap)
  SM = sparse_matrix(QQ)
  count = 1
  cols = Dict{Vector{Int}, Int}()
  for m in mon_basis
    row = Tuple{Int, QQFieldElem}[]
    img = phi(m)
    for (c, e) in zip(AbstractAlgebra.coefficients(img), AbstractAlgebra.exponent_vectors(img))
      col = get(cols, e, nothing)
      if isnothing(col)
        count += 1
        cols[e] = count
        col = count
      end
      push!(row, (col, c))
    end
    push!(SM, sparse_row(QQ, row))
  end
  K = kernel(SM)
  
  return mon_basis * transpose(K)
end

@doc raw"""
    filter_component(deg::FinGenAbGroupElem, mon_basis::Vector{<: MPolyDecRingElem}, jac::MatElem)

This function is used to skip homogeneous components which cannot contain an element of the kernel by checking if the variables in that component are independent
in the matroid defined by the jacboian of a polynomial map. If the submatrix of the jacobian corresponding to a subset of the variables in the codomain is full rank, then
there cannot be a relation in the kernel involving only those variables. 
```
"""
function filter_component(deg::FinGenAbGroupElem, mon_basis::Vector{<: MPolyDecRingElem}, jac::MatElem)
  # if the basis only has 1 element, then there are no generators by assumption
  length(mon_basis) < 2 && return [true, deg]

  # find the indices of all variables involved in this component
  supp = component_support(mon_basis)

  # check if the corresponding submatrix drops rank
  # if it does not, then this component cannot contain any generator of the kernel
  if rank(jac[:, supp]) == length(supp)
    return [true, deg]
  end

  return [false, deg]
end


@doc raw"""
    components_of_kernel(d::Int, phi::MPolyAnyMap; wp::Union{OscarWorkerPool, Nothing}=nothing)

Computes all minimal generators of the kernel of the polynomial map $\phi: \mathbb{K}[x_1, \ldots, x_n] \to \mathbb{K}[t_1, \ldots, t_m]$ such that $(i, j)$ 
with total degree at most $d$ using the main algorithm of [CH26](@cite). This implementation requires that $\phi$ be homogeneous in a multigrading which refines total
degree which ensures the algorithm is parallelizable. The output is a dictionary whose keys are the multidegrees and values consist of a minimal generating set for that multidegree. 

## Examples

```jldoctest
julia> R, x = polynomial_ring(QQ, :x => (1:2, 1:2))
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x[1, 1] x[1, 2]; x[2, 1] x[2, 2]])

julia> S, s, t = polynomial_ring(QQ, :s => 1:2, :t => 1:2)
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[s[1], s[2]], QQMPolyRingElem[t[1], t[2]])

julia> phi = hom(R, S, [s[1]*t[1], s[1]*t[2], s[2]*t[1], s[2]*t[2]])
Ring homomorphism
  from multivariate polynomial ring in 4 variables over QQ
  to multivariate polynomial ring in 4 variables over QQ
defined by
  x[1, 1] -> s[1]*t[1]
  x[2, 1] -> s[1]*t[2]
  x[1, 2] -> s[2]*t[1]
  x[2, 2] -> s[2]*t[2]

julia> d = Oscar.components_of_kernel(2, phi);

julia> d[1, 1, 1, 1]
1-element Vector{QQMPolyRingElem}:
 x[1, 1]*x[2, 2] - x[2, 1]*x[1, 2]
```
"""
function components_of_kernel(d::Int, 
    phi::MPolyAnyMap; # Morphism between ungraded rings
    wp::Union{OscarWorkerPool, Nothing}=nothing,
    batch_size=100
  )
  # grade the domain
  graded_dom = max_grade_domain(phi)
  graded_cod, _ = grade(codomain(phi)) # standard grading
  phi_grad = hom(graded_dom, graded_cod, graded_cod.(_images_of_generators(phi)))
  return Dict{FinGenAbGroupElem, Vector{elem_type(domain(phi))}}(d=>forget_grading.(v) for (d, v) in components_of_kernel(d, phi_grad; wp, batch_size))
end

function degree_over_simplex(R::MPolyDecRing, ng::Int, d::Int)
  lattice_basis = Tuple{Vector{Int}, FinGenAbGroupElem}[]
  for i in 2:ng
    v = zeros(Int, ng)
    v[1] = -1
    v[i] = 1
    deg = generator_degrees(R)[1] - generator_degrees(R)[i]
    push!(lattice_basis, (v, deg))
  end
  e = zeros(Int, ng)
  e[1] = d
  m = monomial(R, e)
  deg = degree(m)

  all_mon = elem_type(R)[m]
  all_deg = FinGenAbGroupElem[deg]
  visited = Dict{Vector{Int}, Tuple{FinGenAbGroupElem, MPolyDecRingElem}}(e => (deg, m))
  stack = [(e, deg, m)]
  
  while length(stack) > 0
    (e, deg, mon) = pop!(stack)
    for lb in lattice_basis
      next_e = e + lb[1]
      any(<(0), next_e) && continue
      next_e in keys(visited) && continue
      next_mon = monomial(R, next_e)
      next_deg = deg + lb[2]
      visited[next_e] = (next_deg, next_mon)
      push!(stack, (next_e, next_deg, next_mon))
    end
  end

  return return values(visited)
end

function components_of_kernel(d::Int, 
    phi::MPolyAnyMap{<:MPolyDecRing, <:MPolyDecRing, Nothing}; # Morphism with a graded domain
    wp::Union{OscarWorkerPool, Nothing}=nothing,
    batch_size::Int=100
  )
  @assert is_graded(domain(phi)) && is_graded(codomain(phi)) "morphism must be between graded rings"
  @assert all(is_homogeneous, _images_of_generators(phi)) "morphism must be homogeneous"

  # grade the domain by the standard grading as well and compute the jacobian at a random point over a finite field
  ungraded_dom = forget_grading(domain(phi))
  ungraded_cod = forget_grading(codomain(phi))
  total_deg_dom = grade(ungraded_dom, [1 for i in 1:ngens(domain(phi))])[1]
  jac = jacobian_at_rand_point(phi)

  # create a dictionary to store the generators by their degree
  gens_dict = Dict{FinGenAbGroupElem, Vector{<:MPolyDecRingElem}}()

  for i in 1:d
    deg_mon_tuples = degree_over_simplex(domain(phi), ngens(domain(phi)), i)
    mon_bases = Dict{FinGenAbGroupElem, Vector{elem_type(domain(phi))}}()

    # avoid redundant degree computation
    for (d, m) in deg_mon_tuples
      bucket = get!(mon_bases, d) do
        sizehint!(typeof(m)[], 1)
      end
      push!(bucket, m)
    end

    # find the previous generators 
    if isempty(gens_dict)
      prev_gens = elem_type(domain(phi))[]
    else
      prev_gens = reduce(vcat, values(gens_dict))
    end

    # first filter out all easy cases
    # this could be improved to do some load-balancing
    if isnothing(wp)
      filter_results = pmap(filter_component,
                            [deg for deg in keys(mon_bases)],
                            [mon_bases[deg] for deg in keys(mon_bases)],
                            [jac for _ in keys(mon_bases)]; distributed=false)
    else
      filter_results = pmap(filter_component, wp,
                            [deg for deg in keys(mon_bases)],
                            [mon_bases[deg] for deg in keys(mon_bases)],
                            [jac for _ in keys(mon_bases)]; batch_size=batch_size)
    end

    remain_degs = [result[2] for result in filter_results if !result[1]]

    # now we compute all of the remaining cases which we cannot filter with the Jacobian of phi
    # this could also be improved to do some load-balancing
    if !isempty(remain_degs)
      if isnothing(wp)
        results = pmap(compute_kernel_component, map(deg -> mon_bases[deg], remain_degs),
                       [phi for _ in remain_degs];
                       distributed=false)
      else
        results = pmap(compute_kernel_component, wp, map(deg -> mon_bases[deg], remain_degs),
                       [phi for _ in remain_degs]; batch_size=batch_size)
      end
    else
      results =[]
    end

    merge!(gens_dict, Dict(zip(remain_degs, results)))
  end

  return gens_dict
end


