@doc raw"""
    homogeneity_space(I::MPolyIdeal)

Computes a basis for the homogeneity space of the ideal `I` which is the lineality space of the cones in the Groebner fan of `I`.

## Examples

```jldoctest
julia> R, x = polynomial_ring(QQ, :x => (1:2, 1:2))
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x[1, 1] x[1, 2]; x[2, 1] x[2, 2]])

julia> I = ideal([x[1,1]*x[2,2] - x[1,2]*x[2,1]])
Ideal generated by
  x[1, 1]*x[2, 2] - x[2, 1]*x[1, 2]

julia> Oscar.homogeneity_space(I)
[1   0   0   -1]
[0   1   0    1]
[0   0   1    1]
```
"""
function homogeneity_space(I::MPolyIdeal)
  n = ngens(base_ring(I))
  homogeneity_eqs = zero_matrix(ZZ, 1, n)

  for f in gens(I)
    exps = [exponent_vector(f,i) for i in 1:length(f)]
    eqs = matrix(ZZ, vcat([exps[1] - exps[i] for i in 2:length(exps)]))
    homogeneity_eqs = vcat(homogeneity_eqs, eqs)
  end

  return rref(transpose(nullspace(homogeneity_eqs)[2]))[2]
end

@doc raw"""
    max_grade_domain(phi::MPolyAnyMap)

Computes the maximal rank grading on the kernel of $\phi: \mathbb{K}[x_1, \ldots, x_n] \to \mathbb{K}[t_1, \ldots, t_m]$ which can be induced by grading the codomain of `phi`.
The first $m$ columns of the resulting matrix correspond to the degrees of the codomain while the last $n$ columns are the resulting degrees on the domain.

## Examples

```jldoctest
julia> R, x = polynomial_ring(QQ, :x => (1:2, 1:2))
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x[1, 1] x[1, 2]; x[2, 1] x[2, 2]])

julia> S, s, t = polynomial_ring(QQ, :s => 1:2, :t => 1:2)
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[s[1], s[2]], QQMPolyRingElem[t[1], t[2]])

julia> phi = hom(R, S, [s[1]*t[1], s[1]*t[2], s[2]*t[1], s[2]*t[2]])
Ring homomorphism
  from multivariate polynomial ring in 4 variables over QQ
  to multivariate polynomial ring in 4 variables over QQ
defined by
  x[1, 1] -> s[1]*t[1]
  x[2, 1] -> s[1]*t[2]
  x[1, 2] -> s[2]*t[1]
  x[2, 2] -> s[2]*t[2]

julia> Oscar.max_grade_domain(phi)
Multivariate polynomial ring in 4 variables over QQ graded by
  x[1, 1] -> [1 0 1 0]
  x[2, 1] -> [1 0 0 1]
  x[1, 2] -> [0 1 1 0]
  x[2, 2] -> [0 1 0 1]
```
"""
function max_grade_domain(phi::MPolyAnyMap)
  codom = codomain(phi)
  dom = domain(phi)
  elim_ring, z = polynomial_ring(QQ, vcat(symbols(codom), symbols(dom)); cached=false)
  lift_codom = hom(codom, elim_ring, gens(elim_ring)[1:ngens(codom)])
  lift_dom = hom(dom, elim_ring, z[ngens(codom) + 1:ngens(elim_ring)])

  A = homogeneity_space(ideal([lift_dom(x) - lift_codom(phi(x)) for x in gens(dom)]))

  # grade the domain
  return grade(domain(phi), A[:, ngens(codomain(phi)) + 1:end])[1]
end

function max_grade_domain(phi::MPolyAnyMap{<:MPolyDecRing})
  error("domain is already graded")
end

@doc raw"""
    jacobian(phi::MPolyAnyMap{<:MPolyRing, <:MPolyRing})

Computes the Jacobian of a polynomial map $\phi: \mathbb{K}[x_1, \ldots, x_n] \to \mathbb{K}[t_1, \ldots, t_m]$ such that $(i, j)$ entry is $\frac{d \phi(x_j)}{d t_i}$.

## Examples

```jldoctest
julia> R, x = polynomial_ring(QQ, :x => (1:2, 1:2))
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x[1, 1] x[1, 2]; x[2, 1] x[2, 2]])

julia> S, s, t = polynomial_ring(QQ, :s => 1:2, :t => 1:2)
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[s[1], s[2]], QQMPolyRingElem[t[1], t[2]])

julia> phi = hom(R, S, [s[1]*t[1], s[1]*t[2], s[2]*t[1], s[2]*t[2]])
Ring homomorphism
  from multivariate polynomial ring in 4 variables over QQ
  to multivariate polynomial ring in 4 variables over QQ
defined by
  x[1, 1] -> s[1]*t[1]
  x[2, 1] -> s[1]*t[2]
  x[1, 2] -> s[2]*t[1]
  x[2, 2] -> s[2]*t[2]

julia> jacobian(phi)
[t[1]   t[2]      0      0]
[   0      0   t[1]   t[2]]
[s[1]      0   s[2]      0]
[   0   s[1]      0   s[2]]
```
"""
jacobian(phi::MPolyAnyMap{<:MPolyRing, <:MPolyRing}) = jacobian_matrix(codomain(phi), _images_of_generators(phi))


# compute the jacobian at a random point with parameters sampled from a finite field
function jacobian_at_rand_point(phi::MPolyAnyMap; char::UInt=UInt(32003))
  K = fpField(char)

  # randomly sample parameter values in the finite field
  pt = rand(K, ngens(codomain(phi)))
  for f in jacobian(phi)
    if any(is_zero(K(denominator(c))) for c in AbstractAlgebra.coefficients(f))
      return jacobian_at_rand_point(phi; char=next_prime(char))
    end
  end

  # is it possible we only need numerator here?
  dirty_eval(c) = K(numerator(c))*inv(K(denominator(c)))
  fin_field_jac = map_coefficients.(dirty_eval, jacobian(phi))
  eval_at_pt = Base.Fix2(evaluate, pt)
  return eval_at_pt.(fin_field_jac)
end

# find the indices of the variable support of all monomials in mon_basis
component_support(mon_basis::Vector{<: MPolyDecRingElem}) = findall(!iszero, eachcol(matrix(first.(AbstractAlgebra.exponent_vectors.(mon_basis)))))

@doc raw"""
    compute_kernel_component(mon_basis::Vector{<:MPolyDecRingElem}, phi::MPolyAnyMap)

Computes a basis for the elements in the kernel of a polynomial map
$\phi: \mathbb{K}[x_1, \ldots, x_n] \to \mathbb{K}[t_1, \ldots, t_m]$ which
lie in the homogeneous component corresponding to `mon_basis`.
"""
function compute_kernel_component(mon_basis::Vector{<:MPolyDecRingElem}, phi::MPolyAnyMap)
  imgs = phi.(mon_basis)
  mon_basis_imgs = collect(map(img -> collect.(coefficients_and_exponents.(img)), imgs))

  SM = sparse_matrix(QQ)
  count = 1
  cols = Dict{Vector{Int}, Int}()
  for img in mon_basis_imgs
    row = Tuple{Int, QQFieldElem}[]
    for (c, e) in img
      col = get(cols, e, nothing)
      if isnothing(col)
        cols[e] = count
        col = count
        count += 1
      end
      push!(row, (col, c))
    end
    push!(SM, sparse_row(QQ, row))
  end
  K = kernel(transpose(SM); side=:right)
  return mon_basis * K
end

@doc raw"""
    filter_component(deg::FinGenAbGroupElem, mon_basis::Vector{<: MPolyDecRingElem}, jac::MatElem)

This function is used to skip homogeneous components which cannot contain an element of the kernel by checking if the variables in that component are independent
in the matroid defined by the jacobian of a polynomial map. If the submatrix of the jacobian corresponding to a subset of the variables in the codomain is full rank, then
there cannot be a relation in the kernel involving only those variables.
```
"""
function filter_component(deg::FinGenAbGroupElem, mon_basis::Vector{<: MPolyDecRingElem}, jac::MatElem)
  # if the basis only has 1 element, then there are no generators by assumption
  length(mon_basis) < 2 && return [true, deg]

  # find the indices of all variables involved in this component
  supp = component_support(mon_basis)

  # check if the corresponding submatrix drops rank
  # if it does not, then this component cannot contain any generator of the kernel
  if rank(jac[:, supp]) == length(supp)
    return [true, deg]
  end

  return [false, deg]
end


@doc raw"""
    components_of_kernel(d::Int, phi::MPolyAnyMap; wp::Union{OscarWorkerPool, Nothing}=nothing)

Computes all minimal generators of the kernel of the polynomial map $\phi: \mathbb{K}[x_1, \ldots, x_n] \to \mathbb{K}[t_1, \ldots, t_m]$ such that $(i, j)$
with total degree at most $d$ using the main algorithm of [CH26](@cite). This implementation requires that $\phi$ be homogeneous in a multigrading which refines total
degree which ensures the algorithm is parallelizable. The output is a dictionary whose keys are the multidegrees and values consist of a minimal generating set for that multidegree.

## Examples

```jldoctest
julia> R, x = polynomial_ring(QQ, :x => (1:2, 1:2))
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x[1, 1] x[1, 2]; x[2, 1] x[2, 2]])

julia> S, s, t = polynomial_ring(QQ, :s => 1:2, :t => 1:2)
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[s[1], s[2]], QQMPolyRingElem[t[1], t[2]])

julia> phi = hom(R, S, [s[1]*t[1], s[1]*t[2], s[2]*t[1], s[2]*t[2]])
Ring homomorphism
  from multivariate polynomial ring in 4 variables over QQ
  to multivariate polynomial ring in 4 variables over QQ
defined by
  x[1, 1] -> s[1]*t[1]
  x[2, 1] -> s[1]*t[2]
  x[1, 2] -> s[2]*t[1]
  x[2, 2] -> s[2]*t[2]

julia> d = components_of_kernel(2, phi);

julia> length(d)
1
```
"""
function components_of_kernel(d::Int,
                              phi::MPolyAnyMap; # Morphism between ungraded rings
                              wp::Union{OscarWorkerPool, Nothing}=nothing,
                              batch_size=100
                              )
  # grade the domain
  graded_dom = Oscar.max_grade_domain(phi)
  graded_cod, _ = grade(codomain(phi)) # standard grading
  phi_grad = hom(graded_dom, graded_cod, graded_cod.(_images_of_generators(phi)))
  return Dict{FinGenAbGroupElem, Vector{elem_type(domain(phi))}}(d=>forget_grading.(v) for (d, v) in components_of_kernel(d, phi_grad; wp, batch_size))
end

function components_of_kernel(d::Int,
                              phi::MPolyAnyMap{<:MPolyRing, <:MPolyRing{<:MPolyRingElem}}; # Morphism between ungraded rings
                              wp::Union{OscarWorkerPool, Nothing}=nothing,
                              batch_size=100
                              )
  new_phi = flatten(phi)
  # grade the domain
  graded_dom = Oscar.max_grade_domain(new_phi)
  graded_cod, _ = grade(codomain(new_phi)) # standard grading
  phi_grad = hom(graded_dom, graded_cod, graded_cod.(_images_of_generators(new_phi)))
  return Dict{FinGenAbGroupElem, Vector{elem_type(domain(phi))}}(d=>forget_grading.(v) for (d, v) in components_of_kernel(d, phi_grad; wp, batch_size))
end

function lifted_monomials(deg::FinGenAbGroupElem,
                          lower_simplex::Dict{FinGenAbGroupElem, Vector{<:MPolyDecRingElem}},
                          gens_dict::Dict{FinGenAbGroupElem, Vector{<:MPolyDecRingElem}})
  gen_shifts = MPolyDecRingElem[]
  for (gen_deg, gens) in gens_dict
    if haskey(lower_simplex, deg - gen_deg)
      append!(gen_shifts, reduce(vcat, [[g * m for m in lower_simplex[deg - gen_deg]] for g in gens_dict[gen_deg]]))
    end
  end
  isempty(gen_shifts) && return Set{MPolyDecRingElem}([])
  mons = unique!(reduce(vcat, [collect(monomials(f)) for f in gen_shifts]))
  M = matrix(QQ, [[coeff(f, m) for f in gen_shifts] for m in mons])
  rref!(M)
  mon_indices = Int[]
  for j in 1:ncols(M)
    rows = findall(!iszero, M[:, j])
    isnothing(rows) && continue
    isone(length(rows)) && push!(mon_indices, only(rows))
  end
  return Set(mons[mon_indices])
end

# recursively computes the degrees over the scaled simplex,
# increasing the scaling factor by one on each iteration
# expects the lattice basis to be precomputed and passed
# where the lattice basis is a vector of tuples (exponent vector, deg)
function degree_over_simplex(lower_simplex::Dict{Vector{Int}, Tuple{FinGenAbGroupElem, <:MPolyDecRingElem}},
                             R::MPolyDecRing,
                             lattice_basis::Vector{Tuple{Vector{Int}, FinGenAbGroupElem}})
  e = zeros(Int, ngens(R))
  e[1] = 1
  m = monomial(R, e)
  d = degree(m)
  degree_simplex = Dict{Vector{Int}, Tuple{FinGenAbGroupElem, <:MPolyDecRingElem}}()
  if isempty(lower_simplex)
    degree_simplex[e] = (d, m)
    for lb in lattice_basis
      next_e = e + lb[1]
      next_m = monomial(R, next_e)
      next_d = d + lb[2]
      degree_simplex[next_e] = (next_d, next_m)
    end
  else
    for (exp, (deg, mon)) in lower_simplex
      # builds an open dim + 1 simplex from lower_simplex
      next_exp = exp + e
      next_deg = deg + d
      next_mon = monomial(R, next_exp)
      degree_simplex[next_exp] = (next_deg, next_mon)

      # adds the missing face
      if iszero(exp[1])
        i = findfirst(!iszero, exp)

        for lb in lattice_basis[1: i - 1]
          next_e = next_exp + lb[1]
          next_m = monomial(R, next_e)
          next_d = next_deg + lb[2]
          degree_simplex[next_e] = (next_d, next_m)
        end
      end
    end
  end

  return degree_simplex
end

function components_of_kernel(d::Int,
                              phi::MPolyAnyMap{<:MPolyDecRing, <:MPolyDecRing, Nothing}; # Morphism with a graded domain
                              wp::Union{OscarWorkerPool, Nothing}=nothing,
                              batch_size::Int=1000
                              )
  @assert is_graded(domain(phi)) && is_graded(codomain(phi)) "morphism must be between graded rings"
  @assert all(is_homogeneous, _images_of_generators(phi)) "morphism must be homogeneous"

  # grade the domain by the standard grading as well and compute the jacobian at a random point over a finite field
  ungraded_dom = forget_grading(domain(phi))
  ungraded_cod = forget_grading(codomain(phi))
  total_deg_dom = grade(ungraded_dom, [1 for i in 1:ngens(domain(phi))])[1]
  jac = jacobian_at_rand_point(phi)

  # create a dictionary to store the generators by their degree
  # this is what will be returned
  gens_dict = Dict{FinGenAbGroupElem, Vector{<:MPolyDecRingElem}}()

  # keeps track of computed degrees and the monomials in that degree
  simplex_monomials = Dict{Int,
                           Dict{Vector{Int}, Tuple{FinGenAbGroupElem, <:MPolyDecRingElem}}}()

  # compute the basis and it's degrees once
  lattice_basis = Tuple{Vector{Int}, FinGenAbGroupElem}[]
  for i in 2:ngens(domain(phi))
    v = zeros(Int, ngens(domain(phi)))
    v[1] = -1
    v[i] = 1
    deg = Oscar.generator_degrees(domain(phi))[i] - Oscar.generator_degrees(domain(phi))[1]
    push!(lattice_basis, (v, deg))
  end

  for i in 1:d
    lower_simplex = get!(simplex_monomials, i - 1, Dict{Vector{Int}, Tuple{FinGenAbGroupElem, <:MPolyDecRingElem}}())
    simplex_monomials[i] = degree_over_simplex(lower_simplex, domain(phi), lattice_basis)
    all_degrees = Dict{FinGenAbGroupElem, Vector{<:MPolyDecRingElem}}()
    for sm in values(simplex_monomials)
      for (_, (deg, m)) in sm
        b = get!(all_degrees, deg, typeof(m)[])
        push!(b, m)
      end
    end
    l_monomials = Dict{FinGenAbGroupElem, Set{<:MPolyDecRingElem}}()
    mon_bases = Dict{FinGenAbGroupElem, Vector{<:MPolyDecRingElem}}()
    for (_, (deg, m)) in simplex_monomials[i]
      if !haskey(l_monomials, deg)
        l_monomials[deg] = lifted_monomials(deg, all_degrees, gens_dict)
      end
      b = get!(mon_bases, deg, typeof(m)[])
      !(m in l_monomials[deg]) && push!(b, m)
    end

    degrees = collect(keys(mon_bases))
    # first filter out all easy cases
    if isnothing(wp) || length(mon_bases) < 30 * batch_size
      filter_results = pmap(filter_component,
                            [deg for deg in degrees],
                            [mon_bases[deg] for deg in degrees],
                            [jac for _ in degrees]; distributed=false)
    else
      filter_results = pmap(filter_component, wp,
                            [deg for deg in degrees],
                            [mon_bases[deg] for deg in degrees],
                            [jac for _ in degrees]; batch_size=batch_size)
    end

    remain_degs = [result[2] for result in filter_results if !result[1]]
    # now we compute all of the remaining cases which we cannot filter with the Jacobian of phi
    # this could also be improved to do some load-balancing
    if !isempty(remain_degs)
      if isnothing(wp) || length(remain_degs) < batch_size
        results = pmap(compute_kernel_component,
                       [mon_bases[deg] for deg in remain_degs], [phi for _ in remain_degs], distributed=false)
      else
        results = pmap(compute_kernel_component, wp,
                       [mon_bases[deg] for deg in remain_degs], [phi for _ in remain_degs], batch_size=batch_size)
      end
    else
      results = []
    end

    merge!(gens_dict, Dict(deg => results[i] for (i, deg) in enumerate(remain_degs) if !isempty(results[i])))
  end

  return gens_dict
end
