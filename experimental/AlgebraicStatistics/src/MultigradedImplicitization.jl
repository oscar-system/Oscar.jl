function pivots(M::MatElem)
  rref!(M)
  pivots = Vector{Int}[]

  for i in 1:nrows(M)
    for j in 1:ncols(M)
      if !iszero(M[i,j])
        push!(pivots, [i,j])
        break
      end
    end
  end

  return pivots
end

@doc raw"""
    homogeneity_space(I::MPolyIdeal)

Computes a basis for the homogeneity space of the ideal `I` which is the lineality space of the cones in the Groebner fan of `I`. 

## Examples

```jldoctest
julia> R, x = polynomial_ring(QQ, :x => (1:2, 1:2))
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x[1, 1] x[1, 2]; x[2, 1] x[2, 2]])

julia> I = ideal([x[1,1]*x[2,2] - x[1,2]*x[2,1]])
Ideal generated by
  x[1, 1]*x[2, 2] - x[2, 1]*x[1, 2]

julia> homogeneity_space(I)
[1   0   0   -1]
[0   1   0    1]
[0   0   1    1]
```
"""
function homogeneity_space(I::MPolyIdeal)
  n = ngens(base_ring(I))
  homogeneity_eqs = zero_matrix(ZZ, 1, n)

  for f in gens(I)
    exps = [exponent_vector(f,i) for i in 1:length(f)]
    eqs = matrix(ZZ, vcat([exps[1] - exps[i] for i in 2:length(exps)]))
    homogeneity_eqs = vcat(homogeneity_eqs, eqs)
  end
  
  return rref(transpose(nullspace(homogeneity_eqs)[2]))[2]
end

@doc raw"""
    max_grading(phi::MPolyAnyMap)

Computes the maximal rank grading on the kernel of $\phi: \mathbb{K}[x_1, \ldots, x_n] \to \mathbb{K}[t_1, \ldots, t_m]$ which can be induced by grading the codomain of `phi`. 
The first $m$ columns of the resulting matrix correspond to the degrees of the codomain while the last $n$ columns are the resulting degrees on the domain. 

## Examples

```jldoctest
julia> R, x = polynomial_ring(QQ, :x => (1:2, 1:2))
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x[1, 1] x[1, 2]; x[2, 1] x[2, 2]])

julia> S, s, t = polynomial_ring(QQ, :s => 1:2, :t => 1:2)
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[s[1], s[2]], QQMPolyRingElem[t[1], t[2]])

julia> phi = hom(R, S, [s[1]*t[1], s[1]*t[2], s[2]*t[1], s[2]*t[2]])
Ring homomorphism
  from multivariate polynomial ring in 4 variables over QQ
  to multivariate polynomial ring in 4 variables over QQ
defined by
  x[1, 1] -> s[1]*t[1]
  x[2, 1] -> s[1]*t[2]
  x[1, 2] -> s[2]*t[1]
  x[2, 2] -> s[2]*t[2]

julia> max_grading(phi)
[1   0   0   0   1   1   0   0]
[0   1   0   0   0   0   1   1]
[0   0   1   0   1   0   1   0]
[0   0   0   1   0   1   0   1]
```
"""
function max_grading(phi::MPolyAnyMap)
  codom = codomain(phi)
  dom = domain(phi)
  elim_ring, z = polynomial_ring(QQ, vcat(symbols(codom), symbols(dom)))
  lift_codom = hom(codom, elim_ring, gens(elim_ring)[1:ngens(codom)])
  lift_dom = hom(dom, elim_ring, z[ngens(codom) + 1:ngens(elim_ring)])

  return homogeneity_space(ideal([lift_dom(x) - lift_codom(phi(x)) for x in gens(dom)]))
end

@doc raw"""
    jacobian(phi::MPolyAnyMap)

Computes the Jacobian of a polynomial map $\phi: \mathbb{K}[x_1, \ldots, x_n] \to \mathbb{K}[t_1, \ldots, t_m]$ such that $(i, j)$ entry is $\frac{d \phi(x_j)}{d t_i}$.

## Examples

```jldoctest
julia> R, x = polynomial_ring(QQ, :x => (1:2, 1:2))
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x[1, 1] x[1, 2]; x[2, 1] x[2, 2]])

julia> S, s, t = polynomial_ring(QQ, :s => 1:2, :t => 1:2)
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[s[1], s[2]], QQMPolyRingElem[t[1], t[2]])

julia> phi = hom(R, S, [s[1]*t[1], s[1]*t[2], s[2]*t[1], s[2]*t[2]])
Ring homomorphism
  from multivariate polynomial ring in 4 variables over QQ
  to multivariate polynomial ring in 4 variables over QQ
defined by
  x[1, 1] -> s[1]*t[1]
  x[2, 1] -> s[1]*t[2]
  x[1, 2] -> s[2]*t[1]
  x[2, 2] -> s[2]*t[2]

julia> jacobian(phi)
[t[1]   t[2]      0      0]
[   0      0   t[1]   t[2]]
[s[1]      0   s[2]      0]
[   0   s[1]      0   s[2]]
```
"""
function jacobian(phi::MPolyAnyMap)
  return matrix(codomain(phi), [[derivative(phi(j), i) for j in gens(domain(phi))] for i in gens(codomain(phi))])
end

# compute the jacobian and evalauate it at the point pt
function jacobian_at_point(phi::MPolyAnyMap, pt::fpFieldElem)
  return matrix(codomain(phi), [[evaluate(derivative(phi(j), i), pt) for j in gens(domain(phi))] for i in gens(codomain(phi))])
end

# compute the jacobian at a random point with parameters sampled from a finite field
function jacobian_at_rand_point(phi::MPolyAnyMap; char::UInt=UInt(32003))
  K = fpField(char)
  
  # remake codomain over finite field
  R = codomain(phi)
  fq_R, fq_R_gens = polynomial_ring(K, ngens(R))

  # randomly sample parameter values in the finite field
  pt = rand(K, ngens(fq_R))

  return matrix(K, [[evaluate(derivative(fq_R(phi(j)), i), pt) for j in gens(domain(phi))] for i in fq_R_gens])
end

# find the indices of the variable support of all monomials in mon_basis
function component_support(mon_basis::Vector{<: MPolyDecRingElem})
  supp = var_index.(unique!(reduce(vcat, vars.(mon_basis))))
end

@doc raw"""
    compute_component(mon_basis::Vector{<:MPolyDecRingElem}, phi::MPolyAnyMap)

Computes a basis for the elements in the kernel of a polynomial map $\phi: \mathbb{K}[x_1, \ldots, x_n] \to \mathbb{K}[t_1, \ldots, t_m]$ which lie in the homogeneous component corresponding to `mon_basis`. 

## Examples

```jldoctest
julia> R, x = graded_polynomial_ring(QQ, :x => (1:2, 1:2); weights = [[1, 0, 1, 0], [1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 0, 1]])
(Graded multivariate polynomial ring in 4 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1, 1] x[1, 2]; x[2, 1] x[2, 2]])

julia> S, s, t = polynomial_ring(QQ, :s => 1:2, :t => 1:2)
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[s[1], s[2]], QQMPolyRingElem[t[1], t[2]])

julia> phi = hom(R, S, [s[1]*t[1], s[1]*t[2], s[2]*t[1], s[2]*t[2]])
Ring homomorphism
  from graded multivariate polynomial ring in 4 variables over QQ
  to multivariate polynomial ring in 4 variables over QQ
defined by
  x[1, 1] -> s[1]*t[1]
  x[2, 1] -> s[1]*t[2]
  x[1, 2] -> s[2]*t[1]
  x[2, 2] -> s[2]*t[2]

julia> B = monomial_basis(R, [1,1,1,1])
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x[2, 1]*x[1, 2]
 x[1, 1]*x[2, 2]

julia> compute_component(B, phi)
1-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x[1, 1]*x[2, 2] - x[2, 1]*x[1, 2]
```
"""
function compute_component(mon_basis::Vector{<:MPolyDecRingElem}, phi::MPolyAnyMap)
  image_polys = [phi(m) for m in mon_basis]
  mons = unique!(reduce(vcat, [collect(monomials(f)) for f in image_polys]))
  coeffs = matrix(QQ, [[coeff(f, mon) for f in image_polys] for mon in mons])
  (r, K) = nullspace(coeffs)
  return mon_basis * K
end

@doc raw"""
    filter_component(deg::FinGenAbGroupElem, mon_basis::Vector{<: MPolyDecRingElem}, jac::MatElem)

This function is used to skip homogeneous components which cannot contain an element of the kernel by checking if the variables in that component are independent
in the matroid defined by the jacboian of a polynomial map. If the submatrix of the jacobian corresponding to a subset of the variables in the codomain is full rank, then
there cannot be a relation in the kernel involving only those variables. 
```
"""
function filter_component(deg::FinGenAbGroupElem, mon_basis::Vector{<: MPolyDecRingElem}, jac::MatElem)
  # if the basis only has 1 element, then there are no generators by assumption
  length(mon_basis) < 2 && return [true, deg]

  # find the indices of all variables involved in this component
  supp = component_support(mon_basis)

  # check if the corresponding submatrix drops rank
  # if it does not, then this component cannot contain any generator of the kernel
  if rank(jac[:, supp]) == length(supp)
    return [true, deg]
  end

  return [false, deg]
end


@doc raw"""
    components_of_kernel(d::Int, phi::MPolyAnyMap; wp::Union{OscarWorkerPool, Nothing}=nothing)

Computes all minimal generators of the kernel of the polynomial map $\phi: \mathbb{K}[x_1, \ldots, x_n] \to \mathbb{K}[t_1, \ldots, t_m]$ such that $(i, j)$ 
with total degree at most $d$ using the main algorithm of [CH26](@cite). This implementation requires that $\phi$ be homogeneous in a multigrading which refines total
degree which ensures the algorithm is parallelizable. The output is a dictionary whose keys are the multidegrees and values consist of a minimal generating set for that multidegree. 

## Examples

```jldoctest
julia> R, x = polynomial_ring(QQ, :x => (1:2, 1:2))
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[x[1, 1] x[1, 2]; x[2, 1] x[2, 2]])

julia> S, s, t = polynomial_ring(QQ, :s => 1:2, :t => 1:2)
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[s[1], s[2]], QQMPolyRingElem[t[1], t[2]])

julia> phi = hom(R, S, [s[1]*t[1], s[1]*t[2], s[2]*t[1], s[2]*t[2]])
Ring homomorphism
  from multivariate polynomial ring in 4 variables over QQ
  to multivariate polynomial ring in 4 variables over QQ
defined by
  x[1, 1] -> s[1]*t[1]
  x[2, 1] -> s[1]*t[2]
  x[1, 2] -> s[2]*t[1]
  x[2, 2] -> s[2]*t[2]

julia> components_of_kernel(2, phi)
Dict{FinGenAbGroupElem, Vector{<:MPolyDecRingElem}} with 1 entry:
  [1 1 1 1] => MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1, 1]*x[2, 2] - x[2, 1]*x[1, 2]]
```
"""
function components_of_kernel(d::Int, phi::MPolyAnyMap;
                              wp::Union{OscarWorkerPool, Nothing}=nothing)
  # Compute a maximal grading on the domain
  A = Oscar.max_grading(phi)[:, ngens(codomain(phi)) + 1:end]
  
  # grade the domain
  graded_dom = grade(domain(phi), A)[1]
  
  # grade the domain by the standard grading as well and compute the jacobian at a random point over a finite field
  total_deg_dom = grade(domain(phi), [1 for i in 1:ngens(domain(phi))])[1]
  graded_phi = hom(graded_dom, codomain(phi), [phi(x) for x in gens(domain(phi))])
  jac = Oscar.jacobian_at_rand_point(graded_phi)

  # create a dictionary to store the generators by their degree
  gens_dict = Dict{FinGenAbGroupElem, Vector{<:MPolyDecRingElem}}()

  for i in 1:d
    all_mons = graded_dom.(monomial_basis(total_deg_dom, [i]))
    all_degs = degree.(all_mons)
    mon_bases = Dict{FinGenAbGroupElem, Vector{<:MPolyDecRingElem}}()

    # avoid redundant degree computation
    for (d, m) in zip(all_degs, all_mons)
      if haskey(mon_bases, d)
        push!(mon_bases[d], m)
      else
        mon_bases[d] = [m]
      end
    end

    # find the previous generators 
    if isempty(gens_dict)
      prev_gens = MPolyDecRingElem[]
    else
      prev_gens = reduce(vcat, values(gens_dict))
    end

    # first filter out all easy cases
    # this could be improved to do some load-balancing
    if isnothing(wp)
      filter_results = pmap(filter_component,
                            [deg for deg in keys(mon_bases)],
                            [mon_bases[deg] for deg in keys(mon_bases)],
                            [jac for _ in keys(mon_bases)]; distributed=false)
    else
      filter_results = pmap(filter_component, wp,
                            [deg for deg in keys(mon_bases)],
                            [mon_bases[deg] for deg in keys(mon_bases)],
                            [jac for _ in keys(mon_bases)])
    end

    remain_degs = [result[2] for result in filter_results if !result[1]]

    # now we compute all of the remaining cases which we cannot filter with the Jacobian of phi
    # this could also be improved to do some load-balancing
    if !isempty(remain_degs)
      if isnothing(wp)
        results = pmap(compute_component, map(deg -> mon_bases[deg], remain_degs),
                       [graded_phi for _ in remain_degs];
                       distributed=false)
      else
        results = pmap(compute_component, wp, map(deg -> mon_bases[deg], remain_degs),
                       [graded_phi for _ in remain_degs])
      end
    else
      results =[]
    end

    merge!(gens_dict, Dict(zip(remain_degs, results)))
  end

  return gens_dict
end

