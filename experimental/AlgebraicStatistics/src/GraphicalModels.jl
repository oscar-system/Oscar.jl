export GraphicalModel, graph, ring, param_ring, param_gens, vanishing_ideal

import Oscar.graph
import Oscar.vertices
import Oscar.gens
import Base.show

###################################################################################
#
#       Additional functions for graphs
#
###################################################################################

function vertices(G::Graph)
  E = [[src(e), dst(e)] for e in edges(G)]
  sort(unique(reduce(vcat, E)))
end

###################################################################################
#
#       Additional functions for matrices
#
###################################################################################

function adjugate(A::Generic.MatSpaceElem)
  if nrows(A) != ncols(A)
    error("adjugate can only be computed for a square matrix")
  end
  adj, _ = pseudo_inv(A)
  # pseudo_inv guarantees only that A*adj == d*Id but that allows adj and d
  # to both differ from the adjugate and the determinant, respectively, by
  # a sign. We compute one cofactor by hand to make sure we get sign right.
  n = nrows(A)
  c = det(A[1:n-1, 1:n-1])
  if c == adj[n,n]
    return adj
  elseif c == -adj[n,n]
    return -adj
  else # unlikely, but fall back to computing many determinants
    return matrix(base_ring(A), [[(-1)^(i+j)*det(A[setdiff(1:n, j), setdiff(1:n, i)]) for j in 1:n] for i in 1:n])
  end
end

###################################################################################
#
#       Generic Graphical Models
#
###################################################################################

struct GraphicalModel{G, T}
  graph::G
  ring::T
  param_ring::Ring
  param_gens
end

# todo
function graph(M::GraphicalModel)
  M.graph
end

# todo
function ring(M::GraphicalModel)
  M.ring
end

function param_ring(M::GraphicalModel)
  M.param_ring
end

function param_gens(M::GraphicalModel)
  M.param_gens
end

include("GaussianGraphicalModels.jl")

@doc raw"""
    vanishing_ideal(M::GraphicalModel)

Computes the vanishing ideal for a graphical model `M`.
This is done by computing the kernel of the parametrization.

## Examples

``` jldoctest
julia> M = graphical_model(graph_from_edges(Directed, [[1,2], [2,3]]), gaussian_ring(3))
Gaussian graphical model on a directed graph with edges:
(1, 2), (2, 3)

julia> vanishing_ideal(M)
Ideal generated by
  -s[1, 2]*s[2, 3] + s[1, 3]*s[2, 2]
```
"""
function vanishing_ideal(M::GraphicalModel)
  kernel(parametrization(M))
end
