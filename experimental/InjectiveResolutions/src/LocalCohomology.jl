# data structures
struct SectorLC
  A::Vector{Vector{Int}}
  sector::Polyhedron
  index_vector::Vector{Int}
  H::Generic.QuotientModule
end
mutable struct SectorPartitionLC
  M::SubquoModule{<:MonoidAlgebraElem}
  i::Int
  I::MonoidAlgebraIdeal
  sectors::Vector{SectorLC}
  maps::Vector{Tuple{SectorLC,SectorLC,Generic.ModuleHomomorphism}}

  function SectorPartitionLC(M::SubquoModule{<:MonoidAlgebraElem}, i::Int, I::MonoidAlgebraIdeal)
    return new(
      M,
      i,
      I,
      Vector{SectorLC}(),
      Vector{Tuple{SectorLC,SectorLC,Generic.ModuleHomomorphism}}(),
    )
  end
end

@doc raw"""
    is_zero(s::SectorLC)

Test if local cohomology is zero on a sector.
"""
function is_zero(s::SectorLC)
  return dim(s.H) == 0
end

@doc raw"""
    is_zero(S::SectorPartitionLC)

Given a sector partition of a local cohomology module, check if the local cohomology module is zero.
"""
function is_zero(S::SectorPartitionLC)
  return all([dim(s.H) == 0 for s in S.sectors])
end

function print_A_vector(io::IO, A::Vector{Vector{Int}})
  print(io, "[")
  for (i, subvec) in enumerate(A)
    print(io, isempty(subvec) ? "[]" : string(subvec))
    if i != length(A)
      print(io, ", ")
    end
  end
  print(io, "]")
end

function Base.show(io::IO, ::MIME"text/plain", S::SectorLC)
  println(
    io, "sector S_A of ZZ^", ambient_dim(S.sector), " of dimension ", dim(S.sector), " with"
  )
  print(io, "   A = ")
  print_A_vector(io, S.A)
  print(io, " and local cohomology of dimension ",
    dim(S.H),
  )
end

function Base.show(io::IO, S::SectorLC)
  print(io, "sector of ZZ^", ambient_dim(S.sector), " with local cohomology of dimension ", dim(S.H))
end

function Base.show(io::IO, ::MIME"text/plain", SP::SectorPartitionLC)
  println(
    io,
    "sector partition of ",
    SP.i,
    "-th local cohomology module supported on ideal (",
    join(gens(SP.I), ", "),
    ") of ",
  )
  println(io, " ", SP.M)
end

@doc raw"""
    local_cohomology(I_M::MonoidAlgebraIdeal,I::MonoidAlgebraIdeal,i::Integer)

Compute a sector partition of the local cohomology module $H^i_I(k[Q]/I_M)$, where $I_M$ and $I$ are ideals in $k[Q]$.

!!! note
    The monoid algebra $k[Q]$ must be normal. 

# Examples
```jldoctest
julia> kQ = monoid_algebra([[0,1],[1,1],[2,1]],QQ)
monoid algebra over rational field with cone of dimension 2


julia> x,y,z = gens(kQ)
3-element Vector{MonoidAlgebraElem{QQFieldElem, MonoidAlgebra{QQFieldElem, MPolyQuoRing{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}}}:
 x_1
 x_2
 x_3

julia> I_M = ideal(kQ,[x^2*z,x^4*y]) # M = k[Q]/I_M
ideal over monoid algebra over rational field with cone of dimension 2 generated by x_1^2*x_3, x_1^4*x_2


julia> m = ideal(kQ,[x,y,z]) #maximal ideal 
ideal over monoid algebra over rational field with cone of dimension 2 generated by x_1, x_2, x_3


julia> local_cohomology(I_M,m,1)
sector partition of 1-th local cohomology module supported on ideal (x_1, x_2, x_3) of 
 Graded subquotient of graded submodule of kQ^1 with 1 generator
  1: 1*e[1]
by graded submodule of kQ^1 with 2 generators
  1: x_1^2*x_3*e[1]
  2: x_1^4*x_2*e[1]
```
"""
function local_cohomology(I_M::MonoidAlgebraIdeal, I::MonoidAlgebraIdeal, i::Integer)
  return local_cohomology(quotient_ring_as_module(I_M),I,i)
end

@doc raw"""
    local_cohomology(M::SubquoModule{T}, I::MonoidAlgebraIdeal, i::Integer) where {T<:MonoidAlgebraElem}

Compute a sector partition of the local cohomology module $H^i_I(M)$. 

!!! note
    The monoid algebra $k[Q]$ must be normal. 
"""
function local_cohomology(M::SubquoModule{T}, I::MonoidAlgebraIdeal, i::Integer) where {T<:MonoidAlgebraElem}
  kQ = base_ring(M)
  k = coefficient_ring(kQ)

  @req kQ == I.monoid_algebra "module and ideal must be over same monoid algebra"
  @req is_normal(kQ) "monoid algebra must be normal"

  #compute injective resolution
  inj_res = injective_resolution(M, i+1)

  #initialize sector partition
  LC = SectorPartitionLC(M, i, I)

  if i > inj_res.upto #local cohomology zero
    return LC
  end

  #get the injective modules J^{i-1} -> J^i -> J^{i+1}
  Ji_ = inj_res.inj_mods[i]
  Ji = inj_res.inj_mods[i + 1]

  if inj_res.upto > i # J^{i+1} â‰  0
    Ji_1 = inj_res.inj_mods[i + 2]
  else
    Ji_1 = InjMod(kQ, Vector{IndecInj}())
  end

  #get maps _phi: J^{i-1} -> J^i and _psi: J^i -> J^{i+1}
  _phi = get_scalar_matrix(kQ, inj_res.cochain_maps[i])

  if inj_res.upto > i
    _psi = get_scalar_matrix(kQ, inj_res.cochain_maps[i + 1])
  else # map is zero 
    _psi = matrix(k, zeros(k, length(Ji.indec_injectives), 1))
  end

  #apply the functor Gamma_I(-) to J^{i-1},J^i and J^{i+1} -> J is direct sum of Gamma_I(J^{i-1}), Gamma_I(J^{i}) and Gamma_I(J^{i+1})
  J, phi, psi, (j, k) = apply_gamma!(Ji_, Ji, Ji_1, _phi, _psi, I)

  #compute sector partition of J -> sector partition of H^i_I(M) (see Theorem 5.2. in HM05)
  LC.sectors = sector_partition(kQ, phi, psi, j, k, J...)

  #compute the needed maps in 3. of Definition 1.2 in HM05 (uses Algorithm 6.4)
  LC.maps = maps_needed(kQ, LC.sectors)
  return LC
end

@doc raw"""
    zeroth_local_cohomology(M::SubquoModule{T}, I::MonoidAlgebraIdeal) where {T<:MonoidAlgebraElem}

Computes the local cohomology module supported on I in cohomological degree zero.

# Examples
```jldoctest
julia> kQ = monoid_algebra([[0,1],[1,1],[2,1]],QQ)
monoid algebra over rational field with cone of dimension 2


julia> x,y,z = gens(kQ)
3-element Vector{MonoidAlgebraElem{QQFieldElem, MonoidAlgebra{QQFieldElem, MPolyQuoRing{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}}}:
 x_1
 x_2
 x_3

julia> I_M = ideal(kQ,[x^2*z,x^4*y]) # M = k[Q]/I_M
ideal over monoid algebra over rational field with cone of dimension 2 generated by x_1^2*x_3, x_1^4*x_2


julia> m = ideal(kQ,[x,y,z]) #maximal ideal 
ideal over monoid algebra over rational field with cone of dimension 2 generated by x_1, x_2, x_3


julia> H0 = zeroth_local_cohomology(quotient_ring_as_module(I_M),m)
Graded subquotient of graded submodule of kQ^1 with 1 generator
  1: x_1^2*x_2*e[1]
by graded submodule of kQ^1 with 2 generators
  1: x_1^2*x_3*e[1]
  2: x_1^4*x_2*e[1]
```
"""
function zeroth_local_cohomology(M::SubquoModule{T}, I::MonoidAlgebraIdeal) where {T<:MonoidAlgebraElem}
  #apply gamma_I to M -> corresponds to the saturation (0_M : I^\infty)
  zeroM = sub(M, [zero(M)])[1]
  return saturation(zeroM, I)
end

@doc raw"""
    local_cohomology_all(I_M::MonoidAlgebraIdeal, I::MonoidAlgebraIdeal, i::Integer)

For $1 \leq j \leq i$ compute sector partitions of the local cohomology modules $H^i_I(k[Q]/I_M)$, where $k[Q]$ is a monoid algebra. This function only computes one injective resolution of $k[Q]/I_M$ up to cohomological degree $i+1$. 

!!! note
    The monoid algebra $k[Q]$ must be normal.  
"""
function local_cohomology_all(I_M::MonoidAlgebraIdeal, I::MonoidAlgebraIdeal, i::Integer)
  @req I_M.algebra == I.algebra "ideals must be over same monoid algebra"
  return local_cohomology_all(quotient_ring_as_module(M),I,i)
end

@doc raw"""
    local_cohomology_all(M::SubquoModule{T}, I::MonoidAlgebraIdeal, i::Integer) where {T<:MonoidAlgebraElem}

For $1 \geq j \leq i $ compute sector partitions of the local cohomology modules $H^i_I(M))$, where $k[Q]$ is a monoid algebra. This function only computes one injective resolution of $M$ up to cohomological degree $i+1$. 

!!! note
    The monoid algebra $k[Q]$ must be normal.  
"""
function local_cohomology_all(M::SubquoModule{T}, I::MonoidAlgebraIdeal, i::Integer) where {T<:MonoidAlgebraElem}
  kQ = base_ring(M)
  @req kQ == I.monoid_algebra "module and ideal must be over same monoid algebra"
  @req is_normal(kQ) "monoid algebra must be normal"

  #compute injective resolution
  inj_res = injective_resolution(M, i+1)

  #compute a sector partition of H^j_I(M) for 1 \leq j \leq i
  H = Vector{SectorPartitionLC}()
  for j in 1:i
    _phi = get_scalar_matrix(kQ, inj_res.cochain_maps[j])
    _psi = get_scalar_matrix(kQ, inj_res.cochain_maps[j + 1])
    Jj = inj_res.inj_mods[j]
    Jj_1 = inj_res.inj_mods[j + 1]
    Jj_2 = inj_res.inj_mods[j + 2]

    J, phi, psi, (j, k) = apply_gamma!(Jj, Jj_1, Jj_2, _phi, _psi, I)
    Hj = sector_partition(kQ, phi, psi, j, k, J...)
    push!(
      H,
      SectorPartitionLC(M, j, I.ideal, Hj, maps_needed(kQ, Hj)),
    )
  end
  return H
end

# given a matrix with entries in a MPolyDecRing or a MPolyQuoRing, return the matrix with the corresponding scalar coefficients
@doc raw"""
  get_scalar_matrix(A::MonoidAlgebra, M)

Given a monomial matrix, return the corresponding coefficient matrix. 
"""
function get_scalar_matrix(A::MonoidAlgebra, M)
  k = coefficient_ring(A)
  return map(x -> evaluate(x,ones(elem_type(k),ngens(A))), M)
end

# given a monoid algebra k[Q] compute linear functions \tau_1,...,\tau_n that define Q. 
# there is one defining linear functional for every facet of Q and Q is the intersection of the halfspaces {\tau_i \leq 0} 

@doc raw"""
  compute_taus(kQ::MonoidAlgebra, J::IndecInj...)

This function computes a vector $\tau^j \in (\mathbb{Z}\cup \infty)^n$ for every indecomposable injective $J^j$.
See [HM05](@cite) (Section 6).
"""
function compute_taus(kQ::MonoidAlgebra, J::IndecInj...)
  # get linear functionals tau_i for every hyperplane bounding Q, i.e. for every facet
  A, _ = halfspace_matrix_pair(facets(kQ.cone))
  H = []
  for i in 1:length(kQ.hyperplanes)
    push!(H, [kQ.hyperplanes[i].hyperplane, A[i, :]])
  end

  # for every indecomposable injectives J_j = k{a_j + F_j - Q} compute the vector \tau^j used in Section 6 of HM05  
  _tau = []
  for J_i in J
    in
    tau_i = []
    for h in H
      if issubset(J_i.face.poly, h[1])
        a_ih = dot(h[2], J_i.vector)
        push!(tau_i, a_ih)
      else
        push!(tau_i, -Inf)
      end
    end
    push!(_tau, tau_i)
  end

  #transform _tau consisting of length(kQ.hyperplanes)-lists into a list of length(J) (divide by coordinate index)
  tau = []
  for i in 1:length(kQ.hyperplanes)
    push!(tau, [t[i] for t in _tau])
  end
  return tau
end

@doc raw"""
  get_halfspace_eq(kQ::MonoidAlgebra)

Returns a finite set of positive halfspaces such that $Q$ is the intersection of them. 

!!! note 
    The corresponding semigroup $Q$ must be saturated. 
"""
function get_halfspace_eq(kQ::MonoidAlgebra)
  A, _ = halfspace_matrix_pair(facets(kQ.cone))
  H = []
  for i in 1:length(kQ.hyperplanes)
    push!(H, [kQ.hyperplanes[i].hyperplane, A[i, :]])
  end
  return H
end

@doc raw"""
  sector_partition(kQ::MonoidAlgebra,phi::Union{Vector{Any},MatElem{T}},psi::Union{Vector{Any},MatElem{T}},j::Integer,k::Integer,J::IndecInj...,) where {T<:FieldElem}

Given a cochain complex of injective modules J^0 -> J^1 -> J^2, where phi: J^0 -> J^1 and psi: J^1 -> J^2, let J = J^0 + J^1 + J^2
and j = |J^0|, k = |J^0| + |J^1|. This function computes a sector partition of the local cohomology module ker(psi)/im(phi). 
"""
function sector_partition(
  kQ::MonoidAlgebra,
  phi::MatElem{T},
  psi::MatElem{T},
  j::Integer,
  k::Integer,
  J::IndecInj...,
) where {T<:FieldElem}
 
  # check that kQ is compatible with the indecomposable injectives
  # ...
  field = coefficient_ring(kQ)
  field_elem = elem_type(field)
  r = length(J)

  # compute tau's
  tau = compute_taus(kQ, J...)

  #sort tau's
  sorted_taus = []
  for t in tau
    pi_t = sortperm(t)
    t_sorted = push!([], -Inf)
    append!(t_sorted, t[pi_t])
    push!(t_sorted, Inf)
    push!(sorted_taus, t_sorted)
  end

  # get linear functionals (one for each facet) 
  H = get_halfspace_eq(kQ)

  # compute all stripes
  stripes = []
  for j in 1:length(tau) # loop over all linear functionals tau_i
    stripes_j = []
    for i in 1:(r + 1) # loop over all indices (indecomposable injectives)
      _A = Vector{Vector{field_elem}}()
      b = Vector{field_elem}()

      if sorted_taus[j][i + 1] == -Inf*one(field)
        push!(stripes_j, NaN) # corresponds to empty stripe
        continue
      elseif sorted_taus[j][i + 1] != Inf*one(field)
        push!(b, sorted_taus[j][i + 1]-1)
        push!(_A, H[j][2])
      end
      if sorted_taus[j][i] != -Inf*one(field)
        push!(b, -sorted_taus[j][i])
        push!(_A, -H[j][2])
      end

      if length(b) < 1
        push!(stripes_j, NaN) # corresponds to empty stripe
        continue
      end
      A = reduce(vcat, transpose(_A))
      push!(stripes_j, polyhedron(A, b))
    end
    push!(stripes, stripes_j)
  end

  #compute all sectors  \Delta(l1,...,ln) of the sector partition
  #this are intersection of the stripes
  S_A = Vector{SectorLC}()
  for tuple in Iterators.product(ntuple(_ -> 1:(r + 1), length(tau))...) #for all tuples (l1,...,ln) where li \in {1,...,r}) and n is the number of facets
    _delta = Vector{Polyhedron}()
    valid = true # is one strip empty? => the intersection is empty
    A_tuple = []
    for i in eachindex(tau)
      if all(x -> x == -Inf*one(field), tau[i])
        continue
      end
      if stripes[i][tuple[i]] isa Polyhedron
        push!(_delta, stripes[i][tuple[i]])
      else #stripe is empty
        valid = false
        break
      end

      # compute the set of all indices j such that the current stripe lies in J^j 
      A_i = Vector{Int}()
      if sorted_taus[i][tuple[i]] == -Inf*one(field)
        A_i = findall(x -> x == -Inf*one(field), tau[i])
      else
        A_i = findall(x -> x == -Inf*one(field) || (x <= sorted_taus[i][tuple[i]]), tau[i])
      end
      push!(A_tuple, A_i)
    end
    if length(_delta) > 0 && valid
      # compute the sector \Delta(l1,...,ln)
      poly_tuple = intersect(_delta...)
      if dim(poly_tuple) < 0
        continue
      elseif dim(poly_tuple) == 0 && length(lattice_points(poly_tuple)) == 0
        continue
      end

      # get A \subseteeq {1,...,r} such that |Delta(l1,...,ln) \in J^j if and only if j \in A
      A = intersect(A_tuple...)

      # compute local cohomology of sector
      H_A, A_ = _local_cohomology_sector(field, A, j, k, phi, psi)

      #avoid duplicates 
      s_A = [s for s in S_A if s.A == A_ && s.sector == poly_tuple]
      if is_empty(s_A)
        push!(S_A, SectorLC(A_, poly_tuple, collect(tuple), H_A)) # changed
      end
    end
  end
  return S_A
end

@doc raw"""
  _local_cohomology_sector(field::Field,A::Vector{Int},j::Integer,k::Integer,phi::Union{Vector{Any},MatElem{T}},psi::Union{Vector{Any},MatElem{T}}) where {T<:FieldElem}

This function follows the construction in the proof of [HM05](@cite) (Theorem 5.2).
"""
function _local_cohomology_sector(
  field::Field,
  A::Vector{Int},
  j::Integer,
  k::Integer,
  phi::MatElem{T},
  psi::MatElem{T}
) where {T<:FieldElem}
  @assert elem_type(field) == T
  # divide A into triple
  A_0 = [a for a in A if a <= j]
  A_1 = [a for a in A if j < a <= k]
  A_2 = [a for a in A if k < a]
  _A = [A_0, A_1, A_2]

  # define vector spaces J_{S_A0}, J_{S_A1} and J_{S_A2}
  F_0 = free_module(field, length(A_0))
  F_1 = free_module(field, length(A_1))
  F_2 = free_module(field, length(A_2))

  #compute the maps by deleting rows and columns in phi and psi
  #phi
  phi_del = matrix(field, zeros(field, length(A_0), length(A_1)))

  if !is_empty(phi) # `is_empty` is true for the the m x 0-matrix
    rows = []
    for i in A_0 #delete i-th row of phi for i \notin A_0
      push!(rows, phi[i, :])
    end
    _phi_del = transpose(hcat(rows...))

    if all(>(0), size(_phi_del)) #not of size 0xn or nx0
      columns = []
      for i in A_1 #delete i-th column of phi for i \notin A_1
        push!(columns, _phi_del[:, i - j])
      end
      if length(columns) > 0
        phi_del = matrix(field, hcat(columns...))
      end
    end
  end

  #psi
  psi_del = matrix(field, zeros(field, length(A_1), length(A_2)))
  if !is_empty(psi)
    rows = []
    for i in A_1 #delete i-th row of psi for i \notin A_1 
      push!(rows, psi[i - j, :])
    end
    _psi_del = transpose(hcat(rows...))

    if all(>(0), size(_psi_del)) #not of size 0xn or nx0
      columns = []
      for i in A_2 #delete i-th column of psi for i \notin A_2 
        push!(columns, _psi_del[:, i - k])
      end
      if length(columns) > 0
        psi_del = matrix(field, hcat(columns...))
      end
    end
  end

  #define maps phi_{0,1} and psi_{1,2}
  f0 = hom(F_0, F_1, phi_del)
  f1 = hom(F_1, F_2, psi_del)
  return quo(kernel(f1)[1], image(f0)[1])[1], _A
end

@doc raw"""
  apply_gamma!(J0::InjMod,J1::InjMod,J2::InjMod,phi::MatElem{T},psi::MatElem{T},I::MonoidAlgebraIdeal) where {T<:FieldElem}

Apply the functor $\Gamma_I(-)$ to a cochain complex of injective modules $J_0 \xrightarrow{phi} J_1 \xrightarrow{\psi} J_2$. It maps a $\mathbb{Z}^d$-graded $k[Q]$-momdule $M$
to the submodule $\Gamma_I(M) = \{m \in M \mid m \cdot I^n = 0 \text{ for some }n>0\}$. Applying the functor corresponds to deleting all indecomposable injectives
$k\{a_i + F_i - Q\}$ with $I \not\subseteq p_{F_i}$. The monomial matrices of the maps $\phi$ and $\psi$ are updated by deleting the corresponding rows and columns.  
"""
function apply_gamma!(
  J0::InjMod,
  J1::InjMod,
  J2::InjMod,
  phi::MatElem{T},
  psi::MatElem{T},
  I::MonoidAlgebraIdeal,
) where {T<:FieldElem}
  @assert J0.monoid_algebra == J1.monoid_algebra == J2.monoid_algebra == I.monoid_algebra

  k = coefficient_ring(I.monoid_algebra)
  J_0 = J0.indec_injectives
  J_1 = J1.indec_injectives
  J_2 = J2.indec_injectives

  _J_0 = []
  rows_phi = []
  for i in eachindex(J_0)
    if issubset(underlying_ideal(I), J_0[i].face.prime)
      # if issubset(I,J_0[i].face.prime) 
      push!(_J_0, J_0[i])
      push!(rows_phi, phi[i, :])
    end
  end
  _phi = transpose(hcat(rows_phi...))

  columns_phi = []
  rows_psi = []
  _J_1 = []
  for i in eachindex(J_1)
    if issubset(underlying_ideal(I), J_1[i].face.prime)
      push!(_J_1, J_1[i])
      if rows_phi != []
        push!(columns_phi, _phi[:, i])
      end
      push!(rows_psi, psi[i, :])
    end
  end
  if is_empty(columns_phi)
    phi = zero_matrix(k, length(rows_phi), 0)
  else
    phi = matrix(k, hcat(columns_phi...))
  end
  _psi = transpose(hcat(rows_psi...))

  columns_psi = []
  _J_2 = []
  for i in eachindex(J_2)
    if issubset(underlying_ideal(I), J_2[i].face.prime)
      push!(_J_2, J_2[i])
      if rows_psi != []
        push!(columns_psi, _psi[:, i])
      end
    end
  end
  if is_empty(columns_psi)
    psi = zero_matrix(k, length(rows_psi), 0)
  else
    psi = matrix(k, hcat(columns_psi...))
  end

  return [_J_0..., _J_1..., _J_2...], phi::MatElem, psi::MatElem, (length(_J_0), length(_J_0) + length(_J_1))
end

@doc raw"""
  maps_needed(kQ::MonoidAlgebra, S_A::Vector{SectorLC})

This follows Algorithm 6.4. in [HM05](@cite) and computes all needed maps (as described in the proof of [HM05](@cite) (Proposition 5.1)).
"""
function maps_needed(kQ::MonoidAlgebra, S_A::Vector{SectorLC})
  k = coefficient_ring(kQ)
  maps = []
  for s1 in S_A, s2 in S_A # loop over all pairs
    if s1 == s2
      continue
    end
    if issubset(s2.A, s1.A) && s1.index_vector >= s2.index_vector # check if B \subseteq A and (l_1, ..., l_n) <= (l_1', ..., l_n')
      K = s2.sector + (-1)*s1.sector # minkowski sum (|Delta_B - \Delta_A)
      if dim(intersect(K, kQ.cone)) > -1 # check if Q \cap (|Delta_B - \Delta_A) \neq \emptyset
        # compute the map x^{B - A}: H_A -> H_B
        A = vcat(s1.A...)
        B = vcat(s2.A...)
        H_A = free_module(k, length(A)) # changed
        H_B = free_module(k, length(B)) # changed
        T = elem_type(H_A)
        V = Vector{T}()
        for i in eachindex(A)
          if A[i] in B
            j = findfirst(x -> x == A[i], B)
            push!(V, H_B[j])
          else
            push!(V, 0*zero(H_B))
          end
        end

        # define map H_A -> H_B
        f_AB = hom(H_A, H_B, V)

        if is_zero(f_AB)
          continue
        else
          push!(maps, (s1, s2, f_AB))
        end
      end
    else
      continue
    end
  end
  return maps
end
