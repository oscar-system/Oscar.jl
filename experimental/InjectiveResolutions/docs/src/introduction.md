```@meta
CurrentModule = Oscar
CollapsedDocStrings = true
DocTestSetup = Oscar.doctestsetup()
```

# Introduction

Injective resolutions are a fundmental homological tool in commutative algebra to understand modules
and in algebraic geometry to study sheaves.  Local cohomology allows one to
study the local geometric features of sheaves.  Many invariants such as
Castelnuovo-Mumford regularity can be formulated in terms of vanishing of local
cohomology in specific degrees.

This project implements the algorithms in [HM05](@cite) to compute 
[injective resolutions](./injective_resolutions.md) and 
[local cohomology](./local_cohomology.md) over 
[monoid algebras](./monoid_algebras.md) (also called semigroup
rings in the literature).  A key feature of this setting is that monoid algebras 
also include many non-regular rings.  A technical limitation is that for several
algorithms only saturated semigroups (i.e. modules over *normal* monoid
algebras) can be considered.

Injective modules over polynomial rings or monoid algebras are generally not
finitely generated and hence cannot be algorithmically treated with off-the-shelf
tools implemented in OSCAR.  However, there exist polyhedral data structures for
both injective modules and local cohomlogy that allow to represent them using
lattice points and polyhedra.  Because resolutions typically are also infinite,
we can finitely represent it them only up to a given cohomological degree.
This package provides all the necessary data structures and algorithms.

## Example

We consider a monoid algebra $k[Q]$, whose monoid $Q$ consists of all the lattice
points in a cone over a square.  This is also the coordinate ring of the 
Segre embedding $\mathbb{P}^1\times \mathbb{P}^1 \to \mathbb{P}^3$.

```jldoctest introExample
julia> kQ = monoid_algebra([[1, 0, 0], [1, 1, 0], [1, 1, 1], [1, 0, 1]], QQ)
monoid algebra over rational field with cone of dimension 3


julia> a, b, c, d = gens(kQ)
4-element Vector{MonoidAlgebraElem{QQFieldElem, MonoidAlgebra{QQFieldElem, MPolyQuoRing{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}}}:
 x_1
 x_2
 x_3
 x_4
```

We will compute an injective resolution and local cohomology 
of $M = k[Q]$ as a $k[Q]$-module.  For this we set up $M$
as the quotient of $k[Q]$ by the zero ideal:

```jldoctest introExample
julia> I_M = ideal(kQ, [])
ideal over monoid algebra over rational field with cone of dimension 3 generated by 


julia> M = quotient_ring_as_module(I_M)
Graded submodule of kQ^1 with 1 generator
  1: 1*e[1]
represented as subquotient with no relations
```

Let us take a look at the beginning of an injective resolution until cohomological
degree 3.
```jldoctest introExample
julia> inj_res = injective_resolution(M, 3)
injective resolution 
  J^0 -> J^1 -> J^2 -> J^3
where 
 J^0 = direct sum of
    k{[0, 0, 0] + F - Q}, where p_F = Ideal ()
 J^1 = direct sum of
    k{[0, 0, -1] + F - Q}, where p_F = Ideal with 11 generators
    k{[-1, -1, -1] + F - Q}, where p_F = Ideal with 11 generators
    k{[-1, -1, 0] + F - Q}, where p_F = Ideal with 11 generators
    k{[-1, 0, 1] + F - Q}, where p_F = Ideal with 11 generators
 J^2 = direct sum of
    k{[-1, -1, -1] + F - Q}, where p_F = Ideal with 13 generators
    k{[-3, -2, -1] + F - Q}, where p_F = Ideal with 13 generators
    k{[-3, -2, -2] + F - Q}, where p_F = Ideal with 13 generators
    k{[-3, -1, -2] + F - Q}, where p_F = Ideal with 13 generators
 J^3 = direct sum of
    k{[-2, -1, -1] + F - Q}, where p_F = Ideal with 14 generators
of Graded submodule of kQ^1 with 1 generator
  1: 1*e[1]
represented as subquotient with no relations
over monoid algebra over rational field with cone of dimension 3
```

Now we compute local cohomology supported on a face of the cone or respectively,
the ideal 
```jldoctest introExample
julia> I = ideal(kQ, [a, b])
ideal over monoid algebra over rational field with cone of dimension 3 generated by x_1, x_2
```

The zeroth local cohomology is just the well known module $\Gamma_I (M)$ module.
This can be represented with the standard data structures and hence we compute:

```jldoctest introExample
julia> H0 = zeroth_local_cohomology(M, I)
Graded submodule of kQ^1 with 0 generators
represented as subquotient with no relations

julia> is_zero(H0)
true
```
There is a dedicated implementation of `is_zero` for local cohomology modules
and their data structures.  The zeroth local cohomology vanishes.

Now let's move to cohomological degree one.
```jldoctest introExample
julia> H1 = local_cohomology(M, I, 1)
sector partition of 1-th local cohomology module supported on ideal (x_1, x_2) of 
 Graded submodule of kQ^1 with 1 generator
  1: 1*e[1]
represented as subquotient with no relations


julia> H1_sectors = [h for h in H1.sectors if dim(h.H)>0] #sectors with non-zero local cohomomology
1-element Vector{Oscar.InjectiveResolutions.SectorLC}:
 sector of ZZ^3 with local cohomology of dimension 1

julia> is_zero(H1)
false

julia> length(H1_sectors)
1
```
This local cohomology is non-zero.  There is one sector supporting local
cohomology.

The second local cohomology is also non-zero.
```jldoctest introExample
julia> H2 = local_cohomology(M, I, 2)
sector partition of 2-th local cohomology module supported on ideal (x_1, x_2) of 
 Graded submodule of kQ^1 with 1 generator
  1: 1*e[1]
represented as subquotient with no relations


julia> H2_sectors = [h for h in H2.sectors if dim(h.H)>0] #sectors with non-zero local cohomology
1-element Vector{Oscar.InjectiveResolutions.SectorLC}:
 sector of ZZ^3 with local cohomology of dimension 1

julia> is_zero(H2)
false

julia> length(H2_sectors)
1
```

And the third vanishes.
```jldoctest introExample
julia> H3 = local_cohomology(M, I, 3)
sector partition of 3-th local cohomology module supported on ideal (x_1, x_2) of 
 Graded submodule of kQ^1 with 1 generator
  1: 1*e[1]
represented as subquotient with no relations


julia> is_zero(H3)
true
```

## Contact

Any questions or comments about injective resolutions and local cohomology in
OSCAR can be sent to:

- [Anna Hofer](https://annahofer00.github.io)
- [Thomas Kahle](https://www.thomas-kahle.de)

## Acknowledgements

We appreciate extensive support on integrating this code into OSCAR provided by
[Matthias Zach](https://hechtiderlachs.github.io/).
