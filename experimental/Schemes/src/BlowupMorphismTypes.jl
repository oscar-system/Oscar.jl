@doc raw"""
    AbsDesingMor{
                                  DomainType<:AbsCoveredScheme,
                                  CodomainType<:AbsCoveredScheme,
                                  BlowupMorphismType
       } <: AbsCoveredSchemeMorphism{
                                 DomainType,
                                 CodomainType,
                                 Nothing,
                                 BlowupMorphismType
                                }
Abstract type for desingularizations ``f : X -> Y `` of schemes where

  * ``Y`` is the scheme of which the singularities are to be resolved
  * ``f`` is a birational proper map 
          may for instance be BlowUpSequence or Lipman-style combination of blow-ups and normalization
  * ``Y`` is a regular scheme
"""
abstract type AbsDesingMor{
                           DomainType<:AbsCoveredScheme,
                           CodomainType<:AbsCoveredScheme,
                           BlowupMorphismType
                          } <: AbsCoveredSchemeMorphism{
                                                        DomainType,
                                                        CodomainType,
                                                        Nothing,
                                                        BlowupMorphismType
                                                       }
end

########################################################################
# An abstract type for blowup morphisms.
#
# This should also comprise sequences of simple blowups leading
# to a partial or full resolution of singularities. The interface
# is specified below.
########################################################################
abstract type AbsBlowupMorphism{DomainType<:AbsCoveredScheme,
                                  CodomainType<:AbsCoveredScheme,
                                  BlowupMorphismType
                                 } <: AbsDesingMor{DomainType, CodomainType, BlowupMorphismType}
end

abstract type AbsSimpleBlowupMorphism{DomainType<:AbsCoveredScheme,
                                     CodomainType<:AbsCoveredScheme,
                                     BlowupMorphismType
    } <: AbsBlowupMorphism{
                             DomainType,
                             CodomainType,
                             BlowupMorphismType
                            }
end


########################################################################
# BlowupMorphism
#
# A datastructure to maintain all information necessary to effectively
# handle blowups. This is work in progress and will one day serve as
# a building block for sequences of blowups
########################################################################

@doc raw"""
    BlowupMorphism

A datastructure to encode blowups of covered schemes in some sheaves of ideals.

It is described as a morphism from the new scheme to the blown-up scheme, with
information about its center (i.e. the ideal sheaves blown-up in the bottom
scheme) and its exceptional locus (i.e. the preimage of the center under the
blowup).

# Examples
```jldoctest
julia> R, (x,y,z) = QQ[:x, :y, :z];

julia> A3 = spec(R)
Spectrum
  of multivariate polynomial ring in 3 variables x, y, z
    over rational field

julia> I = ideal(R, [x,y,z])
Ideal generated by
  x
  y
  z

julia> bl = blow_up(A3, I)
Blowup
  of scheme over QQ covered with 1 patch
    1b: [x, y, z]   affine 3-space
  in sheaf of ideals with restriction
    1b: Ideal (x, y, z)
with domain
  scheme over QQ covered with 3 patches
    1a: [(s1//s0), (s2//s0), x]   scheme(0, 0, 0)
    2a: [(s0//s1), (s2//s1), y]   scheme(0, 0, 0)
    3a: [(s0//s2), (s1//s2), z]   scheme(0, 0, 0)
and exceptional divisor
  effective cartier divisor defined by
    sheaf of ideals with restrictions
      1a: Ideal (x)
      2a: Ideal (y)
      3a: Ideal (z)

julia> E = exceptional_divisor(bl)
Effective cartier divisor
  on scheme over QQ covered with 3 patches
    1: [(s1//s0), (s2//s0), x]   scheme(0, 0, 0)
    2: [(s0//s1), (s2//s1), y]   scheme(0, 0, 0)
    3: [(s0//s2), (s1//s2), z]   scheme(0, 0, 0)
defined by
  sheaf of ideals with restrictions
    1: Ideal (x)
    2: Ideal (y)
    3: Ideal (z)

julia> Z = center(bl)
Sheaf of ideals
  on scheme over QQ covered with 1 patch
    1: [x, y, z]   affine 3-space
with restriction
  1: Ideal (x, y, z)
```
"""
@attributes mutable struct BlowupMorphism{
     DomainType<:AbsCoveredScheme, # Not a concrete type in general because this is lazy
     CodomainType<:AbsCoveredScheme,
   } <: AbsSimpleBlowupMorphism{
                                  DomainType,
                                  CodomainType,
                                  BlowupMorphism{DomainType, CodomainType}
                                 }
  projective_bundle::CoveredProjectiveScheme
  codomain::CodomainType   # in general a CoveredScheme
  center::AbsIdealSheaf      # on codomain
  projection::AbsCoveredSchemeMorphism
  domain::AbsCoveredScheme # in general a CoveredScheme
  exceptional_divisor::EffectiveCartierDivisor

  function BlowupMorphism(
      IP::CoveredProjectiveScheme,
      I::AbsIdealSheaf
    )
    X = base_scheme(IP)
    X === scheme(I) || error("ideal sheaf not compatible with blown up variety")
    return new{AbsCoveredScheme, typeof(X)}(IP, X, I)
  end
end

########################################################################
# Resolutions of singularities                                         #
########################################################################

@doc raw"""
    BlowUpSequence{
    DomainType<:AbsCoveredScheme,
    CodomainType<:AbsCoveredScheme
   } <: AbsDesingMor{
                                 DomainType,
                                 CodomainType,
                                }


"""
@attributes mutable struct BlowUpSequence{
                                          DomainType<:AbsCoveredScheme,
                                          CodomainType<:AbsCoveredScheme
                                         }<:AbsBlowupMorphism{
                                                                DomainType, CodomainType, 
                                                                BlowUpSequence{DomainType, CodomainType}
                                                               }
  maps::Vector{<:BlowupMorphism}                 # count right to left:
                                                 # original scheme is codomain of map 1
  
  embeddings::Vector{<:AbsCoveredSchemeMorphism} # if set,
                                                 # assert codomain(maps[i])===codomain(embeddings[i]) 
  # boolean flags
  is_embedded::Bool                              # do not set embeddings, ex_mult, controlled_transform etc
                                                 #     if is_embedded == false
  resolves_sing::Bool                            # domain(maps[end]) smooth?
  is_trivial::Bool                               # codomain already smooth?
  is_strong::Bool                                # snc divisors ensured?
  transform_type::Symbol                         # can be :strict, :weak or :control
                                                 #     only relevant for is_embedded == true

  # fields for caching, may be filled during computation
  ex_div::Vector{<:EffectiveCartierDivisor}      # list of exc. divisors arising from individual steps
                                                 # lives in domain(maps[end])
  control::Int                                   # value of control for controlled transform
  ex_mult::Vector{Int}                           # multiplicities of exceptional divisors removed from
                                                 # total transform, not set for is_embedded == false
                                                 # or transform_type == strict
  controlled_transform::AbsIdealSheaf            # holds weak or controlled transform according to transform_type
  dont_meet::Vector{Tuple{Int,Int}}              # mostly for dim=2: intersections which cannot exist according
                                                 # to intermediate computations
  caution_multi_charts::Vector{Tuple{Int,Int}}   # only for dim=2: intersection of divisors not
                                                 # entirely visible in a single chart


  # fields for caching to be filled a posteriori (on demand, only if partial_res==false)
  underlying_morphism::CompositeCoveredSchemeMorphism{DomainType, CodomainType}
  exceptional_divisor::CartierDivisor            # exceptional divisor of composed_map
  exceptional_locus::WeilDivisor                 # exceptional locus of composed map
  exceptional_divisor_on_X::CartierDivisor          # exceptional divisor of composed_map
                                                 # restricted to domain(embeddings[end])

  function BlowUpSequence(maps::Vector{<:BlowupMorphism})
    n = length(maps)
    for i in 1:n-1
      @assert domain(maps[i]) === codomain(maps[i+1]) "not a sequence of morphisms"
    end
    return new{typeof(domain(maps[end])),typeof(codomain(first(maps)))}(maps)
  end
end

########################################################################
# strict transforms of ideal sheaves                                   #
########################################################################

@attributes mutable struct StrictTransformIdealSheaf{SpaceType, OpenType, OutputType,
                                                     RestrictionType
                                                    } <: AbsIdealSheaf{
                                                                       SpaceType, OpenType,
                                                                       OutputType, RestrictionType
                                                                      }
  morphism::AbsSimpleBlowupMorphism
  orig::AbsIdealSheaf
  underlying_presheaf::AbsPreSheaf

  function StrictTransformIdealSheaf(
      f::AbsSimpleBlowupMorphism,
      J::AbsIdealSheaf
    )
    @assert scheme(J) === codomain(f)
    X = domain(f)
    Ipre = PreSheafOnScheme(X,
                      OpenType=AbsAffineScheme, OutputType=Ideal,
                      RestrictionType=Map,
                      is_open_func=_is_open_func_for_schemes_without_affine_scheme_open_subscheme(X)
                     )
    I = new{typeof(X), AbsAffineScheme, Ideal, Map}(f, J, Ipre)
    return I
  end
end

#####################################################################################################
# Desingularization morphism: birational map between covered schemes with smooth domain
#####################################################################################################
@doc raw"""
    MixedBlowUpSequence{
              DomainType<:AbsCoveredScheme,
              CodomainType<:AbsCoveredScheme
            }<:AbsDesingMor{  DomainType,
                              CodomainType, 
                              MixedBlowUpSequence{DomainType, CodomainType}
                                              }
A datastructure to encode sequences of blow-ups and normalizations of covered schemes
as needed for desingularization of non-embedded schemes by the approaches of Zariski and of
Lipman. 
"""

@attributes mutable struct MixedBlowUpSequence{
                                                DomainType<:AbsCoveredScheme,
                                                CodomainType<:AbsCoveredScheme
                                              }<:AbsDesingMor{  DomainType,
                                                                CodomainType, 
                                                                MixedBlowUpSequence{DomainType, CodomainType}
                                              }
  maps::Vector{Union{<:BlowupMorphism,<:NormalizationMorphism}}       # count right to left:
                                                 # original scheme is codomain of map 1
  # boolean flags
  resolves_sing::Bool                            # domain not smooth yet?
  is_trivial::Bool                               # codomain already smooth?
  is_strong::Bool                                # snc divisors ensured?

  # fields for caching, to be filled during desingularization
  # always carried along to domain(maps[end])) using strict_transform
  ex_div::Vector{AbsIdealSheaf}      # list of exc. divisors arising from individual steps
  dont_meet::Vector{Tuple{Int,Int}}             # mostly for dim=2: intersections which cannot exist
                                                # according to intermediate computations
  caution_multi_charts::Vector{Tuple{Int,Int}}  # only for dim=2: intersection of divisors not
                                                # entirely visible in a single chart

  # keep track of the normalization steps
  normalization_steps::Vector{Int}

  # fields for caching to be filled a posteriori (on demand, only if partial_res==false)
  underlying_morphism::CompositeCoveredSchemeMorphism{DomainType, CodomainType}
  exceptional_divisor::AbsWeilDivisor
  exceptional_locus::AbsAlgebraicCycle

  function MixedBlowUpSequence(maps::Vector{<:AbsCoveredSchemeMorphism})
    n = length(maps)
    for i in 1:n
      @assert all(x->((x isa BlowupMorphism) || (x isa NormalizationMorphism)), maps) "only blow-ups and normalizations allowed"
    end
    for i in 1:n-1
      @assert domain(maps[i]) === codomain(maps[i+1]) "not a sequence of morphisms"
    end
    resi = new{typeof(domain(maps[end])),typeof(codomain(first(maps)))}(maps)
    resi.normalization_steps = [i for i in 1:n if maps[i] isa NormalizationMorphism]
    return resi
  end

end
