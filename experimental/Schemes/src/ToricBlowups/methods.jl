@doc raw"""
    strict_transform(phi::ToricBlowupMorphism, I::MPolyIdeal) -> MPolyIdeal
    strict_transform(phi::ToricBlowupMorphism, f::MPolyDecRingElem) -> MPolyDecRingElem

Let $\varphi\colon Y \to X$ be the toric blowup corresponding to a star
subdivision along a primitive vector in the support of the fan of $X$.
Let $R$ and $S$ be the Cox rings of $X$ and $Y$, respectively.
Here "strict transform" means the "scheme-theoretic closure of the
complement of the exceptional divisor in the scheme-theoretic inverse
image".
This function returns a homogeneous ideal (or a polynomial generating a
principal ideal) in $S$ corresponding to the strict transform under $\varphi$
of the closed subscheme of $X$ defined by the homogeneous ideal $I$ (or
by the homogeneous principal ideal generated by $f$) in $R$.

This is implemented under the following assumption:
  * the variety $X$ has no torus factors (meaning the rays span
    $N_{\mathbb{R}}$).

!!! note
    Computing `strict_transform(phi, f)` is faster than computing
    `strict_transform(phi, ideal(f))[1]` since it avoids creating an
    ideal.

# Examples
```jldoctest
julia> X = affine_space(NormalToricVariety, 2)
Normal toric variety

julia> phi = blow_up(X, [2, 3])
Toric blowup morphism

julia> R = cox_ring(X)
Multivariate polynomial ring in 2 variables over QQ graded by the trivial group

julia> (x1, x2) = gens(R)
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x1
 x2

julia> I = ideal(R, [x1 + x2])
Ideal generated by
  x1 + x2

julia> strict_transform(phi, I)
Ideal generated by
  x1 + x2*e
```
"""
function strict_transform(phi::ToricBlowupMorphism, I::MPolyIdeal)
  X = codomain(phi)
  @req !has_torusfactor(X) "Only implemented when there are no torus factors"
  S = cox_ring(domain(phi))
  exceptional_var = S[index_of_exceptional_ray(phi)]
  J = cox_ring_module_homomorphism(phi, I)
  return saturation(J, ideal(S, exceptional_var))
end

function strict_transform(phi::ToricBlowupMorphism, f::MPolyDecRingElem)
  X = codomain(phi)
  @req !has_torusfactor(X) "Only implemented when there are no torus factors"
  S = cox_ring(domain(phi))
  exceptional_var = S[index_of_exceptional_ray(phi)]
  h = cox_ring_module_homomorphism(phi, f)
  return remove(h, exceptional_var)[2]
end

@doc raw"""
    total_transform(phi::ToricBlowupMorphism, I::MPolyIdeal) -> MPolyIdeal
    total_transform(phi::ToricBlowupMorphism, f::MPolyDecRingElem) -> MPolyDecRingElem

Let $\varphi\colon Y \to X$ be the toric blowup corresponding to a star
subdivision along a primitive vector in the support of the fan of $X$.
Let $R$ and $S$ be the Cox rings of $X$ and $Y$, respectively.
Here "total transform" means the "scheme-theoretic inverse image".
This function returns a homogeneous ideal (or a polynomial generating a
principal ideal) in $S$ corresponding to the total transform under $\varphi$
of the closed subscheme of $X$ defined by the homogeneous ideal $I$ (or
by the homogeneous principal ideal generated by $f$) in $R$.

This is implemented under the following assumptions:
  * the variety $X$ has no torus factors (meaning the rays span
    $N_{\mathbb{R}}$), and
  * the variety $X$ is an orbifold (meaning its fan is simplicial).

!!! note
    Computing `total_transform(phi, f)` is faster than computing
    `total_transform(phi, ideal(f))[1]` since it avoids creating an ideal.

# Examples
```jldoctest
julia> X = affine_space(NormalToricVariety, 2)
Normal toric variety

julia> phi = blow_up(X, [2, 3])
Toric blowup morphism

julia> R = cox_ring(X)
Multivariate polynomial ring in 2 variables over QQ graded by the trivial group

julia> (x1, x2) = gens(R)
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x1
 x2

julia> I = ideal(R, [x1 + x2])
Ideal generated by
  x1 + x2

julia> total_transform(phi, I)
Ideal generated by
  x1*e^2 + x2*e^3
```
"""
function total_transform(phi::ToricBlowupMorphism, I::Union{MPolyIdeal, MPolyDecRingElem})
  X = codomain(phi)
  @req !has_torusfactor(X) "Only implemented when there are no torus factors"
  @req is_orbifold(X) "Only implemented when the fan is simplicial"
  return cox_ring_module_homomorphism(phi, I)
end

@doc raw"""
    strict_transform_with_index(phi::ToricBlowupMorphism, I::MPolyIdeal) -> (MPolyIdeal, Int)
    strict_transform_with_index(phi::ToricBlowupMorphism, f::MPolyDecRingElem) -> (MPolyDecRingElem, Int)

Return the pair $(J, k)$, where $J$ coincides with `strict_transform(phi, I)`
(or with `strict_transform(phi, f)`) and where $k$ is the multiplicity
of the total transform along the exceptional prime divisor.

This is implemented under the following assumptions:
  * the variety $X$ has no torus factors (meaning the rays span
    $N_{\mathbb{R}}$), and
  * the variety $X$ is smooth.

!!! note
    If the multiplicity $k$ is not needed, we recommend to use
    `strict_transform(phi, I)` which is typically faster.

!!! note
    Computing `strict_transform_with_index(phi, f)` is faster than
    computing `strict_transform_with_index(phi, ideal(f))` since it avoids
    creating an ideal.

# Examples
```jldoctest
julia> X = affine_space(NormalToricVariety, 2)
Normal toric variety

julia> phi = blow_up(X, [2, 3])
Toric blowup morphism

julia> R = cox_ring(X)
Multivariate polynomial ring in 2 variables over QQ graded by the trivial group

julia> (x1, x2) = gens(R)
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x1
 x2

julia> I = ideal(R, [x1 + x2])
Ideal generated by
  x1 + x2

julia> strict_transform_with_index(phi, I)
(Ideal (x1 + x2*e), 2)
```
"""
function strict_transform_with_index(phi::ToricBlowupMorphism, I::MPolyIdeal)
  X = codomain(phi)
  @req !has_torusfactor(X) "Only implemented when there are no torus factors"
  @req is_smooth(X) "Only implemented when the fan is smooth"
  S = cox_ring(domain(phi))
  exceptional_var = S[index_of_exceptional_ray(phi)]
  J = total_transform(phi, I)
  return saturation_with_index(J, ideal(exceptional_var))
end

function strict_transform_with_index(phi::ToricBlowupMorphism, f::MPolyDecRingElem)
  X = codomain(phi)
  @req !has_torusfactor(X) "Only implemented when there are no torus factors"
  @req is_smooth(X) "Only implemented when the fan is smooth"
  S = cox_ring(domain(phi))
  exceptional_var = S[index_of_exceptional_ray(phi)]
  h = cox_ring_module_homomorphism(phi, f)
  pair = remove(h, exceptional_var)
  return pair[2], pair[1]
end

@doc raw"""
    cox_ring_module_homomorphism(phi::ToricBlowupMorphism, f::MPolyDecRingElem) -> MPolyDecRingElem
    cox_ring_module_homomorphism(phi::ToricBlowupMorphism, I::MPolyIdeal) -> MPolyIdeal

Let $\varphi\colon Y \to X$ be the toric blowup corresponding to a star
subdivision along a primitive vector $r$ in the support of the fan of $X$.
Let $R$ and $S$ be the Cox rings of $X$ and $Y$, respectively.
Let $\rho$ be the ray generated by $r$.
Considering $R$ and $S$ with their $\mathbb{C}$-module structures, we
construct a $\mathbb{C}$-module homomorphism $\Phi\colon R \to S$
sending a monomial $g$ to $e^d g$, where $e$ is the variable
corresponding to $\rho$ and where $d = 0$ if $\rho$ belongs to
the fan of $X$ and $d = \lceil a \cdot p \rceil$ otherwise, where $a$ is
the exponent vector of $g$, $p$ is the minimal supercone coordinate
vector of $r$ in the fan of $X$, as returned by
`minimal_supercone_coordinates_of_exceptional_ray(X, r)`, and where $(\cdot)$
denotes the scalar product.

The $\mathbb{C}$-module homomorphism $\Phi$ sends homogeneous ideals to
homogeneous ideals.

# Examples
```jldoctest
julia> X = affine_space(NormalToricVariety, 2)
Normal toric variety

julia> phi = blow_up(X, [2, 3])
Toric blowup morphism

julia> R = cox_ring(X)
Multivariate polynomial ring in 2 variables over QQ graded by the trivial group

julia> (x1, x2) = gens(R)
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x1
 x2

julia> cox_ring_module_homomorphism(phi, x1 + x2)
x1*e^2 + x2*e^3
```
"""
cox_ring_module_homomorphism

function cox_ring_module_homomorphism(f::ToricBlowupMorphism, g::MPolyDecRingElem)
  @req parent(g) === cox_ring(codomain(f)) "g must be an element of the Cox ring of the codomain of f"
  R = cox_ring(codomain(f))
  S = cox_ring(domain(f))
  nvars(R) == nvars(S) && return evaluate(g, gens(S))
  ps = minimal_supercone_coordinates_of_exceptional_ray(f)
  if lcm(denominator.(ps)) == 1
    ps_fast = Vector{Int64}(numerator.(ps))
  else
    ps_fast = Vector{Rational{Int64}}(ps)
  end
  exceptional_var = S[index_of_exceptional_ray(f)]
  C = MPolyBuildCtx(S)

  # Core loop
  for m in terms(g)
    exps = first(exponents(m))
    exceptional_exp = ceil(Int64, sum(ps_fast.*exps))
    exps = [exps; exceptional_exp]
    push_term!(C, first(coefficients(m)), exps)
  end

  h = finish(C)
  return h
end

function cox_ring_module_homomorphism(f::ToricBlowupMorphism, I::MPolyIdeal)
  S = cox_ring(domain(f))
  return ideal(S, [cox_ring_module_homomorphism(f, g) for g in gens(I)])
end
