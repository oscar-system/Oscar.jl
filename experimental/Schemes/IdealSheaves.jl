export IdealSheaf
export extend!
export ideal_sheaf
export order_on_divisor
export scheme
export subscheme

### Forwarding the presheaf functionality
underlying_presheaf(I::IdealSheaf) = I.I
underlying_presheaf(I::PrimeIdealSheafFromChart) = I.F
underlying_presheaf(I::SumIdealSheaf) = I.underlying_presheaf
underlying_presheaf(I::ProductIdealSheaf) = I.underlying_presheaf
underlying_presheaf(I::SimplifiedIdealSheaf) = I.underlying_presheaf

# an alias for the user's convenience
scheme(I::AbsIdealSheaf) = space(I)

@doc raw"""
    IdealSheaf(X::AbsProjectiveScheme, g::Vector{<:RingElem})

Create the ideal sheaf on the covered scheme of ``X`` which is
generated by the dehomogenization of the homogeneous elements in `g`
in every chart.

**Note:** When taking the pullback of an `IdealSheaf` ``ℐ`` along a morphism
``f : X → Y``, what is actually computed, is ``f⁻¹ ℐ ⋅ 𝒪_{X}``.
To obtain the pullback of ``ℐ`` as a sheaf of modules (i.e. ``f* ℐ``),
convert ``ℐ`` into a `CoherentSheaf` on ``Y``, first.

# Examples
```jldoctest
julia> P, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> I = ideal([x^3-y^2*z]);

julia> Y = proj(P)
Projective space of dimension 2
  over rational field
with homogeneous coordinates [x, y, z]

julia> IdealSheaf(Y, I)
Sheaf of ideals
  on scheme over QQ covered with 3 patches
    1: [(y//x), (z//x)]   affine 2-space
    2: [(x//y), (z//y)]   affine 2-space
    3: [(x//z), (y//z)]   affine 2-space
with restrictions
  1: Ideal (-(y//x)^2*(z//x) + 1)
  2: Ideal ((x//y)^3 - (z//y))
  3: Ideal ((x//z)^3 - (y//z)^2)
```
"""
function IdealSheaf(X::AbsProjectiveScheme, I::MPolyIdeal)
  S = base_ring(I)
  S === homogeneous_coordinate_ring(X) || error("ideal does not live in the graded coordinate ring of the scheme")
  g = gens(I)
  X_covered = covered_scheme(X)
  C = default_covering(X_covered)
  r = relative_ambient_dimension(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(C)
    I[U] = ideal(OO(U), dehomogenization_map(X, U).(g))
  end
  return IdealSheaf(X_covered, I, check=false)
end

function IdealSheaf(X::AbsProjectiveScheme, I::MPolyQuoIdeal)
  S = base_ring(I)
  S === homogeneous_coordinate_ring(X) || error("ideal does not live in the graded coordinate ring of the scheme")
  g = gens(I)
  X_covered = covered_scheme(X)
  C = default_covering(X_covered)
  r = relative_ambient_dimension(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(C)
    I[U] = ideal(OO(U), dehomogenization_map(X, U).(g))
  end
  return IdealSheaf(X_covered, I, check=false)
end

ideal_sheaf(X::AbsProjectiveScheme, I::MPolyIdeal) = IdealSheaf(X, I)
ideal_sheaf(X::AbsProjectiveScheme, I::MPolyQuoIdeal) = IdealSheaf(X, I)

function IdealSheaf(
    X::AbsProjectiveScheme,
    g::MPolyDecRingElem
  )
  return IdealSheaf(X, [g])
end

function IdealSheaf(
    X::AbsProjectiveScheme,
    g::MPolyQuoRingElem
  )
  return IdealSheaf(X, [g])
end

ideal_sheaf(X::AbsProjectiveScheme, g::MPolyDecRingElem) = IdealSheaf(X, g)
ideal_sheaf(X::AbsProjectiveScheme, g::MPolyQuoRingElem) = IdealSheaf(X, g)

function IdealSheaf(
    X::AbsProjectiveScheme,
    g::Vector{RingElemType}
  ) where {RingElemType<:MPolyDecRingElem}
  X_covered = covered_scheme(X)
  r = relative_ambient_dimension(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(default_covering(X_covered))
    I[U] = ideal(OO(U), dehomogenization_map(X, U).(g))
  end
  return IdealSheaf(X_covered, I, check=false)
end

function IdealSheaf(
    X::AbsProjectiveScheme,
    g::Vector{RingElemType}
  ) where {RingElemType<:MPolyQuoRingElem}
  X_covered = covered_scheme(X)
  r = relative_ambient_dimension(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(default_covering(X_covered))
    I[U] = ideal(OO(U), dehomogenization_map(X, U).(g))
  end
  return IdealSheaf(X_covered, I, check=false)
end

ideal_sheaf(X::AbsProjectiveScheme, g::Vector{RingElemType}) where {RingElemType<:MPolyDecRingElem} = IdealSheaf(X, g)
ideal_sheaf(X::AbsProjectiveScheme, g::Vector{RingElemType}) where {RingElemType<:MPolyQuoRingElem} = IdealSheaf(X, g)



# this constructs the zero ideal sheaf
function IdealSheaf(X::AbsCoveredScheme)
  C = default_covering(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in basic_patches(C)
    I[U] = ideal(OO(U), elem_type(OO(U))[])
  end
  return IdealSheaf(X, I, check=false)
end

@doc raw"""
    ideal_sheaf(X::AbsCoveredScheme)

See the documentation for `IdealSheaf`.
"""
ideal_sheaf(X::AbsCoveredScheme) = IdealSheaf(X)

# set up an ideal sheaf by automatic extension
# from one prescribed set of generators on one affine patch
@doc raw"""
    IdealSheaf(X::AbsCoveredScheme, U::AbsAffineScheme, I::Ideal)

Set up an ideal sheaf on ``X`` by specifying an ideal ``I``
on one affine open subset ``U`` among the `basic_patches` of the
`default_covering` of ``X``.

**Note:** The ideal ``I`` has to be prime so that its extension 
to the other charts of ``X`` is well defined. 
"""
function IdealSheaf(
    X::AbsCoveredScheme, U::AbsAffineScheme, 
    I::Ideal; check::Bool=false
  )
  @assert base_ring(I) === OO(U) || error("ideal not defined in the correct ring")
  @check is_prime(I) "ideal must be prime"
  return PrimeIdealSheafFromChart(X, U, I)
end

function IdealSheaf(X::AbsAffineScheme, I::Ideal; covered_scheme::AbsCoveredScheme=CoveredScheme(X))
  @assert base_ring(I) === OO(X)
  @assert length(affine_charts(covered_scheme)) == 1 && X === first(affine_charts(covered_scheme))
  return IdealSheaf(covered_scheme, IdDict{AbsAffineScheme, Ideal}([X=>I]); check=false)
end

function IdealSheaf(
    X::AbsCoveredScheme, U::AbsAffineScheme, 
    g::Vector{RET}; check::Bool=false
  ) where {RET<:RingElem}
  return IdealSheaf(X, U, ideal(OO(U), g); check)
end

ideal_sheaf(X::AbsCoveredScheme, U::AbsAffineScheme, g::Vector{RET}; check::Bool=true) where {RET<:RingElem} = IdealSheaf(X, U, g; check)
ideal_sheaf(X::AbsCoveredScheme, U::AbsAffineScheme, I::Ideal; check::Bool=true) = IdealSheaf(X, U, I; check)

@doc raw"""
    IdealSheaf(Y::AbsCoveredScheme,
        phi::CoveringMorphism{<:Any, <:Any, <:ClosedEmbedding}
    )

Internal method to create an ideal sheaf from a `CoveringMorphism`
of `ClosedEmbedding`s; return the ideal sheaf describing the images
of the local morphisms.
"""
function IdealSheaf(Y::AbsCoveredScheme,
    phi::CoveringMorphism{<:Any, <:Any, <:ClosedEmbedding};
    check::Bool=true
  )
  maps = morphisms(phi)
  V = [codomain(ff) for ff in values(maps)]
  dict = IdDict{AbsAffineScheme, Ideal}()
  V = unique!(V)
  for W in V
    i = findall(x->(codomain(x) == W), maps)
    dict[W] = image_ideal(maps[first(i)])
  end
#  for U in affine_charts(Y)
#    if U in V
#      i = findall(x->(codomain(x) == U), maps)
#      dict[U] = image_ideal(maps[first(i)])
#    else
#      dict[U] = ideal(OO(U), one(OO(U)))
#    end
#  end
  return IdealSheaf(Y, dict, check=check)
end


# pullback of an ideal sheaf for internal use between coverings of the same scheme
#function (F::CoveringMorphism)(I::IdealSheaf)
#  X = scheme(I)
#  D = codomain(F)
#  D == covering(I) || error("ideal sheaf is not defined on the correct covering")
#  C = domain(F)
#  new_dict = Dict{AbsAffineScheme, Ideal}()
#
#  # go through the patches of C and pull back the generators
#  # whenever they are defined on the target patch
#  for U in patches(C)
#    f = F[U]
#    V = codomain(f)
#    # for the basic patches here
#    if haskey(ideal_dict(I), V)
#      new_dict[U] = ideal(OO(U), pullback(f).(I[V]))
#    end
#    # check for affine refinements
#    if haskey(affine_refinements(D), V)
#      Vrefs = affine_refinements(D)[V]
#      # pull back the refinement
#      for W in Vrefs
#        h = pullback(f).(gens(W))
#        # take care to discard possibly empty preimages of patches
#        j = [i for i in 1:length(h) if !iszero(h)]
#        Wpre = AffineSchemeOpenSubscheme(U, h[j])
#        add_affine_refinement!(C, Wpre)
#        for i in 1:length(j)
#          if haskey(ideal_dict(I), Wpre[i])
#            new_dict[Wpre[i]] = lifted_numerator.(pullback(f).(I[V[j[i]]]))
#          end
#        end
#      end
#    end
#  end
#  return IdealSheaf(X, C, new_dict)
#end

function +(I::AbsIdealSheaf, J::AbsIdealSheaf)
  return SumIdealSheaf([I, J])
end

function +(I::SumIdealSheaf, J::AbsIdealSheaf)
  return SumIdealSheaf(vcat(summands(I), [J]))
end

function +(I::AbsIdealSheaf, J::SumIdealSheaf)
  return SumIdealSheaf(vcat([I], summands(J)))
end

function +(I::SumIdealSheaf, J::SumIdealSheaf)
  return SumIdealSheaf(vcat(summands(I), summands(J)))
end

function *(I::AbsIdealSheaf, J::AbsIdealSheaf)
  return ProductIdealSheaf([I, J])
end

function *(I::ProductIdealSheaf, J::AbsIdealSheaf)
  return ProductIdealSheaf(vcat(factors(I), [J]))
end

function *(I::AbsIdealSheaf, J::ProductIdealSheaf)
  return ProductIdealSheaf(vcat([I], factors(J)))
end

function *(I::ProductIdealSheaf, J::ProductIdealSheaf)
  return ProductIdealSheaf(vcat(factors(I), factors(J)))
end

function simplify(I::AbsIdealSheaf)
  return SimplifiedIdealSheaf(I)
end

@doc raw"""
    simplify!(I::AbsIdealSheaf)

Replaces the set of generators of the ideal sheaf on each cached chart by a small generating set.
"""
function simplify!(I::IdealSheaf, cov::Covering=default_covering(space(I)))
  object_cache = I.I.obj_cache

  for U in basic_patches(cov)
    if !any(U===i for i in keys(object_cache))
      continue
    end
    object_cache[U] = ideal(OO(U), small_generating_set(I(U)))
  end
  return I
end

@doc """
    subscheme(I::AbsIdealSheaf)

For an ideal sheaf ``ℐ`` on an `AbsCoveredScheme` ``X`` return
the subscheme ``Y ⊂ X`` given by the zero locus of ``ℐ``.
"""
function subscheme(I::AbsIdealSheaf; covering::Covering=default_covering(scheme(I)))
  X = space(I)
  C = covering
  new_patches = IdDict{AbsAffineScheme, AbsAffineScheme}([U=>subscheme(U, I(U)) for U in basic_patches(C) if !isone(I(U))])
  new_gluings = IdDict{Tuple{AbsAffineScheme, AbsAffineScheme}, AbsGluing}()
  decomp_dict = IdDict{AbsAffineScheme, Vector{RingElem}}()
  for (U, Unew) in new_patches
    for (V, Vnew) in new_patches
      (U, V) in keys(gluings(C)) || continue # No gluing before, no gluing after.
      old_glue = C[U, V]
      new_gluings[(Unew, Vnew)] = LazyGluing(Unew, Vnew, _compute_restriction,
                                             RestrictionDataClosedEmbedding(C[U, V], Unew, Vnew)
                                            )
      #new_gluings[(Vnew, Unew)] = LazyGluing(Vnew, Unew, inverse, new_gluings[(Unew, Vnew)])
    end
  end
  Cnew = Covering(collect(values(new_patches)), new_gluings, check=false)

  # Inherit decomposition information if applicable
  if has_decomposition_info(C)
    for (U, V) in new_patches
      set_decomposition_info!(Cnew, V, elem_type(OO(V))[OO(V)(a, check=false) for a in decomposition_info(C)[U]])
    end
  end
  return CoveredScheme(Cnew)
end


@doc raw"""
    extend!(C::Covering, D::Dict{AffineSchemeType, IdealType}) where {AffineSchemeType<:AffineScheme, IdealType<:Ideal}

For ``C`` a covering and ``D`` a dictionary holding vectors of
polynomials on affine patches of ``C`` this function extends the
collection of polynomials over all patches in a compatible way;
meaning that on the overlaps the restrictions of either two sets
of polynomials coincides.

This proceeds by crawling through the gluing graph and taking
closures in the patches ``Uⱼ`` of the subschemes
``Zᵢⱼ = V(I) ∩ Uᵢ ∩ Uⱼ`` in the intersection with a patch ``Uᵢ``
on which ``I`` had already been described.

Note that the covering `C` is not modified.
"""
function extend!(
    C::Covering, D::IdDict{AbsAffineScheme, Ideal};
    all_dense::Bool=false
  )
  all(x->any(y->x===y, patches(C)), keys(D)) || error("ideals must be given on the `patches` of the covering")
  # push all nodes on which I is known in a heap
  visited = collect(keys(D))
  # The nodes which can be used for extension
  fat = AbsAffineScheme[U for U in visited if !isone(D[U])]
  # Nodes which are leafs
  flat = AbsAffineScheme[U for U in visited if isone(D[U])]
  # Nodes to which we might need to extend
  leftover = AbsAffineScheme[U for U in patches(C) if !(U in keys(D))]
  # Nodes to which we can extend in one step
  neighbors = AbsAffineScheme[U for U in leftover if any(V->haskey(gluings(C), (U, V)), fat)]
  # All other nodes
  leftover = AbsAffineScheme[U for U in leftover if !any(W->W===U, neighbors)]
  while length(neighbors) > 0
    good_pairs = Vector{Tuple{AbsAffineScheme, AbsAffineScheme}}()
    for V in neighbors
      for U in fat
        G = C[U, V]
        if (G isa SimpleGluing || (G isa LazyGluing && is_computed(G)))
          push!(good_pairs, (U, V))
        end
      end
    end

    # Initialize some variables
    U = first(visited) # The visited node
    V = first(visited) # The neighboring node for which we do the extension
    if !isempty(good_pairs)
      # In case we find a good neighboring pair, use that
      (U, V) = first(good_pairs)
    else
      # If there is no good neighboring pair, compute a new gluing
      V = first(neighbors)
      k = findfirst(U->haskey(gluings(C), (U, V)), fat)
      U = fat[k]
    end
    f, _ = gluing_morphisms(C[V, U])
    if C[V, U] isa SimpleGluing || (C[V, U] isa LazyGluing && first(gluing_domains(C[V, U])) isa PrincipalOpenSubset)

      # Take a shortcut if possible
      _, UV = gluing_domains(C[V, U])
      if isone(ideal(OO(UV), OO(UV).(gens(D[U]), check=false)))
        D[V] = ideal(OO(V), one(OO(V)))
        # Register this patch as a leaf
        push!(flat, V)
        # Update the neighbors
        neighbors = [W for W in neighbors if !(W===V)]
        continue
      end

      # if not, extend D to this patch
      f, _ = gluing_morphisms(C[V, U])
      pbI_gens = pullback(f).([OO(codomain(f))(x, check=false) for x in gens(D[U])])
      J = ideal(OO(V), lifted_numerator.(pbI_gens))
      #J_sat = saturation(J, ideal(OO(V), complement_equation(domain(f))))
      J_sat = _iterative_saturation(J, lifted_numerator(complement_equation(domain(f))))
      D[V] = J_sat
    else
      Z = subscheme(U, D[U])
      pZ = preimage(f, Z, check=false)
      ZV = closure(pZ, V, check=false)
      D[V] = ideal(OO(V), [g for g in OO(V).(small_generating_set(saturated_ideal(modulus(OO(ZV))))) if !iszero(g)])
    end

    # Update the neighbors
    neighbors = [W for W in neighbors if !(W===V)]
    # Put that new node in the correct list
    if isone(D[V])
      push!(flat, V)
    else
      push!(fat, V)
      for W in leftover
        if haskey(gluings(C), (V, W))
          push!(neighbors, W)
        end
      end
      leftover = [W for W in leftover if !any(x->x===W, neighbors)]
    end
  end
  for U in basic_patches(C)
    if !haskey(D, U)
      D[U] = ideal(OO(U), one(OO(U)))
    end
  end
  return D
end

function _iterative_saturation(I::Ideal, f::RingElem)
  fac = factor(f)
  R = base_ring(I)
  for (u, k) in fac
    I = saturation(I, ideal(R, u))
  end
  return I
end

function ==(I::AbsIdealSheaf, J::AbsIdealSheaf)
  I === J && return true
  X = space(I)
  X == space(J) || return false
  for U in basic_patches(default_covering(X))
    is_subset(I(U), J(U)) && is_subset(J(U), I(U)) || return false
  end
  return true
end

function is_subset(I::AbsIdealSheaf, J::AbsIdealSheaf)
  X = space(I)
  X === space(J) || return false
  for U in basic_patches(default_covering(X))
    is_subset(I(U), J(U)) || return false
  end
  return true
end

# prepares a refinement C' of the covering for the ideal sheaf I
# such that I can be generated by a regular sequence defining a smooth
# local complete intersection subscheme in every patch U of C' and
# returns the ideal sheaf with those generators on C'.
#function as_smooth_lci(
#    I::IdealSheaf;
#    verbose::Bool=false,
#    check::Bool=true,
#    codimension::Int=dim(scheme(I))-dim(subscheme(I)) #assumes both scheme(I) and its subscheme to be equidimensional
#  )
#  X = scheme(I)
#  C = covering(I)
#  AffineSchemeType = affine_patch_type(C)
#  PolyType = poly_type(AffineSchemeType)
#  new_gens_dict = Dict{AffineSchemeType, Vector{PolyType}}()
#  for U in patches(C)
#    V, spec_dict = as_smooth_lci(U, I[U],
#                                 verbose=verbose,
#                                 check=check,
#                                 codimension=codimension)
#    add_affine_refinement!(C, V)
#    merge!(new_gens_dict, spec_dict)
#  end
#  Iprep = IdealSheaf(X, C, new_gens_dict)
#  set_attribute!(Iprep, :is_regular_sequence, true)
#  return Iprep
#end
#
#function as_smooth_lci(
#    U::AffineScheme, g::Vector{T};
#    verbose::Bool=false,
#    check::Bool=true,
#    codimension::Int=dim(U)-dim(subscheme(U, g)) # this assumes both U and its subscheme to be equidimensional
#  ) where {T<:MPolyRingElem}
#  verbose && println("preparing $g as a local complete intersection on $U")
#  f = numerator.(gens(localized_modulus(OO(U))))
#  f = [a for a in f if !iszero(a)]
#  verbose && println("found $(length(f)) generators for the ideal defining U")
#  h = vcat(f, g)
#  r = length(f)
#  s = length(g)
#  Dh = jacobian_matrix(h)
#  (ll, ql, rl, cl) = _non_degeneration_cover(subscheme(U, g), Dh, codimension + codim(U),
#                          verbose=verbose, check=check,
#                          restricted_columns=[collect(1:r), [r + k for k in 1:s]])
#
#  n = length(ll)
#  # first process the necessary refinements of U
#  # The restricted columns in the call to _non_degenerate_cover
#  # assure that the first codim(U) entries of every cl[i] are
#  # indices of some element of f. However, we can discard these,
#  # as they are trivial generators of the ideal sheaf on U.
#  minor_list = [det(Dh[rl[i], cl[i]]) for i in 1:n]
#  V = Vector{open_subset_type(U)}()
#  AffineSchemeType = typeof(U)
#  PolyType = poly_type(U)
#  spec_dict = Dict{AffineSchemeType, Vector{PolyType}}()
#  g = Vector{PolyType}()
#  W = AffineSchemeOpenSubscheme(U, minor_list)
#  for i in 1:n
#    spec_dict[W[i]] = h[cl[i][codim(U)+1:end]]
#  end
#  return W, spec_dict
#end
#

function is_one(I::AbsIdealSheaf; covering::Covering=default_covering(scheme(I)))
  return get_attribute!(I, :is_one) do
    for U in keys(object_cache(I))
      !is_one(cheap_sub_ideal(I, U)) && !is_one(I(U)) && return false
    end
    return all(x->isone(I(x)), covering)
  end::Bool
end

function is_one(I::PrimeIdealSheafFromChart; covering::Covering=default_covering(scheme(I)))
  return false
end

function dim(I::PrimeIdealSheafFromChart)
  return dim(I(original_chart(I)))
end

function is_one(I::SumIdealSheaf; covering::Covering=default_covering(scheme(I)))
  return get_attribute!(I, :is_one) do
    for U in keys(object_cache(I))
      !is_one(I(U)) && return false
    end

    J = summands(I)
    k = findfirst(x->x isa PrimeIdealSheafFromChart, J)
    if k !== nothing
      P = J[k]
      U = original_chart(P)
      if !is_one(cheap_sub_ideal(I, U))
        is_one(I(U)) || return false
      end
    end

    return all(x->(isone(cheap_sub_ideal(I, x)) || isone(I(x))), covering)
  end::Bool
end

function is_one(I::ProductIdealSheaf; covering::Covering=default_covering(scheme(I)))
  return all(x->is_one(x), factors(I))
end

@doc raw"""
    is_prime(I::AbsIdealSheaf) -> Bool

Return whether ``I`` is prime.

We say that a sheaf of ideals is prime if its support is irreducible and
``I`` is locally prime. (Note that the empty set is not irreducible.)
"""
@attr function is_prime(I::AbsIdealSheaf)
  is_locally_prime(I) || return false
  # TODO: this can be made more efficient
  PD = maximal_associated_points(I)
  return length(PD)==1
end

function is_prime(I::PrimeIdealSheafFromChart)
  return true
end

@doc raw"""
    is_locally_prime(I::AbsIdealSheaf) -> Bool

Return whether ``I`` is locally prime.

A sheaf of ideals $\mathcal{I}$ is locally prime if its stalk $\mathcal{I}_p$
at every point $p$ is one or prime.
"""
@attr Bool function is_locally_prime(I::AbsIdealSheaf)
  return all(U->is_prime(I(U)) || is_one(I(U)), basic_patches(default_covering(space(I))))
end

is_locally_prime(I::PrimeIdealSheafFromChart) = true

function is_equidimensional(I::AbsIdealSheaf; covering=default_covering(scheme(I)))
  has_attribute(I, :is_equidimensional) && return get_attribute(I, :is_equidimensional)
  has_attribute(I, :is_prime) && return get_attribute(I, :is_prime)
  local_dims = [dim(I(U)) for U in patches(covering) if !isone(I(U))]
  length(local_dims) == 0 && return true # This only happens if I == OO(X)
  d = first(local_dims)
  if !all(x->x==d, local_dims) ||
     !all(U->(isone(I(U)) || is_equidimensional(I(U))), patches(covering))
    set_attribute!(I, :is_equidimensional=>false)
    return false
  else
    set_attribute!(I, :is_equidimensional=>true)
    return true
  end
end

is_equidimensional(I::PrimeIdealSheafFromChart) = true

@attr Bool function is_equidimensional(I::MPolyIdeal)
  decomp = equidimensional_decomposition_weak(I)
  return isone(length(decomp))
end

@attr Bool function is_equidimensional(I::MPolyQuoIdeal)
  is_equidimensional(saturated_ideal(I))
end

@attr Bool function is_equidimensional(I::MPolyLocalizedIdeal)
  return is_equidimensional(saturated_ideal(I))
end

@attr Bool function is_equidimensional(I::MPolyQuoLocalizedIdeal)
  return is_equidimensional(pre_image_ideal(I))
end

function _minimal_power_such_that(I::Ideal, P::PropertyType) where {PropertyType}
  whole_ring = ideal(base_ring(I), [one(base_ring(I))])
  P(whole_ring) && return (0, whole_ring)
  P(I) && return (1, I)
  I_powers = [(1,I)]

  while !P(last(I_powers)[2])
    push!(I_powers, (last(I_powers)[1]*2, last(I_powers)[2]^2))
  end
  upper = pop!(I_powers)
  lower = pop!(I_powers)
  while upper[1]!=lower[1]+1
    middle = pop!(I_powers)
    middle = (lower[1]+middle[1], lower[2]*middle[2])
    if P(middle[2])
      upper = middle
    else
      lower = middle
    end
  end
  return upper
end

@doc raw"""
    order_on_divisor(f::VarietyFunctionFieldElem, I::AbsIdealSheaf; check::Bool=true) -> Int

Return the order of the rational function `f` on the prime divisor given by the ideal sheaf `I`.
"""
function order_on_divisor(
    f::VarietyFunctionFieldElem,
    I::AbsIdealSheaf;
    check::Bool=true
  )
  @check is_prime(I) "ideal sheaf must be a sheaf of prime ideals"

  X = space(I)::AbsCoveredScheme
  X == variety(parent(f)) || error("schemes not compatible")

  #order_dict = Dict{AbsAffineScheme, Int}()

  # Since X is integral and I is a sheaf of prime ideals,
  # it suffices to find one chart in which I is non-trivial.

  # We look for the chart with the least complexity
  V = first(affine_charts(X))
  #complexity = Vector{Tuple{AbsAffineScheme, Int}}()
  complexity = inf
  for U in keys(Oscar.object_cache(underlying_presheaf(I))) # Those charts on which I is known.
    U in default_covering(X) || continue
    is_one(I(U)) && continue
    tmp = sum([total_degree(lifted_numerator(g)) for g in gens(I(U)) if !iszero(g)]) # /ngens(Oscar.pre_image_ideal(I(U)))
    if tmp < complexity
      complexity = tmp
      V = U
    end
  end
  flag = false
  if complexity == inf
    for U in X[1]
      is_one(I(U)) && continue
      # no chart has been computed, so we just take the first one
      flag = true
      V = U
      break
    end
    flag || error("divisor is empty")
  end
  R = ambient_coordinate_ring(V)
  J = saturated_ideal(I(V))
  K = saturated_ideal(defining_ideal(V))
  floc = f[V]
  aR = ideal(R, numerator(floc))
  bR = ideal(R, denominator(floc))

  # The following uses ArXiv:2103.15101, Lemma 2.18 (4):
  num_mult = _minimal_power_such_that(J, x->(issubset(quotient(x+K, aR), J)))[1]-1
  den_mult = _minimal_power_such_that(J, x->(issubset(quotient(x+K, bR), J)))[1]-1
  return num_mult - den_mult
#    # Deprecated code computing symbolic powers explicitly:
#    L, map = localization(OO(U),
#                          MPolyComplementOfPrimeIdeal(saturated_ideal(I(U)))
#                         )
#    L isa Union{MPolyLocRing{<:Any, <:Any, <:Any, <:Any,
#                                        <:MPolyComplementOfPrimeIdeal},
#                     MPolyQuoLocRing{<:Any, <:Any, <:Any, <:Any,
#                                           <:MPolyComplementOfPrimeIdeal}
#                    } || error("localization was not successful")
#
#    floc = f[U]
#    a = numerator(floc)
#    b = denominator(floc)
#    # TODO: cache groebner bases in a reasonable way.
#    P = L(prime_ideal(inverted_set(L)))
#    if one(L) in P
#      continue # the multiplicity is -∞ in this case and does not count
#    end
#    upper = _minimal_power_such_that(P, x->!(L(a) in x))[1]-1
#    lower = _minimal_power_such_that(P, x->!(L(b) in x))[1]-1
#    order_dict[U] = upper-lower
end

@doc raw"""
    smooth_lci_covering(I::AbsIdealSheaf)

For an ideal sheaf ``ℐ`` on a *smooth* scheme ``X`` with a *smooth*
associated subscheme ``Y = V(ℐ)`` this produces a covering ``𝔘 = {Uₐ}, a ∈ A``
such that ``ℐ(Uₐ) = ⟨f₁,…,fₖ⟩`` is generated by a regular sequence on every
patch ``Uₐ`` of that covering.
"""
function smooth_lci_covering(I::AbsIdealSheaf)
  error("not implemented")
end

function pushforward(inc::CoveredClosedEmbedding, I::AbsIdealSheaf)
  Y = domain(inc)
  scheme(I) === Y || error("ideal sheaf is not defined on the domain of the embedding")
  X = codomain(inc)
  phi = covering_morphism(inc)
  ID = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(domain(phi))
    V = codomain(phi[U])
    ID[V] = pushforward(phi[U], I(U))
  end
  return IdealSheaf(X, ID, check=false)
end

function pushforward(inc::ClosedEmbedding, I::Ideal)
  Y = domain(inc)
  base_ring(I) === OO(Y) || error("ideal is not defined in the coordinate ring of the domain")
  X = codomain(inc)
  return ideal(OO(X), vcat(gens(image_ideal(inc)),
                           OO(X).(lifted_numerator.(gens(I))))
              )
end

########################################################################
# primary decomposition
########################################################################

@doc raw"""
    maximal_associated_points(I::AbsIdealSheaf)

Return a `Vector` of `AbsIdealSheaf`s corresponding to the non-embedded associated points of ``I`` on ``scheme(I)``.

Note:
For usability reasons these associated points are not encoded as a subscheme, but as the corresponding ideal sheaf defining the subscheme.

Background:
More generally, a point ``x`` on a scheme ``X`` associated to a quasi-coherent sheaf ``F`` is embedded, if it is the specialization of another associated point of ``F``.
Note that maximal associated points of an ideal sheaf on an affine scheme ``Spec(A)`` correspond to the minimal associated primes of the corresponding ideal in ``A``.
"""
function maximal_associated_points(I::AbsIdealSheaf; 
    covering=default_covering(scheme(I)),
    algorithm::Symbol=:GTZ
  )
  # The following would reroute to a more high-brow method with cleaner code.
  # It performs equally well in terms of time and memory consumption, but is disabled for the moment. 
  # return _maximal_associated_points(I; covering, use_decomposition_info=false)
  !isone(I) || return typeof(I)[]
  X = scheme(I)
  OOX = OO(X)

  charts_todo = copy(patches(covering))           ## todo-list of charts

  associated_primes_temp = Vector{IdDict{AbsAffineScheme, Ideal}}()  ## already identified components
                                                  ## may not yet contain all relevant charts. but
                                                  ## at least one for each identified component

  result = AbsIdealSheaf[]
  # run through all charts and try to match the components
  while length(charts_todo) > 0
    @vprint :MaximalAssociatedPoints 2 "$(length(charts_todo)) remaining charts to go through\n"
    U = pop!(charts_todo)
    !is_one(I(U)) || continue                        ## supp(I) might not meet all components
    components_here = minimal_primes(I(U); algorithm)
    
    ## run through all primes in MinAss(I(U)) and try to match them with previously found ones
    for comp in components_here
      matches = match_on_intersections(X,U,comp,associated_primes_temp,false)
      nmatches = length(matches)

      if nmatches == 0                             ## not found
        add_dict = IdDict{AbsAffineScheme,Ideal}()         ## create new dict
        add_dict[U] = comp                         ## and fill it
        push!(associated_primes_temp, add_dict)
      elseif nmatches == 1                         ## unique match, update it
        component_index = matches[1]
        associated_primes_temp[component_index][U] = comp
      else                                                ## more than one match, form union
        target_comp = pop!(matches)
        merge!(associated_primes_temp[target_comp], associated_primes_temp[x] for x in matches)
        deleteat!(associated_primes_temp,matches)
        associated_primes_temp[target_comp][U] = comp
      end
    end
  end

  # fill the gaps arising from a support not meeting a patch
  # Warning: This relies on the current implementation of `==` for 
  # `PrimeIdealSheafFromChart`s which cache intermediate results.
  for U in affine_charts(X)
    I_one = ideal(OOX(U),one(OOX(U)))
    for i in 1:length(associated_primes_temp)
      !haskey(associated_primes_temp[i],U) || continue
      associated_primes_temp[i][U] = I_one
    end
  end

  # make sure to return ideal sheaves, not dicts
  associated_primes_result = [IdealSheaf(X,associated_primes_temp[i],check=false) for i in 1:length(associated_primes_temp)]
  for Itemp in associated_primes_result
    set_attribute!(Itemp, :is_prime=>true)
  end
  return associated_primes_result
end

function radical_membership(x::RingElem, I::MPolyLocalizedIdeal)
  return radical_membership(lifted_numerator(x), saturated_ideal(I))
end

function radical_membership(x::RingElem, I::MPolyQuoLocalizedIdeal)
  return radical_membership(lifted_numerator(x), saturated_ideal(I))
end

# Proof of concept method
function _maximal_associated_points(
    I::AbsIdealSheaf; 
    covering=default_covering(scheme(I)), 
    use_decomposition_info::Bool=true,
    algorithm::Symbol=:GTZ
  )
  X = scheme(I)
  comps = AbsIdealSheaf[]
  dec_inf = decomposition_info(covering)
  for U in patches(covering)
    # A list of equations which indicate the locus in this chart 
    # which is *not* visible in "previous" charts. 
    loc_dec = elem_type(OO(U))[OO(U)(a) for a in dec_inf[U]]
    if use_decomposition_info && has_decomposition_info(covering)
      # If the following holds, everything is visible in other charts already.
      is_one(I(U) + ideal(OO(U), loc_dec)) && continue
    else
      # trivial charts can be skipped
      is_one(I(U)) && continue
    end
    #all(g->radical_membership(g, I(U)), loc_dec) && continue
    loc_primes = minimal_primes(I(U); algorithm)

    # Take only those not visible in other charts 
    use_decomposition_info && has_decomposition_info(covering) && filter!(p->all(g->g in p, loc_dec), loc_primes) 
    for p in loc_primes
      P = PrimeIdealSheafFromChart(X, U, p)
      P in comps && continue
      #any(q->q(U) == p, comps) && continue # p is just the local version of a component already collected
      # We found a new component! Keep it.
      push!(comps, P)
    end
  end

  # Manually fill up the cache
  if !use_decomposition_info # We can only do this if all we treated all components on all charts.
    for U in patches(covering)
      I_one = ideal(OO(U), one(OO(U)))
      for P in comps
        haskey(object_cache(P), U) && continue
        object_cache(P)[U] = I_one
      end
    end
  end

  return comps
end

@doc raw"""
    associated_points(I::AbsIdealSheaf)

Return a `Vector` of `AbsIdealSheaf`s corresponding to the associated points of ``I`` on ``scheme(I)``.

Note:
For usability reasons an associated point is not encoded as subscheme, but as the corresponding ideal sheaf defining the subscheme.

Background:
More generally, a point ``x`` on a scheme ``X`` is associated to a quasi-coherent sheaf ``F``, if the maximal ideal ``m_x`` is associated to the ``O_{X,x}``-module ``F_x``.
If ``U = Spec(A)`` is an affine open on a locally noetherian scheme ``X``, ``x \in U`` and ``p \in A`` the corresponding prime ideal, then ``p \in Ass(\Gamma(U,F))`` iff ``x \in Ass(F)``.

"""
function associated_points(I::AbsIdealSheaf)
  !isone(I) || return typeof(I)[]
  X = scheme(I)
  OOX = OO(X)
  charts_todo = copy(affine_charts(X))            ## todo-list of charts

  associated_primes_temp = Vector{IdDict{AbsAffineScheme, Ideal}}()  ## already identified components
                                                  ## may not yet contain all relevant charts. but
                                                  ## at least one for each identified component

# run through all charts and try to match the components
  while !iszero(length(charts_todo))
    U = pop!(charts_todo)
    !is_one(I(U)) || continue                        ## supp(I) might not meet all components
    components_here = [ a for (_,a) in primary_decomposition(I(U))]

## run through all primes in Ass(I(U)) and try to match them with previously found ones
    for comp in components_here
      matches = match_on_intersections(X,U,comp,associated_primes_temp,false)
      nmatches = length(matches)

      if nmatches == 0                             ## not found
        add_dict = IdDict{AbsAffineScheme,Ideal}()         ## create new dict
        add_dict[U] = comp                         ## and fill it
        push!(associated_primes_temp, add_dict)
      elseif nmatches == 1                         ## unique match, update it
        component_index = matches[1]
        associated_primes_temp[component_index][U] = comp
      else                                                ## more than one match, form union
        target_comp = pop!(matches)
        merge!(associated_primes_temp[target_comp], associated_primes_temp[x] for x in matches)
        deleteat!(associated_primes_temp,matches)
        associated_primes_temp[target_comp][U] = comp
      end
    end
  end

# fill the gaps arising from a support not meeting a patch
  for U in affine_charts(X)
    I_one = ideal(OOX(U),one(OOX(U)))
    for i in 1:length(associated_primes_temp)
      !haskey(associated_primes_temp[i],U) || continue
      associated_primes_temp[i][U] = I_one
    end
  end

# make sure to return ideal sheaves, not dicts
  associated_primes_result = [IdealSheaf(X,associated_primes_temp[i],check=false) for i in 1:length(associated_primes_temp)]
  for Itemp in associated_primes_result
    set_attribute!(Itemp, :is_prime=>true)
  end
  return associated_primes_result
end

# Given a prime ideal I on an `affine_chart` U of X and a list 
# of dictionaries { V=>(some prime ideal) } representing prime 
# ideal sheaves on X, this function tries to match I with the 
# entries of the list. 
function match_on_intersections(
      X::AbsCoveredScheme,
      U::AbsAffineScheme,
      I::Union{<:MPolyIdeal, <:MPolyQuoIdeal, <:MPolyQuoLocalizedIdeal, <:MPolyLocalizedIdeal},
      associated_list::Vector{<:IdDict{<:AbsAffineScheme, <:Ideal}},
      check::Bool=true)
  @vprint :MaximalAssociatedPoints 2 "matching $(I) \n to $(length(associated_list))\n on $(U)\n"
  matches = Int[] # the indices of entries in the list matching I on U
  OOX = OO(X)
# run through all components in associated_list and try to match up I
  for i in 1:length(associated_list)
    match_found = false
    match_contradicted = false

## run through all known patches of the component
    for (V,IV) in associated_list[i]
      G = default_covering(X)[V,U]
      VU, UV = gluing_domains(G)
      if UV isa AffineSchemeOpenSubscheme && VU isa AffineSchemeOpenSubscheme
        # This first case is probably never triggered, because the type is hardly used anymore
        I_res = [OOX(U, UV[i])(I) for i in 1:ngens(UV)]
        IV_res = [OOX(V, UV[i])(IV) for i in 1:ngens(UV)]
        if all(i->(I_res[i] == IV_res[i]), 1:ngens(UV))
          match_found = !all(I->is_one(I), I_res)                               ## count only non-trivial matches
          check || break
        else
          match_contradicted = true
          check || break
        end
      elseif UV isa AbsAffineScheme && VU isa AbsAffineScheme
        # Restrict I to the gluing domain
        I_res = OOX(U,UV)(I)
        # Pull the other ideal to the gluing domain
        IV_res = OOX(V,UV)(IV)
        if (I_res == IV_res)
          match_found = !is_one(I_res)                               ## count only non-trivial matches
          check || break
        else
          match_contradicted = true
          check || break
        end
      else
        error("case not implemented")
      end
    end

## make sure we are working on consistent data
   @check begin
      if match_found && match_contradicted
        error("contradictory matching result!!")                     ## this should not be reached for ass. points
      end
    end

## update list of matches
    if match_found
      push!(matches, i)
    end
  end

  return matches
end

function (phi::Map{D, C})(I::Ideal) where {D<:Ring, C<:Ring}
  base_ring(I) === domain(phi) || error("ideal not defined over the domain of the map")
  R = domain(phi)
  S = codomain(phi)
  return ideal(S, phi.(gens(I)))
end

# Workaround for ambiguity
function (id::AbstractAlgebra.Generic.IdentityMap{D})(I::Ideal) where {D<:Ring}
  return I
end

# Necessary for removing ambiguities
function (phi::AbstractAlgebra.Generic.CompositeMap{D, C})(I::Ideal) where {D<:Ring, C<:Ring}
  base_ring(I) === domain(phi) || error("ideal not defined over the domain of the map")
  R = domain(phi)
  S = codomain(phi)
  return ideal(S, phi.(gens(I)))
end

function (phi::MPolyAnyMap{D, C})(I::MPolyIdeal) where {D<:MPolyRing, C<:Ring}
  base_ring(I) === domain(phi) || error("ideal not defined over the domain of the map")
  R = domain(phi)
  S = codomain(phi)
  return ideal(S, phi.(gens(I)))
end

function (phi::MPolyAnyMap{D, C})(I::MPolyQuoIdeal) where {D<:MPolyQuoRing, C<:Ring}
  base_ring(I) === domain(phi) || error("ideal not defined over the domain of the map")
  R = domain(phi)
  S = codomain(phi)
  return ideal(S, phi.(gens(I)))
end

function complement_of_prime_ideal(P::MPolyQuoIdeal)
  return complement_of_prime_ideal(saturated_ideal(P))
end

function complement_of_prime_ideal(P::MPolyQuoLocalizedIdeal)
  return complement_of_prime_ideal(saturated_ideal(P))
end

function complement_of_prime_ideal(P::MPolyLocalizedIdeal)
  return complement_of_prime_ideal(saturated_ideal(P))
end

radical(I::PrimeIdealSheafFromChart) = I

# TODO: This function should be removed for ideal sheaves! 
# Reason: There is no "generating set" for ideal sheaves and even if there was, 
# this is not what the function returns. Whatever it is doing should probably 
# be subsumed under `simplify` and `simlpify!`.
# Why not remove it straight away? @afkafkafk13 is using it in the resolutions of singularities. 
# We will talk about the removal on Monday, March 11, 2024.
function small_generating_set(II::AbsIdealSheaf)
  X = scheme(II)
  # If there is a simplified covering, do the calculations there.
  covering = (has_attribute(X, :simplified_covering) ? simplified_covering(X) : default_covering(X))
  ID = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(covering)
    ID[U] = ideal(OO(U), filter!(!iszero, OO(U).(small_generating_set(saturated_ideal(II(U))))))
  end
  return(IdealSheaf(X, ID, check = false))
end

###########################################################################
## show functions for Ideal sheaves
###########################################################################

# If we know things about the ideal sheaf, we print them
function Base.show(io::IO, I::AbsIdealSheaf)
  io = pretty(io)
  X = scheme(I)
  if get(io, :show_semi_compact, false)
    cov = Oscar._covering_for_printing(io, X)
    n = get(io, :label, "")
    _show_semi_compact(io, I, cov, n)
  else
    show_scheme = get(io, :show_scheme, true)
    if has_attribute(I, :dim) && has_attribute(X, :dim)
      z = dim(X) - dim(I) == 0 ? true : false
    else
      z = false
    end
    prim = get_attribute(I, :is_prime, false)
    if has_attribute(I, :name)
      print(io, get_attribute(I, :name))
    elseif is_terse(io)
      print(io, "Sheaf of ideals")
    else
      if get_attribute(I, :is_one, false)
        print(io, "Sheaf of unit ideals")
      elseif z
        print(io, "Sheaf of zero ideals")
      elseif prim
        print(io, "Sheaf of prime ideals")
      else
        print(io, "Sheaf of ideals")
      end
      if show_scheme
        print(io," on ", Lowercase(), X)
      end
    end
  end
end

function Base.show(io::IO, ::MIME"text/plain", I::PrimeIdealSheafFromChart)
  print(io, "Prime ideal sheaf on ", scheme(I), " extended from ", I.P, " on ", I.U)
end

function Base.show(io::IO, ::MIME"text/plain", I::SumIdealSheaf)
  io = pretty(io)
  print(io, "Sum of \n")
  print(io, Indent())
  for J in summands(I)
    print(io, J, "\n")
  end
  print(io, Dedent())
end

function Base.show(io::IO, ::MIME"text/plain", I::ProductIdealSheaf)
  io = pretty(io)
  print(io, "Product of \n")
  print(io, Indent())
  for J in factors(I)
    print(io, J, "\n")
  end
  print(io, Dedent())
end

function Base.show(io::IO, I::SumIdealSheaf)
  io = pretty(io)
  print(io, "Sum of \n")
  print(io, Indent())
  for J in summands(I)
    print(io, J, "\n")
  end
  print(io, Dedent())
end

function Base.show(io::IO, I::ProductIdealSheaf)
  io = pretty(io)
  print(io, "Product of \n")
  print(io, Indent())
  for J in factors(I)
    print(io, J, "\n")
  end
  print(io, Dedent())
end

function Base.show(io::IO, I::PrimeIdealSheafFromChart)
  io = pretty(io)
  print(io, "Prime ideal sheaf on ", 
        Lowercase(), scheme(I), " extended from ", 
        Lowercase(), I.P, " on ", 
        Lowercase(), I.U)
end

# This semi compact printing is used for nested printings, like in blow-up or
# for the description of Cartier divisors and algebraic cycles.
#
# We want to keep track of a given covering `voc`, for everything to be consistent. In
# case we may have several charts in the nest, we want to make sure to follow-up
# with the labels. Hence the string `n` allows one to do this.
# Usually, in morphisms printing, one would take "a" for the domain's charts
# and "b" for the codomain's ones.
#
# We take also care of left offsets when printing the labels - if there are more
# than 10 charts, this is necessary to have all the labels aligned on the right
function _show_semi_compact(io::IO, I::AbsIdealSheaf, cov::Covering, n::String)
  io = pretty(io)
  X = scheme(I)
  if has_attribute(I, :dim) && has_attribute(X, :dim)
    z = dim(X) - dim(I) == 0 ? true : false
  else
    z = false
  end
  prim = get_attribute(I, :is_prime, false)

  if get_attribute(I, :is_one, false)
    print(io, "Sheaf of unit ideals")
  elseif z
    print(io, "Sheaf of zero ideals")
  else
    # If there is a simplified covering, use it!
    if prim
      print(io, "Sheaf of prime ideals")
    else
      print(io, "Sheaf of ideals")
    end
    if length(cov) > 0
      l = ndigits(length(cov))
      print(io, " with restriction")
      length(cov) > 1 && print(io, "s")
      print(io, Indent())
      for (i, U) in enumerate(patches(cov))
        li = ndigits(i)
        println(io)
        print(io, " "^(l-li)*"$i"*n*": $(I(U))")
      end
      print(io, Dedent())
    end
  end
end

function Base.show(io::IO, ::MIME"text/plain", I::AbsIdealSheaf)
  io = pretty(io)
  X = scheme(I)
  cov = Oscar._covering_for_printing(io, X)
  # If there is a simplified covering, use it!
  println(io, "Sheaf of ideals")
  print(io, Indent(), "on ", Lowercase())
  show(IOContext(io, :show_semi_compact => true, :covering => cov), X)
  if length(cov) > 0
    l = ndigits(length(cov))
    println(io)
    print(io, Dedent(), "with restriction")
    length(cov) > 1 && print(io, "s")
    print(io, Indent())
    for (i, U) in enumerate(patches(cov))
      li = ndigits(i)
      println(io)
      print(io, " "^(l-li)*"$i: $(I(U))")
    end
    print(io, Dedent())
  end
end

function _separate_disjoint_components(comp::Vector{<:AbsIdealSheaf}; covering::Covering=default_covering(scheme(first(comp))))
  isempty(comp) && error("list of components must not be empty")
  X = scheme(first(comp))
  all(x->scheme(x) === X, comp) || error("components must be defined over the same scheme")
  isone(length(comp)) && return covering
  new_patches = Vector{AbsAffineScheme}()
  for U in patches(covering)
    isempty(U) && continue
    loc_comp = [I(U) for I in comp]
    loc_comp = [a for a in loc_comp if !isone(a)]
    if isempty(loc_comp) || isone(length(loc_comp))
      push!(new_patches, U)
      continue
    end
    cof = _cofactors(loc_comp)
    if isempty(cof)
      push!(new_patches, U)
    else
      new_patches = vcat(new_patches, [PrincipalOpenSubset(U, a) for a in cof])
    end
  end
  new_cov = Covering(new_patches)
  inherit_gluings!(new_cov, covering)
  return new_cov
end

function _cofactors(comp::Vector{<:Ideal})
  R = base_ring(first(comp))
  all(x->base_ring(x)===R, comp) || error("ideals must be defined over the same ring")
  n = length(comp)
  pairwise_cof = identity_matrix(R, n)
  for i in 1:n-1
    for j in i+1:n
      I = ideal(R, vcat(gens(comp[i]), gens(comp[j])))
      r = ngens(comp[i])
      s = ngens(comp[j])
      z = coordinates(one(R), I)
      x = z isa MatElem ? [z[1, k] for k in 1:r] : z[1:r]
      y = z isa MatElem ? [z[1, r+k] for k in 1:s] : z[r+1:r+s]
      pairwise_cof[i, j] = sum(x[k]*gen(comp[i], k) for k in 1:r; init=zero(R))
      pairwise_cof[j, i] = sum(y[k]*gen(comp[j], k) for k in 1:s; init=zero(R))
    end
  end
  result = [prod(pairwise_cof[1:n, i]) for i in 1:n]
  return result
end

function _one_patch_per_component(covering::Covering, comp::Vector{<:AbsIdealSheaf})
  new_patches2 = Vector{AbsAffineScheme}()
  patches_todo = copy(patches(covering))
  for P in comp
    # Find one patch in which this component is supported
    i = findfirst(U->!isone(P(U)), patches_todo)
    U = patches_todo[i]
    # Take this patch out of the list
    deleteat!(patches_todo, i)
    # Add it to the list of patches for the new covering
    push!(new_patches2, U)
    # For every other patch V in which P appears we do the following:
    # Replace V by the complement of the support of P.
    # This will not be affine in general, but can be covered by hypersurface
    # complements. Even though this may lead to many charts, they will be harmless
    # in the mext blowup.
    done = Int[]
    for (j, V) in enumerate(patches_todo)
      # Check whether P is visible in this patch; if not leave it
      isone(P(V)) && continue
      # Remember this patch to be done
      push!(done, j)
      sg = small_generating_set(P(V))
      new_patches2 = append!(new_patches2, [PrincipalOpenSubset(V,a) for a in sg])
      # TODO: Cache that P = 1 on all these new patches?
    end
    deleteat!(patches_todo, done)
  end
  new_patches2 = append!(new_patches2, patches_todo)
  new_cov = Covering(new_patches2)
  inherit_gluings!(new_cov, covering)
  return new_cov
end

function small_generating_set(I::MPolyLocalizedIdeal; algorithm::Symbol=:simple)
  get_attribute!(I, :small_generating_set) do
    L = base_ring(I)
    poly_ideal = pre_saturated_ideal(I)
    if algorithm == :simple
      # do nothing more
    elseif algorithm == :with_saturation
      poly_ideal = saturated_ideal(I)
    else
      error("algorithm keyword not recognized")
    end
    g = small_generating_set(poly_ideal)
    unique!(elem_type(L)[gg for gg in L.(g) if !iszero(gg)])
  end::Vector{elem_type(base_ring(I))} 
end

function saturation(I::AbsIdealSheaf, J::AbsIdealSheaf)
  X = scheme(I)
  K = IdDict{AbsAffineScheme, Ideal}()
  for U in affine_charts(X)
    K[U] = saturation(I(U), J(U))
  end
  return IdealSheaf(X, K, check=false)
end

function pushforward(f::AbsCoveredSchemeMorphism, II::AbsIdealSheaf)
  f_cov = covering_morphism(f)
  dom_cov = domain(f_cov)
  cod_cov = codomain(f_cov)
  ideal_dict = IdDict{AbsAffineScheme, Ideal}()
  for V in cod_cov
    f_loc = maps_with_given_codomain(f_cov, V)
    I_loc = [preimage(pullback(f), II(domain(f))) for f in f_loc]
    ideal_dict[V] = intersect(I_loc...)
  end
  return IdealSheaf(codomain(f), ideal_dict, check=true) #TODO: Set to false
end

function Base.:^(II::AbsIdealSheaf, k::IntegerUnion)
  k < 0 && error("negative powers of ideal sheaves are not allowed")
  if iszero(k)
    X = scheme(II)
    return IdealSheaf(X, IdDict{AbsAffineScheme, Ideal}([U => ideal(OO(U), one(OO(U))) for U in affine_charts(X)]), check=false)
  end
  isone(k) && return II
  b = div(k, 2)
  r = k - b
  return II^b * II^r
end

original_chart(P::PrimeIdealSheafFromChart) = P.U

########################################################################
# production of the ideals for the various types
########################################################################

### generic override for the restriction map
produce_restriction_map(I::AbsIdealSheaf, U::AbsAffineScheme, V::AbsAffineScheme) = OO(scheme(I))(U, V)

### IdealSheaf
function produce_object(F::IdealSheaf, U::AbsAffineScheme)
  X = scheme(F)
  OOX = F.OOX
  ID = F.ID
  # If U is an affine chart on which the ideal has already been described, take that.
  haskey(ID, U) && return ID[U]
  # Transferring from another chart did not work. That means 
  # I(U) is already prescribed on some refinement of U. We 
  # need to gather that information from all the patches involved
  # and assemble the ideal from there.
  V = [W for W in keys(ID) if has_ancestor(x->(x===U), W)] # gather all patches under U

  # Check for some SimplifiedAffineScheme lurking around
  if any(x->(x isa SimplifiedAffineScheme), V)
    i = findfirst(x->(x isa SimplifiedAffineScheme), V)
    W = V[i]
    _, g = identification_maps(W)
    return ideal(OO(U), pullback(g).(gens(ID[W])))
  end

  length(V) == 0 && return ideal(OO(U), one(OO(U))) # In this case really nothing is defined here.
  # Just return the unit ideal so that the 
  # associated subscheme is empty.
  result = ideal(OO(U), one(OO(U)))
  V = filter!(x->(x isa PrincipalOpenSubset && ambient_scheme(x) === U), V)
  for VV in V
    result = intersect(result, ideal(OO(U), gens(saturated_ideal(produce_object(F, VV)))))
  end
  return result
end

function produce_object(F::IdealSheaf, U::PrincipalOpenSubset)
  X = scheme(F)
  OOX = F.OOX
  ID = F.ID
  haskey(ID, U) && return ID[U]
  V = ambient_scheme(U)
  # In case the ambient_scheme is leading out of the admissible domain, 
  # this is a top-chart and we have to reconstruct from below.
  if !is_open_func(F)(V, space(F)) 
    V = [W for W in keys(ID) if has_ancestor(x->(x===U), W)] # gather all patches under U

    # Check for some SimplifiedAffineScheme lurking around
    if any(x->(x isa SimplifiedAffineScheme), V)
      i = findfirst(x->(x isa SimplifiedAffineScheme), V)
      W = V[i]
      _, g = identification_maps(W)
      return ideal(OO(U), pullback(g).(gens(ID[W])))
    end

    length(V) == 0 && return ideal(OO(U), one(OO(U))) # In this case really nothing is defined here.
    # Just return the unit ideal so that the 
    # associated subscheme is empty.
    result = ideal(OO(U), one(OO(U)))
    V = filter!(x->(x isa PrincipalOpenSubset && ambient_scheme(x) === U), V)
    for VV in V
      result = intersect(result, ideal(OO(U), gens(saturated_ideal(produce_object(F, VV)))))
    end
    return result
  end

  IV = F(V)::Ideal
  rho = OOX(V, U)
  IU = ideal(OO(U), rho.(gens(IV)))
  return IU
end

function produce_object(F::IdealSheaf, U::SimplifiedAffineScheme)
  X = scheme(F)
  OOX = F.OOX
  ID = F.ID
  haskey(ID, U) && return ID[U]
  V = original(U)
  # In case the original is leading out of the admissible domain, 
  # this is a top-chart and we have to reconstruct from below.
  if !is_open_func(F)(V, space(F)) 
    V = [W for W in keys(ID) if has_ancestor(x->(x===U), W)] # gather all patches under U

    # Check for some SimplifiedAffineScheme lurking around
    if any(x->(x isa SimplifiedAffineScheme), V)
      i = findfirst(x->(x isa SimplifiedAffineScheme), V)
      W = V[i]
      _, g = identification_maps(W)
      return ideal(OO(U), pullback(g).(gens(ID[W])))
    end

    length(V) == 0 && return ideal(OO(U), one(OO(U))) # In this case really nothing is defined here.
    # Just return the unit ideal so that the 
    # associated subscheme is empty.
    result = ideal(OO(U), one(OO(U)))
    V = filter!(x->(x isa PrincipalOpenSubset && ambient_scheme(x) === U), V)
    for VV in V
      result = intersect(result, ideal(OO(U), gens(saturated_ideal(produce_object(F, VV)))))
    end
    return result
  end
  IV = F(V)::Ideal
  rho = OOX(V, U)
  IU = ideal(OO(U), rho.(gens(IV)))
  return IU
end

### Some generic functionality to allow for the production of objects 
# to happen only on the `affine_charts` of a given scheme.
function produce_object(F::AbsIdealSheaf, U::AbsAffineScheme)
  X = scheme(F)

  # If this is an affine chart, delegate to a specialized production method
  if any(V->V===U, affine_charts(X))
    return produce_object_on_affine_chart(F, U)
  end

  # Otherwise, construct the object generically from the affine charts.
  V = __find_chart(U, default_covering(X))
  return OO(X)(V, U)(F(V))
end

### PrimeIdealSheafFromChart
function produce_object(F::PrimeIdealSheafFromChart, U2::AbsAffineScheme)
  # Initialize some local variables
  X = scheme(F)
  OOX = OO(X)
  P = F.P
  U = F.U

  # we are in the same ancestor tree, but on top of the defining chart
  if has_ancestor(x->(x===U2), U)
    iso = _flatten_open_subscheme(U, U2)
    iso_inv = inverse(iso)
    pb_P = pullback(iso_inv)(P)
    result = ideal(OO(U2), [g for g in OO(U2).(gens(saturated_ideal(pb_P))) if !iszero(g)])
    @hassert :IdealSheaves 1 is_one(result) || is_prime(result)
    return result
  end

  V = __find_chart(U, default_covering(X))
  # we are in the same ancestor tree, but somewhere else;
  # reconstruct from the root
  if has_ancestor(x->(x===V), U2)
    result = OOX(V, U2)(F(V))
    @hassert :IdealSheaves 1 is_one(result) || is_prime(result)
    return result
  end

  # we are in a different tree;
  # reconstruct from that root
  V2 = __find_chart(U2, default_covering(X))
  if haskey(object_cache(F), V2) && V2 !== U2
    result = OOX(V2, U2)(F(V2))
    @hassert :IdealSheaves 1 is_one(result) || is_prime(result)
    return result
  end

  F(V) # Fill the cache with at least one element

  fat = [W for W in keys(object_cache(F)) if any(x->x===W, affine_charts(X)) && !isone(F(W))]

  function complexity(X1::AbsAffineScheme)
    init = maximum(total_degree.(lifted_numerator.(gens(F(X1)))); init=0)
    glue = default_covering(X)[V, X1]
    if glue isa SimpleGluing || (glue isa LazyGluing && is_computed(glue))
      return init
    end
    return init + 1000
  end

  sort!(fat, by=complexity)
  for W in fat
    glue = default_covering(X)[W, V2]
    f, g = gluing_morphisms(glue)
    if glue isa SimpleGluing || (glue isa LazyGluing && first(gluing_domains(glue)) isa PrincipalOpenSubset)
      complement_equation(codomain(g)) in F(W) && continue # We know the ideal is prime. No need to saturate!
      I2 = F(codomain(g))
      I = pullback(g)(I2)
      I = ideal(OO(V2), lifted_numerator.(gens(I)))
      I = _iterative_saturation(I, lifted_numerator(complement_equation(domain(g))))
      result = OOX(V2, U2)(ideal(OO(V2), lifted_numerator.(gens(I))))
      @hassert :IdealSheaves 1 is_one(result) || is_prime(result)
      return result
    else
      Z = subscheme(W, F(W))
      pZ = preimage(g, Z, check=false)
      is_empty(pZ) && continue
      ZV = closure(pZ, V2, check=false)
      result = OOX(V2, U2)(ideal(OO(V2), [g for g in OO(V2).(small_generating_set(saturated_ideal(modulus(OO(ZV))))) if !iszero(g)]))
      @hassert :IdealSheaves 1 is_one(result) || is_prime(result)
      return result
    end
  end
  # If nothing pulls back to this chart, the ideal sheaf is trivial here.
  result = ideal(OO(U2), one(OO(U2)))
  return result
end


### SumIdealSheaf
summands(I::SumIdealSheaf) = I.summands

function produce_object(I::SumIdealSheaf, U::AbsAffineScheme)
  result = sum([a(U) for a in summands(I)]; init=ideal(OO(U), elem_type(OO(U))[]))
  # We need to eliminate zeroes manually
  return ideal(OO(U), filter!(!is_zero, gens(result)))
end

### ProductIdealSheaf
factors(I::ProductIdealSheaf) = I.factors

function produce_object(I::ProductIdealSheaf, U::AbsAffineScheme)
  return prod([a(U) for a in factors(I)]; init=ideal(OO(U), one(OO(U))))
end

### SimplifiedIdealSheaf
original_ideal_sheaf(I::SimplifiedIdealSheaf) = I.orig

function produce_object(I::SimplifiedIdealSheaf, U::AbsAffineScheme)
  g = OO(U).(small_generating_set(saturated_ideal(original_ideal_sheaf(I)(U))))
  return ideal(OO(U), filter!(!is_zero, g))
end

### PullbackIdealSheaf
morphism(I::PullbackIdealSheaf) = I.f
original_ideal_sheaf(I::PullbackIdealSheaf) = I.orig
underlying_presheaf(I::PullbackIdealSheaf) = I.Ipre

function produce_object(I::PullbackIdealSheaf, U::AbsAffineScheme)
  f = morphism(I)
  J = original_ideal_sheaf(I)
  f_cov = covering_morphism(f)
  dom = domain(f_cov)
  X = scheme(I)

  # The easy case: We can just pull back
  if any(x->x===U, patches(dom))
    f_loc = f_cov[U]
    V = codomain(f_loc)
    return pullback(f_loc)(original_ideal_sheaf(I)(V))
  end

  # We are in a chart below a patch in the domain covering
  if has_ancestor(x->any(y->y===x, patches(dom)), U)
    V = __find_chart(U, dom)
    return OO(X)(V, U)(I(V))
  end

  # We are in some other branch.
  V = __find_chart(U, default_covering(X))

  if V === U
    # Construct the ideal directly on the root
    subs = AbsAffineScheme[V for V in patches(dom) if has_ancestor(x->x===U, V)]
    length(subs) == 0 && return ideal(OO(U), one(OO(U))) # In this case really nothing is defined here.
    # Just return the unit ideal so that the 
    # associated subscheme is empty.
    result = ideal(OO(U), one(OO(U)))
    sub_surface = AbsAffineScheme[]
    for V in subs
      cut = false
      while !cut
        if V isa SimplifiedAffineScheme && original(V) !== U
          V = original(V)
          continue
        end
        if V isa PrincipalOpenSubset && ambient_scheme(V) !== U
          V = ambient_scheme(V)
          continue
        end
        cut = true
      end
      any(x->x===V, sub_surface) && continue
      push!(sub_surface, V)
    end

    if any(x->(x isa SimplifiedAffineScheme), sub_surface)
      i = findfirst(x->(x isa SimplifiedAffineScheme), sub_surface)
      W = sub_surface[i]
      _, g = identification_maps(W)
      return ideal(OO(U), pullback(g).(gens(I(W))))
    end

    for VV in sub_surface
      result = intersect(result, ideal(OO(U), gens(saturated_ideal(I(VV)))))
    end
    return result
  end

  # Infer the ideal from the root
  return OO(X)(V, U)(I(V))
end

########################################################################
# Cheap previews of an ideal sheaf
#
# In some applications it is already sufficient to get one's hands on 
# some subideal J ⊂ I on an open patch U. For instance, if one wants to 
# know whether I + K is the unit ideal on U: If this already holds for J + K, 
# then we do not need to go through the hustle of computing I.
########################################################################

# The default knows nothing about the ideal sheaf, so we do nothing special
function cheap_sub_ideal(II::AbsIdealSheaf, U::AbsAffineScheme)
  return II(U)
end

function cheap_sub_ideal(II::SumIdealSheaf, U::AbsAffineScheme)
  return sum(cheap_sub_ideal(J, U) for J in summands(II); init = ideal(OO(U), elem_type(OO(U))[]))
end

function cheap_sub_ideal(II::PrimeIdealSheafFromChart, U2::AbsAffineScheme)
  U2 === original_chart(II) && return II(U2)
  haskey(object_cache(II), U2) && return II(U2)

  haskey(II.cheap_sub_ideals, U2) && return II.cheap_sub_ideals[U2]

  # A modification of the code in produce_object

  # Initialize some local variables
  X = scheme(II)
  OOX = OO(X)
  U = original_chart(II)

  # we are in the same ancestor tree, but on top of the defining chart
  if has_ancestor(x->(x===U2), U)
    iso = _flatten_open_subscheme(U, U2)  # an embedding U -> V \subseteq U2
    iso_inv = inverse(iso)
    pb_P = pullback(iso_inv)(P)
    # avoids a saturation by discarding denominators but only produces a subideal
    result = ideal(OO(U2), [g for g in OO(U2).(lifted_numerator.(gens(pb_P))) if !iszero(g)])
    II.cheap_sub_ideals[U2] = result
    return result
  end

  V = __find_chart(U, default_covering(X))
  # we are in the same ancestor tree, but somewhere else;
  # reconstruct from the root
  if has_ancestor(x->(x===V), U2)
    result = OOX(V, U2)(cheap_sub_ideal(II, V))
    II.cheap_sub_ideals[U2] = result
    return result
  end

  # we are in a different tree;
  # reconstruct from that root
  V2 = __find_chart(U2, default_covering(X))
  if haskey(object_cache(II), V2) && V2 !== U2
    result = OOX(V2, U2)(II(V2))
    II.cheap_sub_ideals[U2] = result
    return result
  end

  II(V) # Fill the cache with at least one element

  fat = [W for W in keys(object_cache(II)) if any(x->x===W, affine_charts(X)) && !isone(II(W))]

  function complexity(X1::AbsAffineScheme)
    init = maximum(total_degree.(lifted_numerator.(gens(II(X1)))); init=0)
    glue = default_covering(X)[V, X1]
    if glue isa SimpleGluing || (glue isa LazyGluing && is_computed(glue))
      return init
    end
    return init + 1000
  end

  ext = [(U, complexity(U)) for U in fat]
  sort!(ext, by=x->x[2])
  fat = [U for (U, _) in ext]
  count = 0
  for W in fat
    glue = default_covering(X)[W, V2]
    if glue isa SimpleGluing || (glue isa LazyGluing && first(gluing_domains(glue)) isa PrincipalOpenSubset)
      f, g = gluing_morphisms(glue)
      I2 = II(codomain(g))
      complement_equation(codomain(g)) in I2 && continue
      I = pullback(g)(I2)
    # isone(I) && continue
      result = OOX(V2, U2)(ideal(OO(V2), lifted_numerator.(gens(I))))
      II.cheap_sub_ideals[U2] = result
      return result
    else
      f, g = gluing_morphisms(glue)
      I2 = II(codomain(g))
      Z = subscheme(W, II(W))
      pZ = preimage(g, Z, check=false)
      is_empty(pZ) && continue
      ZV = closure(pZ, V2, check=false)
      result = OOX(V2, U2)(ideal(OO(V2), [g for g in OO(V2).(lifted_numerator.(gens(modulus(OO(ZV))))) if !iszero(g)]))
      II.cheap_sub_ideals[U2] = result
      return result
    end
  end
  # If nothing pulls back to this chart, the ideal sheaf is trivial here.
  result = ideal(OO(U2), one(OO(U2)))
  II.cheap_sub_ideals[U2] = result
  return result
end

function cheap_sub_ideal(I::PullbackIdealSheaf, U::AbsAffineScheme)
  f = morphism(I)
  J = original_ideal_sheaf(I)
  f_cov = covering_morphism(f)
  dom = domain(f_cov)
  X = scheme(I)

  # The easy case: We can just pull back
  if any(x->x===U, patches(dom))
    f_loc = f_cov[U]
    V = codomain(f_loc)
    return pullback(f_loc)(cheap_sub_ideal(original_ideal_sheaf(I), V))
  end

  # We are in a chart below a patch in the domain covering
  if has_ancestor(x->any(y->y===x, patches(dom)), U)
    V = __find_chart(U, dom)
    return OO(X)(V, U)(cheap_sub_ideal(I, V))
  end

  # We are in some other branch.
  V = __find_chart(U, default_covering(X))

  if V === U
    # Construct the ideal directly on the root
    subs = AbsAffineScheme[V for V in patches(dom) if has_ancestor(x->x===U, V)]
    length(subs) == 0 && return ideal(OO(U), one(OO(U))) # In this case really nothing is defined here.
    # Just return the unit ideal so that the 
    # associated subscheme is empty.
    result = ideal(OO(U), one(OO(U)))
    sub_surface = AbsAffineScheme[]
    for V in subs
      cut = false
      while !cut
        if V isa SimplifiedAffineScheme && original(V) !== U
          V = original(V)
          continue
        end
        if V isa PrincipalOpenSubset && ambient_scheme(V) !== U
          V = ambient_scheme(V)
          continue
        end
        cut = true
      end
      any(x->x===V, sub_surface) && continue
      push!(sub_surface, V)
    end

    if any(x->(x isa SimplifiedAffineScheme), sub_surface)
      i = findfirst(x->(x isa SimplifiedAffineScheme), sub_surface)
      W = sub_surface[i]
      _, g = identification_maps(W)
      return ideal(OO(U), pullback(g).(gens(cheap_sub_ideal(I, W))))
    end

    for VV in sub_surface
      result = intersect(result, ideal(OO(U), gens(saturated_ideal(cheap_sub_ideal(I, VV)))))
    end
    return result
  end

  # Infer the ideal from the root
  return OO(X)(V, U)(cheap_sub_ideal(I, V))
end

function sub(I::AbsIdealSheaf)
  X = scheme(I)
  inc = CoveredClosedEmbedding(X, I)
  return domain(inc), inc
end

########################################################################
# Radicals of ideal sheaves                                            #
########################################################################

underlying_presheaf(rad::RadicalOfIdealSheaf) = rad.Ipre
original_ideal_sheaf(rad::RadicalOfIdealSheaf) = rad.orig

function produce_object(rad::RadicalOfIdealSheaf, U::AbsAffineScheme)
  result = radical(original_ideal_sheaf(rad)(U))
  set_attribute!(result, :is_radical=>true) # Necessary? Or should the radical computation take care of this?
  return result
end

function is_subset(I::AbsIdealSheaf, rad::RadicalOfIdealSheaf)
  X = scheme(rad)
  @assert X === scheme(I) "ideal sheaves do not live on the same scheme"
  for U in affine_charts(X)
    all(radical_membership(g, rad(U)) for g in gens(I(U))) || return false
  end
  return true
end

function is_subset(I::PrimeIdealSheafFromChart, rad::RadicalOfIdealSheaf)
  X = scheme(rad)
  @assert X === scheme(I) "ideal sheaves do not live on the same scheme"
  U = original_chart(I)
  return all(g->radical_membership(g, rad(U)), gens(I(U)))
end

function radical(I::AbsIdealSheaf)
  result = RadicalOfIdealSheaf(I)
  return result
end

is_radical(rad::RadicalOfIdealSheaf) = true

########################################################################
# custom functionality for prime ideal sheaves from chart
########################################################################

function is_subset(P::PrimeIdealSheafFromChart, I::AbsIdealSheaf)
  X = scheme(P)
  @assert X === scheme(I)
  U = original_chart(P)
  return is_subset(P(U), I(U))
end

function ==(P::PrimeIdealSheafFromChart, Q::PrimeIdealSheafFromChart)
  X = scheme(P)
  @assert X === scheme(Q)
  U = original_chart(P)
  V = original_chart(Q)

  U === V && return P(U) == Q(U)
  haskey(object_cache(Q), U) && return Q(U) == P(U)
  haskey(object_cache(P), V) && return Q(V) == P(V)
  for (W1, PP) in object_cache(P)
    W1 in keys(object_cache(Q)) || continue
    is_one(PP) && continue
    return PP == Q(W1)
  end

  if any(x->x===U, affine_charts(X)) && any(x->x===V, affine_charts(X))
    gg = default_covering(X)[U, V]
    UV, VU = gluing_domains(gg)
    h_V = complement_equation(UV)
    h_U = complement_equation(VU)
    h_V in P(U) && !(h_U in Q(V)) && return false
    if P(UV) == Q(UV)
      object_cache(P)[V] = Q(V)
      object_cache(Q)[U] = P(U)
      return true
    end
  end

  return !is_one(Q(U)) && P(U) == Q(U)
end

function _pullback_along_base_change(f::AbsCoveredSchemeMorphism, D::AbsWeilDivisor)
  scheme(D) === codomain(f) || error("divisor must live on the codomain of the map")
  comp_dict = IdDict{AbsIdealSheaf, elem_type(coefficient_ring(D))}()
  for I in components(D)
    comp_dict[pullback(f, I)] = D[I]
  end
  return WeilDivisor(AlgebraicCycle(domain(f), coefficient_ring(D), comp_dict; check=false); check=false)
end

########################################################################
# Singular locus ideal sheaf
########################################################################

function produce_object_on_affine_chart(II::SingularLocusIdealSheaf, U::AbsAffineScheme)
  return radical(produce_non_radical_ideal_of_singular_locus(II, U))
end

function produce_non_radical_ideal_of_singular_locus(II::SingularLocusIdealSheaf, U::AbsAffineScheme)
  if !haskey(II.non_radical_ideals, U)
    if is_one(focus(II)(U))
      II.non_radical_ideals[U] = focus(II)(U)
      return focus(II)(U)
    end
    X = scheme(II)
    @assert any(V===U for V in affine_charts(X))
    UU = simplify(U)
    id, id_inv = identification_maps(UU)

    # Prepare for shortcuts in the computation
    has_attribute(X, :is_equidimensional) && get_attribute(X, :is_equidimensional)===true && set_attribute!(UU, :is_equidimensional=>true)
    has_attribute(X, :is_irreducible) && get_attribute(X, :is_irreducible)===true && set_attribute!(UU, :is_irreducible=>true)
    has_attribute(X, :is_reduced) && get_attribute(X, :is_reduced)===true && set_attribute!(UU, :is_reduced=>true)
    S, inc_S = singular_locus(UU; compute_radical=false)
    res = ideal(OO(U), pullback(id_inv).(gens(image_ideal(inc_S)))) + focus(II)(U)
    II.non_radical_ideals[U] = res
  end
  return II.non_radical_ideals[U]::Ideal
end

is_one(II::SingularLocusIdealSheaf) = all(is_one(produce_non_radical_ideal_of_singular_locus(II, U)) for U in affine_charts(scheme(II)))

in_radical(J::AbsIdealSheaf, II::SingularLocusIdealSheaf) = all(all(radical_membership(g, produce_non_radical_ideal_of_singular_locus(II, U)) for g in gens(J(U))) for U in affine_charts(scheme(J)))

