export IdealSheaf
export extend!
export ideal_sheaf
export order_on_divisor
export scheme
export subscheme

### Forwarding the presheaf functionality
underlying_presheaf(I::IdealSheaf) = I.I

# an alias for the user's convenience
scheme(I::IdealSheaf) = space(I)

@doc raw"""
    IdealSheaf(X::AbsProjectiveScheme, g::Vector{<:RingElem})

Create the ideal sheaf on the covered scheme of ``X`` which is
generated by the dehomogenization of the homogeneous elements in `g`
in every chart.

**Note:** When taking the pullback of an `IdealSheaf` ``‚Ñê`` along a morphism
``f : X ‚Üí Y``, what is actually computed, is ``f‚Åª¬π ‚Ñê ‚ãÖ ùí™_{X}``.
To obtain the pullback of ``‚Ñê`` as a sheaf of modules (i.e. ``f* ‚Ñê``),
convert ``‚Ñê`` into a `CoherentSheaf` on ``Y``, first.

# Examples
```jldoctest
julia> P, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> I = ideal([x^3-y^2*z]);

julia> Y = proj(P)
Projective space of dimension 2
  over rational field
with homogeneous coordinates [x, y, z]

julia> IdealSheaf(Y, I)
Sheaf of ideals
  on scheme over QQ covered with 3 patches
    1: [(y//x), (z//x)]   affine 2-space
    2: [(x//y), (z//y)]   affine 2-space
    3: [(x//z), (y//z)]   affine 2-space
with restrictions
  1: Ideal (-(y//x)^2*(z//x) + 1)
  2: Ideal ((x//y)^3 - (z//y))
  3: Ideal ((x//z)^3 - (y//z)^2)
```
"""
function IdealSheaf(X::AbsProjectiveScheme, I::MPolyIdeal)
  S = base_ring(I)
  S === homogeneous_coordinate_ring(X) || error("ideal does not live in the graded coordinate ring of the scheme")
  g = gens(I)
  X_covered = covered_scheme(X)
  C = default_covering(X_covered)
  r = relative_ambient_dimension(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(C)
    I[U] = ideal(OO(U), dehomogenization_map(X, U).(g))
  end
  return IdealSheaf(X_covered, I, check=true)
end

function IdealSheaf(X::AbsProjectiveScheme, I::MPolyQuoIdeal)
  S = base_ring(I)
  S === homogeneous_coordinate_ring(X) || error("ideal does not live in the graded coordinate ring of the scheme")
  g = gens(I)
  X_covered = covered_scheme(X)
  C = default_covering(X_covered)
  r = relative_ambient_dimension(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(C)
    I[U] = ideal(OO(U), dehomogenization_map(X, U).(g))
  end
  return IdealSheaf(X_covered, I, check=true)
end

ideal_sheaf(X::AbsProjectiveScheme, I::MPolyIdeal) = IdealSheaf(X, I)
ideal_sheaf(X::AbsProjectiveScheme, I::MPolyQuoIdeal) = IdealSheaf(X, I)

function IdealSheaf(
    X::AbsProjectiveScheme,
    g::MPolyDecRingElem
  )
  return IdealSheaf(X, [g])
end

function IdealSheaf(
    X::AbsProjectiveScheme,
    g::MPolyQuoRingElem
  )
  return IdealSheaf(X, [g])
end

ideal_sheaf(X::AbsProjectiveScheme, g::MPolyDecRingElem) = IdealSheaf(X, g)
ideal_sheaf(X::AbsProjectiveScheme, g::MPolyQuoRingElem) = IdealSheaf(X, g)

function IdealSheaf(
    X::AbsProjectiveScheme,
    g::Vector{RingElemType}
  ) where {RingElemType<:MPolyDecRingElem}
  X_covered = covered_scheme(X)
  r = relative_ambient_dimension(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(default_covering(X_covered))
    I[U] = ideal(OO(U), dehomogenization_map(X, U).(g))
  end
  return IdealSheaf(X_covered, I, check=false)
end

function IdealSheaf(
    X::AbsProjectiveScheme,
    g::Vector{RingElemType}
  ) where {RingElemType<:MPolyQuoRingElem}
  X_covered = covered_scheme(X)
  r = relative_ambient_dimension(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(default_covering(X_covered))
    I[U] = ideal(OO(U), dehomogenization_map(X, U).(g))
  end
  return IdealSheaf(X_covered, I, check=false)
end

ideal_sheaf(X::AbsProjectiveScheme, g::Vector{RingElemType}) where {RingElemType<:MPolyDecRingElem} = IdealSheaf(X, g)
ideal_sheaf(X::AbsProjectiveScheme, g::Vector{RingElemType}) where {RingElemType<:MPolyQuoRingElem} = IdealSheaf(X, g)



# this constructs the zero ideal sheaf
function IdealSheaf(X::AbsCoveredScheme)
  C = default_covering(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in basic_patches(C)
    I[U] = ideal(OO(U), elem_type(OO(U))[])
  end
  return IdealSheaf(X, I, check=false)
end

@doc raw"""
    ideal_sheaf(X::AbsCoveredScheme)

See the documentation for `IdealSheaf`.
"""
ideal_sheaf(X::AbsCoveredScheme) = IdealSheaf(X)

# set up an ideal sheaf by automatic extension
# from one prescribed set of generators on one affine patch
@doc raw"""
    IdealSheaf(X::AbsCoveredScheme, U::AbsAffineScheme, g::Vector)

Set up an ideal sheaf on ``X`` by specifying a set of generators ``g``
on one affine open subset ``U`` among the `basic_patches` of the
`default_covering` of ``X``.

**Note:** The set ``U`` has to be dense in its connected component
of ``X`` since otherwise, the extension of the ideal sheaf to other
charts can not be inferred.
"""
function IdealSheaf(X::AbsCoveredScheme, U::AbsAffineScheme, g::Vector{RET}) where {RET<:RingElem}
  C = default_covering(X)
  for f in g
    parent(f) === OO(U) || error("the generators do not belong to the correct ring")
  end
  if !any(x->x===U, patches(C))
    inc_U_flat = _flatten_open_subscheme(U, default_covering(X))
    U_flat = codomain(inc_U_flat)::PrincipalOpenSubset
    V = ambient_scheme(U_flat)
    J = saturated_ideal(pullback(inverse(inc_U_flat))(ideal(OO(U), g)))
    return IdealSheaf(X, V, OO(V).(gens(J)))
  end
  D = IdDict{AbsAffineScheme, Ideal}()
  D[U] = ideal(OO(U), g)
  D = extend!(C, D)
  I = IdealSheaf(X, D, check=false)
  return I
end

ideal_sheaf(X::AbsCoveredScheme, U::AbsAffineScheme, g::Vector{RET}) where {RET<:RingElem} = IdealSheaf(X, U, g)

@doc raw"""
    IdealSheaf(Y::AbsCoveredScheme,
        phi::CoveringMorphism{<:Any, <:Any, <:ClosedEmbedding}
    )

Internal method to create an ideal sheaf from a `CoveringMorphism`
of `ClosedEmbedding`s; return the ideal sheaf describing the images
of the local morphisms.
"""
function IdealSheaf(Y::AbsCoveredScheme,
    phi::CoveringMorphism{<:Any, <:Any, <:ClosedEmbedding};
    check::Bool=true
  )
  maps = morphisms(phi)
  V = [codomain(ff) for ff in values(maps)]
  dict = IdDict{AbsAffineScheme, Ideal}()
  V = unique!(V)
  for W in V
    i = findall(x->(codomain(x) == W), maps)
    dict[W] = image_ideal(maps[first(i)])
  end
#  for U in affine_charts(Y)
#    if U in V
#      i = findall(x->(codomain(x) == U), maps)
#      dict[U] = image_ideal(maps[first(i)])
#    else
#      dict[U] = ideal(OO(U), one(OO(U)))
#    end
#  end
  return IdealSheaf(Y, dict, check=check)
end


# pullback of an ideal sheaf for internal use between coverings of the same scheme
#function (F::CoveringMorphism)(I::IdealSheaf)
#  X = scheme(I)
#  D = codomain(F)
#  D == covering(I) || error("ideal sheaf is not defined on the correct covering")
#  C = domain(F)
#  new_dict = Dict{AbsAffineScheme, Ideal}()
#
#  # go through the patches of C and pull back the generators
#  # whenever they are defined on the target patch
#  for U in patches(C)
#    f = F[U]
#    V = codomain(f)
#    # for the basic patches here
#    if haskey(ideal_dict(I), V)
#      new_dict[U] = ideal(OO(U), pullback(f).(I[V]))
#    end
#    # check for affine refinements
#    if haskey(affine_refinements(D), V)
#      Vrefs = affine_refinements(D)[V]
#      # pull back the refinement
#      for W in Vrefs
#        h = pullback(f).(gens(W))
#        # take care to discard possibly empty preimages of patches
#        j = [i for i in 1:length(h) if !iszero(h)]
#        Wpre = AffineSchemeOpenSubscheme(U, h[j])
#        add_affine_refinement!(C, Wpre)
#        for i in 1:length(j)
#          if haskey(ideal_dict(I), Wpre[i])
#            new_dict[Wpre[i]] = lifted_numerator.(pullback(f).(I[V[j[i]]]))
#          end
#        end
#      end
#    end
#  end
#  return IdealSheaf(X, C, new_dict)
#end

function +(I::IdealSheaf, J::IdealSheaf)
  X = space(I)
  X == space(J) || error("ideal sheaves are not defined over the same scheme")
  new_dict = IdDict{AbsAffineScheme, Ideal}()
  CI = default_covering(X)
  for U in patches(CI)
    new_dict[U] = I(U) + J(U)
  end
  return IdealSheaf(X, new_dict, check=false)
end

function *(I::IdealSheaf, J::IdealSheaf)
  X = space(I)
  X == space(J) || error("ideal sheaves are not defined over the same scheme")
  new_dict = IdDict{AbsAffineScheme, Ideal}()
  CI = default_covering(X)
  for U in patches(CI)
    new_dict[U] = I(U) * J(U)
  end
  return IdealSheaf(X, new_dict, check=false)
end

@doc raw"""
    simplify!(I::IdealSheaf)

Replaces the set of generators of the ideal sheaf by a minimal
set of random linear combinations in every affine patch.
"""
function simplify!(I::IdealSheaf)
  new_ideal_dict = IdDict{AbsAffineScheme, Ideal}()
  for U in basic_patches(default_covering(space(I)))
    new_ideal_dict[U] = ideal(OO(U), small_generating_set(I(U)))
    #=
    n = ngens(I(U))
    n == 0 && continue
    R = ambient_coordinate_ring(U)
    kk = coefficient_ring(R)
    new_gens = elem_type(OO(U))[]
    K = ideal(OO(U), new_gens)
    while !issubset(I(U), K)
      new_gen = dot([rand(kk, 1:100) for i in 1:n], gens(I(U)))
      while new_gen in K
        new_gen = dot([rand(kk, 1:100) for i in 1:n], gens(I(U)))
      end
      push!(new_gens, new_gen)
      K = ideal(OO(U), new_gens)
    end
    Oscar.object_cache(underlying_presheaf(I))[U] = K
    =#
  end
  I.I.obj_cache = new_ideal_dict # for some reason the line below led to compiler errors.
  #Oscar.object_cache(underlying_presheaf(I)) = new_ideal_dict
  return I
end

@doc """
    subscheme(I::IdealSheaf)

For an ideal sheaf ``‚Ñê`` on an `AbsCoveredScheme` ``X`` return
the subscheme ``Y ‚äÇ X`` given by the zero locus of ``‚Ñê``.
"""
function subscheme(I::IdealSheaf)
  X = space(I)
  C = default_covering(X)
  new_patches = [subscheme(U, I(U)) for U in basic_patches(C)]
  new_gluings = IdDict{Tuple{AbsAffineScheme, AbsAffineScheme}, AbsGluing}()
  decomp_dict = IdDict{AbsAffineScheme, Vector{RingElem}}()
  for (U, V) in keys(gluings(C))
    i = C[U]
    j = C[V]
    Unew = new_patches[i]
    Vnew = new_patches[j]
    G = C[U, V]
    #new_gluings[(Unew, Vnew)] = restrict(C[U, V], Unew, Vnew, check=false)
    new_gluings[(Unew, Vnew)] = LazyGluing(Unew, Vnew, _compute_restriction,
                                             RestrictionDataClosedEmbedding(C[U, V], Unew, Vnew)
                                            )
    #new_gluings[(Vnew, Unew)] = inverse(new_gluings[(Unew, Vnew)])
    new_gluings[(Vnew, Unew)] = LazyGluing(Vnew, Unew, inverse, new_gluings[(Unew, Vnew)])
  end
  Cnew = Covering(new_patches, new_gluings, check=false)

  # Inherit decomposition information if applicable
  if has_decomposition_info(C)
    for k in 1:length(new_patches)
      U = new_patches[k]
      V = basic_patches(C)[k]
      set_decomposition_info!(Cnew, U, elem_type(OO(U))[OO(U)(a, check=false) for a in decomposition_info(C)[V]])
    end
  end
  return CoveredScheme(Cnew)
end


@doc raw"""
    extend!(C::Covering, D::Dict{AffineSchemeType, IdealType}) where {AffineSchemeType<:AffineScheme, IdealType<:Ideal}

For ``C`` a covering and ``D`` a dictionary holding vectors of
polynomials on affine patches of ``C`` this function extends the
collection of polynomials over all patches in a compatible way;
meaning that on the overlaps the restrictions of either two sets
of polynomials coincides.

This proceeds by crawling through the gluing graph and taking
closures in the patches ``U‚±º`` of the subschemes
``Z·µ¢‚±º = V(I) ‚à© U·µ¢ ‚à© U‚±º`` in the intersection with a patch ``U·µ¢``
on which ``I`` had already been described.

Note that the covering `C` is not modified.
"""
function extend!(
    C::Covering, D::IdDict{AbsAffineScheme, Ideal};
    all_dense::Bool=false
  )
  all(x->any(y->x===y, patches(C)), keys(D)) || error("ideals must be given on the `patches` of the covering")
  # push all nodes on which I is known in a heap
  visited = collect(keys(D))
  # The nodes which can be used for extension
  fat = AbsAffineScheme[U for U in visited if !isone(D[U])]
  # Nodes which are leafs
  flat = AbsAffineScheme[U for U in visited if isone(D[U])]
  # Nodes to which we might need to extend
  leftover = AbsAffineScheme[U for U in patches(C) if !(U in keys(D))]
  # Nodes to which we can extend in one step
  neighbors = AbsAffineScheme[U for U in leftover if any(V->haskey(gluings(C), (U, V)), fat)]
  # All other nodes
  leftover = AbsAffineScheme[U for U in leftover if !any(W->W===U, neighbors)]
  while length(neighbors) > 0
    good_pairs = Vector{Tuple{AbsAffineScheme, AbsAffineScheme}}()
    for V in neighbors
      for U in fat
        G = C[U, V]
        if (G isa SimpleGluing || (G isa LazyGluing && is_computed(G)))
          push!(good_pairs, (U, V))
        end
      end
    end

    # Initialize some variables
    U = first(visited) # The visited node
    V = first(visited) # The neighboring node for which we do the extension
    if !isempty(good_pairs)
      # In case we find a good neighboring pair, use that
      (U, V) = first(good_pairs)
    else
      # If there is no good neighboring pair, compute a new gluing
      V = first(neighbors)
      k = findfirst(U->haskey(gluings(C), (U, V)), fat)
      U = fat[k]
    end
    f, _ = gluing_morphisms(C[V, U])
    if C[V, U] isa SimpleGluing || (C[V, U] isa LazyGluing && first(gluing_domains(C[V, U])) isa PrincipalOpenSubset)

      # Take a shortcut if possible
      _, UV = gluing_domains(C[V, U])
      if isone(ideal(OO(UV), OO(UV).(gens(D[U]), check=false)))
        D[V] = ideal(OO(V), one(OO(V)))
        # Register this patch as a leaf
        push!(flat, V)
        # Update the neighbors
        neighbors = [W for W in neighbors if !(W===V)]
        continue
      end

      # if not, extend D to this patch
      f, _ = gluing_morphisms(C[V, U])
      pbI_gens = pullback(f).([OO(codomain(f))(x, check=false) for x in gens(D[U])])
      J = ideal(OO(V), lifted_numerator.(pbI_gens))
      #J_sat = saturation(J, ideal(OO(V), complement_equation(domain(f))))
      J_sat = _iterative_saturation(J, lifted_numerator(complement_equation(domain(f))))
      D[V] = J_sat
    else
      Z = subscheme(U, D[U])
      pZ = preimage(f, Z, check=false)
      ZV = closure(pZ, V, check=false)
      D[V] = ideal(OO(V), [g for g in OO(V).(small_generating_set(saturated_ideal(modulus(OO(ZV))))) if !iszero(g)])
    end

    # Update the neighbors
    neighbors = [W for W in neighbors if !(W===V)]
    # Put that new node in the correct list
    if isone(D[V])
      push!(flat, V)
    else
      push!(fat, V)
      for W in leftover
        if haskey(gluings(C), (V, W))
          push!(neighbors, W)
        end
      end
      leftover = [W for W in leftover if !any(x->x===W, neighbors)]
    end
  end
  for U in basic_patches(C)
    if !haskey(D, U)
      D[U] = ideal(OO(U), one(OO(U)))
    end
  end
  return D
end

function _iterative_saturation(I::Ideal, f::RingElem)
  fac = factor(f)
  R = base_ring(I)
  for (u, k) in fac
    I = saturation(I, ideal(R, u))
  end
  return I
end

function ==(I::IdealSheaf, J::IdealSheaf)
  I === J && return true
  X = space(I)
  X == space(J) || return false
  for U in basic_patches(default_covering(X))
    is_subset(I(U), J(U)) && is_subset(J(U), I(U)) || return false
  end
  return true
end

function is_subset(I::IdealSheaf, J::IdealSheaf)
  X = space(I)
  X === space(J) || return false
  for U in basic_patches(default_covering(X))
    is_subset(I(U), J(U)) || return false
  end
  return true
end

# prepares a refinement C' of the covering for the ideal sheaf I
# such that I can be generated by a regular sequence defining a smooth
# local complete intersection subscheme in every patch U of C' and
# returns the ideal sheaf with those generators on C'.
#function as_smooth_lci(
#    I::IdealSheaf;
#    verbose::Bool=false,
#    check::Bool=true,
#    codimension::Int=dim(scheme(I))-dim(subscheme(I)) #assumes both scheme(I) and its subscheme to be equidimensional
#  )
#  X = scheme(I)
#  C = covering(I)
#  AffineSchemeType = affine_patch_type(C)
#  PolyType = poly_type(AffineSchemeType)
#  new_gens_dict = Dict{AffineSchemeType, Vector{PolyType}}()
#  for U in patches(C)
#    V, spec_dict = as_smooth_lci(U, I[U],
#                                 verbose=verbose,
#                                 check=check,
#                                 codimension=codimension)
#    add_affine_refinement!(C, V)
#    merge!(new_gens_dict, spec_dict)
#  end
#  Iprep = IdealSheaf(X, C, new_gens_dict)
#  set_attribute!(Iprep, :is_regular_sequence, true)
#  return Iprep
#end
#
#function as_smooth_lci(
#    U::AffineScheme, g::Vector{T};
#    verbose::Bool=false,
#    check::Bool=true,
#    codimension::Int=dim(U)-dim(subscheme(U, g)) # this assumes both U and its subscheme to be equidimensional
#  ) where {T<:MPolyRingElem}
#  verbose && println("preparing $g as a local complete intersection on $U")
#  f = numerator.(gens(localized_modulus(OO(U))))
#  f = [a for a in f if !iszero(a)]
#  verbose && println("found $(length(f)) generators for the ideal defining U")
#  h = vcat(f, g)
#  r = length(f)
#  s = length(g)
#  Dh = jacobian_matrix(h)
#  (ll, ql, rl, cl) = _non_degeneration_cover(subscheme(U, g), Dh, codimension + codim(U),
#                          verbose=verbose, check=check,
#                          restricted_columns=[collect(1:r), [r + k for k in 1:s]])
#
#  n = length(ll)
#  # first process the necessary refinements of U
#  # The restricted columns in the call to _non_degenerate_cover
#  # assure that the first codim(U) entries of every cl[i] are
#  # indices of some element of f. However, we can discard these,
#  # as they are trivial generators of the ideal sheaf on U.
#  minor_list = [det(Dh[rl[i], cl[i]]) for i in 1:n]
#  V = Vector{open_subset_type(U)}()
#  AffineSchemeType = typeof(U)
#  PolyType = poly_type(U)
#  spec_dict = Dict{AffineSchemeType, Vector{PolyType}}()
#  g = Vector{PolyType}()
#  W = AffineSchemeOpenSubscheme(U, minor_list)
#  for i in 1:n
#    spec_dict[W[i]] = h[cl[i][codim(U)+1:end]]
#  end
#  return W, spec_dict
#end
#

function is_one(I::IdealSheaf; covering::Covering=default_covering(scheme(I)))
  return get_attribute!(I, :is_one) do
    return all(x->isone(I(x)), covering)
  end::Bool
end

@doc raw"""
    is_prime(I::IdealSheaf) -> Bool

Return whether ``I`` is prime.

We say that a sheaf of ideals is prime if its support is irreducible and
``I`` is locally prime. (Note that the empty set is not irreducible.)
"""
@attr function is_prime(I::IdealSheaf)
  is_locally_prime(I) || return false
  # TODO: this can be made more efficient
  PD = maximal_associated_points(I)
  return length(PD)==1
end

@doc raw"""
    is_locally_prime(I::IdealSheaf) -> Bool

Return whether ``I`` is locally prime.

A sheaf of ideals $\mathcal{I}$ is locally prime if its stalk $\mathcal{I}_p$
at every point $p$ is one or prime.
"""
@attr Bool function is_locally_prime(I::IdealSheaf)
  return all(U->is_prime(I(U)) || is_one(I(U)), basic_patches(default_covering(space(I))))
end

function is_equidimensional(I::IdealSheaf; covering=default_covering(scheme(I)))
  local_dims = [dim(I(U)) for U in patches(covering) if !isone(I(U))]
  length(local_dims) == 0 && return true # This only happens if I == OO(X)
  d = first(local_dims)
  all(x->x==d, local_dims) || return false
  all(U->(isone(I(U)) || is_equidimensional(I(U))), patches(covering)) || return false
  return true
end

function is_equidimensional(I::MPolyIdeal)
  decomp = equidimensional_decomposition_weak(I)
  return isone(length(decomp))
end

function is_equidimensional(I::MPolyQuoIdeal)
  is_equidimensional(saturated_ideal(I))
end

function is_equidimensional(I::MPolyLocalizedIdeal)
  return is_equidimensional(saturated_ideal(I))
end

function is_equidimensional(I::MPolyQuoLocalizedIdeal)
  return is_equidimensional(pre_image_ideal(I))
end

function _minimal_power_such_that(I::Ideal, P::PropertyType) where {PropertyType}
  whole_ring = ideal(base_ring(I), [one(base_ring(I))])
  P(whole_ring) && return (0, whole_ring)
  P(I) && return (1, I)
  I_powers = [(1,I)]

  while !P(last(I_powers)[2])
    push!(I_powers, (last(I_powers)[1]*2, last(I_powers)[2]^2))
  end
  upper = pop!(I_powers)
  lower = pop!(I_powers)
  while upper[1]!=lower[1]+1
    middle = pop!(I_powers)
    middle = (lower[1]+middle[1], lower[2]*middle[2])
    if P(middle[2])
      upper = middle
    else
      lower = middle
    end
  end
  return upper
end

@doc raw"""
    order_on_divisor(f::VarietyFunctionFieldElem, I::IdealSheaf; check::Bool=true) -> Int

Return the order of the rational function `f` on the prime divisor given by the ideal sheaf `I`.
"""
function order_on_divisor(
    f::VarietyFunctionFieldElem,
    I::IdealSheaf;
    check::Bool=true
  )
  @check is_prime(I) "ideal sheaf must be a sheaf of prime ideals"

  X = space(I)::AbsCoveredScheme
  X == variety(parent(f)) || error("schemes not compatible")

  #order_dict = Dict{AbsAffineScheme, Int}()

  # Since X is integral and I is a sheaf of prime ideals,
  # it suffices to find one chart in which I is non-trivial.

  # We look for the chart with the least complexity
  V = first(affine_charts(X))
  #complexity = Vector{Tuple{AbsAffineScheme, Int}}()
  complexity = inf
  for U in keys(Oscar.object_cache(underlying_presheaf(I))) # Those charts on which I is known.
    U in default_covering(X) || continue
    is_one(I(U)) && continue
    tmp = sum([total_degree(lifted_numerator(g)) for g in gens(I(U)) if !iszero(g)]) # /ngens(Oscar.pre_image_ideal(I(U)))
    if tmp < complexity
      complexity = tmp
      V = U
    end
  end
  flag = false
  if complexity == inf
    for U in X[1]
      is_one(I(U)) && continue
      # no chart has been computed, so we just take the first one
      flag = true
      V = U
      break
    end
    flag || error("divisor is empty")
  end
  R = ambient_coordinate_ring(V)
  J = saturated_ideal(I(V))
  K = saturated_ideal(defining_ideal(V))
  floc = f[V]
  aR = ideal(R, numerator(floc))
  bR = ideal(R, denominator(floc))

  # The following uses ArXiv:2103.15101, Lemma 2.18 (4):
  num_mult = _minimal_power_such_that(J, x->(issubset(quotient(x+K, aR), J)))[1]-1
  den_mult = _minimal_power_such_that(J, x->(issubset(quotient(x+K, bR), J)))[1]-1
  return num_mult - den_mult
#    # Deprecated code computing symbolic powers explicitly:
#    L, map = localization(OO(U),
#                          MPolyComplementOfPrimeIdeal(saturated_ideal(I(U)))
#                         )
#    L isa Union{MPolyLocRing{<:Any, <:Any, <:Any, <:Any,
#                                        <:MPolyComplementOfPrimeIdeal},
#                     MPolyQuoLocRing{<:Any, <:Any, <:Any, <:Any,
#                                           <:MPolyComplementOfPrimeIdeal}
#                    } || error("localization was not successful")
#
#    floc = f[U]
#    a = numerator(floc)
#    b = denominator(floc)
#    # TODO: cache groebner bases in a reasonable way.
#    P = L(prime_ideal(inverted_set(L)))
#    if one(L) in P
#      continue # the multiplicity is -‚àû in this case and does not count
#    end
#    upper = _minimal_power_such_that(P, x->!(L(a) in x))[1]-1
#    lower = _minimal_power_such_that(P, x->!(L(b) in x))[1]-1
#    order_dict[U] = upper-lower
end

@doc raw"""
    smooth_lci_covering(I::IdealSheaf)

For an ideal sheaf ``‚Ñê`` on a *smooth* scheme ``X`` with a *smooth*
associated subscheme ``Y = V(‚Ñê)`` this produces a covering ``ùîò = {U‚Çê}, a ‚àà A``
such that ``‚Ñê(U‚Çê) = ‚ü®f‚ÇÅ,‚Ä¶,f‚Çñ‚ü©`` is generated by a regular sequence on every
patch ``U‚Çê`` of that covering.
"""
function smooth_lci_covering(I::IdealSheaf)
  error("not implemented")
end

function pushforward(inc::CoveredClosedEmbedding, I::IdealSheaf)
  Y = domain(inc)
  scheme(I) === Y || error("ideal sheaf is not defined on the domain of the embedding")
  X = codomain(inc)
  phi = covering_morphism(inc)
  ID = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(domain(phi))
    V = codomain(phi[U])
    ID[V] = pushforward(phi[U], I(U))
  end
  return IdealSheaf(X, ID, check=false)
end

function pushforward(inc::ClosedEmbedding, I::Ideal)
  Y = domain(inc)
  base_ring(I) === OO(Y) || error("ideal is not defined in the coordinate ring of the domain")
  X = codomain(inc)
  return ideal(OO(X), vcat(gens(image_ideal(inc)),
                           OO(X).(lifted_numerator.(gens(I))))
              )
end

########################################################################
# primary decomposition
########################################################################

@doc raw"""
    maximal_associated_points(I::IdealSheaf)

Return a `Vector` of `IdealSheaf`s corresponding to the non-embedded associated points of ``I`` on ``scheme(I)``.

Note:
For usability reasons these associated points are not encoded as a subscheme, but as the corresponding ideal sheaf defining the subscheme.

Background:
More generally, a point ``x`` on a scheme ``X`` associated to a quasi-coherent sheaf ``F`` is embedded, if it is the specialization of another associated point of ``F``.
Note that maximal associated points of an ideal sheaf on an affine scheme ``Spec(A)`` correspond to the minimal associated primes of the corresponding ideal in ``A``.
"""
function maximal_associated_points(I::IdealSheaf; covering=default_covering(scheme(I)))
  !isone(I) || return typeof(I)[]
  X = scheme(I)
  OOX = OO(X)

  charts_todo = copy(patches(covering))           ## todo-list of charts

  associated_primes_temp = Vector{IdDict{AbsAffineScheme, Ideal}}()  ## already identified components
                                                  ## may not yet contain all relevant charts. but
                                                  ## at least one for each identified component

  result = IdealSheaf[]
  # run through all charts and try to match the components
  while length(charts_todo) > 0
    @vprint :MaximalAssociatedPoints 2 "$(length(charts_todo)) remaining charts to go through\n"
    U = pop!(charts_todo)
    J = I(U)
    # Do a quick check whether we even need to worry about this chart
    if has_decomposition_info(covering)
      J = J + ideal(OO(U), Vector{elem_type(OO(U))}(decomposition_info(covering)[U]))
      isone(J) && continue
    end
    !is_one(I(U)) || continue                        ## supp(I) might not meet all components
    components_here = minimal_primes(I(U))
    if has_decomposition_info(covering)
      # We only need those components which are located at the locus presrcibed by the
      # decomposition_info in this chart
      components_here = [ C for C in components_here if all(g->g in C, decomposition_info(covering)[U])]
      result = vcat(result, [IdealSheaf(X, U, gens(C)) for C in components_here])
      continue
    else
      ## run through all primes in MinAss(I(U)) and try to match them with previously found ones
      for comp in components_here
        matches = match_on_intersections(X,U,comp,associated_primes_temp,false)
        nmatches = length(matches)

        if nmatches == 0                             ## not found
          add_dict = IdDict{AbsAffineScheme,Ideal}()         ## create new dict
          add_dict[U] = comp                         ## and fill it
          push!(associated_primes_temp, add_dict)
        elseif nmatches == 1                         ## unique match, update it
          component_index = matches[1]
          associated_primes_temp[component_index][U] = comp
        else                                                ## more than one match, form union
          target_comp = pop!(matches)
          merge!(associated_primes_temp[target_comp], associated_primes_temp[x] for x in matches)
          deleteat!(associated_primes_temp,matches)
          associated_primes_temp[target_comp][U] = comp
        end
      end
    end
  end

  # In case we could use the decomposition info, quit here.
  if has_decomposition_info(covering)
    return result
  end

# fill the gaps arising from a support not meeting a patch
  for U in affine_charts(X)
    I_one = ideal(OOX(U),one(OOX(U)))
    for i in 1:length(associated_primes_temp)
      !haskey(associated_primes_temp[i],U) || continue
      associated_primes_temp[i][U] = I_one
    end
  end

# make sure to return ideal sheaves, not dicts
  associated_primes_result = [IdealSheaf(X,associated_primes_temp[i],check=false) for i in 1:length(associated_primes_temp)]
  return associated_primes_result
end

@doc raw"""
    associated_points(I::IdealSheaf)

Return a `Vector` of `IdealSheaf`s corresponding to the associated points of ``I`` on ``scheme(I)``.

Note:
For usability reasons an associated point is not encoded as subscheme, but as the corresponding ideal sheaf defining the subscheme.

Background:
More generally, a point ``x`` on a scheme ``X`` is associated to a quasi-coherent sheaf ``F``, if the maximal ideal ``m_x`` is associated to the ``O_{X,x}``-module ``F_x``.
If ``U = Spec(A)`` is an affine open on a locally noetherian scheme ``X``, ``x \in U`` and ``p \in A`` the corresponding prime ideal, then ``p \in Ass(\Gamma(U,F))`` iff ``x \in Ass(F)``.

"""
function associated_points(I::IdealSheaf)
  !isone(I) || return typeof(I)[]
  X = scheme(I)
  OOX = OO(X)
  charts_todo = copy(affine_charts(X))            ## todo-list of charts

  associated_primes_temp = Vector{IdDict{AbsAffineScheme, Ideal}}()  ## already identified components
                                                  ## may not yet contain all relevant charts. but
                                                  ## at least one for each identified component

# run through all charts and try to match the components
  while !iszero(length(charts_todo))
    U = pop!(charts_todo)
    !is_one(I(U)) || continue                        ## supp(I) might not meet all components
    components_here = [ a for (_,a) in primary_decomposition(I(U))]

## run through all primes in Ass(I(U)) and try to match them with previously found ones
    for comp in components_here
      matches = match_on_intersections(X,U,comp,associated_primes_temp,false)
      nmatches = length(matches)

      if nmatches == 0                             ## not found
        add_dict = IdDict{AbsAffineScheme,Ideal}()         ## create new dict
        add_dict[U] = comp                         ## and fill it
        push!(associated_primes_temp, add_dict)
      elseif nmatches == 1                         ## unique match, update it
        component_index = matches[1]
        associated_primes_temp[component_index][U] = comp
      else                                                ## more than one match, form union
        target_comp = pop!(matches)
        merge!(associated_primes_temp[target_comp], associated_primes_temp[x] for x in matches)
        deleteat!(associated_primes_temp,matches)
        associated_primes_temp[target_comp][U] = comp
      end
    end
  end

# fill the gaps arising from a support not meeting a patch
  for U in affine_charts(X)
    I_one = ideal(OOX(U),one(OOX(U)))
    for i in 1:length(associated_primes_temp)
      !haskey(associated_primes_temp[i],U) || continue
      associated_primes_temp[i][U] = I_one
    end
  end

# make sure to return ideal sheaves, not dicts
  associated_primes_result = [IdealSheaf(X,associated_primes_temp[i],check=false) for i in 1:length(associated_primes_temp)]
  return associated_primes_result
end

function match_on_intersections(
      X::AbsCoveredScheme,
      U::AbsAffineScheme,
      I::Union{<:MPolyIdeal, <:MPolyQuoIdeal, <:MPolyQuoLocalizedIdeal, <:MPolyLocalizedIdeal},
      associated_list::Vector{<:IdDict{<:AbsAffineScheme, <:Ideal}},
      check::Bool=true)
  @vprint :MaximalAssociatedPoints 2 "matching $(I) \n to $(length(associated_list))\n on $(U)\n"
  matches = Int[]
  OOX = OO(X)
# run through all components in associated_list and try to match up I
  for i in 1:length(associated_list)
    match_found = false
    match_contradicted = false

## run through all known patches of the component
    for (V,IV) in associated_list[i]
      G = default_covering(X)[V,U]
      VU, UV = gluing_domains(G)
      if UV isa AffineSchemeOpenSubscheme && VU isa AffineSchemeOpenSubscheme
        I_res = [OOX(U, UV[i])(I) for i in 1:ngens(UV)]
        IV_res = [OOX(V, UV[i])(IV) for i in 1:ngens(UV)]
        if all(i->(I_res[i] == IV_res[i]), 1:ngens(UV))
          match_found = !all(I->is_one(I), I_res)                               ## count only non-trivial matches
          check || break
        else
          match_contradicted = true
          check || break
        end
      elseif UV isa AbsAffineScheme && VU isa AbsAffineScheme
        I_res = OOX(U,UV)(I)
        IV_res = OOX(V,UV)(IV)
        if (I_res == IV_res)
          match_found = !is_one(I_res)                               ## count only non-trivial matches
          check || break
        else
          match_contradicted = true
          check || break
        end
      else
        error("case not implemented")
      end
    end

## make sure we are working on consistent data
   @check begin
      if match_found && match_contradicted
        error("contradictory matching result!!")                     ## this should not be reached for ass. points
      end
    end

## update list of matches
    if match_found
      push!(matches, i)
    end
  end

  return matches
end

function (phi::Map{D, C})(I::Ideal) where {D<:Ring, C<:Ring}
  base_ring(I) === domain(phi) || error("ideal not defined over the domain of the map")
  R = domain(phi)
  S = codomain(phi)
  return ideal(S, phi.(gens(I)))
end

# Necessary for removing ambiguities
function (phi::AbstractAlgebra.Generic.CompositeMap{D, C})(I::Ideal) where {D<:Ring, C<:Ring}
  base_ring(I) === domain(phi) || error("ideal not defined over the domain of the map")
  R = domain(phi)
  S = codomain(phi)
  return ideal(S, phi.(gens(I)))
end

function (phi::MPolyAnyMap{D, C})(I::MPolyIdeal) where {D<:MPolyRing, C<:Ring}
  base_ring(I) === domain(phi) || error("ideal not defined over the domain of the map")
  R = domain(phi)
  S = codomain(phi)
  return ideal(S, phi.(gens(I)))
end

function (phi::MPolyAnyMap{D, C})(I::MPolyQuoIdeal) where {D<:MPolyQuoRing, C<:Ring}
  base_ring(I) === domain(phi) || error("ideal not defined over the domain of the map")
  R = domain(phi)
  S = codomain(phi)
  return ideal(S, phi.(gens(I)))
end

function complement_of_prime_ideal(P::MPolyQuoIdeal)
  return complement_of_prime_ideal(saturated_ideal(P))
end

function complement_of_prime_ideal(P::MPolyQuoLocalizedIdeal)
  return complement_of_prime_ideal(saturated_ideal(P))
end

function complement_of_prime_ideal(P::MPolyLocalizedIdeal)
  return complement_of_prime_ideal(saturated_ideal(P))
end

@attr IdealSheaf function radical(II::IdealSheaf)
  X = scheme(II)
  # If there is a simplified covering, do the calculations there.
  covering = (has_attribute(X, :simplified_covering) ? simplified_covering(X) : default_covering(X))
  ID = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(covering)
    ID[U] = radical(II(U))
  end
  return IdealSheaf(X, ID, check=false)
end

function small_generating_set(II::IdealSheaf)
  X = scheme(II)
  # If there is a simplified covering, do the calculations there.
  covering = (has_attribute(X, :simplified_covering) ? simplified_covering(X) : default_covering(X))
  ID = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(covering)
    ID[U] = ideal(base_ring(II(U)),small_generating_set(saturated_ideal(II(U))))
  end
  return(IdealSheaf(X, ID, check = false))
end

###########################################################################
## show functions for Ideal sheaves
###########################################################################

# If we know things about the ideal sheaf, we print them
function Base.show(io::IO, I::IdealSheaf)
  io = pretty(io)
  X = scheme(I)
  if get(io, :show_semi_compact, false)
    cov = Oscar._covering_for_printing(io, X)
    n = get(io, :label, "")
    _show_semi_compact(io, I, cov, n)
  else
    show_scheme = get(io, :show_scheme, true)
    if has_attribute(I, :dim) && has_attribute(X, :dim)
      z = dim(X) - dim(I) == 0 ? true : false
    else
      z = false
    end
    prim = get_attribute(I, :is_prime, false)
    if has_attribute(I, :name)
      print(io, get_attribute(I, :name))
    elseif get(io, :supercompact, false)
      print(io, "Sheaf of ideals")
    else
      if get_attribute(I, :is_one, false)
        print(io, "Sheaf of unit ideals")
      elseif z
        print(io, "Sheaf of zero ideals")
      elseif prim
        print(io, "Sheaf of prime ideals")
      else
        print(io, "Sheaf of ideals")
      end
      if show_scheme
        print(io," on ", Lowercase(), X)
      end
    end
  end
end

# This semi compact printing is used for nested printings, like in blow-up or
# for the description of Cartier divisors and algebraic cycles.
#
# We want to keep track of a given covering `voc`, for everything to be consistent. In
# case we may have several charts in the nest, we want to make sure to follow-up
# with the labels. Hence the string `n` allows one to do this.
# Usually, in morphisms printing, one would take "a" for the domain's charts
# and "b" for the codomain's ones.
#
# We take also care of left offsets when printing the labels - if there are more
# than 10 charts, this is necessary to have all the labels aligned on the right
function _show_semi_compact(io::IO, I::IdealSheaf, cov::Covering, n::String)
  io = pretty(io)
  X = scheme(I)
  if has_attribute(I, :dim) && has_attribute(X, :dim)
    z = dim(X) - dim(I) == 0 ? true : false
  else
    z = false
  end
  prim = get_attribute(I, :is_prime, false)

  if get_attribute(I, :is_one, false)
    print(io, "Sheaf of unit ideals")
  elseif z
    print(io, "Sheaf of zero ideals")
  else
    # If there is a simplified covering, use it!
    if prim
      print(io, "Sheaf of prime ideals")
    else
      print(io, "Sheaf of ideals")
    end
    if length(cov) > 0
      l = ndigits(length(cov))
      print(io, " with restriction")
      length(cov) > 1 && print(io, "s")
      print(io, Indent())
      for (i, U) in enumerate(patches(cov))
        li = ndigits(i)
        println(io)
        print(io, " "^(l-li)*"$i"*n*": $(I(U))")
      end
      print(io, Dedent())
    end
  end
end

function Base.show(io::IO, ::MIME"text/plain", I::IdealSheaf)
  io = pretty(io)
  X = scheme(I)
  cov = Oscar._covering_for_printing(io, X)
  # If there is a simplified covering, use it!
  println(io, "Sheaf of ideals")
  print(io, Indent(), "on ", Lowercase())
  show(IOContext(io, :show_semi_compact => true, :covering => cov), X)
  if length(cov) > 0
    l = ndigits(length(cov))
    println(io)
    print(io, Dedent(), "with restriction")
    length(cov) > 1 && print(io, "s")
    print(io, Indent())
    for (i, U) in enumerate(patches(cov))
      li = ndigits(i)
      println(io)
      print(io, " "^(l-li)*"$i: $(I(U))")
    end
    print(io, Dedent())
  end
end

function _separate_disjoint_components(comp::Vector{<:IdealSheaf}; covering::Covering=default_covering(scheme(first(comp))))
  isempty(comp) && error("list of components must not be empty")
  X = scheme(first(comp))
  all(x->scheme(x) === X, comp) || error("components must be defined over the same scheme")
  isone(length(comp)) && return covering
  new_patches = Vector{AbsAffineScheme}()
  for U in patches(covering)
    isempty(U) && continue
    loc_comp = [I(U) for I in comp]
    loc_comp = [a for a in loc_comp if !isone(a)]
    if isempty(loc_comp) || isone(length(loc_comp))
      push!(new_patches, U)
      continue
    end
    cof = _cofactors(loc_comp)
    if isempty(cof)
      push!(new_patches, U)
    else
      new_patches = vcat(new_patches, [PrincipalOpenSubset(U, a) for a in cof])
    end
  end
  new_cov = Covering(new_patches)
  inherit_gluings!(new_cov, covering)
  return new_cov
end

function _cofactors(comp::Vector{<:Ideal})
  R = base_ring(first(comp))
  all(x->base_ring(x)===R, comp) || error("ideals must be defined over the same ring")
  n = length(comp)
  pairwise_cof = identity_matrix(R, n)
  for i in 1:n-1
    for j in i+1:n
      I = ideal(R, vcat(gens(comp[i]), gens(comp[j])))
      r = ngens(comp[i])
      s = ngens(comp[j])
      z = coordinates(one(R), I)
      x = z isa MatElem ? [z[1, k] for k in 1:r] : z[1:r]
      y = z isa MatElem ? [z[1, r+k] for k in 1:s] : z[r+1:r+s]
      pairwise_cof[i, j] = sum(x[k]*gen(comp[i], k) for k in 1:r; init=zero(R))
      pairwise_cof[j, i] = sum(y[k]*gen(comp[j], k) for k in 1:s; init=zero(R))
    end
  end
  result = [prod(pairwise_cof[1:n, i]) for i in 1:n]
  return result
end

function _one_patch_per_component(covering::Covering, comp::Vector{<:IdealSheaf})
  new_patches2 = Vector{AbsAffineScheme}()
  patches_todo = copy(patches(covering))
  for P in comp
    # Find one patch in which this component is supported
    i = findfirst(U->!isone(P(U)), patches_todo)
    U = patches_todo[i]
    # Take this patch out of the list
    deleteat!(patches_todo, i)
    # Add it to the list of patches for the new covering
    push!(new_patches2, U)
    # For every other patch V in which P appears we do the following:
    # Replace V by the complement of the support of P.
    # This will not be affine in general, but can be covered by hypersurface
    # complements. Even though this may lead to many charts, they will be harmless
    # in the mext blowup.
    done = Int[]
    for (j, V) in enumerate(patches_todo)
      # Check whether P is visible in this patch; if not leave it
      isone(P(V)) && continue
      # Remember this patch to be done
      push!(done, j)
      sg = small_generating_set(P(V))
      new_patches2 = append!(new_patches2, [PrincipalOpenSubset(V,a) for a in sg])
      # TODO: Cache that P = 1 on all these new patches?
    end
    deleteat!(patches_todo, done)
  end
  new_patches2 = append!(new_patches2, patches_todo)
  new_cov = Covering(new_patches2)
  inherit_gluings!(new_cov, covering)
  return new_cov
end

@attr Vector{<:MPolyQuoLocRingElem} function small_generating_set(I::MPolyQuoLocalizedIdeal)
  L = base_ring(I)
  g = small_generating_set(saturated_ideal(I))
  return Vector{elem_type(L)}([gg for gg in L.(g) if !iszero(gg)])
end

@attr Vector{<:MPolyLocRingElem} function small_generating_set(I::MPolyLocalizedIdeal)
  L = base_ring(I)
  g = small_generating_set(saturated_ideal(I))
  return Vector{elem_type(L)}([gg for gg in L.(g) if !iszero(gg)])
end

function saturation(I::IdealSheaf, J::IdealSheaf)
  X = scheme(I)
  K = IdDict{AbsAffineScheme, Ideal}()
  for U in affine_charts(X)
    K[U] = saturation(I(U), J(U))
  end
  return IdealSheaf(X, K, check=false)
end

function pushforward(f::AbsCoveredSchemeMorphism, II::IdealSheaf)
  f_cov = covering_morphism(f)
  dom_cov = domain(f_cov)
  cod_cov = codomain(f_cov)
  ideal_dict = IdDict{AbsAffineScheme, Ideal}()
  for V in cod_cov
    f_loc = maps_with_given_codomain(f_cov, V)
    I_loc = [preimage(pullback(f), II(domain(f))) for f in f_loc]
    ideal_dict[V] = intersect(I_loc...)
  end
  return IdealSheaf(codomain(f), ideal_dict, check=true) #TODO: Set to false
end

function Base.:^(II::IdealSheaf, k::IntegerUnion)
  k < 0 && error("negative powers of ideal sheaves are not allowed")
  if iszero(k)
    X = scheme(II)
    return IdealSheaf(X, IdDict{AbsAffineScheme, Ideal}([U => ideal(OO(U), one(OO(U))) for U in affine_charts(X)]), check=false)
  end
  isone(k) && return II
  b = div(k, 2)
  r = k - b
  return II^b * II^r
end
