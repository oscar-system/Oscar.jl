@doc raw"""
    tate_section_a1(t::GlobalTateModel)

Return the Tate section ``a_1``.

# Examples
```jldoctest
julia> using Random;

julia> t = global_tate_model_over_projective_space(2, rng = Random.Xoshiro(1234))
Global Tate model over a concrete base

julia> degree(tate_section_a1(t))
Abelian group element [3]
```
"""
tate_section_a1(t::GlobalTateModel) = explicit_model_sections(t)["a1"]

@doc raw"""
    tate_section_a2(t::GlobalTateModel)

Return the Tate section ``a_2``.

# Examples
```jldoctest
julia> using Random;

julia> t = global_tate_model_over_projective_space(2, rng = Random.Xoshiro(1234))
Global Tate model over a concrete base

julia> degree(tate_section_a2(t))
Abelian group element [6]
```
"""
tate_section_a2(t::GlobalTateModel) = explicit_model_sections(t)["a2"]

@doc raw"""
    tate_section_a3(t::GlobalTateModel)

Return the Tate section ``a_3``.

# Examples
```jldoctest
julia> using Random;

julia> t = global_tate_model_over_projective_space(2, rng = Random.Xoshiro(1234))
Global Tate model over a concrete base

julia> degree(tate_section_a3(t))
Abelian group element [9]
```
"""
tate_section_a3(t::GlobalTateModel) = explicit_model_sections(t)["a3"]

@doc raw"""
    tate_section_a4(t::GlobalTateModel)

Return the Tate section ``a_4``.

# Examples
```jldoctest
julia> using Random;

julia> t = global_tate_model_over_projective_space(2, rng = Random.Xoshiro(1234))
Global Tate model over a concrete base

julia> degree(tate_section_a4(t))
Abelian group element [12]
```
"""
tate_section_a4(t::GlobalTateModel) = explicit_model_sections(t)["a4"]

@doc raw"""
    tate_section_a6(t::GlobalTateModel)

Return the Tate section ``a_6``.

# Examples
```jldoctest
julia> using Random;

julia> t = global_tate_model_over_projective_space(2, rng = Random.Xoshiro(1234))
Global Tate model over a concrete base

julia> degree(tate_section_a6(t))
Abelian group element [18]
```
"""
tate_section_a6(t::GlobalTateModel) = explicit_model_sections(t)["a6"]

@doc raw"""
    tate_polynomial(t::GlobalTateModel)

Return the Tate polynomial of the model.

Alias: [`hypersurface_equation(t::GlobalTateModel)`](@ref).

# Examples
```jldoctest
julia> using Random;

julia> t = global_tate_model_over_projective_space(2, rng = Random.Xoshiro(1234))
Global Tate model over a concrete base

julia> tate_polynomial(t) == hypersurface_equation(t)
true
```
"""
function tate_polynomial(t::GlobalTateModel)
  if !isdefined(t, :tate_polynomial)
    @req t.tate_ideal_sheaf isa ToricIdealSheafFromCoxRingIdeal "Reconstruction of Tate polynomial is not implemented in the non-toric case"
    if isdefined(t, :tate_ideal_sheaf)
      tate_ideal = ideal_in_coordinate_ring(t.tate_ideal_sheaf)
      @req isone(ngens(tate_ideal)) "Tate ideal generated by more than one polynomial"
      t.tate_polynomial = first(gens(tate_ideal))
    else
      error("Tate polynomial cannot be reconstructed")
    end
  end
  return t.tate_polynomial
end

@doc raw"""
    hypersurface_equation(t::GlobalTateModel)

Alias for [`tate_polynomial(t::GlobalTateModel)`](@ref).
"""
hypersurface_equation(t::GlobalTateModel) = tate_polynomial(t)

@doc raw"""
    tate_ideal_sheaf(t::GlobalTateModel)

Return the Tate ideal sheaf of the global Tate model.

This method is relevant when the global Tate model cannot be represented by a single
global polynomialâ€”e.g., after non-toric blowups. In such cases, the model is defined
locally by an ideal sheaf on each affine patch rather than by a global hypersurface equation.

# Examples
```jldoctest
julia> using Random;

julia> t = global_tate_model_over_projective_space(2, rng = Random.Xoshiro(1234))
Global Tate model over a concrete base

julia> tate_ideal_sheaf(t)
Sheaf of ideals
  on normal toric variety
with restrictions
  1: Ideal with 1 generator
  2: Ideal with 1 generator
  3: Ideal with 1 generator
  4: Ideal with 2 generators
  5: Ideal with 2 generators
  6: Ideal with 2 generators
  7: Ideal with 5 generators
  8: Ideal with 5 generators
  9: Ideal with 5 generators
```
"""
function tate_ideal_sheaf(t::GlobalTateModel)
  if !isdefined(t, :tate_ideal_sheaf)
    @req ambient_space(t) isa NormalToricVariety "Reconstruction from Tate polynomial not implemented in the non-toric case"
    if isdefined(t, :tate_polynomial)
      my_ideal = ideal([t.tate_polynomial])
      t.tate_ideal_sheaf = ideal_sheaf(ambient_space(t), my_ideal)
    else
      error("Tate ideal sheaf cannot be reconstructed")
    end
  end
  return t.tate_ideal_sheaf
end

@doc raw"""
    weierstrass_model(t::GlobalTateModel)

Return the Weierstrass model which is equivalent to the given global Tate model.

# Examples
```jldoctest
julia> using Random;

julia> t = global_tate_model_over_projective_space(2, rng = Random.Xoshiro(1234))
Global Tate model over a concrete base

julia> weierstrass_model(t)
Weierstrass model over a concrete base
```
"""
@attr WeierstrassModel function weierstrass_model(t::GlobalTateModel)
  @req (base_space(t) isa NormalToricVariety || base_space(t) isa FamilyOfSpaces) "Conversion of global Tate model into Weierstrass model is currently only supported for toric varieties and family of spaces as base space"

  # Compute explicit Weierstrass sections
  b2 = 4 * tate_section_a2(t) + tate_section_a1(t)^2
  b4 = 2 * tate_section_a4(t) + tate_section_a1(t) * tate_section_a3(t)
  b6 = 4 * tate_section_a6(t) + tate_section_a3(t)^2
  f = -1//48 * (b2^2 - 24 * b4)
  g = 1//864 * (b2^3 - 36 * b2 * b4 + 216 * b6)

  # Compute explicit_model_sections
  new_explicit_model_sections = Dict("f" => f, "g" => g)
  sections_t = collect(keys(explicit_model_sections(t)))
  for section in sections_t
    if !(section in ["a1", "a2", "a3", "a4", "a6"])
      new_explicit_model_sections[section] = explicit_model_sections(t)[section]
    end
  end

  # Compute Weierstrass polynomial
  S = coordinate_ring(ambient_space(t))
  x, y, z = gens(S)[(ngens(S) - 2):ngens(S)]
  ring_map = hom(parent(f), S, gens(S)[1:ngens(parent(f))])
  pw = x^3 - y^2 + ring_map(f) * x * z^4 + ring_map(g) * z^6

  # Compute parametrization of Weierstrass sections
  parametrization = model_section_parametrization(t)
  param_keys = collect(keys(parametrization))
  new_model_section_parametrization = Dict{String,MPolyRingElem}()
  if length(param_keys) > 0
    # Find ring to evaluate polynomials into
    R = parent(parametrization[param_keys[1]])

    # Identify how we parametrize a1
    if haskey(parametrization, "a1")
      param_a1 = parametrization["a1"]
    else
      param_a1 = eval_poly("a1", R)
    end

    # Identify how we parametrize a2
    if haskey(parametrization, "a2")
      param_a2 = parametrization["a2"]
    else
      param_a2 = eval_poly("a2", R)
    end

    # Identify how we parametrize a3
    if haskey(parametrization, "a3")
      param_a3 = parametrization["a3"]
    else
      param_a3 = eval_poly("a3", R)
    end

    # Identify how we parametrize a4
    if haskey(parametrization, "a4")
      param_a4 = parametrization["a4"]
    else
      param_a4 = eval_poly("a4", R)
    end

    # Identify how we parametrize a6
    if haskey(parametrization, "a6")
      param_a6 = parametrization["a6"]
    else
      param_a6 = eval_poly("a6", R)
    end

    # Compute parametrization of b2, b4, b6
    param_b2 = 4 * param_a2 + param_a1^2
    param_b4 = 2 * param_a4 + param_a1 * param_a3
    param_b6 = 4 * param_a6 + param_a3^2

    # Compute parametrization of f, g
    param_f = -1//48 * (param_b2^2 - 24 * param_b4)
    param_g = 1//864 * (param_b2^3 - 36 * param_b2 * param_b4 + 216 * param_b6)

    # Compute model_section_parametrization
    new_model_section_parametrization = Dict("f" => param_f, "g" => param_g)
  end

  # Compute Weierstrass model
  model = WeierstrassModel(
    new_explicit_model_sections,
    new_model_section_parametrization,
    pw,
    base_space(t),
    ambient_space(t),
  )

  # Copy attributes and return model
  model_attributes = t.__attrs
  for (key, value) in model_attributes
    set_attribute!(model, key, value)
  end
  return model
end

@doc raw"""
    discriminant(t::GlobalTateModel)

Return the discriminant ``\Delta = 4 f^3 + 27 g^2`` of the Weierstrass model equivalent to the given global Tate model.

# Examples
```jldoctest
julia> using Random;

julia> t = global_tate_model_over_projective_space(2, rng = Random.Xoshiro(1234))
Global Tate model over a concrete base

julia> degree(discriminant(t))
Abelian group element [36]
```
"""
@attr MPolyRingElem function discriminant(t::GlobalTateModel)
  @req (base_space(t) isa NormalToricVariety || base_space(t) isa FamilyOfSpaces) "Discriminant of global Tate model is currently only supported for toric varieties and family of spaces as base space"
  return discriminant(weierstrass_model(t))
end

@doc raw"""
    singular_loci(t::GlobalTateModel)

Return the singular loci of the Weierstrass model equivalent to the given Tate model,
along with the order of vanishing of ``(f, g, \Delta)`` at each locus and the corresponding
refined Tate fiber type. See [`singular_loci(w::WeierstrassModel)`](@ref) for more details.

!!! warning
    The classification of singularities is performed using a Monte Carlo algorithm, involving randomized sampling.
    While reliable in practice, this probabilistic method may occasionally yield non-deterministic results.
    The random source can be set with the optional argument `rng`.

Below, we demonstrate this functionality by computing the singular loci of a Type ``III`` Tate model
[KMSS11](@cite). In this case, the Tate sections are factored as follows:
- ``a_1 = a_{11} w^1``,
- ``a_2 = a_{21} w^1``,
- ``a_3 = a_{31} w^1``,
- ``a_4 = a_{41} w^1``,
- ``a_6 = a_{62} w^2``.
Hence, there is a Kodaira type ``III`` singularity over the divisor ``{w = 0}``. By theory,
the discriminant ``\Delta`` vanishes to order 3 on ``{w = 0}``, while the Weierstrass
sections ``f`` and ``g`` vanish to orders 1 and 2, respectively.

# Examples
```jldoctest
julia> auxiliary_base_ring, (a11, a21, a31, a41, a62, w) = QQ[:a10, :a21, :a32, :a43, :a65, :w];

julia> auxiliary_base_grading = [1 2 3 4 6 0; -1 -1 -1 -1 -2 1];

julia> a1 = a11 * w;

julia> a2 = a21 * w;

julia> a3 = a31 * w;

julia> a4 = a41 * w;

julia> a6 = a62 * w^2;

julia> ais = [a1, a2, a3, a4, a6];

julia> t = global_tate_model(auxiliary_base_ring, auxiliary_base_grading, 3, ais)
Global Tate model over a not fully specified base

julia> using Random;

julia> sort([k[2:3] for k in singular_loci(t; rng = Random.Xoshiro(1234))])
2-element Vector{Tuple{Tuple{Int64, Int64, Int64}, String}}:
 ((0, 0, 1), "I_1")
 ((1, 2, 3), "III")
```
"""
@attr Vector{<:Tuple{<:MPolyIdeal{<:MPolyRingElem},Tuple{Int64,Int64,Int64},String}} function singular_loci(
  t::GlobalTateModel; rng::AbstractRNG=Random.default_rng()
)
  @req (base_space(t) isa NormalToricVariety || base_space(t) isa FamilyOfSpaces) "Singular loci of global Tate model currently only supported for toric varieties and families of spaces as base space"
  return singular_loci(weierstrass_model(t); rng)
end
