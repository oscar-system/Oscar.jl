@doc raw"""
    weierstrass_section_f(w::WeierstrassModel)

Return the Weierstrass section ``f`` of the Weierstrass model.

# Examples
```jldoctest
julia> using Random;

julia> w =  weierstrass_model_over_projective_space(3, rng = Random.Xoshiro(1234))
Weierstrass model over a concrete base

julia> weierstrass_section_f(w);
```
"""
weierstrass_section_f(w::WeierstrassModel) = explicit_model_sections(w)["f"]

@doc raw"""
    weierstrass_section_g(w::WeierstrassModel)

Return the Weierstrass section ``g`` of the Weierstrass model.

# Examples
```jldoctest
julia> using Random;

julia> w =  weierstrass_model_over_projective_space(3, rng = Random.Xoshiro(1234))
Weierstrass model over a concrete base

julia> weierstrass_section_g(w);
```
"""
weierstrass_section_g(w::WeierstrassModel) = explicit_model_sections(w)["g"]

@doc raw"""
    weierstrass_polynomial(w::WeierstrassModel)

Return the Weierstrass polynomial of the model.

Alias: [`hypersurface_equation(w::WeierstrassModel)`](@ref).

# Examples
```jldoctest
julia> using Random;

julia> w =  weierstrass_model_over_projective_space(3, rng = Random.Xoshiro(1234))
Weierstrass model over a concrete base

julia> weierstrass_polynomial(w) == hypersurface_equation(w)
true
```
"""
function weierstrass_polynomial(w::WeierstrassModel)
  if !isdefined(w, :weierstrass_polynomial)
    @req w.weierstrass_ideal_sheaf isa ToricIdealSheafFromCoxRingIdeal "Reconstruction of Weierstrass polynomial is not implemented in the non-toric case"
    if isdefined(w, :weierstrass_ideal_sheaf) &&
      isone(ngens(ideal_in_coordinate_ring(w.weierstrass_ideal_sheaf)))
      weierstrass_ideal = ideal_in_coordinate_ring(w.weierstrass_ideal_sheaf)
      @req isone(ngens(weierstrass_ideal)) "Weierstrass ideal generated by more than one polynomial"
      w.weierstrass_polynomial = first(gens(weierstrass_ideal))
    else
      error("Weierstrass polynomial cannot be reconstructed")
    end
  end
  return w.weierstrass_polynomial
end

@doc raw"""
    hypersurface_equation(w::WeierstrassModel)

Alias for [`weierstrass_polynomial(w::WeierstrassModel)`](@ref).
"""
hypersurface_equation(w::WeierstrassModel) = weierstrass_polynomial(w)

@doc raw"""
    weierstrass_ideal_sheaf(w::WeierstrassModel)

Return the Weierstrass ideal sheaf of the Weierstrass model.

This method is relevant when the Weierstrass model cannot be represented by a single
global polynomial—e.g., after non-toric blowups. In such cases, the model is defined
locally by an ideal sheaf on each affine patch rather than by a global hypersurface equation.

# Examples
```jldoctest
julia> using Random;

julia> w =  weierstrass_model_over_projective_space(2, rng = Random.Xoshiro(1234))
Weierstrass model over a concrete base

julia> weierstrass_ideal_sheaf(w)
Sheaf of ideals
  on normal toric variety
with restrictions
  1: Ideal with 1 generator
  2: Ideal with 1 generator
  3: Ideal with 1 generator
  4: Ideal with 2 generators
  5: Ideal with 2 generators
  6: Ideal with 2 generators
  7: Ideal with 5 generators
  8: Ideal with 5 generators
  9: Ideal with 5 generators
```
"""
function weierstrass_ideal_sheaf(w::WeierstrassModel)
  if !isdefined(w, :weierstrass_ideal_sheaf)
    @req ambient_space(w) isa NormalToricVariety "Reconstruction from Weierstrass polynomial not implemented in the non-toric case"
    if isdefined(w, :weierstrass_polynomial)
      my_ideal = ideal([w.weierstrass_polynomial])
      w.weierstrass_ideal_sheaf = ideal_sheaf(ambient_space(w), my_ideal)
    else
      error("Weierstrass ideal sheaf cannot be reconstructed")
    end
  end
  return w.weierstrass_ideal_sheaf
end

@doc raw"""
    discriminant(w::WeierstrassModel)

Return the discriminant ``\Delta = 4 f^3 + 27 g^2`` of the Weierstrass model.

# Examples
```jldoctest
julia> using Random;

julia> w =  weierstrass_model_over_projective_space(3, rng = Random.Xoshiro(1234))
Weierstrass model over a concrete base

julia> discriminant(w);
```
"""
@attr MPolyRingElem function discriminant(w::WeierstrassModel)
  @req (base_space(w) isa NormalToricVariety || base_space(w) isa FamilyOfSpaces) "Discriminant of Weierstrass model is currently only supported for toric varieties and family of spaces as base space"
  return 4 * weierstrass_section_f(w)^3 + 27 * weierstrass_section_g(w)^2
end

@doc raw"""
    singular_loci(w::WeierstrassModel)

Return the singular loci of the Weierstrass model, along with the order of
vanishing of ``(f, g, \Delta)`` at each locus and the refined Tate fiber type.

Currently, the method either explicitly or implicitly assumes a toric variety
as base space—either because the user provides one, or because an unspecified
base is treated symbolically as such. This allows us to filter out trivial
singular loci effectively.

Specifically, recall that every closed subvariety of a simplicial toric variety
is of the form ``V(I)``, where ``I`` is a homogeneous ideal of the Cox ring.
Let ``B`` be the irrelevant ideal of this toric variety. Then, by Proposition 5.2.6
of [CLS11](@cite), ``V(I)`` is trivial (i.e., empty) if and only if ``B^l \subseteq I``
for some ``l \geq 0``. This can be checked by testing whether the saturation
``I : B^\infty`` equals the unit ideal.

By treating unspecified base spaces as symbolic toric varieties, we can
extend this check to those cases as well.

Advanced technical details are available in [BMT25](@cite BMT25).

!!! warning
    The classification of singularities is based on a Monte Carlo algorithm, which involves random sampling.
    While reliable in practice, this probabilistic method may occasionally yield non-deterministic results.
    The random source can be set with the optional argument `rng`.

# Examples
```jldoctest
julia> using Random;

julia> w =  weierstrass_model_over_projective_space(3, rng = Random.Xoshiro(1234))
Weierstrass model over a concrete base

julia> using Random;

julia> length(singular_loci(w; rng = Random.Xoshiro(1234)))
1
```
"""
@attr Vector{<:Tuple{<:MPolyIdeal{<:MPolyRingElem},Tuple{Int64,Int64,Int64},String}} function singular_loci(
  w::WeierstrassModel; rng::AbstractRNG=Random.default_rng()
)
  @req (base_space(w) isa NormalToricVariety || base_space(w) isa FamilyOfSpaces) "Singular loci of Weierstrass model is currently only supported for toric varieties and families of spaces as base space"
  B = irrelevant_ideal(base_space(w))
  d_primes = factor(discriminant(w))
  nontrivial_d_primes = [k for k in d_primes if _is_nontrivial(ideal([k[1]]), B)]
  kodaira_types = Vector{
    Tuple{<:MPolyIdeal{<:MPolyRingElem},Tuple{Int64,Int64,Int64},String}
  }(
    undef, length(nontrivial_d_primes)
  )
  f = weierstrass_section_f(w)
  g = weierstrass_section_g(w)
  for (i, (p, d_order)) in enumerate(nontrivial_d_primes)
    f_order = valuation(f, p)
    g_order = valuation(g, p)
    ords = (f_order, g_order, d_order)
    I = ideal([p])
    kodaira_types[i] = (I, ords, _kodaira_type(I, ords, w; rng))
  end
  sort!(kodaira_types; by=x -> (x[2][2], x[2][3]))
  return kodaira_types
end
