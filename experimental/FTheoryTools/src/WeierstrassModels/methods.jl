#####################################################
# 1: Resolve a Weierstrass model via blowup
#####################################################

@doc raw"""
    blow_up(w::WeierstrassModel, ideal_gens::Vector{String}; coordinate_name::String = "e")

Resolve a Weierstrass model by blowing up a locus in the ambient space.

# Examples
```jldoctest
julia> B2 = projective_space(NormalToricVariety, 2)
Normal toric variety

julia> b = torusinvariant_prime_divisors(B2)[1]
Torus-invariant, prime divisor on a normal toric variety

julia> w = literature_model(arxiv_id = "1208.2695", equation = "B.19", base_space = B2, model_sections = Dict("b" => b), completeness_check = false)
Construction over concrete base may lead to singularity enhancement. Consider computing singular_loci. However, this may take time!

Weierstrass model over a concrete base -- U(1) Weierstrass model based on arXiv paper 1208.2695 Eq. (B.19)

julia> blow_up(w, ["x", "y", "x1"]; coordinate_name = "e1")
Partially resolved Weierstrass model over a concrete base -- U(1) Weierstrass model based on arXiv paper 1208.2695 Eq. (B.19)
```
"""
function blow_up(w::WeierstrassModel, ideal_gens::Vector{String}; coordinate_name::String = "e")
  R = cox_ring(ambient_space(w))
  I = ideal([eval_poly(k, R) for k in ideal_gens])
  return blow_up(w, I; coordinate_name = coordinate_name)
end

function blow_up(w::WeierstrassModel, I::MPolyIdeal; coordinate_name::String = "e")
  
  # This method only works if the model is defined over a toric variety over toric scheme
  @req typeof(base_space(w)) <: NormalToricVariety "Blowups of Weierstrass models are currently only supported for toric bases"
  @req typeof(ambient_space(w)) <: NormalToricVariety "Blowups of Weierstrass models are currently only supported for toric ambient spaces"

  # Compute the new ambient_space
  bd = blow_up(ambient_space(w), I; coordinate_name = coordinate_name)
  new_ambient_space = domain(bd)

  # Compute the new base
  # FIXME: THIS WILL IN GENERAL BE WRONG! IN PRINCIPLE, THE ABOVE ALLOWS TO BLOW UP THE BASE AND THE BASE ONLY.
  # FIXME: We should save the projection \pi from the ambient space to the base space.
  # FIXME: This is also ties in with the model sections to be saved, see below. Should the base change, so do these sections...
  new_base = base_space(w)

  # Prepare for the computation of the strict transform of the Weierstrass polynomial
  # FIXME: This assume that I is generated by indeterminates! Very special!
  S = cox_ring(new_ambient_space)
  _e = eval_poly(coordinate_name, S)
  images = MPolyRingElem[]
  for v in gens(S)
    v == _e && continue
    if string(v) in [string(k) for k in gens(I)]
      push!(images, v * _e)
    else
      push!(images, v)
    end
  end
  ring_map = hom(base_ring(I), S, images)
  total_transform = ring_map(ideal([weierstrass_polynomial(w)]))
  exceptional_ideal = total_transform + ideal([_e])
  strict_transform, exceptional_factor = saturation_with_index(total_transform, exceptional_ideal)
  new_pw = gens(strict_transform)[1]

  # Extract the old Weierstrass sections, which do not change.
  f = weierstrass_section_f(w)
  g = weierstrass_section_g(w)

  # Construct the new model
  # This is not really a Weierstrass model any more, as the hypersurface equation is merely a strict transform of a Weierstrass polynomial.
  # Change/Fix? We may want to provide not only output that remains true forever but also output, while the internals may change?
  model = WeierstrassModel(f, g, new_pw, base_space(w), new_ambient_space)

  # Copy known attributes from old model and overwrite as appropriate
  model_attributes = w.__attrs
  for (key, value) in model_attributes
    set_attribute!(model, key, value)
  end
  set_attribute!(model, :partially_resolved, true)

  # Return the partially resolved model
  return model
end
