#####################################################
# 1: Resolve a Weierstrass model via blowup
#####################################################

@doc raw"""
    blow_up(w::WeierstrassModel, ideal_gens::Vector{String}; coordinate_name::String = "e")

Resolve a Weierstrass model by blowing up a locus in the ambient space.

# Examples
```jldoctest
julia> B2 = projective_space(NormalToricVariety, 2)
Normal toric variety

julia> b = torusinvariant_prime_divisors(B2)[1]
Torus-invariant, prime divisor on a normal toric variety

julia> w = literature_model(arxiv_id = "1208.2695", equation = "B.19", base_space = B2, model_sections = Dict("b" => b), completeness_check = false)
Construction over concrete base may lead to singularity enhancement. Consider computing singular_loci. However, this may take time!

Weierstrass model over a concrete base -- U(1) Weierstrass model based on arXiv paper 1208.2695 Eq. (B.19)

julia> blow_up(w, ["x", "y", "x1"]; coordinate_name = "e1")
Partially resolved Weierstrass model over a concrete base -- U(1) Weierstrass model based on arXiv paper 1208.2695 Eq. (B.19)
```
"""
function blow_up(w::WeierstrassModel, ideal_gens::Vector{String}; coordinate_name::String = "e")
  R = cox_ring(ambient_space(w))
  I = ideal([eval_poly(k, R) for k in ideal_gens])
  return blow_up(w, I; coordinate_name = coordinate_name)
end

function blow_up(w::WeierstrassModel, I::MPolyIdeal; coordinate_name::String = "e")
  
  # This method only works if the model is defined over a toric variety over toric scheme
  @req typeof(base_space(w)) <: NormalToricVariety "Blowups of Weierstrass models are currently only supported for toric bases"
  @req typeof(ambient_space(w)) <: NormalToricVariety "Blowups of Weierstrass models are currently only supported for toric ambient spaces"

  # Compute the new ambient_space
  bd = blow_up(ambient_space(w), I; coordinate_name = coordinate_name)
  new_ambient_space = domain(bd)

  # Compute the new base
  # FIXME: THIS WILL IN GENERAL BE WRONG! IN PRINCIPLE, THE ABOVE ALLOWS TO BLOW UP THE BASE AND THE BASE ONLY.
  # FIXME: We should save the projection \pi from the ambient space to the base space.
  # FIXME: This is also ties in with the model sections to be saved, see below. Should the base change, so do these sections...
  new_base = base_space(w)

  # Prepare for the computation of the strict transform of the Weierstrass polynomial
  # FIXME: This assume that I is generated by indeterminates! Very special!
  S = cox_ring(new_ambient_space)
  _e = eval_poly(coordinate_name, S)
  images = MPolyRingElem[]
  for v in gens(S)
    v == _e && continue
    if string(v) in [string(k) for k in gens(I)]
      push!(images, v * _e)
    else
      push!(images, v)
    end
  end
  ring_map = hom(base_ring(I), S, images)
  total_transform = ring_map(ideal([weierstrass_polynomial(w)]))
  exceptional_ideal = total_transform + ideal([_e])
  strict_transform, exceptional_factor = saturation_with_index(total_transform, exceptional_ideal)
  new_pw = gens(strict_transform)[1]

  # Extract the old Weierstrass sections, which do not change.
  f = weierstrass_section_f(w)
  g = weierstrass_section_g(w)

  # Construct the new model
  # This is not really a Weierstrass model any more, as the hypersurface equation is merely a strict transform of a Weierstrass polynomial.
  # Change/Fix? We may want to provide not only output that remains true forever but also output, while the internals may change?
  model = WeierstrassModel(f, g, new_pw, base_space(w), new_ambient_space)

  # Copy known attributes from old model and overwrite as appropriate
  model_attributes = w.__attrs
  for (key, value) in model_attributes
    set_attribute!(model, key, value)
  end
  set_attribute!(model, :partially_resolved, true)

  # Return the partially resolved model
  return model
end


#####################################################
# 2: Tune a Weierstrass model
#####################################################

@doc raw"""
    tune(w::WeierstrassModel, special_section_choices::Dict{String, <:MPolyRingElem}; completeness_check::Bool = true)

Tune a Weierstrass model. For this, a dictionary is presented as second argument,
which specifies the desired specific choices for the Weierstrass sections.

# Examples
```jldoctest
julia> B2 = projective_space(NormalToricVariety, 2)
Normal toric variety

julia> b = torusinvariant_prime_divisors(B2)[1]
Torus-invariant, prime divisor on a normal toric variety

julia> w = literature_model(arxiv_id = "1208.2695", equation = "B.19", base_space = B2, model_sections = Dict("b" => b), completeness_check = false)
Construction over concrete base may lead to singularity enhancement. Consider computing singular_loci. However, this may take time!

Weierstrass model over a concrete base -- U(1) Weierstrass model based on arXiv paper 1208.2695 Eq. (B.19)

julia> x1, x2, x3 = gens(cox_ring(base_space(w)))
3-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x1
 x2
 x3

julia> my_choice = Dict("f" => x1^12)
Dict{String, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}} with 1 entry:
  "f" => x1^12

julia> tuned_w = tune(w, my_choice)
Weierstrass model over a concrete base

julia> weierstrass_section_f(tuned_w) == my_choice["f"]
true
```
"""
function tune(w::WeierstrassModel, special_section_choices::Dict{String, <:MPolyRingElem}; completeness_check::Bool = true)
  @req !(typeof(base_space(w)) <: FamilyOfSpaces) "Currently, tuning is only possible for models over concrete toric bases"
  isempty(special_section_choices) && return w
  f = weierstrass_section_f(w)
  g = weierstrass_section_g(w)
  if haskey(special_section_choices, "f")
    @req parent(special_section_choices["f"]) == parent(weierstrass_section_f(w)) "Parent mismatch between given and existing Weierstrass section f"
    @req degree(special_section_choices["f"]) == degree(weierstrass_section_f(w)) "Parent mismatch between given and existing Weierstrass section f"
    f = special_section_choices["f"]
  end
  if haskey(special_section_choices, "g")
    @req parent(special_section_choices["g"]) == parent(weierstrass_section_g(w)) "Parent mismatch between given and existing Weierstrass section g"
    @req degree(special_section_choices["g"]) == degree(weierstrass_section_g(w)) "Parent mismatch between given and existing Weierstrass section g"
    g = special_section_choices["g"]
  end
  return weierstrass_model(base_space(w), f, g; completeness_check)
end


@doc raw"""
    tune(w::WeierstrassModel, p::MPolyRingElem; completeness_check::Bool = true)

Tune a Weierstrass model by replacing the Weierstrass polynomial by a custom hypersurface
equation (given by a polynomial). The latter can be any type of polynomial:
a Tate polynomial, Weierstrass polynomial or a general hypersurface. We do not
conduct checks to tell if the provided polynomial is a Weierstrass polynomial. Instead,
we always return a hypersurface model.

Note that currently, there is less functionality for hypersurface models than for
Weierstrass model. For instance, `singular_loci` can currently not be computed
for hypersurface models.

# Examples
```jldoctest
julia> B2 = projective_space(NormalToricVariety, 2)
Normal toric variety

julia> b = torusinvariant_prime_divisors(B2)[1]
Torus-invariant, prime divisor on a normal toric variety

julia> w = literature_model(arxiv_id = "1208.2695", equation = "B.19", base_space = B2, model_sections = Dict("b" => b), completeness_check = false)
Construction over concrete base may lead to singularity enhancement. Consider computing singular_loci. However, this may take time!

Weierstrass model over a concrete base -- U(1) Weierstrass model based on arXiv paper 1208.2695 Eq. (B.19)

julia> x1, x2, x3, x, y, z = gens(parent(weierstrass_polynomial(w)))
6-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x1
 x2
 x3
 x
 y
 z

julia> new_weierstrass_polynomial = x^3 - y^2 - x3^12 * x * z^4
-x3^12*x*z^4 + x^3 - y^2

julia> tuned_w = tune(w, new_weierstrass_polynomial)
Hypersurface model over a concrete base

julia> hypersurface_equation(tuned_w) == new_weierstrass_polynomial
true

julia> base_space(tuned_w) == base_space(w)
true
```
"""
function tune(w::WeierstrassModel, p::MPolyRingElem; completeness_check::Bool = true)
  @req !(typeof(base_space(w)) <: FamilyOfSpaces) "Currently, tuning is only possible for models over concrete toric bases"
  @req parent(p) == parent(weierstrass_polynomial(w)) "Parent mismatch between given and existing Weierstrass polynomial"
  @req degree(p) == degree(weierstrass_polynomial(w)) "Degree mismatch between given and existing Weierstrass polynomial"
  p == weierstrass_polynomial(w) && return w
  tuned_model = HypersurfaceModel(base_space(w), ambient_space(w), fiber_ambient_space(w), p)
  set_attribute!(tuned_model, :partially_resolved, false)
  return tuned_model
end
