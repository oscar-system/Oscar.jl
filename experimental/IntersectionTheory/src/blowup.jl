function _parse_symbol(symbol::String, I::UnitRange)
  return ["$symbol[$i]" for i in I]
end
function _parse_symbol(symbol::String, n::Int, I::UnitRange)
  return [symbol*"[$n, $i]" for i in I]
end

@doc raw"""
      present_finite_extension_ring(F::Oscar.AffAlgHom)

Given a finite homomorphism `F` $:$ `A` $\rightarrow$ `B`  of algebras of type `<: Union{MPolyRing, MPolyQuoRing}` over a field, return a presentation

$A^r \rightarrow A^s\rightarrow B \rightarrow 0$

of `B` as an `A`-module.

More precisely, return a tuple `(gensB, M, pf)`, say, where
- `gensB` is a vector of polynomials representing generators for `B` as an `A`-module,
- `M` is an `r` $\times$ `s`-matrix of polynomials defining the map $A^r \rightarrow A^s$, and
- `pf` is a map which gives rise to a section of the map $ A^s\rightarrow B$.

!!! note
    The finiteness condition on `F` is checked by the function.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> I = ideal(R, [z^2-y^2*(y+1)])
Ideal generated by
  -y^3 - y^2 + z^2

julia> A, _ = quo(R, I)
(Quotient of multivariate polynomial ring by ideal (-y^3 - y^2 + z^2), Map: R -> A)

julia> B, (s,t) =  polynomial_ring(QQ, ["s", "t"]);

julia> F = hom(A,B, [s, t^2-1, t*(t^2-1)])
Ring homomorphism
  from quotient of multivariate polynomial ring by ideal (-y^3 - y^2 + z^2)
  to multivariate polynomial ring in 2 variables over QQ
defined by
  x -> s
  y -> t^2 - 1
  z -> t^3 - t

julia> gensB, M, pf = present_finite_extension_ring(F);

julia> gensB
2-element Vector{QQMPolyRingElem}:
 t
 1

julia> M
2×2 Matrix{QQMPolyRingElem}:
 y   -z
 -z  y^2 + y

julia> pf(s)
2-element Vector{QQMPolyRingElem}:
 0
 x

julia> pf(t)
2-element Vector{QQMPolyRingElem}:
 1
 0

```

```
julia> A, (a, b, c) = polynomial_ring(QQ, ["a", "b", "c"]);

julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> I = ideal(R, [x*y])
Ideal generated by
  x*y

julia> B, _ = quo(R, I)
(Quotient of multivariate polynomial ring by ideal (x*y), Map: R -> B)

julia> (x, y, z) = gens(B)
3-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:
 x
 y
 z

julia> F = hom(A, B, [x^2+z, y^2-1, z^3])
Ring homomorphism
  from multivariate polynomial ring in 3 variables over QQ
  to quotient of multivariate polynomial ring by ideal (x*y)
defined by
  a -> x^2 + z
  b -> y^2 - 1
  c -> z^3

julia> gensB, M, pf = present_finite_extension_ring(F);

julia> gensB
2-element Vector{QQMPolyRingElem}:
 y
 1

julia> M
2×2 Matrix{QQMPolyRingElem}:
 a^3 - c  0
 0        a^3*b + a^3 - b*c - c

julia> pf(y)
2-element Vector{QQMPolyRingElem}:
 1
 0

julia> pf(one(B))
2-element Vector{QQMPolyRingElem}:
 0
 1

```
"""
function  present_finite_extension_ring(F::Oscar.AffAlgHom)
  A, B = F.domain, F.codomain
  
  if A isa MPolyQuoRing
    AR = base_ring(A)
  else
    AR = A
  end
  if B isa MPolyQuoRing
    BR = base_ring(B)
    M = [F(gens(A)[i]).f for i = 1:ngens(A)]
  else
    BR = B
    M = [F(gens(A)[i]) for i = 1:ngens(A)]
  end
  @assert base_ring(AR) == base_ring(BR)

  I = ideal(BR, isdefined(B, :I) ? vcat(gens(B.I), M) : M)
  C, _ = quo(BR, I)
  gensB = monomial_basis(C)
  @assert gensB[end] == 1 # the last one should always be 1
  g = length(gensB)

  base = base_ring(AR)
  symsA, symsB = string.(gens(AR)), string.(gens(BR))
  a, b = length(symsA), length(symsB)
  R, _ = tensor_product(BR, AR, use_product_ordering = true)
  ba = gens(R)

  AtoR = hom(AR, R, ba[b+1:end], check = false)
  BtoR = hom(BR, R, ba[1:b], check = false)
  RtoA = hom(R, AR, vcat(repeat([AR()], b), gens(AR)))
  
  gensB_lift = [R(BtoR(g)) for g in gensB]
  
  # compute the ideal J of the graph of F
  rels = [R(ba[b+i]-BtoR(m)) for (i,m) in enumerate(M)]
  if isdefined(A, :I) for g in gens(A.I) push!(rels, R(AtoR(g))) end end
  if isdefined(B, :I) for g in gens(B.I) push!(rels, R(BtoR(g))) end end
  J = ideal(R, rels) # the ideal of the graph of F

  V = groebner_basis(J)
  pf = x -> (y = reduce(R(BtoR(BR(x))), gens(V));
	     ans = Nemo.elem_type(AR)[];
	     for i in 1:g
	       q = div(y, gensB_lift[i])
	       push!(ans, RtoA(q))
	       y -= q * gensB_lift[i]
	     end; ans)

  FM = free_module(R, g)
  gB = elem_type(FM)[FM(push!([j == i ? R(1) : R() for j in 1:g-1], -gensB_lift[i])) for i in 1:g-1]
  gJ = elem_type(FM)[FM([j==i ? x : R() for j in 1:g]) for x in gens(J) for i in 1:g]
  U  = vcat(gB, gJ)
  S, _ = sub(FM, U)
  P = groebner_basis(S, ordering = default_ordering(R)*lex(FM))
  Rw, _ = grade(R, vcat(repeat([1], b), repeat([0], a)))
  RtoRw = hom(R, Rw, gens(Rw))
  inA = x -> x == zero(Rw) ?  true : (degree(Int, leading_term(RtoRw(x)))) <= 0
  M = hcat([(RtoA.(Vector(P[i]))) for i in 1:ngens(P) if all(inA, Vector(P[i]))]...)
 
  return gensB, M, pf
end

######################################
@doc raw"""
      blowup(i::AbstractVarietyMap; symbol::String="e")

Given an inclusion `i`$ : $ `X` $\rightarrow$ `Y`, say, return the blowup of `Y` along `X`.

More precisely, return a tuple `(Bl, E, j)`, say, where
- `Bl`, an abstract variety, is the blowup,
- `E`, an abstract variety, is the exceptional divisor, and
- `j`, a map of abstract varieties, is the inclusion of `E` into `Bl`.

!!! note
    The resulting maps `Bl` $\rightarrow$ `Y` and `E` $\rightarrow$ `X` are obtained entering `structure_map(E)` and `structure_map(Bl)`, respectively.

# Examples

```jldoctest
julia> P2 = abstract_projective_space(2)
AbstractVariety of dim 2

julia> P5 = abstract_projective_space(5, symbol = "H")
AbstractVariety of dim 5

julia> h = gens(P2)[1]
h

julia> H = gens(P5)[1]
H

julia> i = hom(P2, P5, [2*h])
AbstractVarietyMap from AbstractVariety of dim 2 to AbstractVariety of dim 5

julia> Bl, E, j = blowup(i)
(AbstractVariety of dim 5, AbstractVariety of dim 4, AbstractVarietyMap from AbstractVariety of dim 4 to AbstractVariety of dim 5)

julia> e, HBl = gens(chow_ring(Bl))
2-element Vector{MPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:
 e
 H

julia> integral((6*HBl-2*e)^5)
3264

```
"""
function blowup(i::AbstractVarietyMap; symbol::String = "e")
  SED = symbol
  X, Y = i.domain, i.codomain
  N = -i.T # normal bundle
  d = rank(N) # codimension of X in Y
  d <= 0 && error("not a proper subvariety")
  AˣY, RY = Y.ring, base_ring(Y.ring)
  gs, M, pf = present_finite_extension_ring(i.pullback)
  n = length(gs)

 # the last variable E is the class of the exceptional divisor
  syms = vcat(push!(_parse_symbol(SED, 1:n-1), SED), string.(gens(RY)))
  degs = [degree(Int, X(gs[i])) + 1 for i in 1:n]
  degsRY = [Int(degree(gens(RY)[i])[1])  for i = 1:ngens(RY)]
  RBl = graded_polynomial_ring(Y.base, syms, vcat(degs, degsRY))[1]
  
  E, y = gens(RBl)[1:n], gens(RBl)[n+1:end]
  fˣ = hom(RY, RBl, y)
  jₓgˣ = x -> sum(E .* fˣ.(pf(x.f)))
 
  # now we determine the relations in AˣBl

  rels = elem_type(RY)[]

  # 1) relations from Y
  if isdefined(AˣY, :I)
    for r in fˣ.(gens(AˣY.I)) push!(rels, r) end
  end

# 2) relations for AˣX as an AˣY-module
  for r in transpose(E) * fˣ.(M) push!(rels, r) end

# 3) jₓx ⋅ jₓy = -jₓ(x⋅y⋅ζ)
  # recall that E[i] = jₓgˣ(gs[i])
  for j in 1:n-1, k in j:n-1
    push!(rels, E[j] * E[k] + jₓgˣ(X(gs[j] * gs[k])) * (-E[end]))
  end

# 4) relation for AˣPN: ∑ gˣcₖ(N) ⋅ ζᵈ⁻ᵏ = 0
  cN = total_chern_class(N)[0:d] # cN[k] = cₖ₋₁(N)
  push!(rels, sum([jₓgˣ(cN[k+1]) * (-E[end])^(d-k) for k in 0:d]))

 # 5) fˣiₓx = jₓ(gˣx ⋅ ctop(Q)) where Q is the tautological quotient bundle on PN
  # we have ctop(Q) = ∑ gˣcₖ₋₁(N) ⋅ ζᵈ⁻ᵏ
  for j in 1:n
    lhs = fˣ(i.pushforward(X(gs[j])).f) # this is the crucial step where iₓ is needed
    rhs = sum([jₓgˣ(gs[j] * cN[k]) * (-E[end])^(d-k) for k in 1:d])
    push!(rels, lhs - rhs)
  end

  AˣBl, _ = quo(RBl , ideal( RBl, rels))
  Bl = abstract_variety(Y.dim, AˣBl)

# Bl being constructed, we add the morphisms f, g, and j
  RBltoRY = hom(RBl, RY, vcat(repeat([RY()], n), gens(RY)))
  fₓ = x -> (xf = simplify(x).f;
	     Y(RBltoRY(xf));)
  fₓ = map_from_func(fₓ, Bl.ring, Y.ring)
  f = AbstractVarietyMap(Bl, Y, Bl.(y), fₓ)
  Bl.struct_map = f
  if isdefined(Y, :point) Bl.point = f.pullback(Y.point) end
  PN = abstract_projective_bundle(N) # the exceptional divisor as the projectivization of N
  
  g = PN.struct_map
  ζ = g.O1
  jˣ = vcat([-ζ * g.pullback(X(xi)) for xi in gs], [g.pullback(i.pullback(f)) for f in gens(AˣY)])
  
  # pushforward of j: write as a polynomial in ζ, and compute term by term
  RX = base_ring(X.ring)
  RPNtoRX = hom(base_ring(PN.ring), RX, pushfirst!(gens(RX), RX()))
  jₓ = x -> (xf = simplify(x).f;
	     RX = base_ring(X.ring); ans = RBl();
	     for k in d-1:-1:0
	       q = div(xf, ζ.f^k)
	       ans += jₓgˣ(X(RPNtoRX(q))) * (-E[end])^k
	       xf -= q * ζ.f^k
	     end; Bl(ans))
  jₓ = map_from_func(jₓ, PN.ring, Bl.ring)
  j = AbstractVarietyMap(PN, Bl, jˣ, jₓ)

  # the normal bundle of E in Bl is O(-1)
  j.T = -PN.bundles[1]

  # finally, compute the tangent bundle of Bl
  # 0 → Bl.T → fˣ(Y.T) → jₓ(Q) → 0 where Q is the tautological quotient bundle
  f.T = -pushforward(j, PN.bundles[2])
  Bl.T = pullback(f, Y.T) + f.T

# chern(Bl.T) can be readily computed from its Chern character, but the following is faster
  α = sum(sum((binomial(ZZ(d-j), ZZ(k)) - binomial(ZZ(d-j), ZZ(k+1))) * ζ^k for k in 0:d-j) * g.pullback(chern_class(N, j)) for j in 0:d)
  Bl.T.chern = simplify(f.pullback(total_chern_class(Y.T)) + j.pushforward(g.pullback(total_chern_class(X.T)) * α))
  set_attribute!(PN, :projections => [j, g])
  set_attribute!(Bl, :exceptional_divisor => PN)
  set_attribute!(Bl, :description => "Blowup of $Y with center $X")
  if get_attribute(X, :alg) == true && get_attribute(Y, :alg) == true
    set_attribute!(Bl, :alg => true)
  end
  return Bl, PN, j
end


@doc raw"""
    function blowup_points(X::AbstractVariety, n::Int; symbol::String = "e")

Return the blowup of `X` at `n` points.

# Examples
```jldoctest
julia> P2 = abstract_projective_space(2)
AbstractVariety of dim 2

julia> Bl = blowup_points(P2, 1)
AbstractVariety of dim 2

julia> chow_ring(Bl)
Quotient
  of multivariate polynomial ring in 2 variables over QQ graded by
    e -> [1]
    h -> [1]
  by ideal (h^3, e*h, e^3, e^2 + h^2)

```
"""
function blowup_points(X::AbstractVariety, n::Int; symbol::String = "e")
  SED = symbol
  if n == 1
    symbs = [SED]
  else
    symbs = _parse_symbol(SED, 1:n)
  end
  Bl = X
  P = abstract_point(base = X.base)
  for i in 1:n
    Bl = blowup(hom(P, Bl, [zero(P.ring)]), symbol=symbs[i])[1]
  end
  set_attribute!(Bl, :description => "Blowup of $X at $n points")
  Bl.struct_map = hom(Bl, X)
  if get_attribute(X, :alg) == true
    set_attribute!(Bl, :alg => true)
  end
  return Bl
end







