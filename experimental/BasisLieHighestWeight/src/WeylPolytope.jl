
@doc raw"""
    orbit_weylgroup(L::LieAlgebraStructure, weight_w::Vector{ZZRingElem}) -> Vector{Vector{ZZRingElem}}

Computes the orbit of the weight `weight_w` given as coefficients to the fundamental weights
$\omega_i$ under the action of the Weyl group of the Lie algebra `L`.
"""
function orbit_weylgroup(L::LieAlgebraStructure, weight_w::Vector{ZZRingElem})
  # initialization
  weyl_group = GAPWrap.WeylGroup(GAPWrap.RootSystem(L.lie_algebra_gap))
  orbit_iterator = GAPWrap.WeylOrbitIterator(weyl_group, GAP.Obj(Int.(weight_w)))
  vertices = Vector{ZZRingElem}[]

  # operate with the weylgroup on weight_vector
  while !(GAPWrap.IsDoneIterator(orbit_iterator))
    w = GAPWrap.NextIterator(orbit_iterator)
    push!(vertices, Vector{ZZRingElem}(w))
  end

  return vertices
end

@doc raw"""
    get_dim_weightspace(L::LieAlgebraStructure, highest_weight::Vector{ZZRingElem}) -> Dict{Vector{ZZRingElem},Int}

Computes the dimension of the weight spaces of the Lie algebra `L` module with highest weight `highest_weight`.
For all dominant weights, the dimension is computed with GAP. For the remaining weights, the dimension is
calculated by checking which dominant weight lies in the orbit of the weight under the action of the Weyl group.

The weights are given as coefficients to the fundamental weights $\omega_i$.
"""
function get_dim_weightspace(L::LieAlgebraStructure, highest_weight::Vector{ZZRingElem})
  # calculate dimension for dominant weights with GAP
  root_system = root_system_gap(L)
  dominant_char = GAP.Globals.DominantCharacter(root_system, GAP.Obj(Int.(highest_weight)))
  dominant_weights = map(weight -> ZZ.(weight), dominant_char[1])
  dominant_weights_dim = Int.(dominant_char[2])
  weightspaces = Dict{Vector{ZZRingElem},Int}()

  # calculate dimension for the rest by checking which dominant weight lies in the orbit
  for (dominant_weight, dim) in zip(dominant_weights, dominant_weights_dim)
    for weight in orbit_weylgroup(L, dominant_weight)
      weightspaces[highest_weight - weight] = dim
    end
  end
  return weightspaces
end

function convert_lattice_points_to_monomials(
  ZZx::ZZMPolyRing, lattice_points_weightspace::Vector{Vector{ZZRingElem}}
)
  return [ZZx([ZZ(1)], [lattice_point]) for lattice_point in lattice_points_weightspace]
end

@doc raw"""
    get_lattice_points_of_weightspace(root_weights::Vector{Vector{QQFieldElem}}, weight::Vector{QQFieldElem}, zero_coordinates::Vector{Int})


Calculates all lattice points in a given weightspace for a Lie algebra highest weight module.
This is equivalent to finding $\mathbb{Z}$-linear combinations of `root_weights` that equal `weight`,
where the coordinates in `zero_coordinates` are set to zero.
All weights are given as coefficients to the simple roots $\alpha_i$.
"""
function get_lattice_points_of_weightspace(
  root_weights::Vector{Vector{QQFieldElem}},
  weight::Vector{QQFieldElem},
  zero_coordinates::Vector{Int},
)
  # calculate all integer solutions to the following linear program:
  # [   |              |    ]       [   x   ]      
  # [root_weights[1]...root_weights[k]]   *   [   |   ]   =   weight
  # [   |              |    ]       [  res  ] 
  # [   |              |    ]       [   |   ]
  # where res[i] >= 0 for all i
  n = length(root_weights)
  m = length(weight)

  A = zero_matrix(QQ, 2m + n + length(zero_coordinates), n)
  b = [zero(QQ) for _ in 1:(2m + n + length(zero_coordinates))]

  # equalities
  for i in 1:n
    w = matrix(QQ, m, 1, root_weights[i])
    A[1:m, i] = w
    A[(m + 1):(2m), i] = -w
  end

  b[1:m] = weight
  b[(m + 1):(2m)] = -weight
  # non-negativity
  for i in 1:n
    A[2m + i, i] = -1
  end
  for (j, i) in enumerate(zero_coordinates)
    A[2m + n + j, i] = 1
    b[2m + n + j] = 0
  end
  sol = Vector{ZZRingElem}.(lattice_points(polyhedron(A, b)))
  return sol
end

@doc raw"""
    compute_zero_coordinates(bir_sequence::BirationalSequence, highest_weight::Vector{ZZRingElem})

This function returns all indices into the birational sequence `bir_sequence` that correspond to
root vectors that are in the annihilator of the submodule generated by everything on their right
on the highest weight vector.
"""
function compute_zero_coordinates(
  bir_sequence::BirationalSequence, highest_weight::Vector{ZZRingElem}
)
  n = length(bir_sequence.weights_alpha)
  m = length(highest_weight)
  non_zeros = Set{Int}(findall(!iszero, highest_weight))

  zero_coordinates = Int[]
  for c in n:-1:1
    length(non_zeros) == m && break
    if !isdisjoint(non_zeros, findall(!iszero, bir_sequence.weights_alpha[c]))
      union!(non_zeros, findall(<(0), bir_sequence.weights_w[c]))
    else
      push!(zero_coordinates, c)
    end
  end
  return zero_coordinates
end
