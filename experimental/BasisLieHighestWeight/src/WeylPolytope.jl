
@doc raw"""
    get_dim_weightspace(L::LieAlgebraStructure, highest_weight::WeightLatticeElem) -> Dict{Vector{ZZRingElem},Int}

Computes the dimension of the weight spaces of the Lie algebra `L` module with highest weight `highest_weight`.

The weights are given as coefficients to the fundamental weights $\omega_i$.
"""
function get_dim_weightspace(L::LieAlgebraStructure, highest_weight::WeightLatticeElem)
  weightspaces = Dict{WeightLatticeElem,Int}()
  for (weight, dim) in character(L.lie_algebra, highest_weight)
    weightspaces[highest_weight - WeightLatticeElem(root_system(L), weight)] = dim
  end
  return weightspaces
end

function convert_lattice_points_to_monomials(
  ZZx::ZZMPolyRing, lattice_points_weightspace::Vector{Vector{ZZRingElem}}
)
  return [ZZx([ZZ(1)], [lattice_point]) for lattice_point in lattice_points_weightspace]
end

@doc raw"""
    get_lattice_points_of_weightspace(root_weights::Vector{Vector{QQFieldElem}}, weight::Vector{QQFieldElem}, zero_coordinates::Vector{Int})


Calculates all lattice points in a given weightspace for a Lie algebra highest weight module.
This is equivalent to finding $\mathbb{Z}$-linear combinations of `root_weights` that equal `weight`,
where the coordinates in `zero_coordinates` are set to zero.
All weights are given as coefficients to the simple roots $\alpha_i$.
"""
function get_lattice_points_of_weightspace(
  root_weights::Vector{RootSpaceElem},
  weight::RootSpaceElem,
  zero_coordinates::Vector{Int},
)
  # calculate all integer solutions to the following linear program:
  # [   |              |    ]       [   x   ]      
  # [root_weights[1]...root_weights[k]]   *   [   |   ]   =   weight
  # [   |              |    ]       [  res  ] 
  # [   |              |    ]       [   |   ]
  # where res[i] >= 0 for all i
  n = length(root_weights)
  m = rank(root_system(weight))

  A = zero_matrix(QQ, 2m + n + length(zero_coordinates), n)
  b = [zero(QQ) for _ in 1:(2m + n + length(zero_coordinates))]

  # equalities
  for i in 1:n
    w = transpose(coefficients(root_weights[i]))
    A[1:m, i] = w
    A[(m + 1):(2m), i] = -w
  end

  b[1:m] = Oscar._vec(coefficients(weight))
  b[(m + 1):(2m)] = -Oscar._vec(coefficients(weight))
  # non-negativity
  for i in 1:n
    A[2m + i, i] = -1
  end
  for (j, i) in enumerate(zero_coordinates)
    A[2m + n + j, i] = 1
    b[2m + n + j] = 0
  end
  sol = Vector{ZZRingElem}.(lattice_points(polyhedron(A, b)))
  return sol
end

@doc raw"""
    compute_zero_coordinates(bir_sequence::BirationalSequence, highest_weight::WeightLatticeElem)

This function returns all indices into the birational sequence `bir_sequence` that correspond to
root vectors that are in the annihilator of the submodule generated by everything on their right
on the highest weight vector.
"""
function compute_zero_coordinates(
  bir_sequence::BirationalSequence, highest_weight::WeightLatticeElem
)
  n = length(bir_sequence.operator_roots)
  m = rank(root_system(highest_weight))
  non_zeros = Set(findall(!iszero, coefficients(highest_weight)))

  zero_coordinates = Int[]
  for c in n:-1:1
    length(non_zeros) == m && break
    if !isdisjoint(non_zeros, findall(!iszero, coefficients(bir_sequence.operator_roots[c])))
      union!(non_zeros, findall(<(0), coefficients(bir_sequence.operator_weights[c])))
    else
      push!(zero_coordinates, c)
    end
  end
  return zero_coordinates
end
