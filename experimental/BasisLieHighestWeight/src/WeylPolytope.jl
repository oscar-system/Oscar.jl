function convert_lattice_points_to_monomials(
  ZZx::ZZMPolyRing, lattice_points_weightspace::Vector{Vector{ZZRingElem}}
)
  return [ZZx([ZZ(1)], [lattice_point]) for lattice_point in lattice_points_weightspace]
end

@doc raw"""
    get_lattice_points_of_weightspace(root_weights::Vector{Vector{QQFieldElem}}, weight::Vector{QQFieldElem}, zero_coordinates::Vector{Int})


Calculates all lattice points in a given weightspace for a Lie algebra highest weight module.
This is equivalent to finding $\mathbb{Z}$-linear combinations of `root_weights` that equal `weight`,
where the coordinates in `zero_coordinates` are set to zero.
All weights are given as coefficients to the simple roots $\alpha_i$.
"""
function get_lattice_points_of_weightspace(
  root_weights::Vector{RootSpaceElem},
  weight::RootSpaceElem,
  zero_coordinates::Vector{Int},
)
  # calculate all integer solutions to the following linear program:
  # [       |                 |       ]       [   x   ]      
  # [root_weights[1]...root_weights[k]]   *   [   |   ]   =   weight
  # [       |                 |       ]       [  res  ] 
  # [       |                 |       ]       [   |   ]
  # where res[i] >= 0 for all i
  n = length(root_weights)
  m = rank(root_system(weight))

  # equalities
  A_eq = zero_matrix(QQ, m + length(zero_coordinates), n)
  b_eq = [zero(QQ) for _ in 1:(m + length(zero_coordinates))]
  for i in 1:n
    A_eq[1:m, i] = transpose(coefficients(root_weights[i]))
  end
  b_eq[1:m] = view(coefficients(weight), 1, :)
  for (j, i) in enumerate(zero_coordinates)
    A_eq[m + j, i] = 1
  end

  # non-negativity
  A_ineq = -identity_matrix(QQ, n)
  b_ineq = [zero(QQ) for _ in 1:n]

  sol = Vector{ZZRingElem}.(lattice_points(polyhedron((A_ineq, b_ineq), (A_eq, b_eq))))
  return sol
end

@doc raw"""
    compute_zero_coordinates(bir_sequence::BirationalSequence, highest_weight::WeightLatticeElem)

This function returns all indices into the birational sequence `bir_sequence` that correspond to
root vectors that are in the annihilator of the submodule generated by everything on their right
on the highest weight vector.
"""
function compute_zero_coordinates(
  bir_sequence::BirationalSequence, highest_weight::WeightLatticeElem
)
  n = length(bir_sequence)
  m = rank(root_system(highest_weight))
  non_zeros = Set(findall(!iszero, coefficients(highest_weight)))

  zero_coordinates = Int[]
  for c in n:-1:1
    length(non_zeros) == m && break
    if !isdisjoint(
      non_zeros, findall(!iszero, coefficients(operator_as_root(bir_sequence, c)))
    )
      union!(non_zeros, findall(<(0), coefficients(operator_as_weight(bir_sequence, c))))
    else
      push!(zero_coordinates, c)
    end
  end
  return zero_coordinates
end
