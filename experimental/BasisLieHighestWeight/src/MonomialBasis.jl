@attributes mutable struct MonomialBasis{T<:ModuleData}
  V::T
  birational_seq::BirationalSequence
  monomial_ordering::MonomialOrdering
  monomials::Set{ZZMPolyRingElem}
  monomials_parent::ZZMPolyRing

  function MonomialBasis(
    V::T,
    birational_seq::BirationalSequence,
    monomial_ordering::MonomialOrdering,
    monomials::Set{ZZMPolyRingElem},
  ) where {T<:ModuleData}
    @req dim(V) == length(monomials) "dimesion mismatch"
    return new{T}(
      V,
      birational_seq,
      monomial_ordering,
      monomials,
      parent(first(monomials)),
    )
  end
end

base_lie_algebra(basis::MonomialBasis) = base_lie_algebra(basis.V)

highest_weight(basis::MonomialBasis{<:SimpleModuleData}) = highest_weight(basis.V)

dim(basis::MonomialBasis) = dim(basis.V)
length(basis::MonomialBasis) = dim(basis)

monomials(basis::MonomialBasis) = basis.monomials

monomial_ordering(basis::MonomialBasis) = basis.monomial_ordering

birational_sequence(basis::MonomialBasis) = basis.birational_seq
#TODO: Tidy show function
function Base.show(io::IO, ::MIME"text/plain", basis::MonomialBasis{<:SimpleModuleData})
  io = pretty(io)
  print(io, "Monomial basis of a highest weight module")
  print(
    io,
    Indent(),
    "\nof highest weight $(Int.(Oscar._vec(coefficients(highest_weight(basis)))))",
    Dedent(),
  )
  print(io, Indent(), "\nof dimension $(dim(basis))", Dedent())
  print(io, Indent(), "\nwith monomial ordering $(monomial_ordering(basis))", Dedent())
  # TODO: use the following line instead of printing workaround below
  # print(io, "\nover ", Lowercase(), base_lie_algebra(basis))
  # begin of workaround
  L = base_lie_algebra(basis)
  print(io, "\nover Lie algebra")
  if has_root_system(L)
    rs = root_system(L)
    if has_root_system_type(rs)
      type, ord = root_system_type_with_ordering(rs)
      print(io, " of type ", _root_system_type_string(type))
      if !issorted(ord)
        print(io, " (non-canonical ordering)")
      end
    end
  end
  # end of workaround
  if get_attribute(basis, :algorithm, nothing) in
    (basis_lie_highest_weight_compute, basis_coordinate_ring_kodaira_compute)
    print(
      io,
      Indent(),
      "\nwhere the used birational sequence consists of the following roots (given as coefficients w.r.t. alpha_i):",
      Indent(),
    )
    for root in operators_as_roots(birational_sequence(basis))
      print(io, '\n', Int.(Oscar._vec(coefficients(root))))
    end
    print(io, Dedent(), Dedent())
    print(
      io,
      Indent(),
      "\nand the basis was generated by Minkowski sums of the bases of the following highest weight modules:",
      Indent(),
    )
    for gen in get_attribute(basis, :minkowski_gens)
      print(io, '\n', Int.(Oscar._vec(coefficients(gen))))
    end
    print(io, Dedent(), Dedent())
  end
end

function Base.show(io::IO, basis::MonomialBasis{<:SimpleModuleData})
  if is_terse(io)
    print(io, "Monomial basis of a highest weight module")
  else
    io = pretty(io)
    print(
      io,
      "Monomial basis of a highest weight module with highest weight $(Int.(Oscar._vec(coefficients(highest_weight(basis))))) over ",
    )
    # TODO: use the following line instead of printing workaround below
    # print(terse(io), Lowercase(), base_lie_algebra(basis))
    # begin of workaround
    L = base_lie_algebra(basis)
    print(io, "Lie algebra")
    if has_root_system(L)
      rs = root_system(L)
      if has_root_system_type(rs)
        type, ord = root_system_type_with_ordering(rs)
        print(io, " of type ", _root_system_type_string(type))
        if !issorted(ord)
          print(io, " (non-canonical ordering)")
        end
      end
    end
    # end of workaround
  end
end

function Base.show(io::IO, ::MIME"text/plain", basis::MonomialBasis{<:DemazureModuleData})
  io = pretty(io)
  print(io, "Monomial basis of a Demazure module")
  print(
    io,
    Indent(),
    "\nof extremal weight $(Int.(Oscar._vec(coefficients(highest_weight(basis.V))))) * $(weyl_group_elem(basis.V))",
    Dedent(),
  )
  print(io, Indent(), "\nof dimension $(dim(basis))", Dedent())
  print(io, Indent(), "\nwith monomial ordering $(monomial_ordering(basis))", Dedent())
  # TODO: use the following line instead of printing workaround below
  # print(io, "\nover ", Lowercase(), base_lie_algebra(basis))
  # begin of workaround
  L = base_lie_algebra(basis)
  print(io, "\nover Lie algebra")
  if has_root_system(L)
    rs = root_system(L)
    if has_root_system_type(rs)
      type, ord = root_system_type_with_ordering(rs)
      print(io, " of type ", _root_system_type_string(type))
      if !issorted(ord)
        print(io, " (non-canonical ordering)")
      end
    end
  end
  # end of workaround
  if get_attribute(basis, :algorithm, nothing) === basis_lie_highest_weight_compute
    print(
      io,
      Indent(),
      "\nwhere the used birational sequence consists of the following roots (given as coefficients w.r.t. alpha_i):",
      Indent(),
    )
    for root in operators_as_roots(birational_sequence(basis))
      print(io, '\n', Int.(Oscar._vec(coefficients(root))))
    end
    print(io, Dedent(), Dedent())
    print(
      io,
      Indent(),
      "\nand the basis was generated by Minkowski sums of the bases of the following Demazure modules:",
      Indent(),
    )
    for gen in get_attribute(basis, :minkowski_gens)
      print(
        io, '\n', "$(Int.(Oscar._vec(coefficients(gen)))) * $(weyl_group_elem(basis.V))"
      )
    end
    print(io, Dedent(), Dedent())
  elseif get_attribute(basis, :algorithm, nothing) === basis_coordinate_ring_kodaira_compute
    print(
      io,
      Indent(),
      "\nwhere the used birational sequence consists of the following roots (given as coefficients w.r.t. alpha_i):",
      Indent(),
    )
    for root in operators_as_roots(birational_sequence(basis))
      print(io, '\n', Int.(Oscar._vec(coefficients(root))))
    end
    print(io, Dedent(), Dedent())
    print(
      io,
      Indent(),
      "\nand the basis was generated by Minkowski sums of the bases of the following Demazure modules:",
      Indent(),
    )
    for gen in get_attribute(basis, :minkowski_gens)
      print(
        io, '\n', "$(Int.(Oscar._vec(coefficients(gen)))) * $(weyl_group_elem(basis.V))"
      )
    end
    print(io, Dedent(), Dedent())
  end
end

function Base.show(io::IO, basis::MonomialBasis{<:DemazureModuleData})
  if is_terse(io)
    print(io, "Monomial basis of a Demazure module")
  else
    io = pretty(io)
    print(
      io,
      "Monomial basis of a Demazure module with extremal weight $(Int.(Oscar._vec(coefficients(highest_weight(basis.V))))) * $(weyl_group_elem(basis.V)) over ",
    )
    # TODO: use the following line instead of printing workaround below
    # print(terse(io), Lowercase(), base_lie_algebra(basis))
    # begin of workaround
    L = base_lie_algebra(basis)
    print(io, "Lie algebra")
    if has_root_system(L)
      rs = root_system(L)
      if has_root_system_type(rs)
        type, ord = root_system_type_with_ordering(rs)
        print(io, " of type ", _root_system_type_string(type))
        if !issorted(ord)
          print(io, " (non-canonical ordering)")
        end
      end
    end
    # end of workaround
  end
end
