@attributes mutable struct MonomialBasis
  lie_algebra::AbstractLieAlgebra{QQFieldElem}
  highest_weight::WeightLatticeElem
  birational_seq::BirationalSequence
  monomial_ordering::MonomialOrdering
  dimension::Int
  monomials::Set{ZZMPolyRingElem}
  monomials_parent::ZZMPolyRing

  function MonomialBasis(
    lie_algebra::AbstractLieAlgebra{QQFieldElem},
    highest_weight::WeightLatticeElem,
    birational_seq::BirationalSequence,
    monomial_ordering::MonomialOrdering,
    monomials::Set{ZZMPolyRingElem},
  )
    return new(
      lie_algebra,
      highest_weight,
      birational_seq,
      monomial_ordering,
      length(monomials),
      monomials,
      parent(first(monomials)),
    )
  end
end

base_lie_algebra(basis::MonomialBasis) = basis.lie_algebra

highest_weight(basis::MonomialBasis) = basis.highest_weight

dim(basis::MonomialBasis) = basis.dimension
length(basis::MonomialBasis) = dim(basis)

monomials(basis::MonomialBasis) = basis.monomials

monomial_ordering(basis::MonomialBasis) = basis.monomial_ordering

birational_sequence(basis::MonomialBasis) = basis.birational_seq

function Base.show(io::IO, ::MIME"text/plain", basis::MonomialBasis)
  io = pretty(io)
  print(io, "Monomial basis of a highest weight module")
  print(
    io,
    Indent(),
    "\nof highest weight $(Int.(Oscar._vec(coefficients(highest_weight(basis)))))",
    Dedent(),
  )
  print(io, Indent(), "\nof dimension $(dim(basis))", Dedent())
  print(io, Indent(), "\nwith monomial ordering $(monomial_ordering(basis))", Dedent())
  # TODO: use the following line instead of printing workaround below
  # print(io, "\nover ", Lowercase(), base_lie_algebra(basis))
  # begin of workaround
  L = base_lie_algebra(basis)
  print(io, "\nover Lie algebra")
  if has_root_system(L)
    rs = root_system(L)
    if has_root_system_type(rs)
      type, ord = root_system_type_with_ordering(rs)
      print(io, " of type ", _root_system_type_string(type))
      if !issorted(ord)
        print(io, " (non-canonical ordering)")
      end
    end
  end
  # end of workaround
  if get_attribute(basis, :algorithm, nothing) === basis_lie_highest_weight_compute
    print(
      io,
      Indent(),
      "\nwhere the used birational sequence consists of the following roots (given as coefficients w.r.t. alpha_i):",
      Indent(),
    )
    for root in operators_as_roots(birational_sequence(basis))
      print(io, '\n', Int.(Oscar._vec(coefficients(root))))
    end
    print(io, Dedent(), Dedent())
    print(
      io,
      Indent(),
      "\nand the basis was generated by Minkowski sums of the bases of the following highest weight modules:",
      Indent(),
    )
    for gen in get_attribute(basis, :minkowski_gens)
      print(io, '\n', Int.(Oscar._vec(coefficients(gen))))
    end
    print(io, Dedent(), Dedent())
  elseif get_attribute(basis, :algorithm, nothing) === basis_coordinate_ring_kodaira_compute
    print(
      io,
      Indent(),
      "\nwhere the used birational sequence consists of the following roots (given as coefficients w.r.t. alpha_i):",
      Indent(),
    )
    for root in operators_as_roots(birational_sequence(basis))
      print(io, '\n', Int.(Oscar._vec(coefficients(root))))
    end
    print(io, Dedent(), Dedent())
    print(
      io,
      Indent(),
      "\nand the basis was generated by Minkowski sums of the bases of the following highest weight modules:",
      Indent(),
    )
    for gen in get_attribute(basis, :minkowski_gens)
      print(io, '\n', Int.(Oscar._vec(coefficients(gen))))
    end
    print(io, Dedent(), Dedent())
  end
end

function Base.show(io::IO, basis::MonomialBasis)
  if is_terse(io)
    print(io, "Monomial basis of a highest weight module")
  else
    io = pretty(io)
    print(
      io,
      "Monomial basis of a highest weight module with highest weight $(Int.(Oscar._vec(coefficients(highest_weight(basis))))) over ",
    )
    # TODO: use the following line instead of printing workaround below
    # print(terse(io), Lowercase(), base_lie_algebra(basis))
    # begin of workaround
    L = base_lie_algebra(basis)
    print(io, "Lie algebra")
    if has_root_system(L)
      rs = root_system(L)
      if has_root_system_type(rs)
        type, ord = root_system_type_with_ordering(rs)
        print(io, " of type ", _root_system_type_string(type))
        if !issorted(ord)
          print(io, " (non-canonical ordering)")
        end
      end
    end
    # end of workaround
  end
end
