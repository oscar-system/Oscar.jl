
###############################################################################
#
# Orthogonal direct sums and embeddings of orthogonal groups
#
###############################################################################

# This function is called whenever A and B are in orthogonal direct sum in a
# bigger torsion module. Let D be this sum. Since A and B are in orthogonal
# direct sum in D, we can embed O(A) and O(B) in O(D) by setting the identity on
# the complement.
#
# This function returns D, the embeddings A\to D and B\to D, as well as O(D)
# together with the embeddings O(A) \to O(D) and O(B) \to O(D)
function _sum_with_embeddings_orthogonal_groups(A::TorQuadModule, B::TorQuadModule)
  D = A+B
  AinD = hom(A, D, elem_type(D)[D(lift(a)) for a in gens(A)])
  BinD = hom(B, D, elem_type(D)[D(lift(b)) for b in gens(B)])
  @hassert :ZZLatWithIsom 1 all(AinD(a)*BinD(b) == 0 for a in gens(A), b in gens(B))
  OD = orthogonal_group(D)
  OA = orthogonal_group(A)
  OB = orthogonal_group(B)

  gene = data.(union!(AinD.(gens(A)), BinD.(gens(B))))
  geneOAinOD = elem_type(OD)[]
  for f in gens(OA)
    imgf = data.(union!(AinD.(f.(gens(A))), BinD.(gens(B))))
    fab = hom(gene, imgf)
    fD = OD(hom(D, D, fab.map); check = false)
    push!(geneOAinOD, fD)
  end

  geneOBinOD = elem_type(OD)[]
  for f in gens(OB)
    imgf = data.(union!(AinD.(gens(A)), BinD.(f.(gens(B)))))
    fab = hom(gene, imgf)
    fD = OD(hom(D, D, fab.map); check = false)
    push!(geneOBinOD, fD)
  end
  OAtoOD = hom(OA, OD, geneOAinOD; check = false)
  OBtoOD = hom(OB, OD, geneOBinOD; check = false)
  return D, AinD, BinD, OD, OAtoOD, OBtoOD
end

# Construct the direct sum D of A and B. Since the images of A and B are in
# orthogonal direct sum, we can embed O(A) in O(D) and O(B) in O(D).
#
# This function returns D together with the injections A \to D and B \to D, as
# well as O(D) with the embeddings O(A) \to O(D) and O(B) \to O(D).
function _direct_sum_with_embeddings_orthogonal_groups(A::TorQuadModule, B::TorQuadModule)
  D, inj = direct_sum(A, B)
  AinD, BinD = inj
  OD = orthogonal_group(D)
  OA = orthogonal_group(A)
  OB = orthogonal_group(B)

  geneOAinOD = elem_type(OD)[]
  for f in gens(OA)
    m = block_diagonal_matrix(ZZMatrix[matrix(f), identity_matrix(ZZ, ngens(B))])
    fD = OD(hom(D, D, m); check = false)
    push!(geneOAinOD, fD)
  end

  geneOBinOD = elem_type(OD)[]
  for f in gens(OB)
    m = block_diagonal_matrix(ZZMatrix[identity_matrix(ZZ, ngens(A)), matrix(f)])
    fD = OD(hom(D, D, m); check = false)
    push!(geneOBinOD, fD)
  end
  OAtoOD = hom(OA, OD, geneOAinOD; check = false)
  OBtoOD = hom(OB, OD, geneOBinOD; check = false)
  return D, AinD, BinD, OD, OAtoOD, OBtoOD
end

###############################################################################
#
#  Local tools
#
###############################################################################


# If fq is an isometry of the torsion module q, we compute the kernel of mu(fq)
# restricted to the p-elementary part of q (i.e. the submodule of q generated by
# all the elements of order p)
#
# This object is defined in Algorithm 2 of [BH23], the glue kernel we aim to use
# for gluing lattices in a p-admissible triples are actually submodules of these
# V's.
function _get_V(fq::TorQuadModuleMor, mu::PolyRingElem, p::IntegerUnion)
  q = domain(fq)
  V, _ = primary_part(q, p)
  _, Vinq = sub(q, elem_type(q)[q(lift(divexact(order(g), p)*g)) for g in gens(V) if !(order(g)==1)])
  fpV = restrict_endomorphism(fq, Vinq; check = false)
  fpV = evaluate(mu, fpV)
  V, _ = kernel(fpV)
  Vinq = hom(V, q, elem_type(q)[q(lift(a)) for a in gens(V)])
  @hassert :ZZLatWithIsom 1 is_injective(Vinq)
  return V, Vinq
end

# This is the rho function as defined in Definition 4.8 of BH23.
function _rho_functor(q::TorQuadModule, p::IntegerUnion, l::IntegerUnion; quad::Bool = (p == 2))
  pq, pqtoq = primary_part(q, p)
  pq = rescale(pq, QQ(p)^(l-1))
  Nv = cover(pq)
  N = relations(pq)
  if quad && p == 2
    fr = _is_free(q, p, l)
  else
    fr = false
  end
  mqf = fr ? QQ(2) : QQ(1)
  if l == 0 
    Gl = N
    Gm = intersect(1//p*N, Nv)
    rholN = torsion_quadratic_module(Gl, p*Gm; modulus = QQ(1), modulus_qf = mqf)
  else
    k = l-1
    m = l+1
    Gk = intersect((1//(p^k))*N, Nv)
    Gl = intersect((1//(p^l))*N, Nv)
    Gm = intersect((1//(p^m))*N, Nv)
    B = Gk+p*Gm
    rholN = torsion_quadratic_module(Gl, B; modulus = QQ(1), modulus_qf = mqf)
  end
  return rholN
end

# A finite bilinear module over the 2-adic integers is even if all square are
# zeros.
function _is_even(T::TorQuadModule, p::IntegerUnion, l::IntegerUnion)
  B = gram_matrix_bilinear(_rho_functor(T, p, l; quad = false))
  return is_empty(B) || (all(is_zero, diagonal(B)) && all(is_integral, 2*B))
end

function _is_free(T::TorQuadModule, p::IntegerUnion, l::IntegerUnion)
  return _is_even(T, p, l-1) && _is_even(T, p, l+1)
end

###############################################################################
#
#  Overlattices
#
###############################################################################

# Compute the overlattice corresponding to the glue map gamma, in the ambient
# space of the covering lattice of the finite bilinear module D. As inputs,
# gamma must be an anti-isometry between HA and HB, both should embed in D and
# gamma commutes with the actions of fA and fB on HA and HB respectively.
#
# If `same_ambient = true`, then we consider all the problem in a same ambient
# quadratic space. In particular, the covering lattices of HA, HB and D are all
# in that same space.
#
# fA and fB here are considered as isometry of the relations lattice of HA and
# HB, respectively.
function _overlattice(gamma::TorQuadModuleMor,
                      HAinD::TorQuadModuleMor,
                      HBinD::TorQuadModuleMor,
                      fA::QQMatrix = identity_matrix(QQ, rank(relations(domain(HAinD)))),
                      fB::QQMatrix = identity_matrix(QQ, rank(relations(domain(HBinD))));
                      same_ambient::Bool = false)
  HA = domain(HAinD)
  HB = domain(HBinD)
  A = relations(HA)
  B = relations(HB)
  D = codomain(HAinD)
  if same_ambient
    _glue = Vector{QQFieldElem}[lift(g) + lift(gamma(g)) for g in gens(domain(gamma))]
    z = zero_matrix(QQ, 0, degree(A))
    glue = reduce(vcat, QQMatrix[matrix(QQ, 1, degree(A), g) for g in _glue]; init=z)
    glue = vcat(basis_matrix(A+B), glue)
    Fakeglue = FakeFmpqMat(glue)
    _FakeB = hnf(Fakeglue)
    _B = QQ(1, denominator(Fakeglue))*change_base_ring(QQ, numerator(_FakeB))
    C = lattice(ambient_space(A), _B[end-rank(A)-rank(B)+1:end, :])
    fC = block_diagonal_matrix(QQMatrix[fA, fB])
    _B = solve_left(reduce(vcat, basis_matrix.([A,B])), basis_matrix(C))
    fC = _B*fC*inv(_B)
  else
    _glue = Vector{QQFieldElem}[lift(HAinD(a)) + lift(HBinD(gamma(a))) for a in gens(domain(gamma))]
    z = zero_matrix(QQ, 0, degree(cover(D)))
    glue = reduce(vcat, QQMatrix[matrix(QQ, 1, degree(cover(D)), g) for g in _glue]; init=z)
    glue = vcat(block_diagonal_matrix(basis_matrix.(ZZLat[A, B])), glue)
    Fakeglue = FakeFmpqMat(glue)
    _FakeB = hnf(Fakeglue)
    _B = QQ(1, denominator(Fakeglue))*change_base_ring(QQ, numerator(_FakeB))
    C = lattice(ambient_space(cover(D)), _B[end-rank(A)-rank(B)+1:end, :])
    fC = block_diagonal_matrix(QQMatrix[fA, fB])
    _B = solve_left(block_diagonal_matrix(basis_matrix.(ZZLat[A, B])), basis_matrix(C))
    fC = _B*fC*inv(_B)
  end
  @hassert :ZZLatWithIsom 1 fC*gram_matrix(C)*transpose(fC) == gram_matrix(C)
  _, graph = sub(D, D.(_glue))
  return C, fC, graph
end

# Same as above where we glue along the trivial subgroups of HA and HB. In that
# particular case, HA and HB are the discriminant group of the lattices
# considered (so HA = L^{\vee}/L for some lattice integral lattice L, and same
# for HB), and D is the orthogonal direct sum of HA and HB in an appropriate
# quadratic space.
function _overlattice(HAinD::TorQuadModuleMor,
                      HBinD::TorQuadModuleMor,
                      fA::QQMatrix = identity_matrix(QQ, rank(relations(domain(HAinD)))),
                      fB::QQMatrix = identity_matrix(QQ, rank(relations(domain(HBinD))));
                      same_ambient::Bool = false)
  HA = domain(HAinD)
  HB = domain(HBinD)
  zA, _ = sub(HA, TorQuadModuleElem[])
  zB, _ = sub(HB, TorQuadModuleElem[])
  gamma = hom(zA, zB, zero_matrix(ZZ, 0, 0))
  return _overlattice(gamma, HAinD, HBinD, fA, fB; same_ambient)
end

###############################################################################
#
#  Orbits and stabilizers of discriminant subgroups
#
###############################################################################

# T is a submodule of the domain q of g, and the function return the submodule
# g(T) of q (which is isomorphic to T as torsion quadratic module by definition
# of g).
function _on_subgroups(T::TorQuadModule, g::AutomorphismGroupElem)
  q = domain(parent(g))
  gene = elem_type(q)[g(q(lift(t))) for t in gens(T)]
  return sub(q, gene)[1]
end

# Compute stabilizer of a subgroup of a `TorQuadModule` under the action by
# automorphisms.
function stabilizer(O::AutomorphismGroup{TorQuadModule}, i::TorQuadModuleMor)
  @req domain(O) === codomain(i) "Incompatible arguments"
  q = domain(O)
  N, _ = sub(q, i.(gens(domain(i))))
  stab, _ = stabilizer(O, N, _on_subgroups)
  return sub(O, elem_type(O)[O(h) for h in gens(stab)])
end

# Given an embedding of an `(O, f)`-stable finite quadratic module `V` of `q`,
# compute representatives of `O`-orbits of `f`-stable submodules of `V` of order
# `ord`. If `compute_stab = true`, then the stabilizers in `O` is also computed.
# Otherwise, we set as "fake stabilizers" the full group `O`.
#
# Note that any torsion quadratic module `H` in output is given by an embedding
# of `H` in `q`.
function _subgroups_orbit_representatives_and_stabilizers(Vinq::TorQuadModuleMor,
                                                          O::AutomorphismGroup{TorQuadModule},
                                                          ord::IntegerUnion = -1,
                                                          f::Union{TorQuadModuleMor, AutomorphismGroupElem{TorQuadModule}} = id_hom(codomain(Vinq));
                                                          compute_stab::Bool = true)
  res = Tuple{TorQuadModuleMor, AutomorphismGroup{TorQuadModule}}[]

  V = domain(Vinq)
  q = codomain(Vinq)

  if !is_divisible_by(order(V), ord)
    return res
  end

  fV = f isa TorQuadModuleMor ? restrict_endomorphism(f, Vinq; check = false) : restrict_endomorphism(hom(f), Vinq; check = false)
  if ord == -1
    subs = collect(stable_submodules(V, TorQuadModuleMor[fV]))
  else
    subs = collect(submodules(V; order = ord))
    filter!(s -> is_invariant(fV, s[2]), subs)
  end

  subs = TorQuadModule[s[1] for s in subs]
  m = gset(O, _on_subgroups, subs)
  orbs = orbits(m)
  for orb in orbs
    rep = representative(orb)
    if compute_stab
      stab, _ = stabilizer(O, rep, _on_subgroups)
    else
      stab = O
    end
    _, rep = sub(q, TorQuadModuleElem[q(lift(g)) for g in gens(rep)])
    push!(res, (rep, stab))
  end
  return res
end

# The underlying abelian groups of H and V are elementary abelian p-groups, f is
# an automorphism of V fixing H, so in particular it acts on the quotient V/H
# whose abelian structure actually defines a finite dimensional Fp-vector space.
#
# This map return Qp := V/H as an Fp-vector space, the map which transforms V into a
# Fp-vector space Vp, the quotient map Vp \to Qp, and the restriction fQp of f
# to Qp
function _cokernel_as_Fp_vector_space(HinV::TorQuadModuleMor, p::IntegerUnion)
  H = domain(HinV)
  V = codomain(HinV)

  n = ngens(V)
  F = GF(p)
  Vp = VectorSpace(F, n)

  function _VtoVp(x::TorQuadModuleElem)
    v = data(x).coeff
    return Vp(vec(collect(v)))
  end

  function _VptoV(v::ModuleElem{FpFieldElem})
    x = lift.(v.v)
    return sum(x[i]*V[i] for i in 1:n)
  end

  VtoVp = Hecke.MapFromFunc(V, Vp, _VtoVp, _VptoV)
  subgene = elem_type(Vp)[VtoVp(HinV(a)) for a in gens(H)]
  Hp, _ = sub(Vp, subgene)
  Qp, VptoQp = quo(Vp, Hp)

  return Qp, VtoVp, VptoQp
end

# Almost duplicate of an existing function: we do not always want to compute
# stabilizers but just some orbit representatives
function _orbit_representatives(G::MatrixGroup{E}, k::Int, O::AutomorphismGroup{TorQuadModule}) where E <: FinFieldElem
  F = base_ring(G)
  n = degree(G)
  q = GAP.Obj(order(F))
  V = VectorSpace(F, n)
  orbs = GAP.Globals.Orbits(G.X, GAP.Globals.Subspaces(GAP.Globals.GF(q)^n, k))
  orbs1 = [GAP.Globals.BasisVectors(GAP.Globals.Basis(orb[1])) for orb in orbs]
  orbs2 = [[[F(x) for x in v] for v in bas] for bas in orbs1]::Vector{Vector{Vector{elem_type(F)}}}
  orbs3 = [sub(V, [V(v) for v in bas])[1] for bas in orbs2]
  return [(orbs3[i], O) for i in 1:length(orbs3)]
end

# Given an embedding of an `(O, f)`-stable finite quadratic module `V` of `q`,
# where the abelian group structure on `V` is `p`-elementary, compute
# representatives of `G`-orbit of `f`-stable subgroups of `V` of order `ord`,
# which contains `p^l*q_p` where `q_p` is the `p`-primary part of `q`.
#
# Note that `G` must lie in the centralizer of `f` in `O(q)` and `G` is seen
# as a set of outer automorphisms (so two subgroups are in the
# same orbit if they are `G`-isomorphic).
#
# If `compute_stab = true`, then the stabilizers in `G` is also computed.
# Otherwise, we set as "fake stabilizers" the full group `G`.
#
# Note that any torsion quadratic module `H` in output is given by an embedding
# of `H` in `q`.
function _subgroups_orbit_representatives_and_stabilizers_elementary(Vinq::TorQuadModuleMor,
                                                                     G::AutomorphismGroup{TorQuadModule},
                                                                     ord::IntegerUnion,
                                                                     f::Union{TorQuadModuleMor, AutomorphismGroupElem{TorQuadModule}} = id_hom(codomain(Vinq)),
                                                                     l::IntegerUnion = -1;
                                                                     compute_stab::Bool = true)
  res = Tuple{TorQuadModuleMor, AutomorphismGroup{TorQuadModule}}[]

  V = domain(Vinq)

  # If V is trivial, then we ignore f and l, we just need to ensure that the
  # order wanted is also 1
  if order(V) == 1
    ord != 1 && (return res)
    push!(res, (Vinq, G))
    return res
  end

  q = codomain(Vinq)
  p = elementary_divisors(V)[1]
  pq, pqtoq = primary_part(q, p)
  l = l < 0 ? valuation(order(pq), p) : l
  g = valuation(ord, p)

  # some other trivial cases: if ord is 1, then l should be null (-1 by default)
  # Otherwise, if ord == order(V), since V is preserved by f and contained the
  # good subgroup of q, we just return V
  if ord == 1
    l < valuation(order(pq), p) && (return res)
    _, triv = sub(codomain(Vinq), TorQuadModuleElem[])
    push!(res, (triv, G))
    return res
  elseif ord == order(V)
    push!(res, (Vinq, G))
    return res
  end

  # In theory, V should contain H0 := p^l*pq where pq is the p-primary part of q
  all(a -> has_preimage(Vinq, (p^l)*pqtoq(a))[1], gens(pq)) || return res
  H0, H0inq = sub(q, elem_type(q)[q(lift((p^l)*a)) for a in gens(pq)])
  @hassert :ZZLatWithIsom 1 is_invariant(f, H0inq)

  # H0 should be contained in the group we want. So either H0 is the only one
  # and we return it, or if order(H0) > ord, there are no subgroups as wanted
  if order(H0) >= ord
    order(H0) > ord && return res
    push!(res, (H0inq, G))
    return res
  end

  H0inV = hom(H0, V, elem_type(V)[V(lift(a)) for a in gens(H0)])
  @hassert :ZZLatWithIsom 1 is_injective(H0inV)

  # Since V and H0 are elementary p-groups, they can be seen as finite
  # dimensional vector spaces over a finite field, and so is their quotient.
  # Moreover, subgroups of V of order ord and containing H0 are in bijections
  # with cosets in V/H0 of rank val_p(ord-order(H)) over the finite field F_p
  Qp, VtoVp, VptoQp = _cokernel_as_Fp_vector_space(H0inV, p)
  Vp = codomain(VtoVp)

  # Should never happen, but who knows...
  dim(Qp) == 0 && return res

  # We descend G to V for computing stabilizers later on
  GV, GtoGV = restrict_automorphism_group(G, Vinq; check = false)
  if compute_stab
    satV, j = kernel(GtoGV)
  end

  # Automorphisms in G preserved V and H0, since the construction of H0 is
  # natural. Therefore, the action of G descends to the quotient and we look for
  # invariants sub-vector spaces of given rank in the quotient (then lifting
  # generators and putting them with H0 will give us invariant subgroups as
  # wanted)
  act_GV = FpMatrix[change_base_ring(base_ring(Qp), matrix(gg)) for gg in gens(GV)]
  act_GV = FpMatrix[solve(VptoQp.matrix, g*VptoQp.matrix) for g in act_GV]
  MGp = matrix_group(base_ring(Qp), dim(Qp), act_GV)
  GVtoMGp = hom(GV, MGp, MGp.(act_GV); check = false)
  GtoMGp = compose(GtoGV, GVtoMGp)

  g-ngens(snf(abelian_group(H0))[1]) >= dim(Qp) && return res
  
  F = base_ring(Qp)
  # K is H0 but seen a subvector space of Vp (which is V)
  k, K = kernel(VptoQp.matrix; side = :left)
  gene_H0p = elem_type(Vp)[Vp(vec(collect(K[i,:]))) for i in 1:k]
  if compute_stab
    orb_and_stab = orbit_representatives_and_stabilizers(MGp, g-k)
  else
    orb_and_stab = _orbit_representatives(MGp, g-k, G)
  end

  for (orb, stab) in orb_and_stab
    i = orb.map
    gene_orbQp = elem_type(Qp)[Qp(vec(collect(i(v).v))) for v in gens(domain(i))]
    gene_orbVp = elem_type(Vp)[preimage(VptoQp, v) for v in gene_orbQp]

    gene_orbVp = vcat(gene_orbVp, gene_H0p)
    gene_orbV = elem_type(V)[preimage(VtoVp, Vp(v)) for v in gene_orbVp]
    gene_orbq = elem_type(q)[image(Vinq, v) for v in gene_orbV]
    orbq, orbqinq = sub(q, gene_orbq)
    @hassert :ZZLatWithIsom 1 order(orbq) == ord
    # We keep only f-stable subspaces
    is_invariant(f, orbqinq) || continue

    if compute_stab
      stabq_gen = elem_type(G)[GtoMGp\(s) for s in gens(stab)]
      stabq, _ = sub(G, union!(stabq_gen, gens(satV)))
      # Stabilizers should preserve the actual subspaces, by definition. so if we
      # have lifted since properly, this should hold..
      @hassert :ZZLatWithIsom 1 is_invariant(stabq, orbqinq)
    else
      stabq = G
    end
    push!(res, (orbqinq, stabq))
  end
  return res
end

# Compute `O`-orbits of `f`-stable submodules of `q` which are isometric, as
# torsion quadratic modules, to `H`. If `compute_stab = true`, it also computes
# the stabilizers in `O` of such subgroups. Otherwise, it returns as "fake
# stabilziers" the full group `O`.
#
# The outputs are given by embeddings of such submodules in `q`.
#
# The code splits the computations into primary part since they are orthogonal
# on to the others.
function _classes_isomorphic_subgroups(q::TorQuadModule,
                                       O::AutomorphismGroup{TorQuadModule},
                                       H::TorQuadModule,
                                       f::Union{TorQuadModuleMor, AutomorphismGroupElem{TorQuadModule}} = id_hom(domain(O)),
                                       compute_stab::Bool = true)
  res = Tuple{TorQuadModuleMor, AutomorphismGroup{TorQuadModule}}[]

  # Trivial case: we look for subgroups in a given primary part of q
  ok, p = is_primary_with_prime(H)
  if ok
    if is_elementary(H, p)
      _, Vinq = _get_V(id_hom(q), minimal_polynomial(identity_matrix(QQ, 1)), p)
      sors = _subgroups_orbit_representatives_and_stabilizers_elementary(Vinq, O, order(H), f; compute_stab)
    else
      _, Vinq = primary_part(q, p)
      sors = _subgroups_orbit_representatives_and_stabilizers(Vinq, O, order(H), f; compute_stab)
    end
    filter!(d -> is_isometric_with_isometry(domain(d[1]), H)[1], sors)
    return sors
  end

  # We inspect each primary part of q and look for orbit representatives and
  # stabilizers of isomorphic subgroups which will be isometric to the given
  # primary part of H.
  #
  # First, we cut q as an orthogonal direct sum of its primary parts
  pds = sort!(prime_divisors(order(q)))
  if compute_stab
    blocks = TorQuadModuleMor[primary_part(q, pds[1])[2]]
    ni = Int[ngens(domain(blocks[1]))]
    for i in 2:length(pds)
      _f = blocks[end]
      _, j = has_complement(_f)
      _T = domain(j)
      __f = primary_part(_T, pds[i])[2]
      push!(blocks, compose(__f, j))
      push!(ni, ngens(domain(__f)))
    end
    D, inj, proj = biproduct(domain.(blocks))
  else
    blocks = TorQuadModuleMor[primary_part(q, p)[2] for p in pds]
    D, inj, proj = biproduct(domain.(blocks))
  end
  phi = hom(D, q, TorQuadModuleElem[sum([blocks[i](proj[i](a)) for i in 1:length(pds)]) for a in gens(D)])
  @hassert :ZZLatWithIsom 1 is_isometry(phi)

  list_can = Vector{Tuple{TorQuadModuleMor, AutomorphismGroup{TorQuadModule}}}[]
  # We collect the possible subgroups for each primary part, with the stabilizer
  for i in 1:length(pds)
    p = pds[i]
    qpinq = blocks[i]
    qp = domain(qpinq)
    T, _ = primary_part(H, p)
    Oqp, _ = restrict_automorphism_group(O, qpinq; check = false)
    fqp = restrict_endomorphism(f, qpinq; check = false)
    if is_elementary(T, p)
      _, j = _get_V(id_hom(qp), minimal_polynomial(identity_matrix(QQ, 1)), p)
      sors = _subgroups_orbit_representatives_and_stabilizers_elementary(j, Oqp, order(T), fqp; compute_stab)
    else
      sors = _subgroups_orbit_representatives_and_stabilizers(id_hom(qp), Oqp, order(T), fqp; compute_stab)
    end
    filter!(d -> is_isometric_with_isometry(domain(d[1]), T)[1], sors)
    is_empty(sors) && return res
    push!(list_can, sors)
  end

  # We gather together: we do a big cartesian product, and we remember to
  # reconstruct the stabilizer. Since primary parts do not talk to each other,
  # we concatenate generators on an orthogonal direct sum of q into its primary
  # parts (as we do for computations of orthogonal groups in the non split
  # degenerate case)
  for lis in Hecke.cartesian_product_iterator(list_can)
    embs = TorQuadModuleMor[l[1] for l in lis]
    embs = TorQuadModuleMor[hom(domain(embs[i]), q, TorQuadModuleElem[blocks[i](domain(blocks[i])(lift(embs[i](a)))) for a in gens(domain(embs[i]))]) for i in 1:length(lis)]
    H2, _proj = direct_product(domain.(embs)...)
    _, H2inq = sub(q, elem_type(q)[sum([embs[i](_proj[i](g)) for i in 1:length(lis)]) for g in gens(H2)])
    if compute_stab
      stabs = AutomorphismGroup{TorQuadModule}[l[2] for l in lis]
      genestab = ZZMatrix[]

      for i in 1:length(ni)
        nb = sum(ni[1:i-1])
        na = sum(ni[(i+1):end])
        Inb = identity_matrix(ZZ, nb)
        Ina = identity_matrix(ZZ, na)
        append!(genestab, ZZMatrix[block_diagonal_matrix([Inb, matrix(f), Ina]) for f in gens(stabs[i])])
      end

      genestab = TorQuadModuleMor[hom(D, D, g) for g in genestab]
      genestas = ZZMatrix[matrix(compose(compose(inv(phi), g), phi)) for g in genestab]
      stab = Oscar._orthogonal_group(q, unique(genestas); check = false)
      @hassert :ZZLatWithIsom is_invariant(stab, H2inq)
    else
      stab = O
    end
    push!(res, (H2inq, stab))
  end

  return res
end

# Compute `O`-orbits of `f`-stable submodules of `q` of order `ordH`.
# If `compute_stab = true`, it also computes the stabilizers in `O`
# of such subgroups. Otherwise, it returns as "fake stabilziers" the
# full group `O`.
#
# The outputs are given by embeddings of such submodules in `q`.
#
# The code splits the computations into primary part since they are orthogonal
# on to the others.
function _classes_isomorphic_subgroups(q::TorQuadModule,
                                       O::AutomorphismGroup{TorQuadModule},
                                       ordH::IntegerUnion,
                                       f::Union{TorQuadModuleMor, AutomorphismGroupElem{TorQuadModule}} = id_hom(domain(O)),
                                       compute_stab::Bool = true)
  res = Tuple{TorQuadModuleMor, AutomorphismGroup{TorQuadModule}}[]

  !is_divisible_by(order(q), ordH) && return res

  # Trivial case: we look for subgroups in a given primary part of q
  ok, e, p = is_prime_power_with_data(ordH)
  if ok
    if e == 1
      _, Vinq = _get_V(id_hom(q), minimal_polynomial(identity_matrix(QQ, 1)), p)
      sors = _subgroups_orbit_representatives_and_stabilizers_elementary(Vinq, O, ordH, f; compute_stab)
    else
      _, Vinq = primary_part(q, p)
      sors = _subgroups_orbit_representatives_and_stabilizers(Vinq, O, ordH, f; compute_stab)
    end
    return sors
  end

  # We inspect each primary part of q and look for orbit representatives and
  # stabilizers of isomorphic subgroups of the good order wrt to `ordH`
  #
  # First, we cut q as an orthogonal direct sum of its primary parts
  pds = sort!(prime_divisors(order(q)))
  if compute_stab
    blocks = TorQuadModuleMor[primary_part(q, pds[1])[2]]
    ni = Int[ngens(domain(blocks[1]))]
    for i in 2:length(pds)
      _f = blocks[end]
      _, j = has_complement(_f)
      _T = domain(j)
      __f = primary_part(_T, pds[i])[2]
      push!(blocks, compose(__f, j))
      push!(ni, ngens(domain(__f)))
    end
    D, inj, proj = biproduct(domain.(blocks))
  else
    blocks = TorQuadModuleMor[primary_part(q, p)[2] for p in pds]
    D, inj, proj = biproduct(domain.(blocks))
  end
  phi = hom(D, q, TorQuadModuleElem[sum([blocks[i](proj[i](a)) for i in 1:length(pds)]) for a in gens(D)])
  @hassert :ZZLatWithIsom 1 is_isometry(phi)

  list_can = Vector{Tuple{TorQuadModuleMor, AutomorphismGroup{TorQuadModule}}}[]
  # We collect the possible subgroups for each primary part, with the stabilizer
  for i in 1:length(pds)
    p = pds[i]
    qpinq = blocks[i]
    qp = domain(qpinq)
    ordHp = p^valuation(ordH, p)
    Oqp, _ = restrict_automorphism_group(O, qpinq; check = false)
    fqp = restrict_endomorphism(f, qpinq; check = false)
    if ordHp == p
      _, j = _get_V(id_hom(qp), minimal_polynomial(identity_matrix(QQ, 1)), p)
      sors = _subgroups_orbit_representatives_and_stabilizers_elementary(j, Oqp, ordHp, fqp; compute_stab)
    else
      sors = _subgroups_orbit_representatives_and_stabilizers(id_hom(qp), Oqp, ordHp, fqp; compute_stab)
    end
    is_empty(sors) && return res
    push!(list_can, sors)
  end

  # We gather together: we do a big cartesian product, and we remember to
  # reconstruct the stabilizer. Since primary parts do not talk to each other,
  # we concatenate generators on an orthogonal direct sum of q into its primary
  # parts (as we do for computations of orthogonal groups in the non split
  # degenerate case)
  for lis in Hecke.cartesian_product_iterator(list_can)
    embs = TorQuadModuleMor[l[1] for l in lis]
    embs = TorQuadModuleMor[hom(domain(embs[i]), q, TorQuadModuleElem[blocks[i](domain(blocks[i])(lift(embs[i](a)))) for a in gens(domain(embs[i]))]) for i in 1:length(lis)]
    H2, _proj = direct_product(domain.(embs)...)
    _, H2inq = sub(q, elem_type(q)[sum([embs[i](_proj[i](g)) for i in 1:length(lis)]) for g in gens(H2)])
    if compute_stab
      stabs = AutomorphismGroup{TorQuadModule}[l[2] for l in lis]
      genestab = ZZMatrix[]

      for i in 1:length(ni)
        nb = sum(ni[1:i-1])
        na = sum(ni[(i+1):end])
        Inb = identity_matrix(ZZ, nb)
        Ina = identity_matrix(ZZ, na)
        append!(genestab, ZZMatrix[block_diagonal_matrix([Inb, matrix(f), Ina]) for f in gens(stabs[i])])
      end

      genestab = TorQuadModuleMor[hom(D, D, g) for g in genestab]
      genestas = ZZMatrix[matrix(compose(compose(inv(phi), g), phi)) for g in genestab]
      stab = Oscar._orthogonal_group(q, unique(genestas); check = false)
      @hassert :ZZLatWithIsom is_invariant(stab, H2inq)
    else
      stab = O
    end
    push!(res, (H2inq, stab))
  end

  return res
end

###############################################################################
#
# Primitive embeddings and extensions for even lattices
#
###############################################################################

@doc raw"""
    primitive_extensions(M::ZZLat, N::ZZLat; x::Union{IntegerUnion, Nothing} = nothing,
                                             q::Union{TorQuadModule, Nothing} = nothing,
                                             classification::Symbol = :sublat)
                                          -> Vector{Tuple{ZZLat, ZZLat, ZZLat}}

Given two even integer lattices $M$ and $N$, return a list $V$ of representatives
of isomorphism classes of primitive extensions $M \oplus N \subseteq L$.

One can decide to choose the index of $[L:(M\oplus N)]$, which should be a
positive integer by setting `x` to the desired value.
One can also decide on the isometry class of the discriminant form of the
primitive extension by setting `q` to the desired value.
If there are no primitive extensions of $M\oplus N$ satisfying the conditions
imposed by the choice of `x` or `q`, the function returns the empty list.

Otherwise, $V$ consists of triple $(L, M', N')$ such that $M'$ is isometric to $M$,
$N'$ is isometric to $N$ and $L$ is a primitive extension of $M'\oplus N'$ satisfying
conditions `x` or `q` if assigned.

The content of $V$ depends on the value of the symbol `classification`. There
are 3 possibilities:
  - `classification == :first`: $V$ consists of the first primitive extension computed;
  - `classification == :sublat`: $V$ consists of representatives for all isomorphism classes of primitive extensions of $M\oplus N$, up to the actions of $O(M)$ and $O(N)$;
  - `classification == :emb`: $V$ consists of representatives for all isomorphism classes of primitive extensions of $M\oplus N$, up to the action $O(N)$;

The classification methods for the symbols `:sublat` and `:emb` correspond
to the different classes of primitive embeddings defined by V. V. Nikulin in
Proposition 1.5.1 of [Nik79](@cite). Indeed, we can see the classification
of primitive extensions as a classification of primitive embeddings of $M$
into some even lattices, with orthogonal complement isometric to $N$.

For the classifications of type `:emb`, if one wants a classification up to the
action of $O(M)$ only, one should instead call
`primitive_extensions(N, M, rescale(H, -1)); classification = :emb)`.
"""
function primitive_extensions(M::ZZLat, N::ZZLat; x::Union{IntegerUnion, Nothing} = nothing,
                                                  q::Union{TorQuadModule, Nothing} = nothing,
                                                  classification::Symbol = :sublat)
  @req classification in Symbol[:first, :emb, :sublat] "Wrong symbol for classification"

  results = Tuple{ZZLat, ZZLat, ZZLat}[]

  @req is_even(M) && is_even(N) "Only implemented for pairs of even integer lattices"

  # We check the initial conditions to make sense for having a primitive
  # extensions with the potential given requirements
  if !isnothing(x)
    !is_divisible_by(numerator(gcd(det(M), det(N))), x) && return results
    if !isnothing(q)
      @req modulus_quadratic_form(q) == 2 "q does not define the discriminant form of an even lattice"
      @req x^2*order(q) == det(M)*det(N) "Wrong requirements: the square of the index `x` should be equal to (det(M)*det(N)/order(q))"
      aM, _, bM = signature_tuple(M)
      aN, _, bN = signature_tuple(N)
      !is_genus(q, (aM+aN, bM+bN)) && return results
      G = genus(q, (aM+aN, bM+bN))
    end
  elseif !isnothing(q)
    @req modulus_quadratic_form(q) == 2 "q does not define the discriminant form of an even lattice"
    aM, _, bM = signature_tuple(M)
    aN, _, bN = signature_tuple(N)
    !is_genus(q, (aM+aN, bM+bN)) && return results
    G = genus(q, (aM+aN, bM+bN))
    ok, x = divides(numerator(det(M)*det(N)), order(q))
    !ok && return results
    ok, x = is_square_with_sqrt(x)
    !ok && return results
  end

  # Methods are simpler if we work in a fixed space
  same_ambient = ambient_space(M) === ambient_space(N)

  # Decide on a subgroup of O(qM) depending on the kind of classification
  qM = discriminant_group(M)
  if classification == :emb
    GM = Oscar._orthogonal_group(qM, ZZMatrix[matrix(id_hom(qM))]; check = false)
  else
    GM, _ = image_in_Oq(M)
  end

  # On the other side we do always with respect to O(N)
  qN = discriminant_group(N)
  GN, _ = image_in_Oq(N)

  if same_ambient
    D = qM + qN
    qMinD = hom(qM, D, TorQuadModuleElem[D(lift(x)) for x in gens(qM)])
    qNinD = hom(qN, D, TorQuadModuleElem[D(lift(x)) for x in gens(qN)])
  else
    D, inj = direct_sum(qM, qN)
    qMinD, qNinD = inj
  end
  OD = orthogonal_group(D)

  if !isnothing(x)
    # First case: we know the order of the subgroup along which we glue!
    # We first enumerate respective of isometry classes of subgroups of qN of
    # order x
    subsN = _classes_isomorphic_subgroups(qN, GN, x)
    isempty(subsN) && return results
    for H2 in subsN
      # Then for each class, we look for representative of isometry classes of
      # subgroups of M anti-isometric to them
      subsM = _classes_isomorphic_subgroups(qM, GM, rescale(domain(H2[1]), -1))
      isempty(subsM) && continue
      for H1 in subsM
        ok, phi = is_anti_isometric_with_anti_isometry(domain(H1[1]), domain(H2[1]))
        @hassert :ZZLatWithIsom 1 ok

        HMinqM, stabM = H1
        HMinD = compose(HMinqM, qMinD)
        HM = domain(HMinqM)
        OHM = orthogonal_group(HM)

        HNinqN, stabN = H2
        HNinD = compose(HNinqN, qNinD)
        HN = domain(HNinqN)
        OHN = orthogonal_group(HN)

        actM = hom(stabM, OHM, elem_type(OHM)[OHM(restrict_automorphism(x, HMinqM; check = false); check = false) for x in gens(stabM)])
        actN = hom(stabN, OHN, elem_type(OHN)[OHN(restrict_automorphism(x, HNinqN; check = false); check = false) for x in gens(stabN)])
        imN, _ = image(actN)

        stabMphi = elem_type(OHN)[OHN(compose(inv(phi), compose(hom(actM(g)), phi)); check = false) for g in gens(stabM)]
        stabMphi, _ = sub(OHN, stabMphi)

        if is_elementary_with_prime(HN)[1]
          iso = isomorphism(PermGroup, OHN)
        else
          iso = id_hom(OHN)
        end
        reps = double_cosets(codomain(iso), iso(stabMphi)[1], iso(imN)[1])
        @vprintln :ZZLatWithIsom 1 "$(length(reps)) isomorphism classe(s) of primitive extensions"

        for g in reps
          g = iso\(representative(g))
          phig = compose(phi, hom(g))
          L, _, _ = _overlattice(phig, HMinD, HNinD; same_ambient)

          # L might not be in the good genus if one is fixed
          if !isnothing(q)
            genus(L) == G || continue
          end
          M2 = lattice_in_same_ambient_space(L, hcat(basis_matrix(M), zero_matrix(QQ, rank(M), degree(L)-degree(M))))
          @hassert  :ZZLatWithIsom 1 genus(M) == genus(M2)
          N2 = lattice_in_same_ambient_space(L, hcat(zero_matrix(QQ, rank(N), degree(L)-degree(N)), basis_matrix(N)))
          @hassert :ZZLatWithIsom 1 genus(N) == genus(N2)
          push!(results, (L, M2, N2))
          @vprintln :ZZLatWithIsom 1 "Gluing done"
          classification == :first && return results
        end
      end
    end
  else
    # second case: we do not know the order of the glue so we basically go on
    # with every possible orders.
    
    # In the primary and elementary cases, we can simplify many things.
    prN, pN = is_primary_with_prime(N)
    elN = is_elementary(N, pN)

    prM, pM = is_primary_with_prime(M)
    elM = is_elementary(M, pM)

    for k in divisors(gcd(order(qM), order(qN)))
      ok, ek, pk = is_prime_power_with_data(k)
      @vprintln :ZZLatWithIsom 1 "Glue order: $(k)"

      if elN || elM
        _, VNinqN = _get_V(id_hom(qN), minimal_polynomial(identity_matrix(QQ, 1)), max(pN, pM))
        subsN = _subgroups_orbit_representatives_and_stabilizers_elementary(VNinqN, GN, k; compute_stab = false)
      elseif ok && (ek == 1)
        _, VNinqN = _get_V(id_hom(qN), minimal_polynomial(identity_matrix(QQ, 1)), k)
        subsN = _subgroups_orbit_representatives_and_stabilizers_elementary(VNinqN, GN, k; compute_stab = false)
      else
        if prN || prM
          _, VNinqN = primary_part(qN, max(pN, pM))
        elseif ok
          _, VNinqN = primary_part(qN, pk)
        else
          VNinqN = id_hom(qN)
        end
        subsN = _subgroups_orbit_representatives_and_stabilizers(VNinqN, GN, k; compute_stab = false)
      end
      isempty(subsN) && continue

      for H2 in subsN
        subsM = _classes_isomorphic_subgroups(qM, GM, rescale(domain(H2[1]), -1))
        isempty(subsM) && continue
        for H1 in subsM
          ok, phi = is_anti_isometric_with_anti_isometry(domain(H1[1]), domain(H2[1]))
          @hassert :ZZLatWithIsom 1 ok

          HMinqM, stabM = H1
          HMinD = compose(HMinqM, qMinD)
          HM = domain(HMinqM)
          OHM = orthogonal_group(HM)

          HNinqN, stabN = H2
          HNinD = compose(HNinqN, qNinD)
          HN = domain(HNinqN)
          OHN = orthogonal_group(HN)

          actM = hom(stabM, OHM, elem_type(OHM)[OHM(restrict_automorphism(x, HMinqM; check = false); check = false) for x in gens(stabM)])
          actN = hom(stabN, OHN, elem_type(OHN)[OHN(restrict_automorphism(x, HNinqN; check = false); check = false) for x in gens(stabN)])
          imN, _ = image(actN)

          stabMphi = elem_type(OHN)[OHN(compose(inv(phi), compose(hom(actM(g)), phi)); check = false) for g in gens(stabM)]
          stabMphi, _ = sub(OHN, stabMphi)

          if is_elementary_with_prime(HN)[1]
            iso = isomorphism(PermGroup, OHN)
          else
            iso = id_hom(OHN)
          end
          reps = double_cosets(codomain(iso), iso(stabMphi)[1], iso(imN)[1])
          @vprintln :ZZLatWithIsom 1 "$(length(reps)) isomorphism classe(s) of primitive extensions"

          for g in reps
            g = iso\(representative(g))
            phig = compose(phi, hom(g))
            L, _, _ = _overlattice(phig, HMinD, HNinD; same_ambient)
            M2 = lattice_in_same_ambient_space(L, hcat(basis_matrix(M), zero_matrix(QQ, rank(M), degree(L)-degree(M))))
            @hassert  :ZZLatWithIsom 1 genus(M) == genus(M2)
            N2 = lattice_in_same_ambient_space(L, hcat(zero_matrix(QQ, rank(N), degree(L)-degree(N)), basis_matrix(N)))
            @hassert :ZZLatWithIsom 1 genus(N) == genus(N2)
            push!(results, (L, M2, N2))
            @vprintln :ZZLatWithIsom 1 "Gluing done"
            classification == :first && return results
          end
        end
      end
    end
  end
  return results
end

@doc raw"""
    primitive_embeddings(L::ZZLat, M::ZZLat; classification::Symbol = :sublat,
                                             check::Bool = true)
                                    -> Bool, Vector{Tuple{ZZLat, ZZLat, ZZLat}}

Given an even integer lattice $L$, which is unique in its genus, and an even
integer lattice $M$, return whether $M$ embeds primitively in $L$.

The first output of the function is a boolean `T` stating whether $M$ embeds
primitively in $L$. The second output $V$ consists of triples $(L', M', N')$
where $L'$ is isometric to $L$, $M'$ is a primitive sublattice of $L'$ isometric
to $M$, and $N'$ is the orthogonal complement of $M'$ in $L'$.

If `T == false`, then $V$ will always be the empty list. If `T == true`, then
the content of $V$ depends on the value of the symbol `classification`. There
are 4 possibilities:
  - `classification == :none`: $V$ is the empty list;
  - `classification == :first`: $V$ consists of the first primitive embedding found;
  - `classification == :sublat`: $V$ consists of representatives for all isomorphism classes of primitive embeddings of $M$ in $L$, up to the actions of $O(M)$ and $O(q)$ where $q$ is the discriminant group of $L$;
  - `classification == :emb`: $V$ consists of representatives for all isomorphism classes of primitive embeddings of $M$ in $L$ up to the action of $O(q)$ where $q$ is the discriminant group of $L$.

If `check` is set to `true`, the function determines whether $L$ is in fact unique
in its genus.

We follow the algorithm described in the proof of Proposition 1.15.1 of
[Nik79](@cite). The classification methods for the symbols `:sublat` and `:emb`
correspond to the different classes of primitive embeddings defined in
the same proposition: for `:sublat` we classify sublattices of $L$ which are
isometric to $M$, and for `:emb` we classify the different embeddings of $M$
into $L$.

# Examples
We can use such primitive embeddings algorithm to classify embedding in unimodular
lattices

```jldoctest
julia> E8 = root_lattice(:E,8);

julia> A4 = root_lattice(:A,4);

julia> bool, pe = primitive_embeddings(E8, A4)
(true, Tuple{ZZLat, ZZLat, ZZLat}[(Integer lattice of rank 8 and degree 8, Integer lattice of rank 4 and degree 8, Integer lattice of rank 4 and degree 8)])

julia> pe
1-element Vector{Tuple{ZZLat, ZZLat, ZZLat}}:
 (Integer lattice of rank 8 and degree 8, Integer lattice of rank 4 and degree 8, Integer lattice of rank 4 and degree 8)

julia> genus(pe[1][2]) == genus(pe[1][3])
true
```
To be understood: there exists a unique class of embedding of the root lattice
$A_4$ into the root lattice $E_8$, and the orthogonal primitive sublattice
is isometric to $A_4$.
"""
function primitive_embeddings(L::ZZLat, M::ZZLat; classification::Symbol = :sublat, check::Bool = true)
  @req is_even(L) && is_even(M) "At the moment, only primitive embeddings into even integer lattices are computable"
  if check
    @req length(genus_representatives(L)) == 1 "L must be unique in its genus"
  end
  return primitive_embeddings(genus(L), M; classification)
end

@doc raw"""
    primitive_embeddings(q::TorQuadModule, sign::Tuple{Int, Int}, M::ZZLat;
                                            classification::Symbol = :sublat)
                                        -> Bool, Vector{Tuple{ZZLat, ZZLat, ZZLat}}

Given a tuple `sign` of non-negative integers and a torsion quadratic module
$q$ which define a genus symbol $G$ for even integer lattices, return whether the
even integer lattice $M$ embeds primitively in a lattice in $G$.

The first output of the function is a boolean `T` stating whether $M$ embeds
primitively in a lattice in $G$. The second output $V$ consists of triples
$(L', M', N')$ where $L'$ is a lattice in $G$, $M'$ is a sublattice of
$L'$ isometric to $M$, and $N'$ is the orthogonal complement of $M'$ in $L'$.

If `T == false`, then $V$ will always be the empty list. If `T == true`, then
the content of $V$ depends on the value of the symbol `classification`. There
are 4 possibilities:
  - `classification == :none`: $V$ is the empty list;
  - `classification == :first`: $V$ consists of the first primitive embedding found;
  - `classification == :sublat`: $V$ consists of representatives for all isomorphism classes of primitive embeddings of $M$ in lattices in $G$, up to the actions of $O(M)$ and $O(q)$;
  - `classification == :emb`: $V$ consists of representatives for all isomorphism classes of primitive embeddings of $M$ in lattices in $G$ $G$, up to the action of $O(q)$.

If the pair `(q, sign)` does not define a non-empty genus for integer lattices,
an error is thrown.

We follow the algorithm described in the proof of Proposition 1.15.1 of
[Nik79](@cite). The classification methods for the symbols `:sublat` and `:emb`
correspond to the different classes of primitive embeddings defined in
the same proposition: for `:sublat` we classify sublattices of lattices in $G$
which are isometric to $M$, and for `:emb` we classify the different embeddings
of $M$ into lattices in $G$.
"""
function primitive_embeddings(q::TorQuadModule, sign::Tuple{Int, Int}, M::ZZLat; classification::Symbol = :sublat)
  @req is_even(M) "At the moment, only primitive embeddings into even integer lattices are computable"
  @req is_genus(q, sign) "Invariants define the empty genus"
  G = genus(q, sign)
  @req is_even(G) "At the moment, only primitive embeddings into even integer lattices are computable"
  return primitive_embeddings(G, M; classification)
end

@doc raw"""
    primitive_embeddings(G::ZZGenus, M::ZZLat; classification::Symbol = :sublat)
                                      -> Bool, Vector{Tuple{ZZLat, ZZLat, ZZLat}}

Given a genus symbol $G$ for even integer lattices and an even integer
lattice $M$, return whether $M$ embeds primitively in a lattice in $G$.

The first output of the function is a boolean `T` stating whether $M$ embeds
primitively in a lattice in $G$. The second output $V$ consists of triples
$(L', M', N')$ where $L'$ is a lattice in $G$, $M'$ is a sublattice of
$L'$ isometric to $M$, and $N'$ is the orthogonal complement of $M'$ in $L'$.

If `T == false`, then $V$ will always be the empty list. If `T == true`, then
the content of $V$ depends on the value of the symbol `classification`. There
are 4 possibilities:
  - `classification == :none`: $V$ is the empty list;
  - `classification == :first`: $V$ consists of the first primitive embedding found;
  - `classification == :sublat`: $V$ consists of representatives for all isomorphism classes of primitive embeddings of $M$ in lattices in $G$, up to the actions of $O(M)$ and $O(q)$ where $q$ is the discriminant group of a lattice in $G$;
  - `classification == :emb`: $V$ consists of representatives for all isomorphism classes of primitive embeddings of $M$ in of lattices in $G$, up to the action of $O(q)$ where $q$ is the discriminant group of a lattice in $G$.

We follow the algorithm described in the proof of Proposition 1.15.1 of
[Nik79](@cite). The classification methods for the symbols `:sublat` and `:emb`
correspond to the different classes of primitive embeddings defined in
the same proposition: for `:sublat` we classify sublattices of lattices in $G$
which are isometric to $M$, and for `:emb` we classify the different embeddings
of $M$ into lattices in $G$.
"""
function primitive_embeddings(G::ZZGenus, M::ZZLat; classification::Symbol = :sublat)
  @req is_even(G) && is_even(M) "At the moment, only primitive embeddings into even integer lattices are computable"
  @req classification in Symbol[:none, :emb, :sublat, :first] "Wrong symbol for classification"
  posL, _, negL = signature_tuple(G)
  posM, _, negM = signature_tuple(M)
  @req (posL-posM >= 0 && negL-negM >= 0) "Incompatible signatures for the embeddings"

  results = Tuple{ZZLat, ZZLat, ZZLat}[]
  if rank(M) == rank(G)
    genus(M) != G && return false, results
    push!(results, (M, M, orthogonal_submodule(M, M)))
    return true, results
  end

  @req rank(M) < rank(G) "The rank of M must be smaller or equal than the one of the lattices in G"

  # We can carry out the unimodular case apart thanks to Nikulin,
  # Proposition 1.6.1 [Nik79]
  #
  # In that case, the genus of the complement is uniquely determined, and after
  # enumerating it, we just have to classify primitive extensions into G
  if is_unimodular(G)
    qM = discriminant_group(M)
    !is_genus(rescale(qM, -1), (posL-posM, negL-negM)) && return false, results
    GK = genus(rescale(qM, -1), (posL-posM, negL-negM))
    
    # Now for each K in GK, we compute primitive extensions of M and K into a
    # unimodular lattice in G
    for K in representatives(GK)
      pe = primitive_extensions(M, K; x = order(qM), classification)
      if !isempty(pe)
        append!(results, pe)
        classification == :first && return results
      end
    end
    return (length(results) > 0), results
  end

  # Now we go on the harder case, which relies on the previous one
  # We follow the proof of Nikulin: we create `T` unique in its genus and with
  # surjective O(T) -> O(qT), and such that qT and q are anti-isometric
  # The easiest way to do this is to add a hyperbolic plane to a representative
  # of the genus G, rescale by -1.
  T, _ = direct_sum(rescale(lll(representative(G)), -1), hyperbolic_plane_lattice())

  # The algorithm goes on with finding primitive extensions of M+T and then
  # embeddings such in a big unimodular lattice (which we take unique in its
  # genus)
  Vs = primitive_extensions(M, T)

  # GL is our big unimodular genus where we embed each of the V in Vs
  GL = genus(torsion_quadratic_module(QQ[0;]), (rank(G)+1, rank(G)+1))
  # M2 is M seen in V, and T2 is T seen in V
  for (V, M2, T2) in Vs
    okV, resV = primitive_embeddings(GL, V; classification = :sublat)
    !okV && continue
    for (S, V2, W2) in resV
      # This is T seen in S
      T3 = lattice_in_same_ambient_space(S, hcat(basis_matrix(T2), zero_matrix(QQ, rank(T2), degree(W2)-degree(T2))))
      @hassert :ZZLatWithIsom 1 genus(T3) == genus(T)
      # This is one of the lattice in G in which we embed primitively
      L = orthogonal_submodule(S, T3)
      @hassert :ZZLatWithIsom 1 genus(L) == G
      # This is M seen in L
      M3 = lattice_in_same_ambient_space(S, hcat(basis_matrix(M2), zero_matrix(QQ, rank(M2), degree(W2)-degree(M2))))
      @hassert :ZZLatWithIsom 1 is_sublattice(L, M3)
      @hassert :ZZLatWithIsom 1 is_primitive(L, M3)
      # And this is the orthogonal complement of M in L
      N = orthogonal_submodule(L, M3)
      # L, M3 and N live in a very big ambient space: we redescribed them in the
      # rational span of L so that L has full rank and we keep only the
      # necessary information.
      bM = solve_left(basis_matrix(L), basis_matrix(M3))
      bN = solve_left(basis_matrix(L), basis_matrix(N))
      L = integer_lattice(; gram = gram_matrix(L))
      M3 = lattice_in_same_ambient_space(L, bM)
      N = lattice_in_same_ambient_space(L, bN)
      push!(results, (L, M3, N))
      classification == :first && return true, results
    end
  end
  return (length(results) > 0), results
end

###############################################################################
#
# Admissible equivariant primitive extensions
#
###############################################################################

@doc raw"""
    admissible_equivariant_primitive_extensions(Afa::ZZLatWithIsom,
                                                Bfb::ZZLatWithIsom,
                                                Cfc::ZZLatWithIsom,
                                                p::IntegerUnion,
                                                q::IntegerUnion = p; check::Bool = true)
                                                     -> Vector{ZZLatWithIsom}

Given a triple of lattices with isometry $(A, f_A)$, $(B, f_B)$ and $(C, f_C)$,
and a prime number $p$, such that $(A, B, C)$ is $p$-admissible, return a set of
representatives of the double coset $G_B\backslash S/G_A$ where:

  - ``G_A`` and ``G_B`` are the respective images of the morphisms $O(A, f_A) \to O(D_A, D_{f_A})$ and $O(B, f_B) \to O(D_B, D_{f_B})$;
  - ``S`` is the set of all primitive extensions $A \oplus B \subseteq C'$ with isometry $f_C'$ where $p\cdot C' \subseteq A\oplus B$ and such that the type of $(C', (f_C')^q)$ is equal to the type of $(C, f_C)$.

If `check == true` the input triple is checked to a $p$-admissible triple of
integral lattices (with isometry) with $f_A$ and $f_B$ having relatively coprime
irreducible minimal polynomials. Moreover, the function checks that $A$ and $B$
are orthogonal if $A$, $B$ and $C$ lie in the same ambient quadratic space.

Note moreover that the function computes the image of the natural map
$O(C, f_C) \to O(D_C, D_{f_C})$ along the primitive extension
$A\oplus B\subseteq C$ (see Algorithm 2, Line 22 of [BH23](@cite)).
"""
function admissible_equivariant_primitive_extensions(A::ZZLatWithIsom,
                                                     B::ZZLatWithIsom,
                                                     C::ZZLatWithIsom,
                                                     p::IntegerUnion,
                                                     q::IntegerUnion = p; check::Bool = true)
  # p and q can be equal, and they will be most of the time
  @req is_prime(p) && is_prime(q) "p and q must be a prime number" 

  # Requirements for [BH23]
  same_ambient = ambient_space(lattice(A)) === ambient_space(lattice(B)) === ambient_space(lattice(C))
  if check 
    @req all(L -> is_integral(L), [A, B, C]) "Underlying lattices must be integral"
    chiA = minimal_polynomial(A)
    chiB = minimal_polynomial(parent(chiA), isometry(B))
    @req gcd(chiA, chiB) == 1 "Minimal irreducible polynomials must be relatively coprime"
    @req is_admissible_triple(A, B, C, p) "Entries, in this order, do not define an admissible triple with respect to p"
    if same_ambient
      G = gram_matrix(ambient_space(C))
      @req iszero(basis_matrix(A)*G*transpose(basis_matrix(B))) "Lattices in same ambient space must be orthogonal"
    end
  end

  results = ZZLatWithIsom[]

  # this is the glue valuation: it is well-defined because the triple in input is admissible
  g = divexact(valuation(divexact(det(A)*det(B), det(C)), p), 2)

  qA, fqA = discriminant_group(A)
  qB, fqB = discriminant_group(B)
  qC = discriminant_group(lattice(C))
  GA, _ = image_centralizer_in_Oq(A)
  @hassert :ZZLatWithIsom 1 fqA in GA
  GB, _ = image_centralizer_in_Oq(B)
  @hassert :ZZLatWithIsom 1 fqB in GB

  # this is where we will perform the glueing
  if same_ambient
    D, qAinD, qBinD, OD, OqAinOD, OqBinOD = _sum_with_embeddings_orthogonal_groups(qA, qB)
  else
    D, qAinD, qBinD, OD, OqAinOD, OqBinOD = _direct_sum_with_embeddings_orthogonal_groups(qA, qB)
  end

  OqA = domain(OqAinOD)
  OqB = domain(OqBinOD)

  # if the glue valuation is zero, then we glue along the trivial group and we don't
  # have much more to do.
  if g == 0
    # Needed to compute the image of the stabilizer of the isometry we construct
    # (in the orthogonal group of the discriminant group of the new lattice).
    geneA = elem_type(OD)[OqAinOD(OqA(a.X)) for a in gens(GA)]
    geneB = elem_type(OD)[OqBinOD(OqB(b.X)) for b in gens(GB)]
    union!(geneA, geneB)

    # We compute the overlattice in this context
    C2, fC2, _ = _overlattice(qAinD, qBinD, isometry(A), isometry(B); same_ambient)
    C2fC2 = integer_lattice_with_isometry(C2, fC2; ambient_representation = false, check)

    # If not of the good type, we discard it
    !is_of_type(C2fC2^q, type(C)) && return results

    qC2 = discriminant_group(C2)
    OqC2 = orthogonal_group(qC2)
    phi2 = hom(qC2, D, elem_type(D)[D(lift(x)) for x in gens(qC2)])
    @hassert :ZZLatWithIsom 1 is_isometry(phi2)

    # This is the new image of the stabilizer, just a direct product of
    # the previous ones
    GC2 = sub(OqC2, elem_type(OqC2)[OqC2(compose(phi2, compose(hom(g), inv(phi2))); check = false) for g in geneA])

    # This is mainly to check that we have not done anything inconsistent
    @hassert :ZZLatWithIsom 1 discriminant_group(C2fC2)[2] in GC2[1]
    set_attribute!(C2fC2, :image_centralizer_in_Oq, GC2)
    push!(results, C2fC2)
    return results
  end

  # these are GA|GB-invariant, fA|fB-stable, and should contain the kernels of any glue map.
  # VA and VB are submodules of the p-elementary parts of qA and qB
  # respectively.
  VA, VAinqA = _get_V(hom(fqA), minimal_polynomial(B), p)
  VB, VBinqB = _get_V(hom(fqB), minimal_polynomial(A), p)

  # since the glue kernels must have order p^g, in this condition, we have nothing
  if min(order(VA), order(VB)) < p^g
    return results
  end

  # scale of the dual: any glue kernel must contain the multiples of l of the respective
  # primary part of the discriminant groups
  l = valuation(level(genus(C)), p)

  # In the special case where rho_{l+1}(A) and rho_{l+1}(B) are free, then we
  # know that rho_l(C) is even if and only if any admissible gluing should
  # induce an isometry of finite quadratic form between rho_{l+1}(A) and
  # rho_{l+1}(B) (this works only when `p == 2`). In all the other cases, then
  # admissible gluings only induce isometries of finite bilinear modules between
  # rho_{l+1}(A) and rho_{l+1}(B).
  spec = (p == 2) && (_is_free(qA, p, l+1)) && (_is_free(qB, p, l+1)) && (_is_even(qC, p, l))

  # We look for the GA|GB-invariant and fA|fB-stable subgroups of VA|VB which respectively
  # contained lpqA|lpqB, where pqA and pqB are respectively the p-primary parts of qA and qB.
  # This is done by computing orbits and stabilisers of VA/lpqA (resp VB/lpqB)
  # seen as a F_p-vector space under the action of GA (resp. GB). Then we check which ones
  # are fA-stable (resp. fB-stable)
  subsA = _subgroups_orbit_representatives_and_stabilizers_elementary(VAinqA, GA, p^g, fqA, ZZ(l))
  subsB = _subgroups_orbit_representatives_and_stabilizers_elementary(VBinqB, GB, p^g, fqB, ZZ(l))

  # now, for each pair of anti-isometric potential kernels, we need to massage the gluing
  # computed to turn it into an admissible one. Then, we need to decide whether
  # such an admissible gluing can be made (fA,fB)-equivariant, up to conjugacy.
  #
  # Each pair for which we can find such nice gluing, we create the double coset
  # parametrising all such gluing up to certain conditions and we then compute the
  # corresponding overlattice and check whether it satisfies the type conditions.
  for H1 in subsA, H2 in subsB
    ok, phi = is_anti_isometric_with_anti_isometry(domain(H1[1]), domain(H2[1]))
    !ok && continue

    SAinqA, stabA = H1
    SA = domain(SAinqA)
    SAinD = compose(SAinqA, qAinD)
    OSA = orthogonal_group(SA)
    fSA = OSA(restrict_automorphism(fqA, SAinqA; check = false); check = false)

    SBinqB, stabB = H2
    SB = domain(SBinqB)
    SBinD = compose(SBinqB, qBinD)
    OSB = orthogonal_group(SB)
    fSB = OSB(restrict_automorphism(fqB, SBinqB; check = false); check = false)

    # we need a first admissible gluing. We know that such gluing exists because
    # we have an admissible triple as input and the glue kernels have been
    # chosen in such a way that their exist an admissible gluing between them.
    phi = _find_admissible_gluing(SAinqA, SBinqB, phi, l, p, spec)

    # We want all isometries of SB which preserves p^l*q_B and such that they
    # define isometries of rho_{l+1}(B). If `spec == true`, then rho_{l+1}(B) is
    # equipped with a quadratic form and we check isometries preserving it.
    # Otherwise, only isometries preserving the underlying bilinear product.
    OSBrB = _compute_double_stabilizer(SBinqB, l, spec)
    @hassert :ZZLatWithIsom 1 fSB in OSBrB   # Should always hold since the construction of rho_{l+1}(B) is natural in B
    fSB = OSBrB(fSB)

    # phi might not "send" the restriction of fA to this of fB, but at least phi*fA*phi^-1
    # should be conjugate to fB inside O(SB, rho_l(qB)) for the gluing.
    # If not, we try the next potential pair.
    fSAinOSB = OSB(compose(inv(phi), compose(hom(fSA), phi)); check = false)
    @hassert :ZZLatWithIsom 1 fSAinOSB in OSBrB  # Same as before, since phi is admissible, then the image of fSA should preserve rho_{l+1}(B)
    bool, g0 = is_conjugate_with_data(OSBrB, OSBrB(fSAinOSB), fSB)
    bool || continue

    # The new phi is "sending" the restriction of fA to this of fB
    # and it is still admissible. So we can glue SA and SB as wanted.
    phi = compose(phi, hom(OSB(g0)))
    @hassert :ZZLatWithIsom 1 OSBrB(compose(inv(phi), compose(hom(fSA), phi)); check = false) == fSB

    # we compute the image of the stabilizers in the respective OS* and we keep track
    # of the elements of the stabilizers acting trivially in the respective S*
    # (there are in the ker*).
    actA = hom(stabA, OSA, elem_type(OSA)[OSA(restrict_automorphism(x, SAinqA; check = false); check = false) for x in gens(stabA)])
    imA, _ = image(actA)

    actB = hom(stabB, OSB, elem_type(OSB)[OSB(restrict_automorphism(x, SBinqB; check = false); check = false) for x in gens(stabB)])
    imB, _ = image(actB)

    # Now it is time to compute generators for O(SB, rho_l(qB), fB), and the induced
    # images of stabA|stabB for taking the double cosets next
    center, _ = centralizer(OSBrB, fSB)
    center, _ = sub(OSB, elem_type(OSB)[OSB(c) for c in gens(center)])
    stabSAphi, _ = sub(OSB, elem_type(OSB)[OSB(compose(inv(phi), compose(hom(g), phi)); check = false) for g in gens(imA)])
    stabSAphi, _ = intersect(center, stabSAphi)
    stabSB, _ = intersect(center, imB)

    iso = isomorphism(PermGroup, center)
    reps = double_cosets(codomain(iso), iso(stabSB)[1], iso(stabSAphi)[1])

    # We iterate over all double cosets. Each representative, define a new
    # classe of admissible gluing and so, for each such representative we compute the
    # corresponding overlattice along the gluing. If it has the wanted type, we compute
    # the image of the centralizer in OD from the stabA and stabB.
    for g in reps
      g = iso\(representative(g))
      phig = compose(phi, hom(g))
      @hassert :ZZLatWithIsom 1 is_anti_isometry(phig)

      # We compute the overlattice in this context, keeping track whether we
      # cork in a fixed ambient quadratic space
      C2, fC2, extinD = _overlattice(phig, SAinD, SBinD, isometry(A), isometry(B); same_ambient)
      C2fC2 = integer_lattice_with_isometry(C2, fC2; ambient_representation = false, check)

      # This is the type requirement: somehow, we want `(C2, fC2)` to be a "q-th root" of `(C, fC)`.
      !is_of_type(C2fC2^q, type(C)) && continue

      disc, stab = _glue_stabilizers(phig, actA, actB, OqAinOD, OqBinOD, extinD)

      qC2 = discriminant_group(C2)
      OqC2 = orthogonal_group(qC2)
      phi2 = hom(qC2, disc, elem_type(disc)[disc(lift(x)) for x in gens(qC2)])
      @hassert :ZZLatWithIsom 1 is_isometry(phi2)              # In fact they are the same module so phi2, mathematically, is the identity.

      stab = sub(OqC2, elem_type(OqC2)[OqC2(compose(phi2, compose(g, inv(phi2))); check = false) for g in stab])

      # If we have done good things, the action of fC2 on qC2 should centralize
      # itself...
      @hassert :ZZLatWithIsom 1 discriminant_group(C2fC2)[2] in stab[1]

      set_attribute!(C2fC2, :image_centralizer_in_Oq, stab)
      push!(results, C2fC2)
    end
  end
  return results
end

###############################################################################
#
#  Computation of O(H_B, rho_{l+1}(B))
#  ===================================
#  [BH23, Definition 4.16]
#
###############################################################################


# Action of isometries on the gram matrix of a finite bilinear form
function _on_modular_matrix(M::QQMatrix, g::AutomorphismGroupElem)
  q = domain(parent(g))
  R = Hecke.QmodnZ(QQ(1))
  m = matrix(inv(g))
  return map_entries(a -> lift(R(a)), m*M*transpose(m))
end

# Action of isometries on the gram matrix of a finite quadratic form
function _on_modular_matrix_quad(M::QQMatrix, g::AutomorphismGroupElem)
  q = domain(parent(g))
  R1 = Hecke.QmodnZ(QQ(1))
  R2 = Hecke.QmodnZ(QQ(2))
  m = matrix(inv(g))
  m1 = m*M*transpose(m)
  for i in 1:nrows(m1)
    for j in 1:ncols(m1)
      if i == j
        m1[i,j] = lift(R2(m1[i,j]))
      else
        m1[i,j] = lift(R1(m1[i,j]))
      end
    end
  end
  return m1
end

# We compute O(SB, rho_{l+1}(B)) where B has discriminant form qB. `spec` keep
# track whether rho_{l+1}(B) should be considered as a finite quadratic module
# or just a finite bilinear module (depends on the overlattice).
function _compute_double_stabilizer(SBinqB::TorQuadModuleMor, l::IntegerUnion, spec::Bool)
  SB = domain(SBinqB)
  qB = codomain(SBinqB)
  OSB = orthogonal_group(SB)
  p = elementary_divisors(SB)[1]
  rB = _rho_functor(qB, p, l+1)
  rBtoSB = hom(rB, SB, elem_type(SB)[SB(QQ(p^l)*lift(a)) for a in gens(rB)])
  HB, HBinSB = sub(SB, rBtoSB.(gens(rB)))
  OSBHB, _ = stabilizer(OSB, HBinSB)
  OHB, OSBHBtoOHB = restrict_automorphism_group(OSBHB, HBinSB; check = false)
  K, _ = kernel(OSBHBtoOHB)
  if spec
    OHBrB, _ = stabilizer(OHB, gram_matrix_quadratic(rB), _on_modular_matrix_quad)
  else
    OHBrB, _ = stabilizer(OHB, gram_matrix_bilinear(rB), _on_modular_matrix)
  end
  OSBrB, _ = sub(OSB, union!(OSB.(gens((OSBHBtoOHB\(OHBrB))[1])), gens(K)))
  return OSBrB
end

###############################################################################
#
#  Admissible gluings
#
###############################################################################

# If we are given a gluing between SA and SB, given that an admissible gluing
# exist, we massage phi until we turn it into an admissible gluing. There might
# be ways to improve such search, but I would expect that both loops iterating
# on OSB and OSBHB are terminating after few tries.
function _find_admissible_gluing(SAinqA::TorQuadModuleMor,
                                 SBinqB::TorQuadModuleMor,
                                 phi::TorQuadModuleMor,
                                 l::IntegerUnion,
                                 p::IntegerUnion,
                                 spec::Bool)
  SA = domain(SAinqA)
  SB = domain(SBinqB)
  qA = codomain(SAinqA)
  qB = codomain(SBinqB)
  rA = _rho_functor(qA, p, l+1; quad = spec)
  rB = _rho_functor(qB, p, l+1; quad = spec)
  @hassert :ZZLatWithIsom modulus_quadratic_form(rA) == modulus_quadratic_form(rB)

  rAtoSA = hom(rA, SA, elem_type(SA)[SA(QQ(p^l)*lift(a)) for a in gens(rA)])
  HA, HAinSA = sub(SA, rAtoSA.(gens(rA)))
  rAtoHA = hom(rA, HA, elem_type(HA)[HAinSA\(rAtoSA(a)) for a in gens(rA)])

  rBtoSB = hom(rB, SB, elem_type(SB)[SB(QQ(p^l)*(lift(b))) for b in gens(rB)])
  HB, HBinSB = sub(SB, rBtoSB.(gens(rB)))
  rBtoHB = hom(rB, HB, elem_type(HB)[HBinSB\(rBtoSB(b)) for b in gens(rB)])

  # We construct an abstract isometry between the rho functors: since they have
  # the same modulus quadratic, either we see them as finite bilinear modules
  # or both as finite quadratic modules depending on the value of spec
  #
  # Our goal would be to massage phi such that it maps HA to HB, and the
  # restriction to rA and rB agrees with phi_0
  ok, phi_0 = is_anti_isometric_with_anti_isometry(rA, rB)
  @hassert :ZZLatWithIsom 1 ok
  @hassert :ZZLatWithIsom 1 is_anti_isometry(phi_0)

  # We first massage phi such that it maps HA to HB
  phiHA, _ = sub(SB, elem_type(SB)[phi(SA(lift(a))) for a in gens(HA)])
  OSB = orthogonal_group(SB)
  G = GSetByElements(OSB, _on_subgroups, TorQuadModule[HB])
  ok, g = is_conjugate_with_data(G, phiHA, HB)
  @hassert :ZZLatWithIsom 1 ok
  phi_1 = compose(phi, hom(g))
  @hassert :ZZLatWithIsom 1 sub(SB, elem_type(SB)[phi_1(SA(lift(a))) for a in gens(HA)])[1] == HB

  # Now we look at the restriction to rA and rB, and we modify a bit phi_1 by an
  # element of OSBHB, which in particular preserves rB, in order to make phig
  # and phi_0 agree
  phi_1_res = hom(HA, HB, elem_type(HB)[HBinSB\(phi_1(HAinSA(a))) for a in gens(HA)])
  phi_0_res = compose(inv(rAtoHA), compose(phi_0, rBtoHB))
  OSBHB, _ = stabilizer(OSB, HBinSB)
  OHB, OSBHBtoOHB = restrict_automorphism_group(OSBHB, HBinSB; check = false)
  g = OSBHBtoOHB\(OHB(compose(inv(phi_1_res), phi_0_res); check = false))
  phig = compose(phi_1, hom(g))
  @hassert :ZZLatWithIsom 1 matrix(hom(rA, rB, elem_type(rB)[rBtoSB\(phig(rAtoSA(a))) for a in gens(rA)])) == matrix(phi_0)
  @hassert :ZZLatWithIsom 1 sub(SB, elem_type(SB)[phig(SA(lift(a))) for a in gens(HA)])[1] == HB
  return phig
end

###############################################################################
#
#  Extend stabilizers along equivariant primitive extensions
#
###############################################################################

# Given an equivariant gluing phi between stable anti-isometric subgroups SA and
# SB of qA and qB respectively, we know that the image of the centralizer of the
# given equivariant primitive extensions in `O(D)` is given as a certain
# product.
#
# Here actA and actB are respectively the orthogonal representations of the
# stabilizers of SA and SB on SA and SB respectively. Then an isometry of OD
# centralizing the extensions and comes from a global isometry if and only if it
# can be written `(a, b)` where a and b are respectively centralizing elements
# of the isometries of the two sublattices which preserve the glue groups, i.e.
# elements of the domain of actA and actB respectively. We need to take care of
# the kernel of such maps though, and compose the generators of their images.
function _glue_stabilizers(phi::TorQuadModuleMor,
                           actA::GAPGroupHomomorphism,
                           actB::GAPGroupHomomorphism,
                           OqAinOD::GAPGroupHomomorphism,
                           OqBinOD::GAPGroupHomomorphism,
                           graph::TorQuadModuleMor)
  OD = codomain(OqAinOD)
  OqA = domain(OqAinOD)
  imA, _ = image(actA)
  kerA = elem_type(OD)[OqAinOD(x) for x in gens(kernel(actA)[1])]
  push!(kerA, OqAinOD(one(OqA)))

  OqB = domain(OqBinOD)
  imB, _ = image(actB)
  kerB = elem_type(OD)[OqBinOD(x) for x in gens(kernel(actB)[1])]
  push!(kerB, OqBinOD(one(OqB)))

  ext = domain(graph)
  perp, j = orthogonal_submodule(codomain(graph), ext)
  disc = torsion_quadratic_module(cover(perp), cover(ext); modulus = QQ(1), modulus_qf = QQ(2))

  OSA = codomain(actA)
  geneOSA =  elem_type(OSA)[OSA(compose(phi, compose(hom(g1), inv(phi))); check = false) for g1 in unique(gens(imB))]
  im2_phi, _ = sub(OSA, geneOSA)
  im3, _, _ = intersect(imA, im2_phi)
  stab = elem_type(OD)[OqAinOD(actA\x) * OqBinOD(actB\(imB(compose(inv(phi), compose(hom(x), phi)); check = false))) for x in gens(im3)]
  union!(stab, kerA)
  union!(stab, kerB)
  stab = TorQuadModuleMor[restrict_automorphism(g, j; check = false) for g in stab]
  stab = TorQuadModuleMor[hom(disc, disc, elem_type(disc)[disc(lift(g(perp(lift(l))))) for l in gens(disc)]) for g in stab]
  unique!(stab)
  return disc, stab
end
