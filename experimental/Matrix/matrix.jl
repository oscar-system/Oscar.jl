module MatrixGroups

using GAP
using Oscar

export _wrap_for_gap
  
################################################################################
# Initilize GAP function, i.e. GAP reads the file matrix.g
#
function __init__()
    GAP.Globals.Reread(GAP.GapObj(joinpath(Oscar.oscardir, "experimental", "Matrix", "matrix.g")))
end

################################################################################
# Computes the JuliaMatrixRep of a MatrixElem in GAP
#
#    _wrap_for_gap(m::MatrixElem)
#
# Input: m::MatrixElem
# Output: Returns the JuliaMatrixRep of m in GAP
#
# Example
# ```jldoctest
# julia> m = matrix(ZZ, [0 1 ; -1 0]);
# julia> _wrap_for_gap(m)
# GAP: <matrix object of dimensions 2x2 over Integer Ring>
# ```
# """
function _wrap_for_gap(m::MatrixElem)
    return GAP.Globals.MakeJuliaMatrixRep(m)
end


################################################################################
# Construct a GAP group where the elements on the GAP side are wrappers of type
# JuliaMatrixRep around the Oscar matrices.
# Moreover, if G is finite then a nice morphism from G into a GAP matrix group G2
# over a finite field is constructed such that calculations in G can be handled
# automatically  by transferring them to G2.
#
#     MatrixGroup(matrices::Vector{<:MatrixElem{T}}) where T <: Union{fmpz, fmpq, nf_elem}
#
# Input: matrices::Vector{<:MatrixElem{T}} where T <: Union{fmpz, fmpq, nf_elem}
# Output: GAP group generated by the JuliaMatrixReps of matrices
#
# Example
# ```jldoctest
# julia> m1 = matrix(QQ, [0 1 ; -1 0]);
# julia> m2 = matrix(QQ, [ -1 0; 0 1]);
# julia> MatrixGroup([m1,m2])
# GAP: <group with 2 generators>
# ```
# """
function MatrixGroup(matrices::Vector{<:MatrixElem{T}}) where T <: Union{fmpz, fmpq, nf_elem}
       @assert !isempty(matrices)
    
       # One should probably check whether all matrices are n by n (and invertible
       # and such ...)

       K = base_ring(matrices[1])
       if K isa FlintIntegerRing
          K = QQ
       end
       for mat in matrices
            if !(K == mat.base_ring)
                error("Matrices are not from the same base ring")
            end
       end
       n = nrows(matrices[1])

       Fq, matrices_Fq, OtoFq = Oscar.good_reduction(matrices, 2)

       G = Oscar.MatrixGroup(n, Fq, matrices_Fq)
       N = order(G)
       if !isdivisible_by(Hecke._minkowski_multiple(K, n), N)
          error("Group is not finite")
       end

       G_to_fin_pres = GAP.Globals.IsomorphismFpGroupByGenerators(G.X, GapObj([ g.X for g in gens(G) ]))
       F = GAP.Globals.Range(G_to_fin_pres)
       rels = GAP.Globals.RelatorsOfFpGroup(F)

       gens_and_invsF = [ g for g in GAP.Globals.FreeGeneratorsOfFpGroup(F) ]
       append!(gens_and_invsF, [ inv(g) for g in GAP.Globals.FreeGeneratorsOfFpGroup(F) ])
       matrices_and_invs = copy(matrices)
       append!(matrices_and_invs, [ inv(M) for M in matrices ])
       for i = 1:length(rels)
          M = GAP.Globals.MappedWord(rels[i], GapObj(gens_and_invsF), GapObj(matrices_and_invs))
          if !isone(M)
             error("Group is not finite")
          end
       end
        
       G2 = G.X
        
       gapMatrices = GAP.Globals.IdentityMat(length(matrices))
       for i = 1:length(matrices)
           gapMatrices[i] = Oscar.MatrixGroups._wrap_for_gap(matrices[i])
       end
       G = GAP.Globals.Group(gapMatrices)
       
       JuliaGAPMap = GAP.Globals.GroupHomomorphismByImagesNC(G,G2,GAP.Globals.GeneratorsOfGroup(G2))
       
       GAP.Globals.SetNiceMonomorphism(G,JuliaGAPMap);
       GAP.Globals.SetIsHandledByNiceMonomorphism(G, true);
       
       return G
end

end #module MatrixGroups


using .MatrixGroups
