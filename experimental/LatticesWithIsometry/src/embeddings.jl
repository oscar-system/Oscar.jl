const GG = GAP.Globals

################################################################################
#
# Miscellaneous
#
################################################################################

# this function is used whenever A and B are in direct orthogonal sum in a
# bigger torsion module. Let D be this sum. Since A and B are in orthogonal
# direct sum in D, we can embed O(A) and O(B) in O(D).
#
# This function returns D, the embeddings A\to D and B\to D, as well as O(D)
# together with the embeddings O(A) \to O(D) and O(B) \to O(D)
function _sum_with_embeddings_orthogonal_groups(A::TorQuadModule, B::TorQuadModule)
  D = A+B
  AinD = hom(A, D, TorQuadModuleElem[D(lift(a)) for a in gens(A)])
  BinD = hom(B, D, TorQuadModuleElem[D(lift(b)) for b in gens(B)])
  @assert all(v -> AinD(v[1])*BinD(v[2]) == 0, Hecke.cartesian_product_iterator([gens(A), gens(B)], inplace=false))
  OD = orthogonal_group(D)
  OA = orthogonal_group(A)
  OB = orthogonal_group(B)

  gene = data.(union(AinD.(gens(A)), BinD.(gens(B))))
  geneOAinOD = elem_type(OD)[]
  for f in gens(OA)
    imgf = data.(union(AinD.(f.(gens(A))), BinD.(gens(B))))
    fab = hom(gene, imgf)
    fD = OD(hom(D, D, fab.map))
    push!(geneOAinOD, fD)
  end

  geneOBinOD = elem_type(OD)[]
  for f in gens(OB)
    imgf = data.(union(AinD.(gens(A)), BinD.(f.(gens(B)))))
    fab = hom(gene, imgf)
    fD = OD(hom(D, D, fab.map))
    push!(geneOBinOD, fD)
  end
  OAtoOD = hom(OA, OD, geneOAinOD, check = false)
  OBtoOD = hom(OB, OD, geneOBinOD, check = false)
  return D, AinD, BinD, OD, OAtoOD, OBtoOD
end

# Construct the direct sum D of A and B. Since the images of A and B are in
# orthogonal direct sum, we can embed O(A) in O(D) and O(B) in O(D).
#
# This function returns D together with the injections A \to D and B \to D, as
# well as O(D) with the embeddings O(A) \to O(D) and O(B) \to O(D).
function _direct_sum_with_embeddings_orthogonal_groups(A::TorQuadModule, B::TorQuadModule)
  D, inj = direct_sum(A, B)
  AinD, BinD = inj
  OD = orthogonal_group(D)
  OA = orthogonal_group(A)
  OB = orthogonal_group(B)

  geneOAinOD = elem_type(OD)[]
  for f in gens(OA)
    m = block_diagonal_matrix([matrix(f), identity_matrix(ZZ, ngens(B))])
    fD = OD(hom(D, D, m), check=false)
    push!(geneOAinOD, fD)
  end

  geneOBinOD = elem_type(OD)[]
  for f in gens(OB)
    m = block_diagonal_matrix([identity_matrix(ZZ, ngens(A)), matrix(f)])
    fD = OD(hom(D, D, m), check=false)
    push!(geneOBinOD, fD)
  end
  OAtoOD = hom(OA, OD, geneOAinOD, check = false)
  OBtoOD = hom(OB, OD, geneOBinOD, check = false)
  return D, AinD, BinD, OD, OAtoOD, OBtoOD
end

# If fq is an isometry of the torsion module q, we compute the kernel of mu(fq)
# restricted to the p-elementary part of q (i.e. the submodule of q generated by
# all the elements of order p)
#
# This object is defined in Algorithm 2 of [BH23], the glue kernel we aim to use
# for gluing lattices in a p-admissible triples are actually submodules of these
# V's.
function _get_V(fq, mu, p)
  q = domain(fq)
  V, Vinq = primary_part(q, p)
  pV, pVinq = sub(q, [q(lift(divexact(order(g), p)*g)) for g in gens(V) if !(order(g)==1)])
  fpV = restrict_endomorphism(fq, pVinq)
  fpV_mu = evaluate(mu, fpV)
  K, _ = kernel(fpV_mu)
  Ktoq = hom(K, q, [q(lift(a)) for a in gens(K)])
  @hassert :ZZLatWithIsom 1 is_injective(Ktoq)
  return K, Ktoq
end

# This is the rho function as defined in Definition 4.8 of BH23.
function _rho_functor(q::TorQuadModule, p, l::Union{Integer, fmpz}; quad::Bool = (p == 2))
  pq, pqtoq = primary_part(q, p)
  pq = rescale(pq, QQ(p)^(l-1))
  Nv = cover(pq)
  N = relations(pq)
  if quad && p == 2
    fr = _is_free(q, p, l)
  else
    fr = false
  end
  mqf = fr ? QQ(2) : QQ(1)
  if l == 0 
    Gl = N
    Gm = intersect(1//p*N, Nv)
    rholN = torsion_quadratic_module(Gl, p*Gm, modulus = QQ(1), modulus_qf = mqf)
  else
    k = l-1
    m = l+1
    Gk = intersect((1//(p^k))*N, Nv)
    Gl = intersect((1//(p^l))*N, Nv)
    Gm = intersect((1//(p^m))*N, Nv)
    B = Gk+p*Gm
    rholN = torsion_quadratic_module(Gl, B, modulus = QQ(1), modulus_qf = mqf)
  end
  return rholN
end

# A finite bilinear module over the 2-adic integers is even if all square are
# zeros.
function _is_even(T, p, l)
  B = gram_matrix_bilinear(_rho_functor(T, p, l, quad=false))
  return is_empty(B) || all(is_zero, diagonal(B))
end

function _is_free(T, p, l)
  return _is_even(T, p, l-1) && _is_even(T, p, l+1)
end

##############################################################################
#
#  Orbits and stabilizers of discriminant subgroups
#
##############################################################################

# Provisional waiting to be able to compare torsion quadratic modules in a same
# space
function _on_subgroup_automorphic(H::Oscar.GAPGroup, g::AutomorphismGroupElem)
  G = domain(parent(g))
  return sub(G, g.(gens(H)))[1]
end

# Should eventually replace the one above
function _on_subgroup_automorphic(T::TorQuadModule, g::AutomorphismGroupElem)
  q = domain(parent(g))
  gene = TorQuadModuleElem[g(q(lift(t))) for t in gens(T)]
  return sub(q, gene)[1]
end

# Compute stabilizer of a subgroup of a `TorQuadModule` under the action by
# automorphisms. For now we use the GAP infrastructure, we should turn it for
# using the Hecke groups part
function stabilizer(O::AutomorphismGroup{TorQuadModule}, i::TorQuadModuleMor)
  @req domain(O) === codomain(i) "Incompatible arguments"
  q = domain(O)
  togap = get_attribute(O, :to_gap)
  tooscar = get_attribute(O, :to_oscar)
  A = codomain(togap)
  OA = automorphism_group(A)
  OinOA, _ = sub(OA, OA.([g.X for g in gens(O)]))
  N, _ = sub(A, togap.(i.(gens(domain(i)))))
  stab, _ = stabilizer(OinOA, N, _on_subgroup_automorphic)
  return sub(O, O.([h.X for h in gens(stab)]))
end

function _subgroups_orbit_representatives_and_stabilizers(Vinq::TorQuadModuleMor, O::AutomorphismGroup{TorQuadModule};
                                                                                  order::Hecke.IntegerUnion = -1,
                                                                                  f::Union{TorQuadModuleMor, AutomorphismGroupElem{TorQuadModule}} = id_hom(domain(Vinq)))
  fV = f isa TorQuadModuleMor ? restrict_endomorphism(f, Vinq) : restrict_endomorphism(hom(f), Vinq)
  V = domain(OV)
  if order == -1
    subs = stable_submodules(V, [fV])
  else
    subs = submodules(V, order=order)
    filter!(s -> is_invariant(fV, s[2]), subs)
  end
  subs = TorQuadModule[s[1] for s in subs]
  m = gset(O, _on_subgroup_automorphic, subs)
  orbs = orbits(m)
  res = Tuple{TorQuadModuleMor, AutomorphismGroup{TorQuadModule}}[]
  for orb in orbs
    rep = representative(orb)
    stab, _ = stabilizer(O, rep, _on_subgroup_automorphic)
    _, rep = sub(q, TorQuadModuleElem[q(lift(g)) for g in gens(rep)])
    push!(res, (rep, stab))
  end
  return res
end

function _classes_automorphic_subgroups(Vinq::TorQuadModuleMor, O::AutomorphismGroup{TorQuadModule}, q::TorQuadModule; f::Union{TorQuadModuleMor, AutomorphismGroupElem{TorQuadModule}} = id_hom(domain(O)))
  sors = _subgroups_orbit_representatives_and_stabilizers(Vinq, O, order=order(q), f=f)
  return filter(d -> is_isometric_with_isometry(domain(d[1]), q)[1], sors)
end

# The underlying abelian groups of H and V are elementary abelian p-groups, f is
# an automorphism of V fixing H, so in particular it acts on the quotient V/H
# whose abelian structure actually defines a finite dimensional Fp-vector space.
#
# This map return Qp := V/H as an Fp-vector space, the map which transforms V into a
# Fp-vector space Vp, the quotient map Vp \to Qp, and the restriction fQp of f
# to Qp
function _cokernel_as_Fp_vector_space(HinV, p)
  H = domain(HinV)
  V = codomain(HinV)

  n = ngens(V)
  F = GF(p)
  Vp = VectorSpace(F, n)

  function _VtoVp(x::TorQuadModuleElem)
    v = data(x).coeff
    return Vp(vec(collect(v)))
  end

  function _VptoV(v::ModuleElem{FpFieldElem})
    x = lift.(v.v)
    return sum([x[i]*V[i] for i in 1:ngens(V)])
  end

  VtoVp = Hecke.MapFromFunc(_VtoVp, _VptoV, V, Vp)
  subgene = elem_type(Vp)[VtoVp(HinV(a)) for a in gens(H)]
  Hp, _ = sub(Vp, subgene)
  Qp, VptoQp = quo(Vp, Hp)

  return Qp, VtoVp, VptoQp
end

# Given an abelian group injection V \to q where the group structure on V is
# abelian p-elementary, compute orbits and stabilizers of subgroups of V of
# order ord, which contains p^l*q and which are fixed under the action of f, under
# the action by automorphisms of q in G. 
#
# Note that V is fixed by the elements in G, f commutes with the elements in G
# and G is seen as a set of outer automorphisms (so two subgroups are in the
# same orbit if they are G-automorphic).
function _subgroups_orbit_representatives_and_stabilizers_elementary(Vinq::TorQuadModuleMor,
                                                                     G::AutomorphismGroup{TorQuadModule},
                                                                     ord::Hecke.IntegerUnion,
                                                                     f::Union{TorQuadModuleMor, AutomorphismGroupElem{TorQuadModule}} = id_hom(codomain(Vinq)),
                                                                     l::Hecke.IntegerUnion = -1)
  res = Tuple{TorQuadModuleMor, AutomorphismGroup{TorQuadModule}}[]

  V = domain(Vinq)

  if order(V) == 1
    ord != 1 && (return res)
    push!(res, (Vinq, G))
    return res
  end

  q = codomain(Vinq)
  p = elementary_divisors(V)[1]
  pq, pqtoq = primary_part(q, p)
  l = l < 0 ? valuation(order(pq), p) : l
  g = valuation(ord, p)

  if ord == 1
    l < valuation(order(pq), p) && (return res)
    _, triv = sub(codomain(Vinq), TorQuadModuleElem[])
    push!(res, (triv, G))
    return res
  elseif ord == order(V)
    push!(res, (Vinq, G))
    return res
  end

  all(a -> has_preimage(Vinq, (p^l)*pqtoq(a))[1], gens(pq)) || return res
  H0, H0inq = sub(q, [q(lift((p^l)*a)) for a in gens(pq)])
  @hassert :ZZLatWithIsom 1 is_invariant(f, H0inq)
  H0inV = hom(H0, V, [V(lift(a)) for a in gens(H0)])
  @hassert :ZZLatWithIsom 1 is_injective(H0inV)

  if order(H0) >= ord
    order(H0) > ord && (return res)
    push!(res, (H0inq, G))
    return res
  end

  Qp, VtoVp, VptoQp = _cokernel_as_Fp_vector_space(H0inV, p)
  Vp = codomain(VtoVp)

  dim(Qp) == 0 && (return res)

  GV, GtoGV = restrict_automorphism_group(G, Vinq)
  satV, j = kernel(GtoGV)

  act_GV_Vp = FpMatrix[change_base_ring(base_ring(Qp), matrix(gg)) for gg in gens(GV)]
  act_GV_Qp = FpMatrix[solve(VptoQp.matrix, g*VptoQp.matrix) for g in act_GV_Vp]
  MGp = matrix_group(act_GV_Qp)
  GVtoMGp = hom(GV, MGp, MGp.(act_GV_Qp), check = false)
  GtoMGp = compose(GtoGV, GVtoMGp)

  @hassert :ZZLatWithIsom g-ngens(snf(abelian_group(H0))[1]) < dim(Qp)
  
  F = base_ring(Qp)
  k, K = kernel(VptoQp.matrix, side = :left)
  gene_H0p = elem_type(Vp)[Vp(vec(collect(K[i,:]))) for i in 1:k]
  orb_and_stab = orbit_representatives_and_stabilizers(MGp, g-k)
  for (orb, stab) in orb_and_stab
    i = orb.map
    gene_orb_in_Qp = elem_type(Qp)[Qp(vec(collect(i(v).v))) for v in gens(domain(i))]
    gene_orb_in_Vp = elem_type(Vp)[preimage(VptoQp, v) for v in gene_orb_in_Qp]

    gene_submod_in_Vp = vcat(gene_orb_in_Vp, gene_H0p)
    gene_submod_in_V = TorQuadModuleElem[preimage(VtoVp, Vp(v)) for v in gene_submod_in_Vp]
    gene_submod_in_q = TorQuadModuleElem[image(Vinq, v) for v in gene_submod_in_V]
    orbq, orbqinq = sub(q, gene_submod_in_q)
    @hassert :ZZLatWithIsom 1 order(orbq) == ord
    is_invariant(f, orbqinq) || continue

    stabq = AutomorphismGroupElem{TorQuadModule}[GtoMGp\(s) for s in gens(stab)]
    stabq, _ = sub(G, union(stabq, satV))
    @hassert :ZZLatWithIsom 1 is_invariant(stabq, orbqinq)
    push!(res, (orbqinq, stabq))
    @label non_fixed
  end
  return res
end

function Base.:(==)(T1::TorQuadModule, T2::TorQuadModule)
  relations(T1) != relations(T2) && return false
  return cover(T1) == cover(T2)
end

#################################################################################
#
# Embeddings for primary lattices
#
#################################################################################

# We compute representatives of isomorphism classes of primitive extensions
# M \oplus N \to L, where we glue along HM and HN which are respectively
# isometric and anti-isometric to H.
#
# We follow the second definition of Nikulin, i.e. we classify up to the action
# of O(N). If `classification == :strong`, we also classify them up to the
# action of O(M). If `classification == :first`, we return the first embedding
# computed.
function _isomorphism_classes_primitive_extensions(N::ZZLat, M::ZZLat, H::TorQuadModule, classification::Symbol)
  @hassert :ZZLatWithIsom 1 classification in [:first, :weak, :strong]
  results = Tuple{ZZLat, ZZLat, ZZLat}[]
  prim, p = is_primary_with_prime(H)
  el = prim ? is_elementary(H, p) : false

  qN = discriminant_group(N)
  GN, _ = image_in_Oq(N)

  qM = discriminant_group(M)
  if classification == :weak
    GM = Oscar._orthogonal_group(qM, ZZMatrix[matrix(id_hom(qM))])
  else
    GM, _ = image_in_Oq(M)
  end

  D, inj = direct_sum(qN, qM)
  qNinD, qMinD = inj
  OD = orthogonal_group(D)

  if el
    VN, VNinqN, _ = _get_V(id_hom(qN), minpoly(identity_matrix(QQ,1)), p)
    subsN = _subgroups_orbit_representatives_and_stabilizers_elementary(VNinqN, GN, p)
    filter!(HN -> is_anti_isometric_with_anti_isometry(domain(HN[1]), H)[1], subsN)
    @assert !isempty(subsN)
    VM, VMinqM, _ = _get_V(id_hom(qM), minpoly(identity_matrix(QQ, 1)), p)
    subsM = _subgroups_orbit_representatives_and_stabilizers_elementary(VMinqM, GM, p)
    filter!(HM -> is_isometric_with_isometry(domain(HM[1]), H)[1], subsM)
    @assert !isempty(subsM)
  elseif prim
    VN, VNinqN = primary_part(qN, p)
    subsN = _classes_automorphic_subgroups(VNinqN, GN, rescale(H, -1))
    @hassert :ZZLatWithIsom 1 !isempty(subsN)
    VM, VMinqM = primary_part(qM, p)
    subsM = _classes_automorphic_subgroups(VMinqM, GM, H)
    @hassert :ZZLatWithIsom 1 !isempty(subsM)
  else
    VN, VNinqN = qN, id_hom(qN)
    subsN = _classes_automorphic_subgroups(VNinqN, GN, rescale(H, -1))
    @hassert :ZZLatWithIsom 1 !isempty(subsN)
    VM, VMinqM = qM, id_hom(qM)
    subsM = _classes_automorphic_subgroups(VMinqM, GM, H)
    @hassert :ZZLatWithIsom 1 !isempty(subsM)
  end

  for H1 in subsN, H2 in subsM
    ok, phi = is_anti_isometric_with_anti_isometry(domain(H1[1]), domain(H2[1]))
    @hassert :ZZLatWithIsom 1 ok

    HNinVN, stabN = H1
    HN = domain(HNinVN)
    OHN = orthogonal_group(HN)

    HMinVM, stabM = H2
    HM = domain(HMinVM)
    OHM = orthogonal_group(HM)

    actN = hom(stabN, OHN, [OHN(restrict_automorphism(x, HNinVN)) for x in gens(stabN)])

    actM = hom(stabM, OHM, [OHM(restrict_automorphism(x, HMinVM)) for x in gens(stabM)])
    imM, _ = image(actM)

    stabNphi = AutomorphismGroupElem{TorQuadModule}[OHM(compose(inv(phi), compose(hom(actN(g)), phi))) for g in gens(stabN)]
    stabNphi, _ = sub(OHM, stabNphi)
    reps = double_cosets(OHM, stabNphi, imM)
    @vprint :ZZLatWithIsom 1 "$(length(reps)) isomorphism classe(s) of primitive extensions\n"

    for g in reps
      g = representative(g)
      phig = compose(phi, hom(g))
      _glue = Vector{QQFieldElem}[lift(qNinD(VNinqN(HNinVN(g)))) + lift(qMinD(VMinqM(HMinVM(phig(g))))) for g in gens(domain(phig))]
      z = zero_matrix(QQ, 0, degree(N)+degree(M))
      glue = reduce(vcat, [matrix(QQ, 1, degree(N)+degree(M), g) for g in _glue], init = z)
      glue = vcat(block_diagonal_matrix(basis_matrix.(N, M)), glue)
      glue = FakeFmpqMat(glue)
      _B = hnf(glue)
      _B = QQ(1, denominator(glue))*change_base_ring(QQ, numerator(_B))
      L = Hecke.lattice(ambient_space(cover(D)), _B[end-rank(N)-rank(M)+1:end, :])
      N2 = lattice_in_same_ambient_space(L, hcat(basis_matrix(N), zero_matrix(QQ, rank(N), degree(M))))
      @hassert  :ZZLatWithIsom 1 genus(N) == genus(N2)
      M2 = lattice_in_same_ambient_space(L, hcat(zero_matrix(QQ, rank(M), degree(N)), basis_matrix(M)))
      @hassert :ZZLatWithIsom 1 genus(M) == genus(M2)
      push!(results, (L, M2, N2))
      @vprint :ZZLatWithIsom 1 "Gluing done\n"
      GC.gc()
      classification == :first && return results
    end
  end
  return results
end

@doc raw"""
    primitive_embeddings_in_primary_lattice(L::ZZLat, M::ZZLat;
                                            classification::Symbol = :strong,
                                            first::Bool = false,
                                            check::Bool = true)
                                        -> Bool, Vector{Tuple{ZZLat, ZZLat, ZZLat}}

Given a `p`-primary lattice `L`, unique in its genus, and a lattice `M`,
return whether `M` embeds primitively in `L`.

The first input of the function is a boolean `T` stating whether or not `M`
embeds primitively in `L`. The second output `V` consists on triples
`(L', M', N')` where `L'` is isometric to `L`, `M'` is a sublattice of
`L'` isometric to `M`, and `N'` is the orthogonal complement of `M'` in `L'`.

If `T == false`, then `V` will always be the empty list. If `T == true`, then
the content of `V` actually depends on the value of the symbol `classification`.
There are 4 possibilities:
  - `classification = :none`: `V` is the empty list;
  - `classification = :first`: V` consists on the first primitive embedding found;
  - `classification = :strong`: `V` consists on representatives for all isomorphism
  classes of primitive embeddings of `M` in `L` up to the actions of $\bar{O}(M)$
  and $\bar{O}(L)$;
  - `classification = :weak`: `V` consists on representatives for all isomorphism
  classes of primitive embeddings of `M` in `L` up to the action of $\bar{O}(L)$.
"""
function primitive_embeddings_in_primary_lattice(L::ZZLat, M::ZZLat; classification::Symbol = :strong, check::Bool = false)
  @req classification in [:none, :weak, :strong, :first] "Wrong symbol for classification"
  pL, _, nL = signature_tuple(L)
  pM, _, nM = signature_tuple(M)
  @req (pL-pM >= 0 && nL-nM >= 0) "Impossible embedding"
  @req rank(M) < rank(L) "M must be of smaller rank than L"

  bool, p = is_primary_with_prime(L)
  @req bool "L must be unimodular or primary"
  el = is_elementary(L, p)

  if check
    @req length(genus_representatives(L)) == 1 "L must be unique in its genus"
  end

  results = Tuple{ZZLat, ZZLat, ZZLat}[]

  qM = discriminant_group(M)
  GM, _ = image_in_Oq(M)

  GL, _ = image_in_Oq(rescale(L, -1))
  qL = domain(GL)

  D, inj = direct_sum(qM, qL)
  qMinD, qLinD = inj

  if el
    VM, VMinqM, _ = _get_V(id_hom(qM), minpoly(identity_matrix(QQ,1)), p)
  else
    VM, VMinqM = primary_part(qM, p)
  end

  for k in divisors(gcd(order(VM), order(qL)))
    @vprint :ZZLatWithIsom 1 "Glue order: $(k)\n"

    if el
      subsL = _subgroups_orbit_representatives_and_stabilizers_elementary(id_hom(qL), GL, k)
    else
      subsL = _subgroups_orbit_representatives_and_stabilizers(id_hom(qL), GL, order = k)
    end

    @vprint :ZZLatWithIsom 1 "$(length(subsL)) subgroup(s)\n"
    for H in subsL
      HL = domain(H[1])
      it = submodules(VM, order = order(HL))
      subsM = TorQuadModuleMor[sub(qM, lift.(gens(j[1])))[2] for j in it]
      filter!(HM -> is_anti_isometric_with_anti_isometry(domain(HM), HL)[1], subsM)
      isempty(subsM)  && continue

      @vprint :ZZLatWithIsom 1 "Possible gluings\n"
      HM = subsM[1]
      ok, phi = is_anti_isometric_with_anti_isometry(domain(HM), HL)
      @hassert :ZZLatWithIsom 1 ok

      _glue = [lift(qMinD(HM(g))) + lift(qLinD(H[1](phi(g)))) for g in gens(domain(HM))]
      ext, _ = sub(D, D.(_glue))
      perp, j = orthogonal_submodule(D, ext)
      disc = torsion_quadratic_module(cover(perp), cover(ext), modulus = modulus_bilinear_form(perp),
                                                               modulus_qf = modulus_quadratic_form(perp))
      disc2 = rescale(disc, -1)
      !is_genus(disc2, (pL-pM, nL-nM))  && continue

      classification == :none && return true, results

      G = genus(disc2, (pL-pM, nL-nM))
      @vprint :ZZLatWithIsom 1 "We can glue: $G\n"
      Ns = representatives(G)
      @vprint :ZZLatWithIsom 1 "$(length(Ns)) possible orthogonal complement(s)\n"
      Ns = lll.(Ns)
      qM2, _ = orthogonal_submodule(qM, domain(HM))
      for N in Ns
        temp = _isomorphism_classes_primitive_extensions(N, M, qM2, classification)
        if !is_empty(temp)
          classification == :first && return true, temp
          append!(results, temps)
        end
        GC.gc()
      end
    end
  end
  #@hassert :ZZLatWithIsom 1 all(triple -> genus(triple[1]) == genus(L), results)
  return (length(results) > 0), results
end

@doc raw"""
    primitive_embeddings_of_primary_lattice(L::ZZLat, M::ZZLat;
                                            classification::Symbol = :strong,
                                            check::Bool = true)
                                        -> Bool, Vector{Tuple{ZZLat, ZZLat, ZZLat}}

Given a lattice `L`, unique in its genus, and a `p`-primary lattice `M`,
return whether `M` embeds primitively in `L`.

The first input of the function is a boolean `T` stating whether or not `M`
embeds primitively in `L`. The second output `V` consists on triples
`(L', M', N')` where `L'` is isometric to `L`, `M'` is a sublattice of
`L'` isometric to `M`, and `N'` is the orthogonal complement of `M'` in `L'`.

If `T == false`, then `V` will always be the empty list. If `T == true`, then
the content of `V` actually depends on the value of the symbol `classification`.
There are 4 possibilities:
  - `classification = :none`: `V` is the empty list;
  - `classification = :first`: V` consists on the first primitive embedding found;
  - `classification = :strong`: `V` consists on representatives for all isomorphism
  classes of primitive embeddings of `M` in `L` up to the actions of $\bar{O}(M)$
  and $\bar{O}(L)$;
  - `classification = :weak`: `V` consists on representatives for all isomorphism
  classes of primitive embeddings of `M` in `L` up to the action of $\bar{O}(L)$.
"""
function primitive_embeddings_of_primary_lattice(L::ZZLat, M::ZZLat; classification::Symbol = :strong, check::Bool = false)
  @req classification in [:none, :first, :weak, :strong] "Wrong symbol for classification"
  pL, _, nL = signature_tuple(L)
  pM, _, nM = signature_tuple(M)
  @req (pL-pM >= 0 && nL-nM >= 0) "Impossible embedding"
  @req rank(M) < rank(L) "M must be of smaller rank than L"

  bool, p = is_primary_with_prime(M)
  @req bool "M must be unimodular or primary"
  el = is_elementary(M, p)

  if check
    @req length(genus_representatives(L)) == 1 "L must be unique in its genus"
  end

  results = Tuple{ZZLat, ZZLat, ZZLat}[]
  
  qM = discriminant_group(M)
  GM, _ = image_in_Oq(M)

  GL, _ = image_in_Oq(rescale(L, -1))
  qL = domain(GL)

  D, inj, proj = biproduct(qM, qL)
  qMinD, qLinD = inj

  if el
    VL, VLinqL, _ = _get_V(id_hom(qL), minpoly(identity_matrix(QQ,1)), p)
  else
    VL, VLinqL = primary_part(qL, p)
  end

  for k  in divisors(gcd(order(qM), order(VL)))
    @info "Glue order: $(k)"

    if el
      subsL = _subgroups_orbit_representatives_and_stabilizers_elementary(VLinqL, GL, k)
    else
      subsL = _subgroups_orbit_representatives_and_stabilizers(VLinqL, GL, order = k)
    end
    
    @vprint :ZZLatWithIsom 1 "$(length(subsL)) subgroup(s)\n"
    for H in subsL
      HL = domain(H[1])
      it = submodules(qM, order = order(HL))
      subsM = TorQuadModuleMor[H[2] for H in it]
      filter!(HM -> is_anti_isometric_with_anti_isometry(domain(HM), HL)[1], subsM)
      isempty(subsM)  && continue

      @vprint :ZZLatWithIsom 1 "Possible gluings\n"
      HM = subsM[1]
      ok, phi = is_anti_isometric_with_anti_isometry(domain(HM), HL)
      @hassert :ZZLatWithIsom 1 ok

      _glue = [lift(qMinD(HM(g))) + lift(qLinD(VLinqL(H[1](phi(g))))) for g in gens(domain(HM))]
      ext, _ = sub(D, D.(_glue))
      perp, j = orthogonal_submodule(D, ext)
      disc = torsion_quadratic_module(cover(perp), cover(ext), modulus = modulus_bilinear_form(perp),
                                                               modulus_qf = modulus_quadratic_form(perp))
      disc = rescale(disc, -1)
      !is_genus(disc, (pL-pM, nL-nM))  && continue

      classification == :none && return true, results

      G = genus(disc, (pL-pM, nL-nM))
      @info "We can glue: $G"
      Ns = representatives(G)
      @info "$(length(Ns)) possible orthogonal complement(s)"
      Ns = lll.(Ns)
      qM2, _ = orthogonal_submodule(qM, domain(HM))
      for N in Ns
        temp = _isomorphism_classes_primitive_extensions(N, M, qM2, classification)
        if length(temp) > 0
          classification == :first && return true, temp
          append!(results, temp)
        end
        GC.gc()
      end
      GC.gc()
    end
  end
  #@hassert :ZZLatWithIsom 1 all(triple -> genus(triple[1]) == genus(L), results)
  return (length(results) >0), results
end

####################################################################################
#
# Admissible equivariant primitive extensions
#
####################################################################################

# The function is long and cannot be cut easily in subprocesses because we need
# to keep track of too many objects and parameters. So too avoid to have
# subfunctions with dozens of arguments, we just leave it as is and make a bunch
# of comments along the way.
@doc raw"""
    admissible_equivariant_primitive_extensions(Afa::ZZLatWithIsom,
                                                Bfb::ZZLatWithIsom,
                                                Cfc::ZZLatWithIsom,
                                                p::Integer,
                                                q::Integer = p; check=true)
                                                     -> Vector{ZZLatWithIsom}

Given a triple of lattices with isometry `(A, fa)`, `(B, fb)` and `(C, fc)` and a
prime number `p`, such that `(A, B, C)` is `p`-admissible, return a set of
representatives of the double coset $G_B\backslash S\slash/G_A$ where:

  - $G_A$ and $G_B$ are the respective images of the morphisms
    $O(A, fa) -> O(q_A, \bar{fa})$ and $O(B, fb) -> O(q_B, \bar{fb})$;
  - $S$ is the set of all primitive extensions $A \perp B \subseteq C'$ with isometry
    $fc'$ where $p\cdot C' \subseteq A\perpB$ and such that the type of $(C', fc'^q)$
    is equal to the type of `(C, fc)`.

If `check == true` the input triple is checked to a `p`-admissible triple of
integral lattices (with isometry) with `fA` and `fB` having relatively coprime
irreducible minimal polynomials and imposing that `A` and `B` are orthogonal
if `A`, `B` and `C` lie in the same ambient quadratic space.

Note that `Afa` and `Bfb` must be of pure type, i.e. the minimal polynomials
of the associated isometries must be irreducible (and relatively coprime).

See Algorithm 2 of [BH22].
"""
function admissible_equivariant_primitive_extensions(A::ZZLatWithIsom,
                                                     B::ZZLatWithIsom,
                                                     C::ZZLatWithIsom,
                                                     p::Integer,
                                                     q::Integer = p; check=true)
  # p and q can be equal, and they will be most of the time
  @req is_prime(p) && is_prime(q) "p and q must be a prime number" 

  # Requirements for [BH23]
  amb = ambient_space(lattice(A)) === ambient_space(lattice(B)) === ambient_space(lattice(C))
  if check 
    @req all(L -> is_integral(L), [A, B, C]) "Underlying lattices must be integral"
    chiA = minpoly(A)
    chiB = minpoly(parent(chiA), isometry(B))
    @req gcd(chiA, chiB) == 1 "Minimal irreducible polynomials must be relatively coprime"
    @req is_admissible_triple(A, B, C, p) "Entries, in this order, do not define an admissible triple with respect to p"
    if amb
      G = gram_matrix(ambient_space(C))
      @req iszero(basis_matrix(A)*G*transpose(basis_matrix(B))) "Lattices in same ambient space must be orthogonal"
    end
  end

  results = ZZLatWithIsom[]

  # this is the glue valuation: it is well-defined because the triple in input is admissible
  g = div(valuation(divexact(det(A)*det(B), det(C)), p), 2)

  qA, fqA = discriminant_group(A)
  qB, fqB = discriminant_group(B)
  qC, _ = discriminant_group(C)
  GA = image_centralizer_in_Oq(A)
  @hassert :ZZLatWithIsom 1 fqA in GA
  GB = image_centralizer_in_Oq(B)
  @hassert :ZZLatWithIsom 1 fqB in GB

  # this is where we will perform the glueing
  if amb
    D, qAinD, qBinD, OD, OqAinOD, OqBinOD = _sum_with_embeddings_orthogonal_groups(qA, qB)
  else
    D, qAinD, qBinD, OD, OqAinOD, OqBinOD = _direct_sum_with_embeddings_orthogonal_groups(qA, qB)
  end

  OqA = domain(OqAinOD)
  OqB = domain(OqBinOD)

  # if the glue valuation is zero, then we glue along the trivial group and we don't
  # have much more to do. Since the triple is p-admissible, A+B = C
  if g == 0
    geneA = AutomorphismGroupElem{TorQuadModule}[OqAinOD(OqA(a.X)) for a in gens(GA)]
    geneB = AutomorphismGroupElem{TorQuadModule}[OqBinOD(OqB(b.X)) for b in gens(GB)]
    gene = vcat(geneA, geneB)
    GCAB, _ = sub(OD, gene)
    if amb
      C2 = lattice(A)+lattice(B)
      fC2 = block_diagonal_matrix([isometry(A), isometry(B)])
      _B = solve_left(reduce(vcat, basis_matrix.([A,B])), basis_matrix(C2))
      fC2 = _B*fC2*inv(_B)
      @hassert :ZZLatWithIsom 1 fC2*gram_matrix(C2)*transpose(fC2) == gram_matrix(C2)
    else
      _B = block_diagonal_matrix([basis_matrix(A), basis_matrix(B)])
      C2 = lattice_in_same_ambient_space(cover(D), _B)
      fC2 = block_diagonal_matrix([isometry(A), isometry(B)])
      @hassert :ZZLatWithIsom 1 fC2*gram_matrix(C2)*transpose(fC2) == gram_matrix(C2)
    end
    qC2 = discriminant_group(C2)
    phi2 = hom(qC2, D, TorQuadModuleElem[D(lift(x)) for x in gens(qC2)])
    @hassert :ZZLatWithIsom 1 is_isometry(phi2)
    if is_of_type(integer_lattice_with_isometry(C2, fC2^q, ambient_representation=false), type(C))
      GC2 = Oscar._orthogonal_group(qC2, [compose(phi2, compose(hom(g), inv(phi2))).map_ab.map for g in gens(GCAB)])
      C2fc2 = integer_lattice_with_isometry(C2, fC2, ambient_representation=false)
      @hassert :ZZLatWithIsom 1 discriminant_group(C2fc2)[2] in GC2
      set_attribute!(C2fc2, :image_centralizer_in_Oq, GC2)
      push!(results, C2fc2)
    end
    return results
  end

  # these are GA|GB-invariant, fA|fB-stable, and should contain the kernels of any glue map.
  # VA and VB are submodules of the p-elementary parts of qA and qB
  # respectively.
  VA, VAinqA = _get_V(hom(fqA), minpoly(B), p)
  VB, VBinqB = _get_V(hom(fqB), minpoly(A), p)

  # since the glue kernels must have order p^g, in this condition, we have nothing
  if min(order(VA), order(VB)) < p^g
    return results
  end

  # scale of the dual: any glue kernel must contain the multiples of l of the respective
  # primary part of the discriminant groups
  l = valuation(level(genus(C)), p)

  # In the special case where rho_{l+1}(A) and rho_{l+1}(B) are free, then we
  # know that rho_l(C) is even if and only if any admissible gluing should
  # induce an isometry of finite quadratic form between rho_{l+1}(A) and
  # rho_{l+1}(B) (this works only when `p == 2`). In all the other cases, then
  # admissible gluings only induce isometries of finite bilinear modules between
  # rho_{l+1}(A) and rho_{l+1}(B).
  spec = (p == 2) && (_is_free(qA, p, l+1)) && (_is_free(qB, p, l+1)) && (_is_even(qC, p, l))

  # We look for the GA|GB-invariant and fA|fB-stable subgroups of VA|VB which respectively
  # contained lpqA|lpqB, where pqA and pqB are respectively the p-primary parts of qA and qB.
  # This is done by computing orbits and stabilisers of VA/lpqA (resp VB/lpqB)
  # seen as a F_p-vector space under the action of GA (resp. GB). Then we check which ones
  # are fA-stable (resp. fB-stable)
  subsA = _subgroups_orbit_representatives_and_stabilizers_elementary(VAinqA, GA, p^g, fqA, ZZ(l))
  subsB = _subgroups_orbit_representatives_and_stabilizers_elementary(VBinqB, GB, p^g, fqB, ZZ(l))

  # once we have the potential kernels, we create pairs of anti-isometric groups since glue
  # maps are anti-isometry
  R = Tuple{eltype(subsA), eltype(subsB), TorQuadModuleMor}[]
  for H1 in subsA, H2 in subsB
    ok, phi = is_anti_isometric_with_anti_isometry(domain(H1[1]), domain(H2[1]))
    !ok && continue
    push!(R, (H1, H2, phi))
  end

  # now, for each pair of anti-isometric potential kernels, we need to massage the gluing
  # computed to turn it into an admissible one. Then, we need to decide whether
  # such an admissible gluing can be made (fA,fB)-equivariant, up to conjugacy.
  #
  # Each pair for which we can find such nice gluing, we create the double coset
  # parametrising all such gluing up to certain conditions and we then compute the
  # corresponding overlattice and check whether it satisfies the type conditions.
  for (H1, H2, phi) in R
    SAinqA, stabA = H1
    SA = domain(SAinqA)
    OSA = orthogonal_group(SA)

    SBinqB, stabB = H2
    SB = domain(SBinqB)
    OSB = orthogonal_group(SB)
    
    # we need a first admissible gluing. We know that such gluing exists because
    # we have an admissible triple as input and the glue kernels have been
    # chosen in such a way that their exist an admissible gluing between them.
    phi = _find_admissible_gluing(SAinqA, SBinqB, phi, l, spec)

    # we compute the image of the stabilizers in the respective OS* and we keep track
    # of the elements of the stabilizers acting trivially in the respective S*
    # (there are in the ker*).
    actA = hom(stabA, OSA, [OSA(restrict_automorphism(x, SAinqA)) for x in gens(stabA)])
    imA, _ = image(actA)
    kerA = AutomorphismGroupElem{TorQuadModule}[OqAinOD(x) for x in gens(kernel(actA)[1])]
    union!(kerA, OqAinOD(one(OqA)))
    fSA = OSA(restrict_automorphism(fqA, SAinqA))

    actB = hom(stabB, OSB, [OSB(restrict_automorphism(x, SBinqB)) for x in gens(stabB)])
    imB, _ = image(actB)
    kerB = AutomorphismGroupElem{TorQuadModule}[OqBinOD(x) for x in gens(kernel(actB)[1])]
    union!(kerB, OqBinOD(one(OqB)))
    fSB = OSB(restrict_automorphism(fqB, SBinqB))

    # We want all isometries of SB which preserves p^l*q_B and such that they
    # define isometries of rho_{l+1}(B). If `spec == true`, then rho_{l+1}(B) is
    # equiped with a quadratic form and we check isometries preserving it.
    # Otherwise, only isometries preserving the underlying bilinear product.
    OSBrB = _compute_double_stabilizer(SBinqB, l, spec)
    @hassert :ZZLatWithIsom 1 fSB in OSBrB   # Should always hold since the construction of rho_{l+1}(B) is natural in B
    fSB = OSBrB(fSB)

    # phi might not "send" the restriction of fA to this of fB, but at least phi*fA*phi^-1
    # should be conjugate to fB inside O(SB, rho_l(qB)) for the gluing.
    # If not, we try the next potential pair.
    fSAinOSB = OSB(compose(inv(phi), compose(hom(fSA), phi)))
    @hassert :ZZLatWithIsom 1 fSAinOSB in OSBrB  # Same as before, since phi is admissible, then the image of fSA should preserve rho_{l+1}(B)
    bool, g0 = representative_action(OSBrB, OSBrB(fSAinOSB), fSB)
    bool || continue

    # The new phi is "sending" the restriction of fA to this of fB
    # and it is still admissible. So we can glue SA and SB as wanted.
    phi = compose(phi, hom(OSB(g0)))
    fSAinOSB = OSBrB(compose(inv(phi), compose(hom(fSA), phi)))
    @hassert :ZZLatWithIsom 1 fSAinOSB == fSB

    # Now it is time to compute generators for O(SB, rho_l(qB), fB), and the induced
    # images of stabA|stabB for taking the double cosets next
    center, _ = centralizer(OSBrB, fSB)
    center, _ = sub(OSB, [OSB(c) for c in gens(center)])
    stabSAphi, _ = sub(OSB, AutomorphismGroupElem{TorQuadModule}[OSB(compose(inv(phi), compose(hom(g), phi))) for g in gens(imA)])
    stabSAphi, _ = intersect(center, stabSAphi)
    stabSB, _ = intersect(center, imB)
    reps = double_cosets(center, stabSB, stabSAphi)

    # We iterate over all double cosets. Each representative, define a new
    # classe of admissible gluing and so, for each such representative we compute the
    # corresponding overlattice along the gluing. If it has the wanted type, we compute
    # the image of the centralizer in OD from the stabA and stabB.
    for g in reps
      g = representative(g)
      phig = compose(phi, hom(g))
      @assert is_anti_isometry(phig)

      # The following is the regular procedure we use on Oscar/Hecke to compute
      # overlattices of a gluing. We overwrite it here because we have too many
      # parameters to keep track to in this function. We distinguish the case of
      # similar ambient space since everything is made way easier as soon as
      # we work in a unique fixed quadratic space.
      if amb
        _glue = Vector{QQFieldElem}[lift(g) + lift(phig(g)) for g in gens(domain(phig))]
        z = zero_matrix(QQ, 0, degree(A))
        glue = reduce(vcat, [matrix(QQ, 1, degree(A), g) for g in _glue], init=z)
        glue = vcat(basis_matrix(lattice(A)+lattice(B)), glue)
        glue = FakeFmpqMat(glue)
        _B = hnf(glue)
        _B = QQ(1, denominator(glue))*change_base_ring(QQ, numerator(_B))
        C2 = lattice(ambient_space(A), _B[end-rank(A)-rank(B)+1:end, :])
        fC2 = block_diagonal_matrix([isometry(A), isometry(B)])
        _B = solve_left(reduce(vcat, basis_matrix.([A,B])), basis_matrix(C2))
        fC2 = _B*fC2*inv(_B)
      else
        _glue = Vector{QQFieldElem}[lift(qAinD(SAinqA(s)))+  lift(qBinD(SBinqB(phig(s)))) for s in gens(domain(phig))]
        z = zero_matrix(QQ,0,degree(cover(D)))
        glue = reduce(vcat, [matrix(QQ, 1, degree(cover(D)),g) for g in _glue], init=z)
        glue = vcat(block_diagonal_matrix(basis_matrix.([A, B])), glue)
        glue = FakeFmpqMat(glue)
        _B = hnf(glue)
        _B = QQ(1, denominator(glue))*change_base_ring(QQ, numerator(_B))
        C2 = lattice(ambient_space(cover(D)), _B[end-rank(A)-rank(B)+1:end, :])
        fC2 = block_diagonal_matrix([isometry(A), isometry(B)])
        __B = solve_left(block_diagonal_matrix(basis_matrix.([A,B])), basis_matrix(C2))
        fC2 = __B*fC2*inv(__B)
      end
      @hassert :ZZLatWithIsom 1 fC2*gram_matrix(C2)*transpose(fC2) == gram_matrix(C2)

      # This is the type requirement: somehow, we want `(C2, fC2)` to be a "q-th root" of `(C, fC)`.
      if !is_of_type(integer_lattice_with_isometry(C2, fC2^q, ambient_representation = false), type(C))
        continue
      end

      # By the theory of primitive extensions, the discriminant group qC2 of C2
      # is equal to H^{perp}/H where H is the graph of phig in D = qA + qB. We need
      # to treat both at the same time to compute the image of the centralizer
      # O(C2, fC2) in O(qC2, fqC2) using GA and GB.
      ext, _ = sub(D, D.(_glue))
      perp, j = orthogonal_submodule(D, ext)
      disc = torsion_quadratic_module(cover(perp), cover(ext), modulus = modulus_bilinear_form(perp),
                                                               modulus_qf = modulus_quadratic_form(perp))
      qC2 = discriminant_group(C2)
      OqC2 = orthogonal_group(qC2)
      phi2 = hom(qC2, disc, [disc(lift(x)) for x in gens(qC2)])
      @hassert :ZZLatWithIsom 1 is_isometry(phi2)              # In fact they are the same module so phi2, mathematically, is the identity.

      # So now this new integer lattice with isometry `(C2, fC2)` is a good
      # output. Just remain toi compute GC2 in a smart way.
      C2 = integer_lattice_with_isometry(C2, fC2, ambient_representation=false)
      geneOSA =  AutomorphismGroupElem{TorQuadModule}[OSA(compose(phig, compose(hom(g1), inv(phig)))) for g1 in unique(gens(imB))]
      im2_phi, _ = sub(OSA, geneOSA)
      gene_inter = AutomorphismGroupElem{TorQuadModule}[h for h in unique(gens(intersect(imA, im2_phi)[1]))]
      im3, _ = sub(imA, gene_inter)
      stab = Tuple{AutomorphismGroupElem{TorQuadModule}, AutomorphismGroupElem{TorQuadModule}}[(actA\x, actB\(imB(compose(inv(phig), compose(hom(x), phig))))) for x in gens(im3)]
      stab = AutomorphismGroupElem{TorQuadModule}[OqAinOD(x[1])*OqBinOD(x[2]) for x in stab]
      stab = union(stab, kerA)
      stab = union(stab, kerB)
      stab = TorQuadModuleMor[restrict_automorphism(g, j) for g in stab]
      stab = TorQuadModuleMor[hom(disc, disc, [disc(lift(g(perp(lift(l))))) for l in gens(disc)]) for g in stab]
      stab = Oscar._orthogonal_group(qC2, [compose(phi2, compose(g, inv(phi2))).map_ab.map for g in stab])

      # If we have done good things, the action of fC2 on qC2 should centralize
      # itself...
      @hassert :ZZLatWithIsom 1 discriminant_group(C2)[2] in stab

      set_attribute!(C2, :image_centralizer_in_Oq, stab)
      push!(results, C2)
    end
  end
  return results
end

# Action of isometries on the gram matrix of a finite bilinear form
function _on_modular_matrix(M::QQMatrix, g::AutomorphismGroupElem)
  q = domain(parent(g))
  R = Hecke.QmodnZ(QQ(1))
  m = matrix(inv(g))
  return map_entries(a -> lift(R(a)), m*M*transpose(m))
end

# Action of isometries on the gram matrix of a finite quadratic form
function _on_modular_matrix_quad(M::QQMatrix, g::AutomorphismGroupElem)
  q = domain(parent(g))
  R1 = Hecke.QmodnZ(QQ(1))
  R2 = Hecke.QmodnZ(QQ(2))
  m = matrix(inv(g))
  m1 = m*M*transpose(m)
  for i in 1:nrows(m1)
    for j in 1:ncols(m1)
      if i == j
        m1[i,j] = lift(R2(m1[i,j]))
      else
        m1[i,j] = lift(R1(m1[i,j]))
      end
    end
  end
  return m1
end

# We compute O(SB, rho_{l+1}(B)) where B has discriminant form qB. `spec` keep
# track whether rho_{l+1}(B) should be considered as a finite quadratic module
# or just a finite bilinear module (depends on the overlattice).
function _compute_double_stabilizer(SBinqB, l, spec)
  SB = domain(SBinqB)
  qB = codomain(SBinqB)
  OSB = orthogonal_group(SB)
  p = elementary_divisors(SB)[1]
  rB = _rho_functor(qB, p, l+1)
  rBtoSB = hom(rB, SB, [SB(QQ(p^l)*lift(a)) for a in gens(rB)])
  HB, HBinSB = sub(SB, rBtoSB.(gens(rB)))
  OSBHB, _ = stabilizer(OSB, HBinSB)
  OHB, OSBHBtoOHB = restrict_automorphism_group(OSBHB, HBinSB)
  K, _ = kernel(OSBHBtoOHB)
  if p != 2
    OHBrB, _ = stabilizer(OHB, gram_matrix_bilinear(rB), _on_modular_matrix)
  elseif spec
    OHBrB, _ = stabilizer(OHB, gram_matrix_quadratic(rB), _on_modular_matrix_quad)
  else
    OHBrB, _ = stabilizer(OHB, gram_matrix_bilinear(rB), _on_modular_matrix)
  end
  OSBrB, _ = sub(OSB, union(gens(K), OSB.(gens((OSBHBtoOHB\(OHBrB))[1]))))
  return OSBrB
end

# Test whether an abelian group isomorphism respect the finite bilinear product
# of its domain (of type `TorQuadModule`).
function _is_isometry_bilinear(f::TorQuadModuleMor)
  !is_bijective(f) && return false
  for a in gens(domain(f))
    for b in gens(domain(f))
      if f(a)*f(b) != a*b
        return false
      end
    end
  end
  return true
end

# Test whether an abelian group isomorphism defines an anti isometry of the
# finite bilinear product defined on its domain (of type `TorQuadModule`)
function _is_anti_isometry_bilinear(f::TorQuadModuleMor)
  !is_bijective(f) && return false
  for a in gens(domain(f))
    for b in gens(domain(f))
      if f(a)*f(b) != -a*b
        return false
      end
    end
  end
  return true
end

# If we are given a gluing between SA and SB, given that an admissible gluing
# exist, we massage phi until we turn it into an admissible gluing. There might
# be ways to improve such search, but I would expect that both loops iterating
# on OSB and OSBHB are terminating after few tries.
function _find_admissible_gluing(SAinqA, SBinqB, phi, l, spec)
  SA = domain(SAinqA)
  SB = domain(SBinqB)
  p = elementary_divisors(SA)[1]
  qA = codomain(SAinqA)
  qB = codomain(SBinqB)
  pqA, pqAtoqA = primary_part(qA, p)
  pqB, pqBtoqB = primary_part(qB, p)
  rA = _rho_functor(qA, p, l+1)
  rB = _rho_functor(qB, p, l+1)
  rAtoSA = hom(rA, SA, [SA(QQ(p^l)*lift(a)) for a in gens(rA)])
  HA, _ = sub(SA, rAtoSA.(gens(rA)))
  rBtoSB = hom(rB, SB, [SB(QQ(p^l)*(lift(b))) for b in gens(rB)])
  HB, HBinSB = sub(SB, rBtoSB.(gens(rB)))
  if p != 2
    phi_0 = _anti_isometry_bilinear(rA, rB)
  elseif spec
    ok, phi_0 = is_anti_isometric_with_anti_isometry(rA, rB)
    @hassert :ZZLatWithIsom 1 ok
    @hassert :ZZLatWithIsom 1 is_anti_isometry(phi_0)
  else
    phi_0 = _anti_isometry_bilinear(rA, rB)
  end
  phiHA, _ = sub(SB, [phi(SA(lift(a))) for a in gens(HA)])
  OSB = orthogonal_group(SB)
  g = one(OSB)
  for f in OSB
    g = f
    if cover(_on_subgroup_automorphic(phiHA, g)) == cover(HB)
      break
    end
  end
  phi_1 = compose(phi, hom(g))
  OSBHB, _ = stabilizer(OSB, HBinSB)
  g = one(OSBHB)
  for f in OSBHB
    g = f
    phif = compose(phi_1, hom(f))
    psi = hom(rA, rB, [rBtoSB\(phif(rAtoSA(a))) for a in gens(rA)])
    if matrix(psi) == matrix(phi_0)
      break
    end
  end
  phig = compose(phi_1, hom(g))
  return phig
end

# Compute an anti-isometry between the two finite bilinear modules r1 and r2.
function _anti_isometry_bilinear(r1, r2)
  @hassert :ZZLatWithIsom is_semi_regular(r1) === is_semi_regular(r2) === true
  r2m = rescale(r2, -1)
  r2tor2m = hom(r2, r2m, identity_matrix(ZZ, ngens(r2)))
  r1N, r1tor1N = normal_form(r1)
  r2mN, r2mtor2mN = normal_form(r2m)
  @hassert :ZZLatWithIsom 1 gram_matrix_bilinear(r1N) == gram_matrix_bilinear(r2mN)
  T = hom(r1N, r2mN, identity_matrix(ZZ, ngens(r1N)))
  T = compose(r1tor1N, compose(T, compose(inv(r2mtor2mN), inv(r2tor2m))))
  @hassert :ZZLatWithIsom _is_anti_isometry_bilinear(T)
  return T
end

