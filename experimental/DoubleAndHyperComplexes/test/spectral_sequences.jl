@testset "Spectral sequences for toric varieties" begin
  X = projective_space(NormalToricVariety, 2) # IP^2 as a toric variety
  S = cox_ring(X)
  G = grading_group(S)

  F = graded_free_module(S, [zero(G)])
  (x, y, z) = gens(S)
  I, _ = sub(F, [x*y*z*F[1]]) # OO(-3)
  J, _ = sub(F, [x^4*y*z*F[1]]) # OO(-6)
  phi = hom(J, I, [x^3*I[1]]) # a morphism OO(-3) <-- OO(-6)

  # We wrap the above morphism in a 2-term complex. 
  cplx = Oscar.SimpleComplexWrapper(Oscar.ComplexOfMorphisms([phi]))
  res = total_complex(Oscar.CartanEilenbergResolution(cplx))

  # And compute its spectral sequence.
  css = Oscar.CohomologySpectralSequence(X, res);
  # At the moment the code for spectral sequences can not handle 
  # dynamic exponent vectors in the toric context. We are working on 
  # fixing this. In the meantime, the user can set the exponent 
  # vector manually to a global default using the following method.
  Oscar.set_global_exponent_vector!(css, 10)
  p1 = css[1]; # The first page. Printing this still throws an error! sorry...

  # The indexation is a bit awkward (due to internal reasons). 
  # The first index is for the direction of the `phi`-complex.
  # The second index ranges from 0 down to -2 and stands for the Cech-cohomology. 
  # This will give you an impression of the first page:
  @test [ngens(p1[i, j]) for j in 0:-1:-2, i in 0:1] == [0 0; 0 0; 1 10]

  # The map between the two non-trivial entries looks like this:
  @test !is_zero(matrix(map(p1, 1, -2)))

  # Let's look at the second page, then:
  p2 = css[2];
  [ngens(p2[i, j]) for j in 0:-1:-2, i in 0:1]

  # Beware that the entry at (0, -2) is zero!
  @test [!is_zero(p2[i, j]) for j in 0:-1:-2, i in 0:1] == [0 0; 0 0; 0 1]
end

@testset "Spectral sequences for toric varieties with parameters" begin
  # Example code provided by Friedemann Groh.

  # Exponents of polynomials with undetermined coefficients
  support_mats = [[0 0;2 7;1 3],[0 0;2 5;1 2],[3 0;1 1]];

  # Coefficients of polynomials
  coef = [[4,-1,3],[2,5,7],[1,-3]];

  R, a = polynomial_ring(QQ, vcat([["a$(i)_$(j)" for j in 1:nrows(A)] for (i, A) in enumerate(support_mats)]...))

  a_groups = Vector{elem_type(R)}[]
  offset = 0
  for A in support_mats
    push!(a_groups, a[offset+1:offset+nrows(A)])
    offset += nrows(A)
  end

  # Newton polytopes of support sets
  Q = map( convex_hull, support_mats);

  # Toric variety specified by the normal fan of the Minkowski sum of all Newton polytopes  
  X = normal_toric_variety( reduce( minkowski_sum, Q) );
  S = cox_ring(X);
  S_ext, to_S_ext = change_base_ring(R, S)

  x = gens(S_ext);

  # Ray generators in fan of toric variety
  U = map( primitive_generator, rays(X));

  # Coordinates of Cartier divisors in X of the system's Newton polytopes
  div_coords = [map(u -> -minimum( grad*primitive_generator(u) ), rays(X)) for grad in support_mats];

  # Homogeneous polynomials specified by characters in supports
  f = [sum( [a_groups[k][j] * prod( [x[i]^( dot( support_mats[k][j,:], U[i]) + div_coords[k][i] ) for i = 1:n_rays(X)] ) for j = 1:size(support_mats[k],1)] ) for k = 1:length(support_mats)];

  # Koszul complex generated by these polynomials
  Koszul_F = Oscar.HomogKoszulComplex(S_ext,f);

  css = Oscar.CohomologySpectralSequence(X, to_S_ext, Koszul_F);
  @time map(css[3], 3, -2);

  p=1
  [ngens(css[p, i, j]) for j in 0:-1:-7, i in 0:3]
  @test !is_zero(map(css[p], 3, -2))

  p=2
  [ngens(css[p, i, j]) for j in 0:-1:-7, i in 0:3]
  @test is_zero(map(css[p], 3, -2))

  p=3
  [ngens(css[p, i, j]) for j in 0:-1:-7, i in 0:3]
  @test !is_zero(map(css[p], 3, -2))
end

