module GrpExt_module
using Oscar

import Base: *, ==, one, rand, show, iterate
export GrpExt, GrpExtElem
export commutator_decomposition_map

"""
A type representing the group extension by a 2-co-cycle.
Let ``h in H^2(G, M)`` for some group `G` and module `M`.
Then `S` is the type of elements in `G` while `T` is the
type of the module elements.

The chains is then of type `CoChain{2, S, T}`, elements
of this group are essentially pairs of elements of `G` and
`M`.
"""
struct GrpExt{S, T} <: AbstractAlgebra.Group
  c :: Oscar.GrpCoh.CoChain{2, S, T} 
  function GrpExt(c::Oscar.GrpCoh.CoChain{2, A, B}) where A where B
    return new{A, B}(c)
  end
end

function show(io::IO, G::GrpExt)
  print(io, "Extension via $(gmodule(G))")
end

"""
The elements of the extension, given via a 2-co-chain.
"""
struct GrpExtElem{S, T} <: AbstractAlgebra.GroupElem
  P::GrpExt{S, T} #parent
  g::S            #the group bit
  m::T            #the module bit
  function GrpExtElem(P::GrpExt{A, B}, g::A, m::B) where A where B 
    return new{A, B}(P, g, m)
  end
end

function show(io::IO, g::GrpExtElem)
  print(io, "($(g.g), $(g.m))")
end

Oscar.gmodule(P::GrpExt) = P.c.C
Oscar.gmodule(P::GrpExtElem) = gmodule(parent(P))
_module(P::GrpExt) = gmodule(P).M
_group(P::GrpExt) = gmodule(P).G

Oscar.parent(g::GrpExtElem) = g.P

function one(G::GrpExt)
  return GrpExtElem(G, one(_group(G)), zero(_module(G)))
end

function Oscar.gens(G::GrpExt)
  gr = _group(G)
  mo = _module(G)
  g = gens(gr)
  m = gens(mo)
  return vcat([GrpExtElem(G, x, zero(mo)) for x = g], [GrpExtElem(G, one(gr), x) for x = m])
end

function *(g::GrpExtElem, h::GrpExtElem)
  @assert parent(g) === parent(h)
  return GrpExtElem(g.P, g.g*h.g, action(gmodule(g), h.g)(g.m) + h.m + g.P.c(g.g, h.g))
end

function Oscar.inv(g::GrpExtElem)
  gi = inv(g.g)
  return GrpExtElem(g.P, gi, -action(gmodule(g), gi)(g.m)-g.P.c(g.g, gi))
end

function rand(G::GrpExt)
  return GrpExtElem(G, rand(_group(G)), rand(_module(G)))
end

function ==(g::GrpExtElem, h::GrpExtElem)
  @assert g.P === h.P
  return g.g == h.g && g.m == h.m
end

function iterate(G::GrpExt)
  I = Base.Iterators.ProductIterator((_group(G), _module(G)))
  X = iterate(I)

  return GrpExtElem(G, X[1][1], X[1][2]), (I, X[2], G)
end

function iterate(G::GrpExt, X::Tuple)
  n = iterate(X[1], X[2])
  if n === nothing
    return n
  end
  return GrpExtElem(X[3], n[1][1], n[1][2]), (X[1], n[2], X[3])
end

Oscar.order(G::GrpExt) = order(_group(G))*order(_module(G))
Base.length(G::GrpExt) = Int(order(G))

function Oscar.order(g::GrpExtElem)
  o = order(g.g)
  g = g^Int(o)
  return o*order(g.m)
end

function(P::GrpExt{S, T})(g::S, a::T) where S where T
  return GrpExtElem(P, g, a)
end

function Oscar.is_one(m::Map{FinGenAbGroup, FinGenAbGroup})
  domain(m) === codomain(m) || return false
  return all(x->x == m(x), domain(m))
end

function Oscar.is_central(P::GrpExt)
  return all(is_one, action(gmodule(P)))
end

function Oscar.is_stem_extension(P::GrpExt)
  is_central(P) || return false
  G = _group(P)
  #  part of algo is explained in Cohomology.jl
  #
  # a commutator (comm(X, Y)) does not depend on X,m and Y.m
  # We need to check M <= P'
  # in P, M ;ooks like (1, M)
  # any word evaluated in P will have the G part as the evaluation
  # only on the G part (the G part is the projection, hence a hom)
  # any word evaluated in P to get a (1, M) will be a relator of G'
  # Writig such a relator as a word in commutators make the evaluation
  # depend only on the co-chain, not on other choices.
  E, mE = derived_subgroup(G)
  h = commutator_decomposition_map(mE)
  i = isomorphism(FPGroup, E) # E -> Fp
  R = relators(codomain(i))

  g1 = gens(codomain(i)) # in Fp
  g2 = map(pseudo_inv(i), g1) # in E
  g = [map_word(h(x), [P(x, zero(_module((P)))) for x = gens(G)]) for x = g2]
  ss = [map_word(r, g) for r = R]

  @assert all(x->isone(x.g), ss)
  s, ms = sub(_module(P), [x.m for x = ss])
  return is_surjective(ms)
end

@doc raw"""
    sub(G::Oscar.GAPGroup, U::Oscar.GAPGroup, g::Oscar.GAPGroupElem) -> GAPGroup, Map

Computes the subgroup of `G` generated by `U` and `g`.
"""
function Oscar.sub(G::Oscar.GAPGroup, U::Oscar.GAPGroup, g::Oscar.GAPGroupElem)
  H = GAP.Globals.ClosureGroup(U.X, g.X)
  return Oscar._as_subgroup(G, H)
end

function commutator_decomposition_map(G::Oscar.GAPGroup)
  return commutator_decomposition_map(derived_subgroup(G)[2])
end

@doc raw"""
    commutator_decomposition_map(md::Map{<:Oscar.GAPGroup, <:Oscar.GAPGroup})
  
Given
```G' \to G```
compute a map 
```\phi: G' \to F```
into the free group on the number of generators of ``G``, such that the
image is composed of commutators and conjugates only.
"""
function commutator_decomposition_map(md::Map{<:Oscar.GAPGroup, <:Oscar.GAPGroup})
  d = domain(md)
  G = codomain(md)
  g = gens(G)
  F = free_group(length(g))
  s = elem_type(G)[]
  t = elem_type(F)[]
  u, mu = sub(G, [one(G)])
  for i=1:ngens(G), j=i+1:ngens(G)
    gij = comm(G[i], G[j])
    if is_one(gij) || gij in s || gij in u
      continue
    end
    push!(s, gij)
    push!(t, comm(F[i], F[j]))
    u, mu = sub(G, u, gij)
    if order(u) == order(d)
      break
    end
  end
  
  j = 1
  while order(u) < order(d)
    n = length(s)
    for i=j:n, h = 1:ngens(G)
      hg = s[i]^g[h]
      if hg in s || hg in u
        continue
      end
      push!(s, hg)
      push!(t, t[i]^F[h])
      u, mu = sub(G, u, hg)
      if order(u) == order(d)
        break
      end
    end
    j = n
  end
  h = hom(free_group(length(s)), u, s)

  return MapFromFunc(d, F, x->map_word(preimage(h, x), t))
end  
    
Oscar.copy(g::GrpExtElem) = GrpExtElem(g.P, g.g, g.m)

end #module

using .GrpExt_module

export commutator_decomposition_map
