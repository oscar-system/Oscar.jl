export has_canonical_singularities
export has_terminal_singularities
export linear_quotient

@doc raw"""
    linear_quotient(G::MatrixGroup)

Return the linear quotient by `G`, that is, the orbit space of the action of `G`
on the vector space of dimension `degree(G)`.

If the given group is not finite, an error is raised.
"""
function linear_quotient(G::MatrixGroup)
  @req is_finite(G) "The group must be finite"
  return LinearQuotient(G)
end

function show(io::IO, L::LinearQuotient)
  io = pretty(io)
  print(io, "Linear quotient by ", Lowercase(), group(L))
end

group(L::LinearQuotient) = L.group
base_ring(L::LinearQuotient) = base_ring(group(L))
base_ring_type(::Type{LinearQuotient{S,T}}) where {S,T} = base_ring_type(MatrixGroup{S,T})

function fixed_root_of_unity(L::LinearQuotient)
  if isdefined(L, :root_of_unity)
    return L.root_of_unity
  end

  e = exponent(Int, group(L))
  K = base_ring(L)
  if is_one(e)
    L.root_of_unity = (one(K), e)
  elseif e == 2
    L.root_of_unity = (K(-1), e)
  else
    K isa AbsSimpleNumField || throw(Hecke.NotImplemented())
    fl, l = Hecke.is_cyclotomic_type(K)
    fl || throw(Hecke.NotImplemented())
    if is_odd(l)
      ll = 2l
    else
      ll = l
    end
    fl, q = divides(ll, e)
    fl || error("$(base_ring(L)) does not contain a $(e)-th root of unity")
    if is_odd(l)
      zeta = (-gen(K))^q
    else
      zeta = gen(K)^q
    end
    L.root_of_unity = (zeta, e)
  end
  return L.root_of_unity
end

################################################################################
#
#  Class group
#
################################################################################

@doc raw"""
    class_group(L::LinearQuotient)

Return the class group of the linear quotient `L` and a map from `group(L)` to
this group.

If `G = group(L)`, then the class group is `Ab(G/H)`, where `H` is the subgroup
of `G` generated by the pseudo-reflections.
"""
function class_group(L::LinearQuotient)
  if isdefined(L, :class_group)
    return L.class_group
  end

  G = group(L)
  H, _ = subgroup_of_pseudo_reflections(G)
  if !is_trivial(H)
    K, GtoK = quo(G, H)
  else
    K = G
  end
  A, KtoA = maximal_abelian_quotient(FinGenAbGroup, K)
  snfA, snfAtoA = snf(A)
  A = snfA
  KtoA = compose(KtoA, inv(snfAtoA))
  if !is_trivial(H)
    # TODO: this is an insane concatenation of maps and many of them might be identities.
    # Can we have Hecke.compose_and_squash for groups?
    GtoA = compose(GtoK, KtoA)
  else
    GtoA = KtoA
  end
  L.class_group = A, GtoA
  return L.class_group
end

################################################################################
#
#  Age, junior elements, monomial valuation
#
################################################################################

@doc raw"""
    age(g::MatrixGroupElem, zeta::Tuple{FieldElem, Int})

Return the age of `g` with respect to the chosen root of unity `zeta[1]` of order
`zeta[2]`.
If `zeta[2]` is not divisible by `order(g)` an error is raised.

Note that `age(g)` depends on the choice of the root of unity, see [IR96](@cite).
"""
function age(g::MatrixGroupElem{T}, zeta::Tuple{T,Int}) where {T}
  fl, q = divides(zeta[2], order(Int, g))
  @req fl "Order $(zeta[2]) of given root of unity $(zeta[1]) is not divisible by $(order(g))"

  powers_of_zeta = _powers_of_root_of_unity(zeta[1]^q, order(Int, g))
  eig = eigenvalues_with_multiplicities(matrix(g))
  return ZZRingElem(sum(m * powers_of_zeta[e] for (e, m) in eig))//order(g)
end

@doc raw"""
    representatives_of_junior_elements(G::MatrixGroup, zeta::Tuple{FieldElem, Int})

Return representatives of the conjugacy classes of `G` which consist of junior
elements, that is, elements `g` in `G` with `age(g, zeta) == 1`.
"""
function representatives_of_junior_elements(G::MatrixGroup{T}, zeta::Tuple{T,Int}) where {T}
  @req is_subgroup_of_sl(G) "Group is not a subgroup of SL"
  return filter!(g -> is_one(age(g, zeta)), map(representative, conjugacy_classes(G)))
end

# Let R = K[x_1, ..., x_n] with a linear action by g. The element g acts on V = K^n
# and in an eigenbasis this action is given by powers of a root of unity.
# This functions returns an automorphism of R into an eigenbasis of g.
# Additionally, the codomain of this automorphism is graded by the weights of the
# action.
function weights_of_action(
  R::MPolyRing{T}, g::MatrixGroupElem{T}, zeta::Tuple{T,Int}
) where {T}
  @req ngens(R) == degree(parent(g)) "Number of variables must match degree of the matrix"
  fl, q = divides(zeta[2], order(Int, g))
  @req fl "Order $(zeta[2]) of given root of unity $(zeta[1]) is not divisible by $(order(g))"

  zetaq = zeta[1]^q
  powers_of_zeta = _powers_of_root_of_unity(zetaq, order(Int, g))

  K = coefficient_ring(R)
  eig = eigenspaces(matrix(g); side=:left)

  weights = Int[]
  V = zero_matrix(K, 0, ncols(matrix(g)))
  for (e, v) in eig
    for i in 1:nrows(v)
      push!(weights, powers_of_zeta[e])
    end
    V = vcat(V, v)
  end

  to_eig = right_action(R, inv(V))
  S, t = graded_polynomial_ring(K, "t#" => 1:ngens(R); weights=weights)
  # The images of the generators of R are in general not homogeneous in S, so
  # we have to turn of the check, if we want to build this map...
  RtoS = hom(R, S, [to_eig(x)(t...) for x in gens(R)]; check=false)

  return S, RtoS
end

@doc raw"""
    monomial_valuation(R::MPolyRing, g::MatrixGroupElem, zeta::Tuple{FieldElem, Int})

Return the monomial valuation on `R` defined by `g` with respect to the chosen
root of unity `zeta[1]` of order `zeta[2]`.
If `zeta[2]` is not divisible by `order(g)` or if the valuation would not be
surjective with this choice of root of unity, an error is raised.

Note that monomial valuation depends on the choice of the root of unity, see
[IR96](@cite).
"""
function monomial_valuation(
  R::MPolyRing{T}, g::MatrixGroupElem{T}, zeta::Tuple{T,Int}
) where {T}
  S, RtoS = weights_of_action(R, g, zeta)

  # If the weights are not coprime, the valuation is not surjective...
  @assert is_one(gcd([degree(gen(S, i))[1] for i in 1:ngens(S)])) "Construction of well-defined valuation impossible with given choice of root of unity"

  function val(f::MPolyRingElem{T})
    # TODO: Do we have a type-stable concept of infinity in OSCAR?
    @req !is_zero(f) "Valuation is infinite"

    h = RtoS(f)
    mons = ZZRingElem[]
    for e in AbstractAlgebra.monomials(h)
      push!(mons, degree(e)[1])
    end
    return minimum(mons)
  end

  return MapFromFunc(R, ZZ, val)
end

################################################################################
#
#  Singularities
#
################################################################################

@doc raw"""
    has_canonical_singularities(L::LinearQuotient)

Return `true` if `L` has canonical singularities, `false` otherwise.

This is checked using the Reid--Tai criterion, see Theorem 3.21 in [Kol13](@cite).
"""
function has_canonical_singularities(L::LinearQuotient)
  zeta = fixed_root_of_unity(L)
  cc = conjugacy_classes(group(L))
  return all(c -> is_one(representative(c)) || age(representative(c), zeta) >= 1, cc)
end

@doc raw"""
    has_terminal_singularities(L::LinearQuotient)

Return `true` if `L` has terminal singularities, `false` otherwise.

This is checked using the Reid--Tai criterion, see Theorem 3.21 in [Kol13](@cite).
"""
function has_terminal_singularities(L::LinearQuotient)
  zeta = fixed_root_of_unity(L)
  cc = conjugacy_classes(group(L))
  return all(c -> is_one(representative(c)) || age(representative(c), zeta) > 1, cc)
end
