mutable struct LinearQuotient{S, T}
  group::MatrixGroup{S, T}

  # We fix a primitive e-th root of unity, where e is the exponent of the group
  # for consistency
  root_of_unity::Tuple{S, Int}

  class_group::Tuple{FinGenAbGroup, Generic.CompositeMap{MatrixGroup{S, T}, FinGenAbGroup}}

  function LinearQuotient(G::MatrixGroup{S, T}) where {S, T}
    L = new{S, T}()
    L.group = G
    return L
  end
end

# Helper object for the computation of Cox rings.
# See function `homogeneous_generators(::HomBasisBuilder)`.
mutable struct HomBasisBuilder{RingType, RingElemType}
  R::RingType # Base ring

  # We work with a subalgebra A of R generated by power_base(C)
  C::PowerProductCache{RingType, RingElemType}

  # Group acting linearly on the subalgebra A via action
  G::FinGenAbGroup
  action::Function
  eigenvalues_to_group::Function

  # Polynomial ring in length(power_base(C)) variables
  T::RingType

  # The homogeneous generators of A represented as elements of T, so
  # hom_gens[i](power_base(C)...) gives the actual element in R
  hom_gens::Vector{RingElemType}
  degrees::Vector{FinGenAbGroupElem}

  power_base_to_hom_gens::Dict{RingElemType, RingElemType}

  function HomBasisBuilder(C::PowerProductCache{RingType, RingElemType}, G::FinGenAbGroup, action::Function, eigenvalues_to_group::Function) where {RingType, RingElemType}
    R = base_ring(C)
    T, _ = polynomial_ring(coefficient_ring(R), "t" => 1:length(power_base(C)))
    hom_gens = elem_type(T)[]
    degrees = elem_type(G)[]
    power_base_to_hom_gens = Dict{elem_type(R), elem_type(T)}()

    return new{RingType, RingElemType}(R, C, G, action, eigenvalues_to_group, T, hom_gens, degrees, power_base_to_hom_gens)
  end
end
