mutable struct LinearQuotient{S,T}
  group::MatrixGroup{S,T}

  # We fix a primitive e-th root of unity, where e is the exponent of the group
  # for consistency
  root_of_unity::Tuple{S,Int}

  class_group::Tuple{FinGenAbGroup,Generic.CompositeMap{MatrixGroup{S,T},FinGenAbGroup}}

  function LinearQuotient(G::MatrixGroup{S,T}) where {S,T}
    L = new{S,T}()
    L.group = G
    return L
  end
end

# Helper object for the computation of Cox rings.
# See function `homogeneous_generators(::HomBasisBuilder)`.
mutable struct HomBasisBuilder{RingType,RingElemType}
  R::RingType # Base ring

  # We work with a subalgebra A of R generated by power_base(C)
  C::PowerProductCache{RingType,RingElemType}

  # Group acting linearly on the subalgebra A via action
  G::FinGenAbGroup
  action::Function
  eigenvalues_to_group::Function

  # Polynomial ring in length(power_base(C)) variables
  T::RingType

  # The homogeneous generators of A represented as elements of T, so
  # hom_gens[i](power_base(C)...) gives the actual element in R
  hom_gens::Vector{RingElemType}
  degrees::Vector{FinGenAbGroupElem}

  power_base_to_hom_gens::Dict{RingElemType,RingElemType}

  function HomBasisBuilder(
    C::PowerProductCache{RingType,RingElemType},
    G::FinGenAbGroup,
    action::Function,
    eigenvalues_to_group::Function,
  ) where {RingType,RingElemType}
    R = base_ring(C)
    T, _ = polynomial_ring(coefficient_ring(R), :t => 1:length(power_base(C)))
    hom_gens = elem_type(T)[]
    degrees = elem_type(G)[]
    power_base_to_hom_gens = Dict{elem_type(R),elem_type(T)}()

    return new{RingType,RingElemType}(
      R, C, G, action, eigenvalues_to_group, T, hom_gens, degrees, power_base_to_hom_gens
    )
  end
end
