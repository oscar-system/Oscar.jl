export linear_quotient

@doc Markdown.doc"""
    linear_quotient(G::MatrixGroup)

Return the linear quotient by `G`, that is, the orbit space of the action of `G`
on the vector space of dimension `degree(G)`.

If the given group is not finite, an error is raised.
"""
function linear_quotient(G::MatrixGroup)
  @assert isfinite(G)
  return LinearQuotient(G)
end

function show(io::IO, L::LinearQuotient)
  print(io, "Linear quotient by $(group(L))")
end

group(L::LinearQuotient) = L.group
base_ring(L::LinearQuotient) = base_ring(group(L))

function fixed_root_of_unity(L::LinearQuotient)
  if isdefined(L, :root_of_unity)
    return L.root_of_unity
  end

  e = exponent(Int, group(L))
  K = base_ring(L)
  if is_one(e)
    L.root_of_unity = (one(K), e)
  elseif e == 2
    L.root_of_unity = (K(-1), e)
  else
    K isa AnticNumberField || throw(Hecke.NotImplemented())
    fl, l = Hecke.is_cyclotomic_type(K)
    fl || throw(Hecke.NotImplemented())
    fl, q = divides(l, e)
    fl || error("$(base_ring(L)) does not contain a $(e)-th root of unity")
    L.root_of_unity = (gen(K)^q, e)
  end
  return L.root_of_unity
end

@doc Markdown.doc"""
    class_group(L::LinearQuotient)

Return the class group of the linear quotient `L` and a map from `group(L)` to
this group.

If `G = group(L)`, then the class group is `Ab(G/H)`, where `H` is the subgroup
of `G` generated by the reflections.
"""
function class_group(L::LinearQuotient)
  if isdefined(L, :class_group)
    return L.class_group
  end

  G = group(L)
  H = subgroup_of_reflections(G)
  if !is_trivial(H)
    K, GtoK = quo(G, H)
  else
    K = G
  end
  A, KtoA = maximal_abelian_quotient(GrpAbFinGen, K)
  snfA, snfAtoA = snf(A)
  A = snfA
  KtoA = compose(KtoA, inv(snfAtoA))
  if !is_trivial(H)
  # TODO: this is an insane concatenation of maps and many of them might be identities.
  # Can we have Hecke.compose_and_squash for groups?
    GtoA = compose(GtoK, KtoA)
  else
    GtoA = KtoA
  end
  L.class_group = A, GtoA
  return L.class_group
end
