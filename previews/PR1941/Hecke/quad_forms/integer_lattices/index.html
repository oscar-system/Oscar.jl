<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integer Lattices ¬∑ Oscar.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Oscar.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><a class="tocitem" href="../basics/">Spaces</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li><li><a class="tocitem" href="../genusherm/">Genera for hermitian lattices</a></li><li class="is-active"><a class="tocitem" href>Integer Lattices</a><ul class="internal"><li><a class="tocitem" href="#Creation-of-integer-lattices"><span>Creation of integer lattices</span></a></li><li><a class="tocitem" href="#Attributes"><span>Attributes</span></a></li><li><a class="tocitem" href="#Invariants"><span>Invariants</span></a></li><li><a class="tocitem" href="#Isometries"><span>Isometries</span></a></li><li class="toplevel"><a class="tocitem" href="#Root-lattices"><span>Root lattices</span></a></li><li><a class="tocitem" href="#Module-operations"><span>Module operations</span></a></li><li><a class="tocitem" href="#Embeddings"><span>Embeddings</span></a></li><li><a class="tocitem" href="#LLL,-Short-and-Close-Vectors"><span>LLL, Short and Close Vectors</span></a></li></ul></li><li><a class="tocitem" href="../Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../orders/orders/">Orders</a></li><li><a class="tocitem" href="../../orders/elements/">Elements</a></li><li><a class="tocitem" href="../../orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../../Experimental/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/visualization/">Visualization</a></li></ul></li><li><a class="tocitem" href="../../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/homological_algebra/">Homological Algebra</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">Gr√∂bner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/groebner_bases/">Gr√∂bner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/groebner_bases_integers/">Gr√∂bner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../../ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../../ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../../ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../../ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../../ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../../ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../../ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../../ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../../ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../../ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../../TropicalGeometry/curve/">Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Standard Constructions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/StandardConstructions/standard_constructions/">Standard Constructions in Algebraic Geometry</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/K3Surfaces/">Algebraic Surfaces</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Finitely Presented Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../../references/">References</a></li><li><a class="tocitem" href="../../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-7" type="checkbox"/><label class="tocitem" for="menuitem-17-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Linear Algebra</a></li><li><a class="is-disabled">Quadratic and Hermitian forms</a></li><li class="is-active"><a href>Integer Lattices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Integer Lattices</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/Hecke/quad_forms/integer_lattices.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Integer-Lattices"><a class="docs-heading-anchor" href="#Integer-Lattices">Integer Lattices</a><a id="Integer-Lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Integer-Lattices" title="Permalink"></a></h1><p>An integer lattice <span>$L$</span> is a finitely generated <span>$\mathbb{Z}$</span>-submodule of a quadratic vector space <span>$V = \mathbb{Q}^n$</span> over the rational numbers. Integer lattices are also known as quadratic forms over the integers. We will refer to them as <span>$\mathbb{Z}$</span>-lattices.</p><p>A <span>$\mathbb{Z}$</span>-lattice <span>$L$</span> has the type <code>ZLat</code>. It is given in terms of its ambient quadratic space <span>$V$</span> together with a basis matrix <span>$B$</span> whose rows span <span>$L$</span>, i.e. <span>$L = \mathbb{Z}^r B$</span> where <span>$r$</span> is the (<span>$\mathbb{Z}$</span>-module) rank of <span>$L$</span>.</p><p>To access <span>$V$</span> and <span>$B$</span> see <a href="#ambient_space-Tuple{ZLat}"><code>ambient_space(L::ZLat)</code></a> and <a href="#basis_matrix-Tuple{ZLat}"><code>basis_matrix(L::ZLat)</code></a>.</p><h2 id="Creation-of-integer-lattices"><a class="docs-heading-anchor" href="#Creation-of-integer-lattices">Creation of integer lattices</a><a id="Creation-of-integer-lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Creation-of-integer-lattices" title="Permalink"></a></h2><h3 id="From-a-gram-matrix"><a class="docs-heading-anchor" href="#From-a-gram-matrix">From a gram matrix</a><a id="From-a-gram-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#From-a-gram-matrix" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Zlattice-Tuple{fmpq_mat}" href="#Zlattice-Tuple{fmpq_mat}"><code>Zlattice</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Zlattice([B::MatElem]; gram) -&gt; ZLat</code></pre><p>Return the Z-lattice with basis matrix <span>$B$</span> inside the quadratic space with Gram matrix <code>gram</code>.</p><p>If the keyword <code>gram</code> is not specified, the Gram matrix is the identity matrix. If <span>$B$</span> is not specified, the basis matrix is the identity matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = Zlattice(matrix(QQ, 2, 2, [1//2, 0, 0, 2]));

julia&gt; gram_matrix(L) == matrix(QQ, 2, 2, [1//4, 0, 0, 4])
true

julia&gt; L = Zlattice(gram = matrix(ZZ, [2 -1; -1 2]));

julia&gt; gram_matrix(L) == matrix(ZZ, [2 -1; -1 2])
true</code></pre></div></section></article><h3 id="In-a-quadratic-space"><a class="docs-heading-anchor" href="#In-a-quadratic-space">In a quadratic space</a><a id="In-a-quadratic-space-1"></a><a class="docs-heading-anchor-permalink" href="#In-a-quadratic-space" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="lattice-Tuple{Hecke.QuadSpace{FlintRationalField, fmpq_mat}, MatElem}" href="#lattice-Tuple{Hecke.QuadSpace{FlintRationalField, fmpq_mat}, MatElem}"><code>lattice</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice(V::AbsSpace, basis::MatElem ; check::Bool = true) -&gt; AbsLat</code></pre><p>Given an ambient space <code>V</code> and a matrix <code>basis</code>, return the lattice spanned by the rows of <code>basis</code> inside <code>V</code>. If <code>V</code> is hermitian (resp. quadratic) then the output is a hermitian (resp. quadratic) lattice.</p><p>By default, <code>basis</code> is checked to be of full rank. This test can be disabled by setting <code>check</code> to false.</p></div></section></article><h3 id="Special-lattices"><a class="docs-heading-anchor" href="#Special-lattices">Special lattices</a><a id="Special-lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Special-lattices" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="root_lattice-Tuple{Symbol, Int64}" href="#root_lattice-Tuple{Symbol, Int64}"><code>root_lattice</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">root_lattice(R::Symbol, n::Int)</code></pre><p>Return the root lattice of type <code>R</code> given by <code>:A</code>, <code>:D</code> or <code>:E</code> with parameter <code>n</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="hyperbolic_plane_lattice-Tuple{Union{Int64, fmpz}}" href="#hyperbolic_plane_lattice-Tuple{Union{Int64, fmpz}}"><code>hyperbolic_plane_lattice</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hyperbolic_plane_lattice(n::RationalUnion = 1)</code></pre><p>Return the hyperbolic plane with intersection form of scale <code>n</code>, that is, the unique (up to isometry) even unimodular hyperbolic <span>$\mathbb Z$</span>-lattice of rank 2, rescaled by <code>n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = hyperbolic_plane_lattice(6);

julia&gt; gram_matrix(L)
[0   6]
[6   0]

julia&gt; L = hyperbolic_plane_lattice(ZZ(-13));

julia&gt; gram_matrix(L)
[  0   -13]
[-13     0]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Zlattice-Tuple{Symbol, Union{Int64, fmpz}}" href="#Zlattice-Tuple{Symbol, Union{Int64, fmpz}}"><code>Zlattice</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Zlattice(S::Symbol, n::RationalUnion = 1) -&gt; Zlat</code></pre><p>Given <code>S = :H</code> or <code>S = :U</code>, return a <span>$\mathbb Z$</span>-lattice admitting <span>$n*J_2$</span> as Gram matrix in some basis, where <span>$J_2$</span> is the 2-by-2 matrix with 0&#39;s on the main diagonal and 1&#39;s elsewhere.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="leech_lattice" href="#leech_lattice"><code>leech_lattice</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leech_lattice()</code></pre><p>Return the Leech lattice.</p></div></section><section><div><pre><code class="nohighlight hljs">leech_lattice(niemeier_lattice::ZLat) -&gt; Leech, neighbor vector, index</code></pre><p>Return a triple <code>L, v, h</code> where <code>L</code> is the Leech lattice.</p><p>L is an <code>h</code>-neighbor of the Niemeier lattice <code>N</code> with respect to <code>v</code>. This means that <code>L / L ‚à© N  ‚âÖ ‚Ñ§ / h ‚Ñ§</code>. Here <code>h</code> is the Coxeter number of the Niemeier lattice.</p><p>This implements the 23 holy constructions of the Leech lattice in <a href="../../../references/#CS99">J. H. Conway, N. J. A. Sloane (1999)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R = Zlattice(gram=2 * identity_matrix(ZZ, 24));

julia&gt; N = maximal_even_lattice(R) # Some Niemeier lattice
Quadratic lattice of rank 24 and degree 24 over the rationals

julia&gt; minimum(N)
2

julia&gt; det(N)
1

julia&gt; L, v, h = leech_lattice(N);

julia&gt; minimum(L)
4

julia&gt; det(L)
1

julia&gt; h == index(L, intersect(L, N))
true
</code></pre><p>We illustrate how the Leech lattice is constructed from <code>N</code>, <code>h</code> and <code>v</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; Zmodh = ResidueRing(ZZ, h);

julia&gt; V = ambient_space(N);

julia&gt; vG = map_entries(x-&gt;Zmodh(ZZ(x)), inner_product(V, v, basis_matrix(N)));

julia&gt; LN = transpose(lift(kernel(vG)[2]))*basis_matrix(N); # vectors whose inner product with `v` is divisible by `h`.

julia&gt; lattice(V, LN) == intersect(L, N)
true

julia&gt; gensL = vcat(LN, 1//h * v);

julia&gt; lattice(V, gensL, isbasis=false) == L
true
</code></pre></div></section></article><h3 id="From-a-genus"><a class="docs-heading-anchor" href="#From-a-genus">From a genus</a><a id="From-a-genus-1"></a><a class="docs-heading-anchor-permalink" href="#From-a-genus" title="Permalink"></a></h3><p>Integer lattices can be created as representatives of a genus. See (<a href="../Zgenera/#representative-Tuple{ZGenus}"><code>representative(L::ZGenus)</code></a>)</p><h3 id="Rescaling-the-Quadratic-Form"><a class="docs-heading-anchor" href="#Rescaling-the-Quadratic-Form">Rescaling the Quadratic Form</a><a id="Rescaling-the-Quadratic-Form-1"></a><a class="docs-heading-anchor-permalink" href="#Rescaling-the-Quadratic-Form" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="rescale-Tuple{ZLat, Union{Integer, fmpq, fmpz, Rational{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Integer}}" href="#rescale-Tuple{ZLat, Union{Integer, fmpq, fmpz, Rational{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Integer}}"><code>rescale</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(L::ZLat, r::RationalUnion) -&gt; ZLat</code></pre><p>Return the lattice <code>L</code> in the quadratic space with form <code>r \Phi</code>.</p><p><strong>Examples</strong></p><p>This can be useful to apply methods intended for positive definite lattices.</p><pre><code class="language-julia-repl hljs">julia&gt; L = Zlattice(gram=ZZ[-1 0; 0 -1])
Quadratic lattice of rank 2 and degree 2 over the rationals

julia&gt; shortest_vectors(rescale(L, -1))
2-element Vector{Vector{fmpz}}:
 [0, 1]
 [1, 0]</code></pre></div></section></article><h2 id="Attributes"><a class="docs-heading-anchor" href="#Attributes">Attributes</a><a id="Attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Attributes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ambient_space-Tuple{ZLat}" href="#ambient_space-Tuple{ZLat}"><code>ambient_space</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ambient_space(L::AbsLat) -&gt; AbsSpace</code></pre><p>Return the ambient space of the lattice <code>L</code>. If the ambient space is not known, an error is raised.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="basis_matrix-Tuple{ZLat}" href="#basis_matrix-Tuple{ZLat}"><code>basis_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis_matrix(L::ZLat)</code></pre><p>Return the basis matrix <span>$B$</span> of the integer lattice <span>$L$</span>.</p><p>The lattice is given by the row span of <span>$B$</span> seen inside of the ambient quadratic space of <span>$L$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="gram_matrix-Tuple{ZLat}" href="#gram_matrix-Tuple{ZLat}"><code>gram_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gram_matrix(L::ZLat) -&gt; fmpq_mat</code></pre><p>Return the gram matrix of <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = Zlattice(matrix(ZZ, [2 0; -1 2]));

julia&gt; gram_matrix(L)
[ 4   -2]
[-2    5]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rational_span-Tuple{ZLat}" href="#rational_span-Tuple{ZLat}"><code>rational_span</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rational_span(L::ZLat) -&gt; QuadSpace</code></pre><p>Return the rational span of <span>$L$</span>, which is the quadratic space with Gram matrix equal to <code>gram_matrix(L)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = Zlattice(matrix(ZZ, [2 0; -1 2]));

julia&gt; rational_span(L)
Quadratic space over
Rational Field
with Gram matrix
[4 -2; -2 5]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="base_ring-Tuple{ZLat}" href="#base_ring-Tuple{ZLat}"><code>base_ring</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">base_ring(I::MPolyIdeal)</code></pre><p>Return the ambient ring of <code>I</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])

julia&gt; I = ideal(R, [x, y])^2
ideal(x^2, x*y, y^2)

julia&gt; base_ring(I)
Multivariate Polynomial Ring in x, y over Rational Field</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/09b8032955092fc1f2fc5b92c43e6a78445f4171/src/Rings/mpoly-ideals.jl#L1045">source</a></section><section><div><pre><code class="nohighlight hljs">base_ring(X::AbsSpec)</code></pre><p>On an affine scheme <span>$X/ùïú$</span> over <span>$ùïú$</span> this returns the ring <span>$ùïú$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = affine_space(QQ,3)
Spec of Multivariate Polynomial Ring in x1, x2, x3 over Rational Field

julia&gt; base_ring(X)
Rational Field</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/09b8032955092fc1f2fc5b92c43e6a78445f4171/src/Schemes/AffineSchemes/Objects/Attributes.jl#L269-L282">source</a></section><section><div><pre><code class="nohighlight hljs">base_ring(M::PMat)</code></pre><p>The <code>PMat</code> <span>$M$</span> defines an <span>$R$</span>-module for some maximal order <span>$R$</span>. This function returns the <span>$R$</span> that was used to defined <span>$M$</span>.</p></div></section><section><div><pre><code class="language-julia hljs">base_ring(L::AbsLat) -&gt; Ring</code></pre><p>Return the order over which the lattice <code>L</code> is defined.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="base_field-Tuple{ZLat}" href="#base_field-Tuple{ZLat}"><code>base_field</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">base_field(E::EllCrv) -&gt; Field</code></pre><p>Return the base field over which <code>E</code> is defined.</p></div></section><section><div><pre><code class="nohighlight hljs">base_field(C::HypellCrv) -&gt; Field</code></pre><p>Return the base field over which <code>C</code> is defined.</p></div></section><section><div><pre><code class="language-julia hljs">base_field(L::AbsLat) -&gt; Field</code></pre><p>Return the algebra over which the rational span of the lattice <code>L</code> is defined.</p></div></section></article><h2 id="Invariants"><a class="docs-heading-anchor" href="#Invariants">Invariants</a><a id="Invariants-1"></a><a class="docs-heading-anchor-permalink" href="#Invariants" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="rank-Tuple{ZLat}" href="#rank-Tuple{ZLat}"><code>rank</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rank(L::AbsLat) -&gt; Int</code></pre><p>Return the rank of the underlying module of the lattice <code>L</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="det-Tuple{ZLat}" href="#det-Tuple{ZLat}"><code>det</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">det(L::ZLat) -&gt; fmpq</code></pre><p>Return the determinant of the gram matrix of <code>L</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="scale-Tuple{ZLat}" href="#scale-Tuple{ZLat}"><code>scale</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale(L::ZLat) -&gt; fmpq</code></pre><p>Return the scale of <code>L</code>.</p><p>The scale of <code>L</code> is defined as the positive generator of the <span>$\mathbb Z$</span>-ideal generated by <span>$\{\Phi(x, y) : x, y \in L\}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="norm-Tuple{ZLat}" href="#norm-Tuple{ZLat}"><code>norm</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(L::ZLat) -&gt; fmpq</code></pre><p>Return the norm of <code>L</code>.</p><p>The norm of <code>L</code> is defined as the positive generator of the <span>$\mathbb Z$</span>- ideal generated by <span>$\{\Phi(x,x) : x \in L\}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="iseven-Tuple{ZLat}" href="#iseven-Tuple{ZLat}"><code>iseven</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iseven(L::ZLat) -&gt; Bool</code></pre><p>Return whether <code>L</code> is even.</p><p>An integer lattice <code>L</code> in the rational quadratic space <span>$(V,\Phi)$</span> is called even if <span>$\Phi(x,x) \in 2\mathbb{Z}$</span> for all <span>$x in L$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_integral-Tuple{ZLat}" href="#is_integral-Tuple{ZLat}"><code>is_integral</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_integral(L::AbsLat) -&gt; Bool</code></pre><p>Return whether the lattice <code>L</code> is integral.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_primary_with_prime-Tuple{ZLat}" href="#is_primary_with_prime-Tuple{ZLat}"><code>is_primary_with_prime</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_primary_with_prime(L::ZLat) -&gt; Bool, fmpz</code></pre><p>Given a <span>$\mathbb Z$</span>-lattice <code>L</code>, return whether <code>L</code> is primary, that is whether <code>L</code> is integral and its discriminant group (see <a href="../discriminant_group/#discriminant_group-Tuple{ZLat}"><code>discriminant_group</code></a>) is a <code>p</code>-group for some prime number <code>p</code>. In case it is, <code>p</code> is also returned as second output.</p><p>Note that for unimodular lattices, this function returns <code>(true, 1)</code>. If the lattice is not primary, the second return value is <code>-1</code> by default.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_primary-Tuple{ZLat, Union{Integer, fmpz}}" href="#is_primary-Tuple{ZLat, Union{Integer, fmpz}}"><code>is_primary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_primary(L::ZLat, p::Union{Integer, fmpz}) -&gt; Bool</code></pre><p>Given an integral <span>$\mathbb Z$</span>-lattice <code>L</code> and a prime number <code>p</code>, return whether <code>L</code> is <code>p</code>-primary, that is whether its discriminant group (see <a href="../discriminant_group/#discriminant_group-Tuple{ZLat}"><code>discriminant_group</code></a>) is a <code>p</code>-group.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_elementary_with_prime-Tuple{ZLat}" href="#is_elementary_with_prime-Tuple{ZLat}"><code>is_elementary_with_prime</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_elementary_with_prime(L::ZLat) -&gt; Bool, fmpz</code></pre><p>Given a <span>$\mathbb Z$</span>-lattice <code>L</code>, return whether <code>L</code> is elementary, that is whether <code>L</code> is integral and its discriminant group (see <a href="../discriminant_group/#discriminant_group-Tuple{ZLat}"><code>discriminant_group</code></a>) is an elemenentary <code>p</code>-group for some prime number <code>p</code>. In case it is, <code>p</code> is also returned as second output.</p><p>Note that for unimodular lattices, this function returns <code>(true, 1)</code>. If the lattice is not elementary, the second return value is <code>-1</code> by default.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_elementary-Tuple{ZLat, Union{Integer, fmpz}}" href="#is_elementary-Tuple{ZLat, Union{Integer, fmpz}}"><code>is_elementary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_elementary(L::ZLat, p::Union{Integer, fmpz}) -&gt; Bool</code></pre><p>Given an integral <span>$\mathbb Z$</span>-lattice <code>L</code> and a prime number <code>p</code>, return whether <code>L</code> is <code>p</code>-elementary, that is whether its discriminant group (see <a href="../discriminant_group/#discriminant_group-Tuple{ZLat}"><code>discriminant_group</code></a>) is an elementary <code>p</code>-group.</p></div></section></article><h3 id="The-Genus"><a class="docs-heading-anchor" href="#The-Genus">The Genus</a><a id="The-Genus-1"></a><a class="docs-heading-anchor-permalink" href="#The-Genus" title="Permalink"></a></h3><p>For an integral lattice The genus of an integer lattice collects its local invariants. <a href="../Zgenera/#genus-Tuple{ZLat}"><code>genus(::ZLat)</code></a></p><article class="docstring"><header><a class="docstring-binding" id="mass-Tuple{ZLat}" href="#mass-Tuple{ZLat}"><code>mass</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mass(L::ZLat) -&gt; fmpq</code></pre><p>Return the mass of the genus of <code>L</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="genus_representatives-Tuple{ZLat}" href="#genus_representatives-Tuple{ZLat}"><code>genus_representatives</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genus_representatives(L::ZLat) -&gt; Vector{ZLat}</code></pre><p>Return representatives for the isometry classes in the genus of <code>L</code>.</p></div></section></article><h3 id="Real-invariants"><a class="docs-heading-anchor" href="#Real-invariants">Real invariants</a><a id="Real-invariants-1"></a><a class="docs-heading-anchor-permalink" href="#Real-invariants" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="signature_tuple-Tuple{ZLat}" href="#signature_tuple-Tuple{ZLat}"><code>signature_tuple</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signature_tuple(L::ZLat) -&gt; Tuple{Int,Int,Int}</code></pre><p>Return the number of (positive, zero, negative) inertia of <code>L</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_positive_definite-Tuple{ZLat}" href="#is_positive_definite-Tuple{ZLat}"><code>is_positive_definite</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_positive_definite(L::AbsLat) -&gt; Bool</code></pre><p>Return whether the rational span of the lattice <code>L</code> is positive definite.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_negative_definite-Tuple{ZLat}" href="#is_negative_definite-Tuple{ZLat}"><code>is_negative_definite</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_negative_definite(L::AbsLat) -&gt; Bool</code></pre><p>Return whether the rational span of the lattice <code>L</code> is negative definite.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_definite-Tuple{ZLat}" href="#is_definite-Tuple{ZLat}"><code>is_definite</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_definite(L::AbsLat) -&gt; Bool</code></pre><p>Return whether the rational span of the lattice <code>L</code> is definite.</p></div></section></article><h2 id="Isometries"><a class="docs-heading-anchor" href="#Isometries">Isometries</a><a id="Isometries-1"></a><a class="docs-heading-anchor-permalink" href="#Isometries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="automorphism_group_generators-Tuple{ZLat}" href="#automorphism_group_generators-Tuple{ZLat}"><code>automorphism_group_generators</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">automorphism_group_generators(E::EllCrv) -&gt; Vector{EllCrvIso}</code></pre><p>Return generators of the automorphism group of <span>$E$</span>.</p></div></section><section><div><pre><code class="language-julia hljs">automorphism_group_generators(L::AbsLat; ambient_representation::Bool = true)
                                                      -&gt; Vector{MatElem}</code></pre><p>Given a definite lattice <code>L</code>, return generators for the automorphism group of <code>L</code>. If <code>ambient_representation == true</code> (the default), the transformations are represented with respect to the ambient space of <code>L</code>. Otherwise, the transformations are represented with respect to the (pseudo-)basis of <code>L</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="automorphism_group_order-Tuple{ZLat}" href="#automorphism_group_order-Tuple{ZLat}"><code>automorphism_group_order</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">automorphism_group_order(L::AbsLat) -&gt; Int</code></pre><p>Given a definite lattice <code>L</code>, return the order of the automorphism group of <code>L</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_isometric-Tuple{ZLat, ZLat}" href="#is_isometric-Tuple{ZLat, ZLat}"><code>is_isometric</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_isometric(L::AbsLat, M::AbsLat) -&gt; Bool</code></pre><p>Return whether the lattices <code>L</code> and <code>M</code> are isometric.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_locally_isometric-Tuple{ZLat, ZLat, Int64}" href="#is_locally_isometric-Tuple{ZLat, ZLat, Int64}"><code>is_locally_isometric</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_locally_isometric(L::ZLat, M::ZLat, p::Int) -&gt; Bool</code></pre><p>Return whether <code>L</code> and <code>M</code> are isometric over the <code>p</code>-adic integers.</p><p>i.e. whether <span>$L \otimes \Z_p \cong M\otimes \Z_p$</span>.</p></div></section></article><h1 id="Root-lattices"><a class="docs-heading-anchor" href="#Root-lattices">Root lattices</a><a id="Root-lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Root-lattices" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="root_lattice_recognition-Tuple{ZLat}" href="#root_lattice_recognition-Tuple{ZLat}"><code>root_lattice_recognition</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">root_lattice_recognition(L::ZLat)</code></pre><p>Return the ADE type of the root sublattice of <code>L</code>.</p><p>Input:</p><p><code>L</code> ‚Äì a definite and integral <span>$\mathbb{Z}$</span>-lattice.</p><p>Output:</p><p>Two lists, the first one conaining the ADE types and the second one the irreducible root sublattices.</p><p>For more recognizable gram matrices use <a href="#root_lattice_recognition_fundamental-Tuple{ZLat}"><code>root_lattice_recognition_fundamental</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = Zlattice(gram=ZZ[4  0 0  0 3  0 3  0;
                            0 16 8 12 2 12 6 10;
                            0  8 8  6 2  8 4  5;
                            0 12 6 10 2  9 5  8;
                            3  2 2  2 4  2 4  2;
                            0 12 8  9 2 12 6  9;
                            3  6 4  5 4  6 6  5;
                            0 10 5  8 2  9 5  8])
Quadratic lattice of rank 8 and degree 8 over the rationals

julia&gt; R = root_lattice_recognition(L)
([(:A, 1), (:D, 6)], ZLat[Quadratic lattice of rank 1 and degree 8 over the rationals, Quadratic lattice of rank 6 and degree 8 over the rationals])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="root_lattice_recognition_fundamental-Tuple{ZLat}" href="#root_lattice_recognition_fundamental-Tuple{ZLat}"><code>root_lattice_recognition_fundamental</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">root_lattice_recognition_fundamental(L::ZLat)</code></pre><p>Return the ADE type of the root sublattice of <code>L</code> as well as the corresponding irreducible root sublattices with basis given by a fundamental root system.</p><p>Input:</p><p><code>L</code> ‚Äì a definite and integral <span>$\mathbb Z$</span>-lattice.</p><p>Output:</p><ul><li>the root sublattice, with basis given by a fundamental root system</li><li>the ADE types</li><li>a Vector consisting of the irreducible root sublattices.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = Zlattice(gram=ZZ[4  0 0  0 3  0 3  0;
                            0 16 8 12 2 12 6 10;
                            0  8 8  6 2  8 4  5;
                            0 12 6 10 2  9 5  8;
                            3  2 2  2 4  2 4  2;
                            0 12 8  9 2 12 6  9;
                            3  6 4  5 4  6 6  5;
                            0 10 5  8 2  9 5  8])
Quadratic lattice of rank 8 and degree 8 over the rationals

julia&gt; R = root_lattice_recognition_fundamental(L);

julia&gt; gram_matrix(R[1])
[2    0    0    0    0    0    0]
[0    2    0   -1    0    0    0]
[0    0    2   -1    0    0    0]
[0   -1   -1    2   -1    0    0]
[0    0    0   -1    2   -1    0]
[0    0    0    0   -1    2   -1]
[0    0    0    0    0   -1    2]
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ADE_type-Tuple{MatrixElem{T} where T}" href="#ADE_type-Tuple{MatrixElem{T} where T}"><code>ADE_type</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ADE_type(G::MatrixElem) -&gt; Tuple{Symbol,Int64}</code></pre><p>Return the type of the irreducible root lattice with gram matrix <code>G</code>.</p><p>See also <a href="#root_lattice_recognition-Tuple{ZLat}"><code>root_lattice_recognition</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Hecke.ADE_type(gram_matrix(root_lattice(:A,3)))
(:A, 3)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="coxeter_number-Tuple{Symbol, Any}" href="#coxeter_number-Tuple{Symbol, Any}"><code>coxeter_number</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coxeter_number(ADE::Symbol, n)</code></pre><p>Return the Coxeter number of the corresponding ADE root lattice.</p><p>If <span>$L$</span> is a root lattice and <span>$R$</span> its set of roots, then the Coxeter number <span>$h$</span> is <span>$|R|/n$</span> where <code>n</code> is the rank of <span>$L$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; coxeter_number(:D, 4)
6
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="highest_root-Tuple{Symbol, Any}" href="#highest_root-Tuple{Symbol, Any}"><code>highest_root</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">highest_root(ADE::Symbol, n) -&gt; fmpz_mat</code></pre><p>Return coordinates of the highest root of <code>root_lattice(ADE, n)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; highest_root(:E, 6)
[1   2   3   2   1   2]</code></pre></div></section></article><h2 id="Module-operations"><a class="docs-heading-anchor" href="#Module-operations">Module operations</a><a id="Module-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Module-operations" title="Permalink"></a></h2><p>Most module operations assume that the lattices live in the same ambient space. For instance only lattices in the same ambient space compare.</p><article class="docstring"><header><a class="docstring-binding" id="==-Tuple{ZLat, ZLat}" href="#==-Tuple{ZLat, ZLat}"><code>==</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Return <code>true</code> if both lattices have the same ambient quadratic space and the same underlying module.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_sublattice-Tuple{ZLat, ZLat}" href="#is_sublattice-Tuple{ZLat, ZLat}"><code>is_sublattice</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_sublattice(L::AbsLat, M::AbsLat) -&gt; Bool</code></pre><p>Return whether <code>M</code> is a sublattice of the lattice <code>L</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_sublattice_with_relations-Tuple{ZLat, ZLat}" href="#is_sublattice_with_relations-Tuple{ZLat, ZLat}"><code>is_sublattice_with_relations</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_sublattice_with_relations(M::ZLat, N::ZLat) -&gt; Bool, fmpq_mat</code></pre><p>Returns whether <span>$N$</span> is a sublattice of <span>$M$</span>. In this case, the second return value is a matrix <span>$B$</span> such that <span>$B B_M = B_N$</span>, where <span>$B_M$</span> and <span>$B_N$</span> are the basis matrices of <span>$M$</span> and <span>$N$</span> respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="+-Tuple{ZLat, ZLat}" href="#+-Tuple{ZLat, ZLat}"><code>+</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(L::AbsLat, M::AbsLat) -&gt; AbsLat</code></pre><p>Return the sum of the lattices <code>L</code> and <code>M</code>.</p><p>The lattices <code>L</code> and <code>M</code> must have the same ambient space.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="*-Tuple{Union{Integer, fmpq, fmpz, Rational{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Integer}, ZLat}" href="#*-Tuple{Union{Integer, fmpq, fmpz, Rational{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Integer}, ZLat}"><code>*</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(a::RationalUnion, L::ZLat) -&gt; ZLat</code></pre><p>Returns the lattice <span>$aM$</span> inside the ambient space of <span>$M$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="intersect-Tuple{ZLat, ZLat}" href="#intersect-Tuple{ZLat, ZLat}"><code>intersect</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersect(L::AbsLat, M::AbsLat) -&gt; AbsLat</code></pre><p>Return the intersection of the lattices <code>L</code> and <code>M</code>.</p><p>The lattices <code>L</code> and <code>M</code> must have the same ambient space.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="in-Tuple{Vector{T} where T, ZLat}" href="#in-Tuple{Vector{T} where T, ZLat}"><code>in</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.in(v::Vector, L::ZLat) -&gt; Bool</code></pre><p>Return whether the vector <code>v</code> lies in the lattice <code>L</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="in-Tuple{fmpq_mat, ZLat}" href="#in-Tuple{fmpq_mat, ZLat}"><code>in</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.in(v::fmpq_mat, L::ZLat) -&gt; Bool</code></pre><p>Return whether the row span of <code>v</code> lies in the lattice <code>L</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="primitive_closure-Tuple{ZLat, ZLat}" href="#primitive_closure-Tuple{ZLat, ZLat}"><code>primitive_closure</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitive_closure(M::ZLat, N::ZLat) -&gt; ZLat</code></pre><p>Given two <span>$\mathbb Z$</span>-lattices <code>M</code> and <code>N</code> with <span>$N \subseteq \mathbb{Q} M$</span>, return the primitive closure <span>$M \cap \mathbb{Q} N$</span> of <code>N</code> in <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = root_lattice(:D, 6);

julia&gt; N = lattice_in_same_ambient_space(M, 3*basis_matrix(M)[1,:]);

julia&gt; basis_matrix(N)
[3   0   0   0   0   0]

julia&gt; N2 = primitive_closure(M, N)
Quadratic lattice of rank 1 and degree 6 over the rationals

julia&gt; basis_matrix(N2)
[1   0   0   0   0   0]

julia&gt; M2 = primitive_closure(dual(M), M);

julia&gt; is_integral(M2)
false
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_primitive-Tuple{ZLat, ZLat}" href="#is_primitive-Tuple{ZLat, ZLat}"><code>is_primitive</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_primitive(M::ZLat, N::ZLat) -&gt; Bool</code></pre><p>Given two <span>$\mathbb Z$</span>-lattices <span>$N \subseteq M$</span>, return whether <code>N</code> is a primitive sublattice of <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; U = hyperbolic_plane_lattice(3);

julia&gt; bU = basis_matrix(U);

julia&gt; e1, e2 = bU[1,:], bU[2,:]
([1 0], [0 1])

julia&gt; N = lattice_in_same_ambient_space(U, e1 + e2)
Quadratic lattice of rank 1 and degree 2 over the rationals

julia&gt; is_primitive(U, N)
true

julia&gt; M = root_lattice(:A, 3);

julia&gt; f = matrix(QQ, 3, 3, [0 1 1; -1 -1 -1; 1 1 0]);

julia&gt; N = kernel_lattice(M, f+1)
Quadratic lattice of rank 1 and degree 3 over the rationals

julia&gt; is_primitive(M, N)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_primitive-Tuple{ZLat, Union{fmpq_mat, Vector{T} where T}}" href="#is_primitive-Tuple{ZLat, Union{fmpq_mat, Vector{T} where T}}"><code>is_primitive</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_primitive(L::ZLat, v::Union{Vector, fmpq_mat}) -&gt; Bool</code></pre><p>Return whether the vector <code>v</code> is primitive in <code>L</code>.</p><p>A vector <code>v</code> in a <span>$\mathbb Z$</span>-lattice <code>L</code> is called primitive if for all <code>w</code> in <code>L</code> such that <span>$v = dw$</span> for some integer <code>d</code>, then <span>$d = \pm 1$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="divisibility-Tuple{ZLat, Union{fmpq_mat, Vector{T} where T}}" href="#divisibility-Tuple{ZLat, Union{fmpq_mat, Vector{T} where T}}"><code>divisibility</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">divisibility(L::ZLat, v::Union{Vector, fmpq_mat}) -&gt; fmpq</code></pre><p>Return the divisibility of <code>v</code> with respect to <code>L</code>.</p><p>For a vector <code>v</code> in the ambient quadratic space <span>$(V, \Phi)$</span> of <code>L</code>, we call the divisibility of <code>v</code> with the respect to <code>L</code> the non-negative generator of the fractional <span>$\mathbb Z$</span>-ideal <span>$\Phi(v, L)$</span>.</p></div></section></article><h2 id="Embeddings"><a class="docs-heading-anchor" href="#Embeddings">Embeddings</a><a id="Embeddings-1"></a><a class="docs-heading-anchor-permalink" href="#Embeddings" title="Permalink"></a></h2><h3 id="Orthogonal-sublattices"><a class="docs-heading-anchor" href="#Orthogonal-sublattices">Orthogonal sublattices</a><a id="Orthogonal-sublattices-1"></a><a class="docs-heading-anchor-permalink" href="#Orthogonal-sublattices" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="orthogonal_sum-Tuple{ZLat, ZLat}" href="#orthogonal_sum-Tuple{ZLat, ZLat}"><code>orthogonal_sum</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orthogonal_sum(L1::ZLat, L2::ZLat)</code></pre><p>Return the orthogonal direct sum of the lattices <code>L1</code> and <code>L2</code>.</p><p>It lives in the orthogonal direct sum of their ambient spaces.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="orthogonal_submodule-Tuple{ZLat, ZLat}" href="#orthogonal_submodule-Tuple{ZLat, ZLat}"><code>orthogonal_submodule</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orthogonal_submodule(L::ZLat, S::ZLat) -&gt; ZLat</code></pre><p>Return the largest submodule of <code>L</code> orthogonal to <code>S</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="direct_sum-Tuple{Vararg{ZLat, N} where N}" href="#direct_sum-Tuple{Vararg{ZLat, N} where N}"><code>direct_sum</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">direct_sum(x::Vararg{ZLat}) -&gt; ZLat, Vector{AbsSpaceMor}, Vector{AbsSpaceMor}
direct_sum(x::Vector{ZLat}) -&gt; ZLat, Vector{AbsSpaceMor}, Vector{AbsSpaceMor}</code></pre><p>Given a collection of <span>$\mathbb Z$</span>-lattices <span>$L_1, \ldots, L_n$</span>, return their complete direct sum <span>$L := L_1 \oplus \ldots \oplus L_n$</span>, together with the injections <span>$L_i \to L$</span> and the projections <span>$L \to L_i$</span> (seen as maps between the corresponding ambient spaces).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="irreducible_components-Tuple{ZLat}" href="#irreducible_components-Tuple{ZLat}"><code>irreducible_components</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">irreducible_components(L::ZLat)</code></pre><p>Return the irreducible components <span>$L_i$</span> of the positive definite lattice <span>$L$</span>.</p><p>This yields a maximal orthogonal splitting of <code>L</code> as</p><p class="math-container">\[L = \bigoplus_i L_i.\]</p></div></section></article><h3 id="Dual-lattice"><a class="docs-heading-anchor" href="#Dual-lattice">Dual lattice</a><a id="Dual-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Dual-lattice" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="dual-Tuple{ZLat}" href="#dual-Tuple{ZLat}"><code>dual</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual(L::AbsLat) -&gt; AbsLat</code></pre><p>Return the dual lattice of the lattice <code>L</code>.</p></div></section></article><h3 id="Discriminant-group"><a class="docs-heading-anchor" href="#Discriminant-group">Discriminant group</a><a id="Discriminant-group-1"></a><a class="docs-heading-anchor-permalink" href="#Discriminant-group" title="Permalink"></a></h3><p>See <a href="../discriminant_group/#discriminant_group-Tuple{ZLat}"><code>discriminant_group(L::ZLat)</code></a>.</p><h3 id="Overlattices"><a class="docs-heading-anchor" href="#Overlattices">Overlattices</a><a id="Overlattices-1"></a><a class="docs-heading-anchor-permalink" href="#Overlattices" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="glue_map-Tuple{ZLat, ZLat, ZLat}" href="#glue_map-Tuple{ZLat, ZLat, ZLat}"><code>glue_map</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">glue_map(L::ZLat, S::ZLat, R::ZLat; check=true)
                       -&gt; Tuple{TorQuadModMor, TorQuadModMor, TorQuadModMor}</code></pre><p>Given three integral <span>$\mathbb Z$</span>-lattices <code>L</code>, <code>S</code> and <code>R</code>, with <code>S</code> and <code>R</code> primitive sublattices of <code>L</code> and such that the sum of the ranks of <code>S</code> and <code>R</code> is equal to the rank of <code>L</code>, return the glue map <span>$\gamma$</span> of the primitive extension <span>$S+R \subseteq L$</span>, as well as the inclusion maps of the domain and codomain of <span>$\gamma$</span> into the respective discriminant groups of <code>S</code> and <code>R</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = root_lattice(:E,8);

julia&gt; f = matrix(QQ, 8, 8, [-1 -1  0  0  0  0  0  0;
                              1  0  0  0  0  0  0  0;
                              0  1  1  0  0  0  0  0;
                              0  0  0  1  0  0  0  0;
                              0  0  0  0  1  0  0  0;
                              0  0  0  0  0  1  1  0;
                             -2 -4 -6 -5 -4 -3 -2 -3;
                              0  0  0  0  0  0  0  1]);

julia&gt; S = kernel_lattice(M ,f-1)
Quadratic lattice of rank 4 and degree 8 over the rationals

julia&gt; R = kernel_lattice(M , f^2+f+1)
Quadratic lattice of rank 4 and degree 8 over the rationals

julia&gt; glue, iS, iR = glue_map(M, S, R)
(Map with following data
Domain:
=======
TorQuadMod [4//3 0; 0 4//3]
Codomain:
=========
TorQuadMod [2//3 0; 0 2//3], Map with following data
Domain:
=======
TorQuadMod [4//3 0; 0 4//3]
Codomain:
=========
TorQuadMod [4//3 2//3; 2//3 2//3], Map with following data
Domain:
=======
TorQuadMod [2//3 0; 0 2//3]
Codomain:
=========
TorQuadMod [2//3 1//3; 1//3 4//3])

julia&gt; is_bijective(glue)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="overlattice-Tuple{TorQuadModMor}" href="#overlattice-Tuple{TorQuadModMor}"><code>overlattice</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlattice(glue_map::TorQuadModMor) -&gt; ZLat</code></pre><p>Given the glue map of a primitive extension of <span>$\mathbb Z$</span>-lattices <span>$S+R \subseteq L$</span>, return <code>L</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = root_lattice(:E,8);

julia&gt; f = matrix(QQ, 8, 8, [ 1  0  0  0  0  0  0  0;
                              0  1  0  0  0  0  0  0;
                              1  2  4  4  3  2  1  2;
                             -2 -4 -6 -5 -4 -3 -2 -3;
                              2  4  6  4  3  2  1  3;
                             -1 -2 -3 -2 -1  0  0 -2;
                              0  0  0  0  0 -1  0  0;
                             -1 -2 -3 -3 -2 -1  0 -1]);

julia&gt; S = kernel_lattice(M ,f-1)
Quadratic lattice of rank 4 and degree 8 over the rationals

julia&gt; R = kernel_lattice(M , f^4+f^3+f^2+f+1)
Quadratic lattice of rank 4 and degree 8 over the rationals

julia&gt; glue, iS, iR = glue_map(M, S, R);

julia&gt; overlattice(glue) == M
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="local_modification-Tuple{ZLat, ZLat, Any}" href="#local_modification-Tuple{ZLat, ZLat, Any}"><code>local_modification</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">local_modification(M::ZLat, L::ZLat, p)</code></pre><p>Return a local modification of <code>M</code> that matches <code>L</code> at <code>p</code>.</p><p>INPUT:</p><ul><li><span>$M$</span> ‚Äì a <code>\mathbb{Z}_p</code>-maximal lattice</li><li><span>$L$</span> ‚Äì the a lattice           isomorphic to <code>M</code> over <code>\QQ_p</code></li><li><span>$p$</span> ‚Äì a prime number</li></ul><p>OUTPUT:</p><p>an integral lattice <code>M&#39;</code> in the ambient space of <code>M</code> such that <code>M</code> and <code>M&#39;</code> are locally equal at all completions except at <code>p</code> where <code>M&#39;</code> is locally isometric to the lattice <code>L</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="maximal_integral_lattice-Tuple{ZLat}" href="#maximal_integral_lattice-Tuple{ZLat}"><code>maximal_integral_lattice</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maximal_integral_lattice(L::AbsLat) -&gt; AbsLat</code></pre><p>Given a lattice <code>L</code>, return a lattice <code>M</code> in the ambient space of <code>L</code> which is maximal integral and which contains <code>L</code>.</p></div></section></article><h3 id="Sublattices-defined-by-endomorphisms"><a class="docs-heading-anchor" href="#Sublattices-defined-by-endomorphisms">Sublattices defined by endomorphisms</a><a id="Sublattices-defined-by-endomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Sublattices-defined-by-endomorphisms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="kernel_lattice-Tuple{ZLat, MatElem}" href="#kernel_lattice-Tuple{ZLat, MatElem}"><code>kernel_lattice</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kernel_lattice(L::ZLat, f::MatElem;
               ambient_representation::Bool = true) -&gt; ZLat</code></pre><p>Given a <span>$\mathbf{Z}$</span>-lattice <span>$L$</span> and a matrix <span>$f$</span> inducing an endomorphism of <span>$L$</span>, return <span>$\ker(f)$</span> is a sublattice of <span>$L$</span>.</p><p>If <code>ambient_representation</code> is <code>true</code> (the default), the endomorphism is represented with respect to the ambient space of <span>$L$</span>. Otherwise, the endomorphism is represented with respect to the basis of <span>$L$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="invariant_lattice-Tuple{ZLat, Vector{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MatElem}" href="#invariant_lattice-Tuple{ZLat, Vector{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MatElem}"><code>invariant_lattice</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invariant_lattice(L::ZLat, G::Vector{MatElem};
                  ambient_representation::Bool = true) -&gt; ZLat</code></pre><p>Given a <span>$\mathbf{Z}$</span>-lattice <span>$L$</span> and a list of matrices <span>$G$</span> inducing endomorphisms of <span>$L$</span>, return the lattice <span>$L^G$</span>, consisting of elements fixed by <span>$G$</span>.</p><p>If <code>ambient_representation</code> is <code>true</code> (the default), the endomorphism is represented with respect to the ambient space of <span>$L$</span>. Otherwise, the endomorphism is represented with respect to the basis of <span>$L$</span>.</p></div></section></article><h3 id="Computing-embeddings"><a class="docs-heading-anchor" href="#Computing-embeddings">Computing embeddings</a><a id="Computing-embeddings-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-embeddings" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="embed" href="#embed"><code>embed</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>embed(S::ZLat, G::Genus, primitive=true) -&gt; Bool, embedding</p><p>Return a (primitive) embedding of the integral lattice <code>S</code> into some lattice in the genus of <code>G</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; G = genera((8,0), 1, even=true)[1];

julia&gt; L, S, i = embed(root_lattice(:A,5), G);
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="embed_in_unimodular-Tuple{ZLat, Any, Any}" href="#embed_in_unimodular-Tuple{ZLat, Any, Any}"><code>embed_in_unimodular</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed_in_unimodular(S::ZLat, pos, neg, primitive=true, even=true) -&gt; Bool, L, S&#39;, iS, iR</code></pre><p>Return a (primitive) embedding of the integral lattice <code>S</code> into some (even) unimodular lattice of signature <code>(pos, neg)</code>.</p><p>For now this works only for even lattices.</p><pre><code class="language-julia-repl hljs">julia&gt; NS = orthogonal_sum(Zlattice(:U), rescale(root_lattice(:A, 16), -1))[1];

julia&gt; LK3, iNS, i = embed_in_unimodular(NS, 3, 19);

julia&gt; genus(LK3)
ZGenus
Signature: (3, 19)
Genus symbol at 2:   1^22

julia&gt; iNS
Quadratic lattice of rank 18 and degree 22 over the rationals

julia&gt; is_primitive(LK3, iNS)
true</code></pre></div></section></article><h2 id="LLL,-Short-and-Close-Vectors"><a class="docs-heading-anchor" href="#LLL,-Short-and-Close-Vectors">LLL, Short and Close Vectors</a><a id="LLL,-Short-and-Close-Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#LLL,-Short-and-Close-Vectors" title="Permalink"></a></h2><h3 id="LLL-and-indefinite-LLL"><a class="docs-heading-anchor" href="#LLL-and-indefinite-LLL">LLL and indefinite LLL</a><a id="LLL-and-indefinite-LLL-1"></a><a class="docs-heading-anchor-permalink" href="#LLL-and-indefinite-LLL" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="lll-Tuple{ZLat}" href="#lll-Tuple{ZLat}"><code>lll</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lll(L::ZLat, same_ambient::Bool = true) -&gt; ZLat</code></pre><p>Given an integral <span>$\mathbb Z$</span>-lattice <code>L</code> with basis matrix <code>B</code>, compute a basis <code>C</code> of <code>L</code> such that the gram matrix <span>$G_C$</span> of <code>L</code> with respect to <code>C</code> is LLL-reduced.</p><p>By default, it creates the lattice in the same ambient space as <code>L</code>. This can be disabled by setting <code>same_ambient = false</code>. Works with both definite and indefinite lattices.</p></div></section></article><h3 id="Short-Vectors"><a class="docs-heading-anchor" href="#Short-Vectors">Short Vectors</a><a id="Short-Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Short-Vectors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="short_vectors" href="#short_vectors"><code>short_vectors</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">short_vectors(L::ZLat, [lb = 0], ub, [elem_type = fmpz]; check::Bool = true)
                                   -&gt; Vector{Tuple{Vector{elem_type}, fmpq}}</code></pre><p>Returns all tuples <code>(v, n)</code> such that <code>n = v G v^t</code> satisfies <code>lb &lt;= n &lt;= ub</code>, where <code>G</code> is the Gram matrix of <code>L</code> and <code>v</code> is non-zero.</p><p>Note that the vectors are computed up to sign (so only one of <code>v</code> and <code>-v</code> appears).</p><p>It is assumed and checked that <code>L</code> is positive definite.</p><p>See also <a href="#short_vectors_iterator"><code>short_vectors_iterator</code></a> for an iterator version.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="shortest_vectors" href="#shortest_vectors"><code>shortest_vectors</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shortest_vectors(L::ZLat, [elem_type = fmpz]; check::Bool = true)
                                           -&gt; fmpq, Vector{elem_type}, fmpq}</code></pre><p>Returns the list of shortest non-zero vectors. Note that the vectors are computed up to sign (so only one of <code>v</code> and <code>-v</code> appears).</p><p>It is assumed and checked that <code>L</code> is positive definite.</p><p>See also <a href="../../orders/ideals/#minimum-Tuple{NfOrdIdl}"><code>minimum</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="short_vectors_iterator" href="#short_vectors_iterator"><code>short_vectors_iterator</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">short_vectors_iterator(L::ZLat, [lb = 0], ub,
                       [elem_type = fmpz]; check::Bool = true)
                                -&gt; Tuple{Vector{elem_type}, fmpq} (iterator)</code></pre><p>Returns an iterator for all tuples <code>(v, n)</code> such that <code>n = v G v^t</code> satisfies <code>lb &lt;= n &lt;= ub</code>, where <code>G</code> is the Gram matrix of <code>L</code> and <code>v</code> is non-zero.</p><p>Note that the vectors are computed up to sign (so only one of <code>v</code> and <code>-v</code> appears).</p><p>It is assumed and checked that <code>L</code> is positive definite.</p><p>See also <a href="#short_vectors"><code>short_vectors</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="minimum-Tuple{ZLat}" href="#minimum-Tuple{ZLat}"><code>minimum</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum(L::ZLat)</code></pre><p>Return the minimum squared length among the non-zero vectors in <code>L</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="kissing_number-Tuple{ZLat}" href="#kissing_number-Tuple{ZLat}"><code>kissing_number</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kissing_number(L::ZLat)</code></pre><p>Return the Kissing number of the sphere packing defined by <code>L</code>.</p><p>This is the number of non-overlapping spheres touching any other given sphere.</p></div></section></article><h3 id="Close-Vectors"><a class="docs-heading-anchor" href="#Close-Vectors">Close Vectors</a><a id="Close-Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Close-Vectors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="close_vectors-Tuple{ZLat, Vector{T} where T, Vararg{Any, N} where N}" href="#close_vectors-Tuple{ZLat, Vector{T} where T, Vararg{Any, N} where N}"><code>close_vectors</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">close_vectors(L:ZLat, v:Vector, [lb,], ub; check::Bool = false)
                                        -&gt; Vector{Tuple{Vector{Int}}, fmpq}</code></pre><p>Return all tuples <code>(x, d)</code> where <code>x</code> is an element of <code>L</code> such that <code>d = b(v - x, v - x) &lt;= ub</code>. If <code>lb</code> is provided, then also <code>lb &lt;= d</code>.</p><p>If <code>filter</code> is not <code>nothing</code>, then only those <code>x</code> with <code>filter(x)</code> evaluating to <code>true</code> are returned.</p><p>By default, it will be checked whether <code>L</code> is positive definite. This can be disabled setting <code>check = false</code>.</p><p>Both input and output are with respect to the basis matrix of <code>L</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = Zlattice(matrix(QQ, 2, 2, [1, 0, 0, 2]));

julia&gt; close_vectors(L, [1, 1], 1)
3-element Vector{Tuple{Vector{fmpz}, fmpq}}:
 ([2, 1], 1)
 ([0, 1], 1)
 ([1, 1], 0)

julia&gt; close_vectors(L, [1, 1], 1, 1)
2-element Vector{Tuple{Vector{fmpz}, fmpq}}:
 ([2, 1], 1)
 ([0, 1], 1)</code></pre></div></section></article><hr/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../genusherm/">¬´ Genera for hermitian lattices</a><a class="docs-footer-nextpage" href="../Zgenera/">Genera of Integer Lattices ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 14 February 2023 21:38">Tuesday 14 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
