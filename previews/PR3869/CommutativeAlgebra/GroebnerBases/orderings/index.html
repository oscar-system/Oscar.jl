<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Monomial Orderings · Oscar.jl</title><meta name="title" content="Monomial Orderings · Oscar.jl"/><meta property="og:title" content="Monomial Orderings · Oscar.jl"/><meta property="twitter:title" content="Monomial Orderings · Oscar.jl"/><meta name="description" content="Documentation for Oscar.jl."/><meta property="og:description" content="Documentation for Oscar.jl."/><meta property="twitter:description" content="Documentation for Oscar.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Oscar.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../../General/serialization/">Saving and loading files</a></li><li><a class="tocitem" href="../../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../../Groups/action/">Group actions</a></li><li><a class="tocitem" href="../../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../../Groups/group_characters/">Group characters</a></li><li><a class="tocitem" href="../../../Groups/recog/">Group recognition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../../Nemo/finitefield/">Finite fields</a></li><li><a class="tocitem" href="../../../Nemo/algebraic/">Algebraic numbers</a></li><li><a class="tocitem" href="../../../Fields/algebraic_closure_fp/">Algebraic closure of finite prime fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../../NumberTheory/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li></ul></li><li><a class="tocitem" href="../../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox" checked/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro/">Introduction</a></li><li><a class="tocitem" href="../../rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../../affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../../localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../../ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li></ul></li><li><a class="tocitem" href="../../homological_algebra/">Homological Algebra</a></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox" checked/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Gröbner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Monomial Orderings</a><ul class="internal"><li><a class="tocitem" href="#Monomial-Comparisons"><span>Monomial Comparisons</span></a></li><li><a class="tocitem" href="#Matrix-Orderings"><span>Matrix Orderings</span></a></li><li><a class="tocitem" href="#Predefined-Global-Orderings"><span>Predefined Global Orderings</span></a></li><li><a class="tocitem" href="#Predefined-Local-Orderings"><span>Predefined Local Orderings</span></a></li><li><a class="tocitem" href="#Weight-Orderings"><span>Weight Orderings</span></a></li><li><a class="tocitem" href="#Block-Orderings"><span>Block Orderings</span></a></li><li><a class="tocitem" href="#Elimination-Orderings"><span>Elimination Orderings</span></a></li><li><a class="tocitem" href="#Tests-on-Monomial-Orderings"><span>Tests on Monomial Orderings</span></a></li><li><a class="tocitem" href="#Transferring-an-ordering-from-another-ring"><span>Transferring an ordering from another ring</span></a></li><li><a class="tocitem" href="#Module-Orderings"><span>Module Orderings</span></a></li></ul></li><li><a class="tocitem" href="../groebner_bases/">Gröbner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../groebner_bases_integers/">Gröbner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-10" type="checkbox"/><label class="tocitem" for="menuitem-9-10"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../../FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../../InvariantTheory/tori/">Invariants of Tori</a></li><li><a class="tocitem" href="../../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/RationalPointsAffine/">Rational Points on Affine Schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveringsAndGluings/">Coverings</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/">Morphisms of covered schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/ProjectiveSchemes/">Projective schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/">Morphisms of projective schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/RationalPointsProjective/">Rational Points on Projective Schemes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Algebraic Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/">Affine Algebraic Sets</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/">Projective Algebraic Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Algebraic Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/AlgebraicVarieties/AffineVariety/">Affine Varieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/">Projective Varieties</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/AffinePlaneCurves/">Affine plane curves</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/ProjectiveCurves/">Projective Curves</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/ProjectivePlaneCurves/">Projective Plane Curves</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/ParametrizationPlaneCurves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/K3Surfaces/">Automorphism Groups of  K3 surfaces</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/AdjunctionProcess/">Adjunction Process for Surfaces</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/ParametrizationSurfaces/">Rational Parametrization of Rational Surfaces</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/SurfacesP4/">Nongeneral Type Surfaces in <span>$\mathbb P^4$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Sheaf Cohomology</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/SheafCohomology/sheaf_cohomology/">Sheaves on Projective Space</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-8" type="checkbox"/><label class="tocitem" for="menuitem-11-8"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricSchemes/">Toric Schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricIdealSheaves/">Toric Ideal Sheaves (Experimental)</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/BlowdownMorphisms/">Toric Blowdown Morphisms (Experimental)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-9" type="checkbox"/><label class="tocitem" for="menuitem-11-9"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Miscellaneous/miscellaneous/">Some Special Ideals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-10" type="checkbox"/><label class="tocitem" for="menuitem-11-10"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../../TropicalGeometry/semiring/">Tropical semirings, matrices, and polynomials</a></li><li><a class="tocitem" href="../../../TropicalGeometry/semiring_map/">Tropical semiring maps</a></li><li><a class="tocitem" href="../../../TropicalGeometry/variety/">Tropical varieties</a></li><li><a class="tocitem" href="../../../TropicalGeometry/hypersurface/">Tropical hypersurfaces</a></li><li><a class="tocitem" href="../../../TropicalGeometry/curve/">Tropical curves</a></li><li><a class="tocitem" href="../../../TropicalGeometry/linear_space/">Tropical linear spaces</a></li><li><a class="tocitem" href="../../../TropicalGeometry/groebner_theory/">Groebner theory</a></li><li><a class="tocitem" href="../../../TropicalGeometry/tropicalization/">Tropicalization of polynomial ideals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Noncommutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-13-2" type="checkbox"/><label class="tocitem" for="menuitem-13-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li><li><a class="tocitem" href="../../../Combinatorics/phylogenetic_trees/">Phylogenetic Trees</a></li><li><input class="collapse-toggle" id="menuitem-14-5" type="checkbox"/><label class="tocitem" for="menuitem-14-5"><span class="docs-label">Enumerative combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Combinatorics/EnumerativeCombinatorics/partitions/">Partitions</a></li><li><a class="tocitem" href="../../../Combinatorics/EnumerativeCombinatorics/tableaux/">Tableaux</a></li><li><a class="tocitem" href="../../../Combinatorics/EnumerativeCombinatorics/schur_polynomials/">Schur polynomials</a></li><li><a class="tocitem" href="../../../Combinatorics/EnumerativeCombinatorics/compositions/">Compositions</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../../references/">References</a></li><li><a class="tocitem" href="../../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-18" type="checkbox"/><label class="tocitem" for="menuitem-18"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/printing_details/">Printing in OSCAR</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/caching/">Caching parent objects in OSCAR</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/serialization/">Serialization</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/gap_integration/">GAP Integration</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/release/">Release management</a></li><li><input class="collapse-toggle" id="menuitem-18-11" type="checkbox"/><label class="tocitem" for="menuitem-18-11"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-19" type="checkbox"/><label class="tocitem" for="menuitem-19"><span class="docs-label">Experimental</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/intro/">Adding new projects to experimental</a></li><li><input class="collapse-toggle" id="menuitem-19-2" type="checkbox"/><label class="tocitem" for="menuitem-19-2"><span class="docs-label">Double complexes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/DoubleAndHyperComplexes/user_interface/">Double complexes – the user&#39;s interface</a></li><li><a class="tocitem" href="../../../Experimental/DoubleAndHyperComplexes/advice_for_the_programmer/">Advice for the programmer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-3" type="checkbox"/><label class="tocitem" for="menuitem-19-3"><span class="docs-label">Linear Quotients</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/LinearQuotients/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/LinearQuotients/linear_quotients/">Construction and basic functionality</a></li><li><a class="tocitem" href="../../../Experimental/LinearQuotients/cox_rings/">Cox rings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-4" type="checkbox"/><label class="tocitem" for="menuitem-19-4"><span class="docs-label">Matroid Realization Spaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/MatroidRealizationSpaces/introduction/">Matroid Realization Spaces</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-5" type="checkbox"/><label class="tocitem" for="menuitem-19-5"><span class="docs-label">Orthogonal discriminants</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/OrthogonalDiscriminants/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/OrthogonalDiscriminants/access/">Access to precomputed OD data</a></li><li><a class="tocitem" href="../../../Experimental/OrthogonalDiscriminants/compute/">Criteria for computing orthogonal discriminants</a></li><li><a class="tocitem" href="../../../Experimental/OrthogonalDiscriminants/misc/">Miscellaneous functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-6" type="checkbox"/><label class="tocitem" for="menuitem-19-6"><span class="docs-label">Quadratic forms and isometries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/QuadFormAndIsom/introduction/">Quadratic forms and isometries</a></li><li><a class="tocitem" href="../../../Experimental/QuadFormAndIsom/spacewithisom/">Quadratic spaces with isometry</a></li><li><a class="tocitem" href="../../../Experimental/QuadFormAndIsom/latwithisom/">Lattices with isometry</a></li><li><a class="tocitem" href="../../../Experimental/QuadFormAndIsom/enumeration/">Enumeration of isometries</a></li><li><a class="tocitem" href="../../../Experimental/QuadFormAndIsom/primembed/">Nikulin&#39;s theory on primitive embeddings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-7" type="checkbox"/><label class="tocitem" for="menuitem-19-7"><span class="docs-label">Standard Finite Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/StandardFiniteFields/introduction/">-</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-8" type="checkbox"/><label class="tocitem" for="menuitem-19-8"><span class="docs-label">Lie Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/LieAlgebras/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/LieAlgebras/lie_algebras/">Lie algebras</a></li><li><a class="tocitem" href="../../../Experimental/LieAlgebras/ideals_and_subalgebras/">Ideals and Lie subalgebras</a></li><li><a class="tocitem" href="../../../Experimental/LieAlgebras/lie_algebra_homs/">Lie algebra homomorphisms</a></li><li><a class="tocitem" href="../../../Experimental/LieAlgebras/modules/">Lie algebra modules</a></li><li><a class="tocitem" href="../../../Experimental/LieAlgebras/module_homs/">Lie algebra module homomorphisms</a></li><li><a class="tocitem" href="../../../Experimental/LieAlgebras/cartan_matrix/">Cartan Matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-9" type="checkbox"/><label class="tocitem" for="menuitem-19-9"><span class="docs-label">Bases for highest weight modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/BasisLieHighestWeight/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/BasisLieHighestWeight/user_functions/">Functions for a monomial basis of highest weight modules</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-10" type="checkbox"/><label class="tocitem" for="menuitem-19-10"><span class="docs-label">Partitioned Permutations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/PartitionedPermutations/introduction/">Partitioned Permutations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-11" type="checkbox"/><label class="tocitem" for="menuitem-19-11"><span class="docs-label">F-Theory Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/FTheoryTools/introduction/">Welcome to FTheoryTools</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/generalities/">Functionality for all F-theory models</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/weierstrass/">Weierstrass models</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/tate/">Global Tate models</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/hypersurface/">Hypersurface models</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/literature/">Literature constructions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Commutative Algebra</a></li><li><a class="is-disabled">Gröbner/Standard Bases</a></li><li class="is-active"><a href>Monomial Orderings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Monomial Orderings</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/oscar-system/Oscar.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/CommutativeAlgebra/GroebnerBases/orderings.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="monomial_orderings"><a class="docs-heading-anchor" href="#monomial_orderings">Monomial Orderings</a><a id="monomial_orderings-1"></a><a class="docs-heading-anchor-permalink" href="#monomial_orderings" title="Permalink"></a></h1><p>Given a coefficient ring <span>$C$</span> as in the previous section, let <span>$C[x]=C[x_1, \ldots, x_n]$</span> be the polynomial ring over <span>$C$</span> in the set of variables <span>$x=\{x_1, \ldots, x_n\}$</span>. Monomials in <span>$x=\{x_1, \ldots, x_n\}$</span> are written using multi–indices: If <span>$\alpha=(\alpha_1, \ldots, \alpha_n)\in \N^n$</span>, set <span>$x^\alpha=x_1^{\alpha_1}\cdots x_n^{\alpha_n}$</span> and</p><p class="math-container">\[\text{Mon}_n(x) :=  \text{Mon}(x_1, \ldots, x_n) := \{x^\alpha \mid \alpha \in \N^n\}.\]</p><p>A <em>monomial ordering</em> on <span>$\text{Mon}_n(x)$</span> is a total  ordering <span>$&gt;$</span> on <span>$\text{Mon}_n(x)$</span> such that</p><p class="math-container">\[x^\alpha &gt; x^\beta \Longrightarrow x^\gamma x^\alpha &gt; x^\gamma  x^\beta,
\; \text{ for all }\; \alpha, \beta, \gamma \in \mathbb N^n.\]</p><p>A monomial ordering <span>$&gt;$</span> on <span>$\text{Mon}_n(x)$</span> is called</p><ul><li><em>global</em> if <span>$x^\alpha &gt; 1$</span> for all <span>$\alpha \not = (0, \dots, 0)$</span>,</li><li><em>local</em> if  <span>$x^\alpha &lt; 1$</span> for all <span>$\alpha \not = (0, \dots, 0)$</span>, and</li><li><em>mixed</em> if it is neither global nor local.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>A monomial ordering on <span>$\text{Mon}_n(x)$</span> is global iff it is a well-ordering.</li><li>To give a monomial ordering on <span>$\text{Mon}_n(x)$</span> means to give a total ordering <span>$&gt;$</span> on $ \N^n$ such that  <span>$\alpha &gt; \beta$</span> implies $ \gamma + \alpha &gt; \gamma  + \beta$ for all <span>$\alpha , \beta, \gamma \in \N^n.$</span>  Rather than speaking of a monomial ordering on <span>$\text{Mon}_n(x)$</span>, we may, thus, also speak of a  (global, local, mixed) monomial ordering on <span>$\N^n$</span>.</li></ul></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By a result of Robbiano, every monomial ordering can be realized as a matrix ordering.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The lexicograpical monomial ordering specifies the default way of storing and displaying multivariate polynomials in OSCAR (terms are sorted in descending order). The other orderings which can be attached to a multivariate polynomial ring are the degree lexicographical ordering  and the degree reverse lexicographical ordering. Independently of the attached orderings, Gröbner bases can be computed with respect to any monomial ordering. See the section on <a href="../groebner_bases/#gb_fields">Gröbner bases</a>.</p></div></div><p>In this section, we show how to create monomial orderings in OSCAR. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the convenient construction of block orderings on the set of monomials in the variables of a given multivariate polynomial ring, we allow to construct orderings on the monomials in blocks of variables, viewing these orderings as partial orderings on the monomials in all variables.</p></div></div><p>Here are some illustrating examples:</p><h5 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; S, (w, x) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[w, x])

julia&gt; o = lex([w, x])
lex([w, x])

julia&gt; canonical_matrix(o)
[1   0]
[0   1]

julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = degrevlex([w, x])
degrevlex([w, x])

julia&gt; is_global(o1)
true

julia&gt; canonical_matrix(o1)
[1    1   0   0]
[0   -1   0   0]

julia&gt; o2 = neglex([y, z])
neglex([y, z])

julia&gt; is_local(o2)
true

julia&gt; canonical_matrix(o2)
[0   0   -1    0]
[0   0    0   -1]

julia&gt; o3 = o1*o2
degrevlex([w, x])*neglex([y, z])

julia&gt; canonical_matrix(o3)
[1    1    0    0]
[0   -1    0    0]
[0    0   -1    0]
[0    0    0   -1]

julia&gt; is_mixed(o3)
true</code></pre><h2 id="Monomial-Comparisons"><a class="docs-heading-anchor" href="#Monomial-Comparisons">Monomial Comparisons</a><a id="Monomial-Comparisons-1"></a><a class="docs-heading-anchor-permalink" href="#Monomial-Comparisons" title="Permalink"></a></h2><p>The <code>cmp</code> function should be used for comparing two monomials with regard to a monomial ordering.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="cmp-Tuple{MonomialOrdering, MPolyRingElem, MPolyRingElem}" href="#cmp-Tuple{MonomialOrdering, MPolyRingElem, MPolyRingElem}"><code>cmp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cmp(ord::MonomialOrdering, a::MPolyRingElem, b::MPolyRingElem)

cmp(ord::ModuleOrdering, a::FreeModElem{T}, b::FreeModElem{T}) where T &lt;: MPolyRingElem</code></pre><p>Compare monomials <code>a</code> and <code>b</code> with regard to the ordering <code>ord</code>: Return <code>-1</code> for <code>a &lt; b</code> and <code>1</code> for <code>a &gt; b</code> and <code>0</code> for <code>a == b</code>. An error is thrown if <code>ord</code> is a partial ordering that does not distinguish <code>a</code> from <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; cmp(lex([x,y]), x, one(R))
1

julia&gt; try cmp(lex([x,y]), z, one(R)); catch e; e; end
ErrorException(&quot;z and 1 are incomparable with respect to lex([x, y])&quot;)

julia&gt; cmp(lex([x,y,z]), z, one(R))
1

julia&gt; F = free_module(R, 2)
Free module of rank 2 over R

julia&gt; cmp(lex(R)*invlex(F), F[1], F[2])
-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L1551-L1579">source</a></section></article><h2 id="Matrix-Orderings"><a class="docs-heading-anchor" href="#Matrix-Orderings">Matrix Orderings</a><a id="Matrix-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Orderings" title="Permalink"></a></h2><p>Given a matrix <span>$M\in \text{Mat}(k\times n,\mathbb R)$</span> of rank <span>$n$</span>, with rows <span>$m_1,\dots,m_k$</span>, the <em>matrix ordering</em> defined by <span>$M$</span> is obtained by setting</p><p class="math-container">\[x^\alpha&gt;_M x^\beta  \Leftrightarrow  \;\exists\; 1\leq i\leq k:  m_1\alpha=m_1\beta,\ldots, 
m_{i-1}\alpha\ =m_{i-1}\beta,\ m_i\alpha&gt;m_i\beta\]</p><p>(here, <span>$\alpha$</span> and <span>$\beta$</span> are regarded as column vectors).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By a theorem of Robbiano, every monomial ordering arises as a matrix ordering as above with <span>$M\in \text{GL}(n,\mathbb R)$</span>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To create matrix orderings, OSCAR allows for matrices with integer coefficients as input matrices.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For orderings such as <code>lex</code> and <code>degrevlex</code> which are  predefined in OSCAR, using the predefined version is much faster than using a representation as a matrix ordering.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="matrix_ordering-Union{Tuple{T}, Tuple{MPolyRing, Union{MatElem{T}, Matrix{T}}}} where T" href="#matrix_ordering-Union{Tuple{T}, Tuple{MPolyRing, Union{MatElem{T}, Matrix{T}}}} where T"><code>matrix_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_ordering(R::MPolyRing, M::Union{Matrix{T}, MatElem{T}}; check::Bool = true) where T -&gt; MonomialOrdering</code></pre><p>Given an integer matrix <code>M</code> such that <code>nvars(R) = ncols(M) = rank(M)</code>,  return the matrix ordering on the set of variables of <code>R</code> which is defined by <code>M</code>.</p><pre><code class="nohighlight hljs">matrix_ordering(V::AbstractVector{&lt;:MPolyRingElem}, M::Union{Matrix{T}, MatElem{T}}; check::Bool = true) where T -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables and an integer matrix <code>M</code> such that <code>length(V) = ncols(M) = rank(M)</code>,  return the matrix ordering on the set of monomials in the given variables which is defined by <code>M</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The matrix <code>M</code> need not be square.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>check = false</code> is supplied, the rank check is omitted, and the resulting ordering may only be partial.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = QQ[&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;];

julia&gt; M =[1 1 1 1; 0 -1 -1 -1; 0 0 -1 -1; 0 0 0 -1]
4×4 Matrix{Int64}:
 1   1   1   1
 0  -1  -1  -1
 0   0  -1  -1
 0   0   0  -1

julia&gt; o1 = matrix_ordering(R, M)
matrix_ordering([w, x, y, z], [1 1 1 1; 0 -1 -1 -1; 0 0 -1 -1; 0 0 0 -1])

julia&gt; N =[1 1; 0 -1]
2×2 Matrix{Int64}:
 1   1
 0  -1

julia&gt; o2 = matrix_ordering([w, x], N)
matrix_ordering([w, x], [1 1; 0 -1])

julia&gt; canonical_matrix(o2)
[1    1   0   0]
[0   -1   0   0]

julia&gt; o3 = matrix_ordering(gens(R)[3:4], N)
matrix_ordering([y, z], [1 1; 0 -1])

julia&gt; o3 = matrix_ordering(gens(R)[3:4], N)
matrix_ordering([y, z], [1 1; 0 -1])

julia&gt; canonical_matrix(o3)
[0   0   1    1]
[0   0   0   -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L1170-L1224">source</a></section></article><p>As already shown above, OSCAR provides functions to recover defining matrices from given monomial orderings:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="matrix-Tuple{MonomialOrdering}" href="#matrix-Tuple{MonomialOrdering}"><code>matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix(ord::MonomialOrdering)</code></pre><p>Return a matrix defining <code>ord</code> as a matrix ordering.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; o1 = degrevlex(R)
degrevlex([x, y, z])

julia&gt; matrix(o1)
[ 1    1    1]
[ 0    0   -1]
[ 0   -1    0]
[-1    0    0]

julia&gt; o2 = degrevlex([x, y])
degrevlex([x, y])

julia&gt; matrix(o2)
[ 1    1   0]
[ 0   -1   0]
[-1    0   0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L1328-L1354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="canonical_matrix-Tuple{MonomialOrdering}" href="#canonical_matrix-Tuple{MonomialOrdering}"><code>canonical_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">canonical_matrix(ord::MonomialOrdering)</code></pre><p>Return the canonical matrix defining <code>ord</code> as a matrix ordering.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; o1 = degrevlex(R)
degrevlex([x, y, z])

julia&gt; canonical_matrix(o1)
[1    1    1]
[0    0   -1]
[0   -1    0]

julia&gt; o2 = degrevlex([x, y])
degrevlex([x, y])

julia&gt; canonical_matrix(o2)
[1    1   0]
[0   -1   0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L1373-L1397">source</a></section></article><h2 id="Predefined-Global-Orderings"><a class="docs-heading-anchor" href="#Predefined-Global-Orderings">Predefined Global Orderings</a><a id="Predefined-Global-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Predefined-Global-Orderings" title="Permalink"></a></h2><h4 id="The-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Lexicographical-Ordering">The Lexicographical Ordering</a><a id="The-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>lexicographical ordering</em> <code>lex</code> is defined by setting</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;\exists \; 1 \leq i \leq n: \alpha_1 = \beta_1, \dots, \alpha_{i-1} = \beta_{i-1}, \alpha_i &gt; \beta_i.\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="lex-Tuple{MPolyRing}" href="#lex-Tuple{MPolyRing}"><code>lex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">lex(V::AbstractVector{&lt;:MPolyRingElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = lex(R)
lex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[1   0   0   0]
[0   1   0   0]
[0   0   1   0]
[0   0   0   1]

julia&gt; o2 = lex([w, x])
lex([w, x])

julia&gt; o3 = lex(gens(R)[3:4])
lex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L237-L266">source</a></section></article><h4 id="The-Degree-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Degree-Lexicographical-Ordering">The Degree Lexicographical Ordering</a><a id="The-Degree-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Degree-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>degree lexicographical ordering</em> <code>deglex</code> is defined by setting <span>$\;\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;  \deg(x^\alpha) &gt; \deg(x^\beta)  \;\text{ or }\; (\deg(x^\alpha) = \deg(x^\beta) \;\text{ and }\; \exists \; 1 \leq i \leq n: \alpha_1 = \beta_1, \dots, \alpha_{i-1} = \beta_{i-1}, \alpha_i &gt; \beta_i).\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="deglex-Tuple{MPolyRing}" href="#deglex-Tuple{MPolyRing}"><code>deglex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deglex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the degree lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">deglex(V::AbstractVector{&lt;:MPolyRingElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the degree lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = deglex(R)
deglex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[1    1    1    1]
[0   -1   -1   -1]
[0    0   -1   -1]
[0    0    0   -1]

julia&gt; o2 = deglex([w, x])
deglex([w, x])

julia&gt; o3 = deglex(gens(R)[3:4])
deglex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L301-L330">source</a></section></article><h4 id="The-Inverse-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Inverse-Lexicographical-Ordering">The Inverse Lexicographical Ordering</a><a id="The-Inverse-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Inverse-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>inverse lexicographical ordering</em> <code>invlex</code> is defined by setting</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;\exists \; 1 \leq i \leq n: \alpha_n = \beta_n, \dots, \alpha_{i+1} = \beta_{i+1}, \alpha_i  &gt; \beta_i.\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="invlex-Tuple{MPolyRing}" href="#invlex-Tuple{MPolyRing}"><code>invlex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invlex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the inverse lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">invlex(V::AbstractVector{&lt;:MPolyRingElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the inverse lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = invlex(R)
invlex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[0   0   0   1]
[0   0   1   0]
[0   1   0   0]
[1   0   0   0]

julia&gt; o2 = invlex([w, x])
invlex([w, x])

julia&gt; o3 = invlex(gens(R)[3:4])
invlex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L445-L474">source</a></section></article><h4 id="The-Degree-Inverse-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Degree-Inverse-Lexicographical-Ordering">The Degree Inverse Lexicographical Ordering</a><a id="The-Degree-Inverse-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Degree-Inverse-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>degree inverse lexicographical ordering</em> <code>deginvlex</code> is defined by setting</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \deg(x^\alpha) &gt; \deg(x^\beta)  \;\text{ or }\;(\deg(x^\alpha) = \deg(x^\beta) \;\text{ and }\; \;\exists \; 1 \leq i \leq n: \alpha_n = \beta_n, \dots, \alpha_{i+1} = \beta_{i+1}, \alpha_i  &gt; \beta_i).\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="deginvlex-Tuple{MPolyRing}" href="#deginvlex-Tuple{MPolyRing}"><code>deginvlex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deginvlex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the degree inverse lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">deginvlex(V::AbstractVector{&lt;:MPolyRingElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the degree inverse lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = deginvlex(R)
deginvlex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[1   1   1   1]
[0   0   0   1]
[0   0   1   0]
[0   1   0   0]

julia&gt; o2 = deginvlex([w, x])
deginvlex([w, x])

julia&gt; o3 = deginvlex(gens(R)[3:4])
deginvlex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L510-L539">source</a></section></article><h4 id="The-Degree-Reverse-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Degree-Reverse-Lexicographical-Ordering">The Degree Reverse Lexicographical Ordering</a><a id="The-Degree-Reverse-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Degree-Reverse-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>degree reverse lexicographical ordering</em> <code>degrevlex</code> is defined by setting <span>$\;\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \; \deg(x^\alpha) &gt; \deg(x^\beta)  \;\text{ or }\;(\deg(x^\alpha) = \deg(x^\beta) \;\text{ and }\; \exists \; 1 \leq i \leq n: \alpha_n = \beta_n, \dots, \alpha_{i+1} = \beta_{i+1}, \alpha_i &lt; \beta_i).\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="degrevlex-Tuple{MPolyRing}" href="#degrevlex-Tuple{MPolyRing}"><code>degrevlex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degrevlex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the degree reverse lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">degrevlex(V::AbstractVector{&lt;:MPolyRingElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the degree reverse lexicographical ordering on the set of monomials in these variables</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = degrevlex(R)
degrevlex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[1    1    1    1]
[0    0    0   -1]
[0    0   -1    0]
[0   -1    0    0]

julia&gt; o2 = degrevlex([w, x])
degrevlex([w, x])

julia&gt; o3 = degrevlex(gens(R)[3:4])
degrevlex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L373-L402">source</a></section></article><h4 id="Weighted-Lexicographical-Orderings"><a class="docs-heading-anchor" href="#Weighted-Lexicographical-Orderings">Weighted Lexicographical Orderings</a><a id="Weighted-Lexicographical-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Weighted-Lexicographical-Orderings" title="Permalink"></a></h4><p>If <code>W</code> is a vector of positive integers  <span>$w_1, \dots, w_n$</span>, the corresponding <em>weighted lexicographical ordering</em> <code>wdeglex(W)</code>  is defined by setting <span>$\;\text{wdeg}(x^\alpha) = w_1\alpha_1 + \cdots + w_n\alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;  \text{wdeg}(x^\alpha) &gt; \text{wdeg}(x^\beta)  \;\text{ or }\;\\
(\text{wdeg}(x^\alpha) = \text{wdeg}(x^\beta)  \;\text{ and }\; \exists \; 1 \leq i \leq n: \alpha_1 = \beta_1, \dots, \alpha_{i-1} = \beta_{i-1}, \alpha_i &gt; \beta_i).\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="wdeglex-Tuple{MPolyRing, Vector{Int64}}" href="#wdeglex-Tuple{MPolyRing, Vector{Int64}}"><code>wdeglex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wdeglex(R::MPolyRing, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>If <code>W</code> is a vector of positive integers, return the corresponding weighted  lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">wdeglex(V::AbstractVector{&lt;:MPolyRingElem}, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables and a vector <code>W</code> of positive integers, return the corresponding weighted  lexicographical ordering on the set of monomials in the given variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = wdeglex(R, [1, 2, 3, 4])
wdeglex([w, x, y, z], [1, 2, 3, 4])

julia&gt; canonical_matrix(o1)
[1    2    3    4]
[0   -2   -3   -4]
[0    0   -3   -4]
[0    0    0   -1]

julia&gt; o2 = wdeglex([w, x], [1, 2])
wdeglex([w, x], [1, 2])

julia&gt; o3 = wdeglex(gens(R)[3:4], [3, 4])
wdeglex([y, z], [3, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L890-L921">source</a></section></article><h4 id="Weighted-Reverse-Lexicographical-Orderings"><a class="docs-heading-anchor" href="#Weighted-Reverse-Lexicographical-Orderings">Weighted Reverse Lexicographical Orderings</a><a id="Weighted-Reverse-Lexicographical-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Weighted-Reverse-Lexicographical-Orderings" title="Permalink"></a></h4><p>If <code>W</code> is a vector of positive integers  <span>$w_1, \dots, w_n$</span>, the corresponding <em>weighted reverse lexicographical ordering</em> <code>wdegrevlex</code>  is defined by setting <span>$\;\text{wdeg}(x^\alpha) = w_1\alpha_1 + \cdots + w_n\alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \; \text{wdeg}(x^\alpha) &gt; \text{wdeg}(x^\beta)  \;\text{ or }\;\\
(\text{wdeg}(x^\alpha) = \text{wdeg}(x^\beta)  \;\text{ and }\; \exists \; 1 \leq i \leq n: \alpha_n = \beta_n, \dots, \alpha_{i+1} = \beta_{i+1}, \alpha_i &lt; \beta_i).\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="wdegrevlex-Tuple{MPolyRing, Vector{Int64}}" href="#wdegrevlex-Tuple{MPolyRing, Vector{Int64}}"><code>wdegrevlex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wdegrevlex(R::MPolyRing, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>If <code>W</code> is a vector of positive integers, return the corresponding weighted reverse  lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">wdegrevlex(V::AbstractVector{&lt;:MPolyRingElem}, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables and a vector <code>W</code> of positive integers, return the corresponding weighted reverse  lexicographical ordering on the set of monomials in the given variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = wdegrevlex(R, [1, 2, 3, 4])
wdegrevlex([w, x, y, z], [1, 2, 3, 4])

julia&gt; canonical_matrix(o1)
[1    2    3    4]
[0    0    0   -1]
[0    0   -1    0]
[0   -1    0    0]

julia&gt; o2 = wdegrevlex([w, x], [1, 2])
wdegrevlex([w, x], [1, 2])

julia&gt; o3 = wdegrevlex(gens(R)[3:4], [3, 4])
wdegrevlex([y, z], [3, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L959-L990">source</a></section></article><h2 id="Predefined-Local-Orderings"><a class="docs-heading-anchor" href="#Predefined-Local-Orderings">Predefined Local Orderings</a><a id="Predefined-Local-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Predefined-Local-Orderings" title="Permalink"></a></h2><h4 id="The-Negative-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Negative-Lexicographical-Ordering">The Negative Lexicographical Ordering</a><a id="The-Negative-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Negative-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>negative lexicographical ordering</em> <code>neglex</code> is defined by setting</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;\exists \; 1 \leq i \leq n: \alpha_1 = \beta_1, \dots, \alpha_{i-1} = \beta_{i-1}, \alpha_i &lt; \beta_i.\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="neglex-Tuple{MPolyRing}" href="#neglex-Tuple{MPolyRing}"><code>neglex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neglex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the negative lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">neglex(V::AbstractVector{&lt;:MPolyRingElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the negative lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = neglex(R)
neglex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[-1    0    0    0]
[ 0   -1    0    0]
[ 0    0   -1    0]
[ 0    0    0   -1]

julia&gt; o2 = neglex([w, x])
neglex([w, x])

julia&gt; o3 = neglex(gens(R)[3:4])
neglex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L584-L613">source</a></section></article><h4 id="The-Negative-Degree-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Negative-Degree-Lexicographical-Ordering">The Negative Degree Lexicographical Ordering</a><a id="The-Negative-Degree-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Negative-Degree-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>negative degree lexicographical ordering</em> <code>negdeglex</code> is defined by setting <span>$\;\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;  \deg(x^\alpha) &lt; \deg(x^\beta)  \;\text{ or }\; (\deg(x^\alpha) = \deg(x^\beta) \;\text{ and }\;  \exists \; 1 \leq i \leq n: \alpha_1 = \beta_1, \dots, \alpha_{i-1} = \beta_{i-1}, \alpha_i &gt; \beta_i).\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="negdeglex-Tuple{MPolyRing}" href="#negdeglex-Tuple{MPolyRing}"><code>negdeglex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negdeglex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the negative degree lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">negdeglex(V::AbstractVector{&lt;:MPolyRingElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the negative degree lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = negdeglex(R)
negdeglex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[-1   -1   -1   -1]
[ 0   -1   -1   -1]
[ 0    0   -1   -1]
[ 0    0    0   -1]

julia&gt; o2 = negdeglex([w, x])
negdeglex([w, x])

julia&gt; o3 = negdeglex(gens(R)[3:4])
negdeglex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L784-L813">source</a></section></article><h4 id="The-Negative-Inverse-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Negative-Inverse-Lexicographical-Ordering">The Negative Inverse Lexicographical Ordering</a><a id="The-Negative-Inverse-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Negative-Inverse-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>negative inverse lexicographical ordering</em> <code>neginvlex</code> is defined by setting</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;\exists \; 1 \leq i \leq n: \alpha_n = \beta_n, \dots, \alpha_{i+1} = \beta_{i+1}, \alpha_i  &lt; \beta_i.\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="neginvlex-Tuple{MPolyRing}" href="#neginvlex-Tuple{MPolyRing}"><code>neginvlex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neginvlex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the negative inverse lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">neginvlex(V::AbstractVector{&lt;:MPolyRingElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the negative inverse lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = neginvlex(R)
neginvlex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[ 0    0    0   -1]
[ 0    0   -1    0]
[ 0   -1    0    0]
[-1    0    0    0]

julia&gt; o2 = neginvlex([w, x])
neginvlex([w, x])

julia&gt; o3 = neginvlex(gens(R)[3:4])
neginvlex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L648-L677">source</a></section></article><h4 id="The-Negative-Degree-Reverse-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Negative-Degree-Reverse-Lexicographical-Ordering">The Negative Degree Reverse Lexicographical Ordering</a><a id="The-Negative-Degree-Reverse-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Negative-Degree-Reverse-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>negative degree reverse lexicographical ordering</em> <code>negdegrevlex</code> is defined by setting <span>$\;\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \; \deg(x^\alpha) &lt; \deg(x^\beta)  \;\text{ or }\;(\deg(x^\alpha) = \deg(x^\beta) \;\text{ and }\; \exists \; 1 \leq i \leq n: \alpha_n = \beta_n, \dots, \alpha_{i+1} = \beta_{i+1}, \alpha_i &lt; \beta_i).\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="negdegrevlex-Tuple{MPolyRing}" href="#negdegrevlex-Tuple{MPolyRing}"><code>negdegrevlex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negdegrevlex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the negative degree reverse lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">negdegrevlex(V::AbstractVector{&lt;:MPolyRingElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the negative degree reverse lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = negdegrevlex(R)
negdegrevlex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[-1   -1   -1   -1]
[ 0    0    0   -1]
[ 0    0   -1    0]
[ 0   -1    0    0]

julia&gt; o2 = negdegrevlex([w, x])
negdegrevlex([w, x])

julia&gt; o3 = negdegrevlex(gens(R)[3:4])
negdegrevlex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L712-L741">source</a></section></article><h4 id="Negative-Weighted-Lexicographical-Orderings"><a class="docs-heading-anchor" href="#Negative-Weighted-Lexicographical-Orderings">Negative Weighted Lexicographical Orderings</a><a id="Negative-Weighted-Lexicographical-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Negative-Weighted-Lexicographical-Orderings" title="Permalink"></a></h4><p>If <code>W</code> is a vector of positive integers  <span>$w_1, \dots, w_n$</span>, the corresponding <em>negative weighted lexicographical ordering</em> <code>negwdeglex(W)</code>  is defined by setting <span>$\;\text{wdeg}(x^\alpha) = w_1\alpha_1 + \cdots + w_n\alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;  \text{wdeg}(x^\alpha) &lt; \text{wdeg}(x^\beta)  \;\text{ or }\;\\
(\text{wdeg}(x^\alpha) = \text{wdeg}(x^\beta)  \;\text{ and }\; \exists \; 1 \leq i \leq n: \alpha_1 = \beta_1, \dots, \alpha_{i-1} = \beta_{i-1}, \alpha_i &gt; \beta_i).\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="negwdeglex-Tuple{MPolyRing, Vector{Int64}}" href="#negwdeglex-Tuple{MPolyRing, Vector{Int64}}"><code>negwdeglex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negwdeglex(R::MPolyRing, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>If <code>W</code> is a vector of positive integers, return the corresponding negative weighted  lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">negwdeglex(V::AbstractVector{&lt;:MPolyRingElem}, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables and a vector <code>W</code> of positive integers, return the corresponding negative weighted lexicographical ordering on the set of monomials in the given variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = negwdeglex(R, [1, 2, 3, 4])
negwdeglex([w, x, y, z], [1, 2, 3, 4])

julia&gt; canonical_matrix(o1)
[-1   -2   -3   -4]
[ 0   -2   -3   -4]
[ 0    0   -3   -4]
[ 0    0    0   -1]

julia&gt; o2 = negwdeglex([w, x], [1, 2])
negwdeglex([w, x], [1, 2])

julia&gt; o3 = negwdeglex(gens(R)[3:4], [3, 4])
negwdeglex([y, z], [3, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L1028-L1059">source</a></section></article><h4 id="Negative-Weighted-Reverse-Lexicographical-Orderings"><a class="docs-heading-anchor" href="#Negative-Weighted-Reverse-Lexicographical-Orderings">Negative Weighted Reverse Lexicographical Orderings</a><a id="Negative-Weighted-Reverse-Lexicographical-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Negative-Weighted-Reverse-Lexicographical-Orderings" title="Permalink"></a></h4><p>If <code>W</code> is a vector of positive integers  <span>$w_1, \dots, w_n$</span>, the corresponding <em>negative weighted reverse lexicographical ordering</em> <code>negwdegrevlex(W)</code>  is defined by setting <span>$\;\text{wdeg}(x^\alpha) = w_1\alpha_1 + \cdots + w_n\alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \; \text{wdeg}(x^\alpha) &lt; \text{wdeg}(x^\beta)  \;\text{ or }\;\\
(\text{wdeg}(x^\alpha) = \text{wdeg}(x^\beta)  \;\text{ and }\; \exists \; 1 \leq i \leq n: \alpha_n = \beta_n, \dots, \alpha_{i+1} = \beta_{i+1}, \alpha_i &lt; \beta_i).\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="negwdegrevlex-Tuple{MPolyRing, Vector{Int64}}" href="#negwdegrevlex-Tuple{MPolyRing, Vector{Int64}}"><code>negwdegrevlex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negwdegrevlex(R::MPolyRing, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>If <code>W</code> is a vector of positive integers, return the corresponding negative weighted reverse lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">negwdegrevlex(V::AbstractVector{&lt;:MPolyRingElem}, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables and a vector <code>W</code> of positive integers, return the corresponding negative weighted reverse lexicographical ordering on the set of monomials in the given variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o1 = negwdegrevlex(R, [1, 2, 3, 4])
negwdegrevlex([w, x, y, z], [1, 2, 3, 4])

julia&gt; canonical_matrix(o1)
[-1   -2   -3   -4]
[ 0    0    0   -1]
[ 0    0   -1    0]
[ 0   -1    0    0]

julia&gt; o2 = negwdegrevlex([w, x], [1, 2])
negwdegrevlex([w, x], [1, 2])

julia&gt; o3 = negwdegrevlex(gens(R)[3:4], [3, 4])
negwdegrevlex([y, z], [3, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L1097-L1128">source</a></section></article><h2 id="Weight-Orderings"><a class="docs-heading-anchor" href="#Weight-Orderings">Weight Orderings</a><a id="Weight-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Weight-Orderings" title="Permalink"></a></h2><p>If <span>$W$</span> is a vector of integers  <span>$w_1, \dots, w_n$</span>, and <span>$&gt;$</span> is a monomial ordering on <span>$\text{Mon}_n(x)$</span>, then the corresponding <em>weight ordering</em> is defined by setting <span>$\;\text{wdeg}(x^\alpha) = w_1\alpha_1 + \cdots + w_n\alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt;_{W} x^\beta \;  \Leftrightarrow \; \text{wdeg}(x^\alpha) &gt; \text{wdeg}(x^\beta)  \;\text{ or }\;
(\text{wdeg}(x^\alpha) = \text{wdeg}(x^\beta)  \;\text{ and }\; x^\alpha &gt; x^\beta).\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="weight_ordering-Tuple{Vector{Int64}, MonomialOrdering}" href="#weight_ordering-Tuple{Vector{Int64}, MonomialOrdering}"><code>weight_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weight_ordering(W::Vector{Int}, ord::MonomialOrdering) -&gt; MonomialOrdering</code></pre><p>Given an integer vector <code>W</code> and a monomial ordering <code>ord</code> on a set of monomials in <code>length(W)</code> variables, return the monomial ordering <code>ord_W</code> on this set of monomials which is obtained by first comparing the <code>W</code>-weighted degrees and then using <code>ord</code>  in the case of a tie.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The ordering <code>ord_W</code> is   </p><ul><li>global if all entries of <code>W</code> are positive, or if they are all non-negative and <code>ord</code> is global,</li><li>an elimination ordering for the set of variables which correspond to positive entries of <code>W</code>.   </li></ul></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; W = [1, 0, -1];

julia&gt; o = lex(R)
lex([x, y, z])

julia&gt; matrix(o)
[1   0   0]
[0   1   0]
[0   0   1]

julia&gt; oW = weight_ordering(W, o)
matrix_ordering([x, y, z], [1 0 -1])*lex([x, y, z])

julia&gt; matrix(oW)
[1   0   -1]
[1   0    0]
[0   1    0]
[0   0    1]

julia&gt; canonical_matrix(oW)
[1   0   -1]
[0   0    1]
[0   1    0]

julia&gt; o2 = weight_ordering([1, -1], lex([x, z]))
matrix_ordering([x, z], [1 -1])*lex([x, z])

julia&gt; canonical_matrix(o2)
[1   0   -1]
[0   0    1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L1234-L1282">source</a></section></article><h2 id="Block-Orderings"><a class="docs-heading-anchor" href="#Block-Orderings">Block Orderings</a><a id="Block-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Orderings" title="Permalink"></a></h2><p>The concept of block orderings (product orderings) allows one to construct new monomial orderings from already given ones: If <span>$&gt;_1$</span> and <span>$&gt;_2$</span> are monomial orderings on <span>$\text{Mon}_s(x_1, \ldots, x_s)$</span> and <span>$\text{Mon}_{n-s}(x_{s+1}, \ldots, x_n)$</span>, respectively, then the <em>block ordering</em> <span>$&gt; \; = \; (&gt;_1, &gt;_2)$</span> on <span>$\text{Mon}_n(x)=\text{Mon}_n(x_1, \ldots, x_n)$</span> is defined by setting</p><p class="math-container">\[x^\alpha&gt;x^\beta  \;\Leftrightarrow\;  x_1^{\alpha_1}\cdots x_s^{\alpha_s} &gt;_1 x_1^{\beta_1}\cdots x_s^{\beta_s} \;\text{ or }\;
\bigl(x_1^{\alpha_1}\cdots x_s^{\alpha_s} = x_1^{\beta_1}\cdots x_s^{\beta_s} \text{ and }  x_{s+1}^{\alpha_{s+1}}\cdots x_n^{\alpha_n} &gt;_2
x_{s+1}^{\beta_{s+1}}\cdots x_n^{\beta_n}\bigr).\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The ordering  <span>$(&gt;_1, &gt;_2)$</span></p><ul><li>is global (local) iff both <span>$&gt;_1$</span> and <span>$&gt;_2$</span> are global (local). Mixed orderings arise by choosing one of <span>$&gt;_1$</span> and <span>$&gt;_2$</span> global and the other one local,</li><li>is an elimination ordering for the first block of variables iff <span>$&gt;_1$</span> is global.</li></ul></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>The definition of a block ordering above subdivides <span>$x$</span> into a block of initial variables and its complementary block of variables.   Block orderings for a subdivision of <span>$x$</span> into any block of variables and its complementary block are defined similarly and have similar properties.</li><li>Inductively, one obtains block orderings composed of more than two individual orderings.</li></ul></div></div><p>In OSCAR, block orderings are obtained by the concatenation of individual  orderings using the <code>*</code> operator.</p><h5 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 4 variables over QQ, QQMPolyRingElem[w, x, y, z])

julia&gt; o = degrevlex([w, x])*degrevlex([y, z])
degrevlex([w, x])*degrevlex([y, z])
</code></pre><h2 id="Elimination-Orderings"><a class="docs-heading-anchor" href="#Elimination-Orderings">Elimination Orderings</a><a id="Elimination-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Elimination-Orderings" title="Permalink"></a></h2><p>Let <span>$C[x]=C[x_1, \ldots, x_n]$</span> be a multivariate polynomial ring with coefficient ring <span>$C$</span>. Fix a subset <span>$\sigma\subset \{1,\dots, n\}$</span> and write <span>$x_\sigma$</span>  for the set of variables <span>$x_i$</span> with <span>$i\in\sigma$</span>. An <em>elimination ordering for <span>$x\smallsetminus x_\sigma$</span></em>  is a monomial ordering <span>$&gt;$</span> on <span>$\text{Mon}_n(x)$</span> which satisfies the following property: If <span>$a$</span> is a monomial involving one of the variables in <span>$x\smallsetminus x_\sigma$</span> , and <span>$b$</span> is a monomial depending only on the variables in  <span>$x_\sigma$</span>, then <span>$a &gt; b.$</span> Computing a Gröbner basis of <span>$I$</span> with respect to such an ordering provides one way of finding the intersection <span>$I\cap C[x_\sigma]$</span>, that is, of  <em>eliminating the variables in <span>$x\smallsetminus x_\sigma$</span> from <span>$I$</span></em>: The Gröbner basis elements which only depend on the variables in <span>$x_\sigma$</span> form a Gröbner basis for <span>$I\cap C[x_\sigma]$</span> with respect to the restriction of <span>$&gt;$</span> to the set of monomials in <span>$I\cap C[x_\sigma]$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The lexicographical ordering is an elimination ordering for each initial set of variables <span>$x_1, \dots, x_k$</span>. If only a fixed subset of variables is considered, suitable weight or block orderings as discussed above are more effective. The documentation of the <code>is_elimination_ordering</code> function below offers examples and non-examples.</p></div></div><h2 id="Tests-on-Monomial-Orderings"><a class="docs-heading-anchor" href="#Tests-on-Monomial-Orderings">Tests on Monomial Orderings</a><a id="Tests-on-Monomial-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-on-Monomial-Orderings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_elimination_ordering-Tuple{MonomialOrdering, Vector{&lt;:MPolyRingElem}}" href="#is_elimination_ordering-Tuple{MonomialOrdering, Vector{&lt;:MPolyRingElem}}"><code>is_elimination_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_elimination_ordering(ord::MonomialOrdering, V::Vector{&lt;:MPolyRingElem})</code></pre><p>Given a vector <code>V</code> of polynomials which are variables, return <code>true</code> if <code>ord</code> is an elimination ordering for the variables in <code>V</code>. Return <code>false</code>, otherwise.</p><pre><code class="nohighlight hljs">is_elimination_ordering(ord::MonomialOrdering, V:Vector{Int})</code></pre><p>Given a vector <code>V</code> of indices which specify variables, return <code>true</code> if <code>ord</code> is an elimination ordering for the specified variables. Return <code>false</code>, otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; o1 = lex(R)
lex([w, x, y, z])

julia&gt; is_elimination_ordering(o1, [w, x])
true

julia&gt; o2 = weight_ordering([1, 1, 0, 0], degrevlex(R))
matrix_ordering([w, x, y, z], [1 1 0 0])*degrevlex([w, x, y, z])

julia&gt; is_elimination_ordering(o2, [w, x])
true

julia&gt; o3 = weight_ordering([1, -1, 0, 0], degrevlex(R))
matrix_ordering([w, x, y, z], [1 -1 0 0])*degrevlex([w, x, y, z])

julia&gt; is_elimination_ordering(o3, [w, x])
false

julia&gt; o4 = degrevlex([w, x])*degrevlex([y, z])
degrevlex([w, x])*degrevlex([y, z])

julia&gt; is_elimination_ordering(o4, [w, x])
true

julia&gt; o5 = degrevlex([w, x])*negdegrevlex([y, z])
degrevlex([w, x])*negdegrevlex([y, z])

julia&gt; is_elimination_ordering(o5, [w, x])
true

julia&gt; o6 = negdegrevlex([w, x])*negdegrevlex([y, z])
negdegrevlex([w, x])*negdegrevlex([y, z])

julia&gt; is_elimination_ordering(o6, [w, x])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L1613-L1664">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_global-Tuple{MonomialOrdering}" href="#is_global-Tuple{MonomialOrdering}"><code>is_global</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_global(ord::MonomialOrdering)</code></pre><p>Return <code>true</code> if <code>ord</code> is global, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; o = matrix_ordering(R, [1 1; 0 -1])
matrix_ordering([x, y], [1 1; 0 -1])

julia&gt; is_global(o)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L1451-L1466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_local-Tuple{MonomialOrdering}" href="#is_local-Tuple{MonomialOrdering}"><code>is_local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_local(ord::MonomialOrdering)</code></pre><p>Return <code>true</code> if <code>ord</code> is local, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; o = matrix_ordering(R, [-1 -1; 0 -1])
matrix_ordering([x, y], [-1 -1; 0 -1])

julia&gt; is_local(o)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L1477-L1492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_mixed-Tuple{MonomialOrdering}" href="#is_mixed-Tuple{MonomialOrdering}"><code>is_mixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_mixed(ord::MonomialOrdering)</code></pre><p>Return <code>true</code> if <code>ord</code> is mixed, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; o = matrix_ordering(R, [1 -1; 0 -1])
matrix_ordering([x, y], [1 -1; 0 -1])

julia&gt; is_mixed(o)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L1503-L1518">source</a></section></article><h2 id="Transferring-an-ordering-from-another-ring"><a class="docs-heading-anchor" href="#Transferring-an-ordering-from-another-ring">Transferring an ordering from another ring</a><a id="Transferring-an-ordering-from-another-ring-1"></a><a class="docs-heading-anchor-permalink" href="#Transferring-an-ordering-from-another-ring" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="induce-Tuple{AbstractVector{&lt;:MPolyRingElem}, MonomialOrdering}" href="#induce-Tuple{AbstractVector{&lt;:MPolyRingElem}, MonomialOrdering}"><code>induce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">induce(vars::AbstractVector{&lt;:MPolyRingElem}, ord::MonomialOrdering)</code></pre><p>Return the monomial ordering on the variables <code>vars</code> induced by transferring the ordering <code>ord</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; S, (a, b, c) = polynomial_ring(GF(5), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);

julia&gt; ord = degrevlex([x, y])*neglex([z]);

julia&gt; induce([a, b, c], ord)
degrevlex([a, b])*neglex([c])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L1721-L1738">source</a></section></article><h2 id="Module-Orderings"><a class="docs-heading-anchor" href="#Module-Orderings">Module Orderings</a><a id="Module-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Orderings" title="Permalink"></a></h2><p>Let <span>$R = C[x]=C[x_1, \ldots, x_n]$</span> be a multivariate polynomial ring with coefficient ring <span>$C$</span>. Referring to the section on free modules for details, we recall that by a free <span>$R$</span>-module we mean a free module of type <span>$R^p$</span> , where we think of <span>$R^p$</span> as a free module with a given basis, namely the basis of standard unit vectors. In what follows, <span>$F$</span> will denote such free <span>$R$</span>-module, and <span>$\{e_1 ,\dots , e_p\}$</span> will denote the given basis.</p><p>A <em>monomial in <span>$F$</span></em>, involving the basis element <span>$e_i$</span>, is a monomial in <span>$R$</span> times <span>$e_i$</span>.  A term in <span>$F$</span> is a monomial in <span>$F$</span> multiplied by a coefficient <span>$c\in C$</span>. Every nonzero element <span>$f\in F$</span> can  be uniquely expressed as the sum of finitely many nonzero terms involving  distinct monomials. These terms (monomials)  are called the <em>terms (monomials} of <span>$f$</span>.</em></p><p>A <em>monomial ordering</em> on <span>$F$</span> is a total ordering <span>$&gt;$</span> on the set of monomials in <span>$F$</span> such that if <span>$x^\alpha e_i$</span> and <span>$x^\beta e_j$</span> are monomials in <span>$F$</span>, and <span>$x^\gamma$</span> is a monomial in <span>$R$</span>, then </p><p class="math-container">\[x^\alpha e_i &gt; x^\beta e_j \Longrightarrow x^\gamma x^\alpha e_i &gt; x^\gamma x^\beta e_j.\]</p><p>In OSCAR, we require in addition that</p><p class="math-container">\[x^\alpha e_i &gt; x^\beta e_i \;\text{ iff }\; x^\alpha e_j &gt; x^\beta e_j \;\text{ for all }\; i,j.\]</p><p>Then <span>$&gt;$</span> induces a unique monomial ordering on <span>$R$</span> in the obvious way, and we say that  <span>$&gt;$</span> is <em>global</em>, <em>local</em>, or <em>mixed</em> if the induced ordering on <span>$R$</span> is global, local, or mixed. </p><p>One way of getting a monomial ordering on <span>$F$</span> is to pick a monomial ordering <span>$&gt;$</span> on <span>$R$</span>, and extend it to <span>$F$</span>. For instance, setting</p><p class="math-container">\[x^\alpha e_i &gt;  x^\beta e_j \iff x^\alpha &gt; x^\beta \;\text{ or }\; (x^\alpha = x^\beta \;\text{ and }\; i &gt; j)\]</p><p>gives priority to the monomials in <span>$R$</span>, whereas the ordering defined below gives priority to the components of <span>$F$</span>:</p><p class="math-container">\[x^\alpha e_i &gt;  x^\beta e_j \iff i &gt; j \;\text{ or }\; (i = j\;\text{ and } x^\alpha &gt; x^\beta).\]</p><p>Alternatively, we may wish to use <span>$i &lt; j$</span> instead of <span>$i &gt; j$</span> in this definition.</p><p>In other words, these orderings are obtained by concatenating a monomial ordering on the monomials of <span>$R$</span> with a way of ordering the basis vectors of <span>$F$</span> or vice versa. In OSCAR, we refer to the <span>$i &lt; j$</span> ordering on the basis vectors as <em>lex</em>, and to the <span>$i &gt; j$</span> ordering as <em>invlex</em>. And, we use the <code>*</code> operator for concatenation. </p><h5 id="Examples-3"><a class="docs-heading-anchor" href="#Examples-3">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-3" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; F = free_module(R, 3)
Free module of rank 3 over R

julia&gt; o1 = degrevlex(R)*invlex(gens(F))
degrevlex([w, x, y, z])*invlex([gen(1), gen(2), gen(3)])

julia&gt; o2 = invlex(gens(F))*degrevlex(R)
invlex([gen(1), gen(2), gen(3)])*degrevlex([w, x, y, z])
</code></pre><p>The induced ordering on the given polynomial ring is recovered as follows:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="induced_ring_ordering-Tuple{ModuleOrdering}" href="#induced_ring_ordering-Tuple{ModuleOrdering}"><code>induced_ring_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">induced_ring_ordering(ord::ModuleOrdering)</code></pre><p>Return the ring ordering induced by <code>ord</code>.  </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; F = free_module(R, 3)
Free module of rank 3 over R

julia&gt; o = invlex(gens(F))*degrevlex(R)
invlex([gen(1), gen(2), gen(3)])*degrevlex([w, x, y, z])

julia&gt; induced_ring_ordering(o)
degrevlex([w, x, y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/db7a197dbd12b1e688bec3ba325950249aeb1c25/src/Rings/orderings.jl#L1919-L1937">source</a></section></article><p>The comparison function <code>cmp</code> as well as the tests <code>is_global</code>, <code>is_local</code>, and <code>is_mixed</code> are also available for module orderings.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../homological_algebra/">« Homological Algebra</a><a class="docs-footer-nextpage" href="../groebner_bases/">Gröbner/Standard Bases Over Fields »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 21 June 2024 08:49">Friday 21 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
