<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Matroids · Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../Experimental/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/visualization/">Visualization</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/groebner_bases/">Gröbner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/groebner_bases_integers/">Gröbner/Standard Bases Over <span>$\mathbb Z$</span></a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ideals/">Ideals in Multivariate Rings</a></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">Modules Over Multivariate Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/">Subquotient Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/homological_algebra/">Homological Algebra</a></li></ul></li><li><a class="tocitem" href="../../CommutativeAlgebra/affine_algebras/">Affine Algebras</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/binomial_ideals/">Binomial Primary Decomposition</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/localizations/">Localization</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/module_localizations/">Localizations of modules over computable rings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../TropicalGeometry/curve/">Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Standard Constructions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/StandardConstructions/standard_constructions/">Standard Constructions in Algebraic Geometry</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/K3Surfaces/">Algebraic Surfaces</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Finitely Presented Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox" checked/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../graphs/">Graphs</a></li><li class="is-active"><a class="tocitem" href>Matroids</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Construction"><span>Construction</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Properties"><span>Properties</span></a></li></ul></li><li><a class="tocitem" href="../simplicialcomplexes/">Simplicial Complexes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-7" type="checkbox"/><label class="tocitem" for="menuitem-17-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Combinatorics</a></li><li class="is-active"><a href>Matroids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Matroids</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/Combinatorics/matroids.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#Matroids">Matroids</a></li><li class="no-marker"><ul><li><a href="#Introduction">Introduction</a></li><li><a href="#Construction">Construction</a></li><li><a href="#Examples">Examples</a></li><li><a href="#Properties">Properties</a></li></ul></li></ul><h1 id="Matroids"><a class="docs-heading-anchor" href="#Matroids">Matroids</a><a id="Matroids-1"></a><a class="docs-heading-anchor-permalink" href="#Matroids" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Matroids are a fundamental combinatorial object with connections to various fields of mathematics. It is an abstraction of linear independence in vector spaces and forests in graphs. One way to define a <em>matroid</em> is via the following two sets of data:</p><ul><li>a finite <em>ground set</em> <span>$E := \{1,\ldots,n\}$</span> and</li><li>a nonempty finite set <span>$\mathcal{B} \subseteq \mathcal{P}(E)$</span> of <em>bases</em> satisfying an exchange property.</li></ul><p>There are however many equivalent ways to define a matroid. One can also define a matroid via its <em>circuits</em>, <em>hyperplanes</em>, a <em>graph</em>, or a <em>matrix</em>. For a detailed introduction of matroids we refer to the textbook <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><h2 id="Construction"><a class="docs-heading-anchor" href="#Construction">Construction</a><a id="Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Construction" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="matroid_from_bases-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, fmpz}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}" href="#matroid_from_bases-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, fmpz}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}"><code>matroid_from_bases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_bases(B, [n, E])</code></pre><p><strong>Arguments</strong></p><ul><li><code>B::AbstractVector</code>: The set of bases of the matroid.</li><li><code>n::InterUnion</code>: The size of the ground set. The ground set will be <code>{1,..n}</code> in this case.</li><li><code>E::AbstractVector</code>: An explicit ground set passed as vector.</li></ul><p>Construct a <code>matroid</code> with bases <code>B</code> on the ground set <code>E</code> (which can be the empty set). The set <code>B</code> is a non-empty collection of subsets of the ground set <code>E</code> satisfying an exchange property, and the default value for <code>E</code> is the set <code>{1,..n}</code> for a non-negative value <code>n</code>.</p><p>See Section 1.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct a rank two matroid with five bases on four elements you can write:</p><pre><code class="language-julia-repl hljs">julia&gt; B = [[1,2],[1,3],[1,4],[2,3],[2,4]];

julia&gt; M = matroid_from_bases(B,4)
Matroid of rank 2 on 4 elements</code></pre><p>To construct the same matroid on the four elements 1,2,i,j you may write:</p><pre><code class="language-julia-repl hljs">julia&gt; M = matroid_from_bases([[1,2],[1,&#39;i&#39;],[1,&#39;j&#39;],[2,&#39;i&#39;],[2,&#39;j&#39;]],[1,2,&#39;i&#39;,&#39;j&#39;])
Matroid of rank 2 on 4 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matroid_from_nonbases-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, fmpz}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}" href="#matroid_from_nonbases-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, fmpz}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}"><code>matroid_from_nonbases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_nonbases(N, [n, E])</code></pre><p><strong>Arguments</strong></p><ul><li><code>N::AbstractVector</code>: The set of nonbases of the matroid.</li><li><code>n::InterUnion</code>: The size of the ground set. The ground set will be <code>{1,..n}</code> in this case.</li><li><code>E::AbstractVector</code>: An explicit ground set passed as vector.</li></ul><p>Construct a <code>matroid</code> with nonbases <code>N</code> on the ground set <code>E</code> (which can be the empty set). That means that the matroid has as bases all subsets of the size <code>|N[1]|</code> of the ground set that are not in <code>N</code>. The set <code>N</code> can&#39;t be empty in this function. The described complement of <code>N</code> needs to be a non-empty collection of subsets of the ground set <code>E</code> satisfying an exchange property, and the default value for <code>E</code> is the set <code>{1,..n}</code> for a non-negative value <code>n</code>.</p><p>See Section 1.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the Fano matroid you may write:</p><pre><code class="language-julia-repl hljs">julia&gt; H = [[1,2,4],[2,3,5],[1,3,6],[3,4,7],[1,5,7],[2,6,7],[4,5,6]];

julia&gt; M = matroid_from_nonbases(H,7)
Matroid of rank 3 on 7 elements
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matroid_from_circuits-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, fmpz}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}" href="#matroid_from_circuits-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, fmpz}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}"><code>matroid_from_circuits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_circuits(C, [n, E])</code></pre><p><strong>Arguments</strong></p><ul><li><code>C::AbstractVector</code>: The set of circuits of the matroid.</li><li><code>n::InterUnion</code>: The size of the ground set. The ground set will be <code>{1,..n}</code> in this case.</li><li><code>E::AbstractVector</code>: An explicit ground set passed as vector.</li></ul><p>A matroid with circuits <code>C</code> on the ground set <code>E</code> (which can be the empty set). The set <code>C</code> is a collection of subsets of the ground set <code>E</code> satisfying an exchange property, and the default value for <code>E</code> is the set <code>{1,..n}</code> for a non-negative value <code>n</code>. </p><p>See Section 1.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct a rank two matroid with five bases on four elements by its circuits you may write:</p><pre><code class="language-julia-repl hljs">julia&gt; C = [[1,2,3],[1,2,4],[3,4]];

julia&gt; M = matroid_from_circuits(C,4)
Matroid of rank 2 on 4 elements</code></pre><p>To construct the same matroid on the ground set <code>{1,2,i,j}</code> you may write:</p><pre><code class="language-julia-repl hljs">julia&gt; C = [[1,2,&#39;j&#39;],[1,2,&#39;i&#39;],[&#39;i&#39;,&#39;j&#39;]];

julia&gt; M = matroid_from_circuits(C,[1,2,&#39;i&#39;,&#39;j&#39;])
Matroid of rank 2 on 4 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matroid_from_hyperplanes-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, fmpz}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}" href="#matroid_from_hyperplanes-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, fmpz}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}"><code>matroid_from_hyperplanes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_hyperplanes(H, [n, E])</code></pre><p><strong>Arguments</strong></p><ul><li><code>H::AbstractVector</code>: The set of hyperplanes of the matroid.</li><li><code>n::InterUnion</code>: The size of the ground set. The ground set will be <code>{1,..n}</code> in this case.</li><li><code>E::AbstractVector</code>: An explicit ground set passed as vector.</li></ul><p>A matroid with hyperplanes <code>H</code> on the ground set <code>E</code> (which can be the empty set). A hyperplane is a flat of rank <code>r-1</code>. The set <code>H</code> is a collection of subsets of the ground set <code>E</code> satisfying an exchange property, and the default value for <code>E</code> is the set <code>{1,..n}</code> for a non-negative value <code>n</code>. </p><p>See Section 1.4 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the Fano matroid you may write:</p><pre><code class="language-julia-repl hljs">julia&gt; H = [[1,2,4],[2,3,5],[1,3,6],[3,4,7],[1,5,7],[2,6,7],[4,5,6]];

julia&gt; M = matroid_from_hyperplanes(H,7)
Matroid of rank 3 on 7 elements
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matroid_from_matrix_columns-Tuple{MatrixElem{T} where T}" href="#matroid_from_matrix_columns-Tuple{MatrixElem{T} where T}"><code>matroid_from_matrix_columns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_matrix_columns(A::MatrixElem)</code></pre><p>A matroid represented by the column vectors of a matrix <code>A</code>.</p><p>See Section 1.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the vector matroid (a.k.a linear matroid) of the matrix <code>A</code> over the field with two elements write:</p><pre><code class="language-julia-repl hljs">julia&gt; A = matrix(GF(2),[[1,0,1,1],[0,1,1,1]]);

julia&gt; M = matroid_from_matrix_columns(A)
Matroid of rank 2 on 4 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matroid_from_matrix_rows-Tuple{MatrixElem{T} where T}" href="#matroid_from_matrix_rows-Tuple{MatrixElem{T} where T}"><code>matroid_from_matrix_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_matrix_columns(A::MatrixElem)</code></pre><p>A matroid represented by the row vectors of a matrix.</p><p>See Section 1.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the linear matroid of the rows of the matrix <code>A</code> over the field with two elements write:</p><pre><code class="language-julia-repl hljs">julia&gt; A = matrix(GF(2),[[1,0],[0,1],[1,1],[1,1]]);

julia&gt; M = matroid_from_matrix_rows(A)
Matroid of rank 2 on 4 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cycle_matroid-Tuple{Graph}" href="#cycle_matroid-Tuple{Graph}"><code>cycle_matroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cycle_matroid(g::Graph)</code></pre><p>The cycle matroid of a graph <code>g</code>.</p><p>See Section 1.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the cycle matroid of the complete graph of 4 vertices write:</p><pre><code class="language-julia-repl hljs">julia&gt; g = complete_graph(4);

julia&gt; M = cycle_matroid(g)
Matroid of rank 3 on 6 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="bond_matroid-Tuple{Graph}" href="#bond_matroid-Tuple{Graph}"><code>bond_matroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bond_matroid(g::Graph)</code></pre><p>The &quot;bond matroid&quot; or &quot;cocycle matroid&quot; of a graph which is the dual of a cycle matroid, i.e., cographic.</p><p>See Section 2.3 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the bond or cocycle matroid of the complete graph of 4 vertices write:</p><pre><code class="language-julia-repl hljs">julia&gt; g = complete_graph(4);

julia&gt; M = bond_matroid(g)
Matroid of rank 3 on 6 elements</code></pre><p>or equivalently</p><pre><code class="language-julia-repl hljs">julia&gt; g = complete_graph(4);

julia&gt; M = cocycle_matroid(g)
Matroid of rank 3 on 6 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cocycle_matroid-Tuple{Graph}" href="#cocycle_matroid-Tuple{Graph}"><code>cocycle_matroid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <code>bond_matroid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Matroid" href="#Matroid"><code>Matroid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matroid(pm_matroid::Polymake.BigObjectAllocated, [E::GroundsetType])</code></pre><p>Construct a <code>matroid</code> from a <code>polymake</code> matroid <code>M</code> on the default ground set <code>{1,...,n}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matroid_from_revlex_basis_encoding-Tuple{String, Union{Integer, fmpz}, Union{Integer, fmpz}}" href="#matroid_from_revlex_basis_encoding-Tuple{String, Union{Integer, fmpz}, Union{Integer, fmpz}}"><code>matroid_from_revlex_basis_encoding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_revlex_basis_encoding(rvlx::String, r::IntegerUnion, n::IntegerUnion)</code></pre><p>Construct a <code>matroid</code> from a revlex-basis-encoding-string <code>rvlx</code> of rank <code>r</code> and size <code>n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matroid_from_revlex_basis_encoding(&quot;0******0******0***0******0*0**0****&quot;, 3, 7)
Matroid of rank 3 on 7 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L46">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="uniform_matroid-Tuple{Union{Integer, fmpz}, Union{Integer, fmpz}}" href="#uniform_matroid-Tuple{Union{Integer, fmpz}, Union{Integer, fmpz}}"><code>uniform_matroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uniform_matroid(r,n)</code></pre><p>Construct the uniform matroid of rank <code>r</code> on the <code>n</code> elements <code>{1,...,n}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L721-L725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fano_matroid-Tuple{}" href="#fano_matroid-Tuple{}"><code>fano_matroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fano_matroid()</code></pre><p>Construct the Fano matroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L728-L732">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="non_fano_matroid-Tuple{}" href="#non_fano_matroid-Tuple{}"><code>non_fano_matroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">non_fano_matroid()</code></pre><p>Construct the non-Fano matroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L735-L739">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="non_pappus_matroid-Tuple{}" href="#non_pappus_matroid-Tuple{}"><code>non_pappus_matroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">non_pappus_matroid()</code></pre><p>Construct the non-Pappus matroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L742-L746">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="pappus_matroid-Tuple{}" href="#pappus_matroid-Tuple{}"><code>pappus_matroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pappus_matroid()</code></pre><p>Construct the Pappus matroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L749-L753">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="vamos_matroid-Tuple{}" href="#vamos_matroid-Tuple{}"><code>vamos_matroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vamos_matroid()</code></pre><p>Construct the Vamos matroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L756-L760">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="all_subsets_matroid-Tuple{Int64}" href="#all_subsets_matroid-Tuple{Int64}"><code>all_subsets_matroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_subsets_matroid(r)</code></pre><p>Construct the all-subsets-matroid of rank <code>r</code>, a.k.a. the matroid underlying the resonance arrangement or rank <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L763-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="projective_plane-Tuple{Int64}" href="#projective_plane-Tuple{Int64}"><code>projective_plane</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projective_plane(q::Int)</code></pre><p>The projective plane of order <code>q</code>. Note that this only works for prime numbers <code>q</code> for now.</p><p>See Section 6.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = projective_plane(3)
Matroid of rank 3 on 13 elements
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="projective_geometry-Tuple{Int64, Int64}" href="#projective_geometry-Tuple{Int64, Int64}"><code>projective_geometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projective_geometry(r::Int, q::Int)</code></pre><p>The projective geometry of order <code>q</code> and rank <code>r+1</code>. Note that this only works for prime numbers <code>q</code> for now.</p><p>See Section 6.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>. Warning: Following the book of Oxley, the rank of the resulting matroid is <code>r+1</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = projective_geometry(2, 3)
Matroid of rank 3 on 13 elements
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L800">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="affine_geometry-Tuple{Int64, Int64}" href="#affine_geometry-Tuple{Int64, Int64}"><code>affine_geometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">affine_geometry(r::Int, q::Int)</code></pre><p>The affine geometry of order <code>q</code> and rank <code>r+1</code>. Note that this only works for prime numbers <code>q</code> for now.</p><p>See Section 6.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>. Warning: Following the book of Oxley, the rank of the resulting matroid is <code>r+1</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = affine_geometry(2, 3)
Matroid of rank 3 on 9 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L837">source</a></section></article><h3 id="Modifying-matroids"><a class="docs-heading-anchor" href="#Modifying-matroids">Modifying matroids</a><a id="Modifying-matroids-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-matroids" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="dual_matroid-Tuple{Matroid}" href="#dual_matroid-Tuple{Matroid}"><code>dual_matroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual_matroid(M::Matroid)</code></pre><p>The <code>dual matroid</code> of a given matroid <code>M</code>.</p><p>See page 65 and Sectrion 2 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the dual of the Fano matroid write:</p><pre><code class="language-julia-repl hljs">julia&gt; M = dual_matroid(fano_matroid())
Matroid of rank 4 on 7 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="direct_sum-Tuple{Matroid, Matroid}" href="#direct_sum-Tuple{Matroid, Matroid}"><code>direct_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">direct_sum(M::Matroid, N::Matroid)</code></pre><p>The <code>direct sum</code> of the matroids <code>M</code> and <code>N</code>. Optionally one can also pass a vector of matroids.</p><p>See Section 4.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p>To obtain the direct sum of the Fano and a uniform matroid type:</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; direct_sum(fano_matroid(), uniform_matroid(2,4))
Matroid of rank 5 on 11 elements</code></pre><p>To take the sum of three uniform matroids use:</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matroids = Vector([uniform_matroid(2,4), uniform_matroid(1,3), uniform_matroid(3,4)]);

julia&gt; M = direct_sum(matroids)
Matroid of rank 6 on 11 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="deletion-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#deletion-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>deletion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deletion(M, [S, e])</code></pre><p><strong>Arguments</strong></p><ul><li><code>M::Matroid</code>: A matroid <code>M</code>.</li><li><code>S::GroundsetType</code>: A subset <code>S</code> of the ground set of <code>M</code>.</li><li><code>e::ElementType</code>: An element <code>e</code> of the ground set of <code>M</code>.</li></ul><p>The <code>deletion M\S</code> of an element <code>e</code> or a subset <code>S</code> of the ground set <code>E</code> of the matroid <code>M</code>.</p><p>See Section 3 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matroid_from_bases([[1,2],[1,&#39;i&#39;],[1,&#39;j&#39;],[2,&#39;i&#39;],[2,&#39;j&#39;]],[1,2,&#39;i&#39;,&#39;j&#39;]);

julia&gt; N = deletion(M,&#39;i&#39;)
Matroid of rank 2 on 3 elements</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matroid_from_bases([[1,2],[1,&#39;i&#39;],[1,&#39;j&#39;],[2,&#39;i&#39;],[2,&#39;j&#39;]],[1,2,&#39;i&#39;,&#39;j&#39;]);

julia&gt; N = deletion(M,[&#39;i&#39;,&#39;j&#39;])
Matroid of rank 2 on 2 elements

julia&gt; matroid_groundset(N)
2-element Vector{Any}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="restriction-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#restriction-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>restriction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">restriction(M, S)</code></pre><p><strong>Arguments</strong></p><ul><li><code>M::Matroid</code>: A matroid <code>M</code>.</li><li><code>S::GroundSetType</code>: A subset <code>S</code> of the ground set of <code>M</code>.</li></ul><p>The <code>restriction M|S</code> on a subset <code>S</code> of the ground set <code>E</code> of the matroid <code>M</code>.</p><p>See Section 3 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matroid_from_bases([[1,2],[1,&#39;i&#39;],[1,&#39;j&#39;],[2,&#39;i&#39;],[2,&#39;j&#39;]],[1,2,&#39;i&#39;,&#39;j&#39;]);

julia&gt; N = restriction(M,[1,2])
Matroid of rank 2 on 2 elements

julia&gt; matroid_groundset(N)
2-element Vector{Any}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="contraction-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#contraction-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>contraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contraction(M, [S, e])</code></pre><p><strong>Arguments</strong></p><ul><li><code>M::Matroid</code>: A matroid <code>M</code>.</li><li><code>S::GroundSetType</code>: A subset <code>S</code> of the ground set of <code>M</code>.</li><li><code>e::ElementType</code>: An element <code>e</code> of the ground set of <code>M</code>.</li></ul><p>The <code>contraction M/S</code> of an element or a subset <code>S</code> of the ground set <code>E</code> of the matroid <code>M</code>.</p><p>See Section 3 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matroid_from_bases([[1,2],[1,&#39;i&#39;],[1,&#39;j&#39;],[2,&#39;i&#39;],[2,&#39;j&#39;]],[1,2,&#39;i&#39;,&#39;j&#39;]);

julia&gt; N = contraction(M,&#39;i&#39;)
Matroid of rank 1 on 3 elements</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matroid_from_bases([[1,2],[1,&#39;i&#39;],[1,&#39;j&#39;],[2,&#39;i&#39;],[2,&#39;j&#39;]],[1,2,&#39;i&#39;,&#39;j&#39;]);

julia&gt; N = contraction(M,[&#39;i&#39;,&#39;j&#39;])
Matroid of rank 1 on 2 elements

julia&gt; matroid_groundset(N)
2-element Vector{Any}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="minor-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{AbstractSet, AbstractVector{T} where T}}" href="#minor-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{AbstractSet, AbstractVector{T} where T}}"><code>minor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minor(M::Matroid, set_del::GroundsetType, set_cont::GroundsetType)</code></pre><p>The <code>minor M\S/T</code> of disjoint subsets  <code>S</code> and <code>T</code> of the ground set <code>E</code> of the matroid <code>M</code>.</p><p>See also <code>contraction</code> and <code>deletion</code>. You can find more in Section 3 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; S = [1,2,3];

julia&gt; T = [4];

julia&gt;  N = minor(M,S,T) 
Matroid of rank 2 on 3 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="principal_extension-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, fmpz}}" href="#principal_extension-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, fmpz}}"><code>principal_extension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">principal_extension(M::Matroid, F::GroundsetType, e::ElementType)</code></pre><p>The <code>principal extension M +_F e</code> of a matroid <code>M</code> where the element <code>e</code> is freely added to the flat <code>F</code>.</p><p>See Section 7.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To add <code>5</code> freely to the flat <code>{1,2}</code> of the uniform matroid <code>U_{3,4}</code> do</p><pre><code class="language-julia-repl hljs">julia&gt; M = uniform_matroid(3,4);

julia&gt; N = principal_extension(M,[1,2],5)
Matroid of rank 3 on 5 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="free_extension-Tuple{Matroid, Union{Char, Integer, String, fmpz}}" href="#free_extension-Tuple{Matroid, Union{Char, Integer, String, fmpz}}"><code>free_extension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">free_extension(M::Matroid, e::ElementType)</code></pre><p>The <code>free extension M +_E e</code> of a matroid <code>M</code> where the element <code>e</code>.</p><p>See <span>$principal_extension$</span> and Section 7.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To add <code>5</code> freely to the uniform matroid <code>U_{3,4}</code> do</p><pre><code class="language-julia-repl hljs">julia&gt; M = uniform_matroid(3,4);

julia&gt;  N = free_extension(M,5)
Matroid of rank 3 on 5 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L649">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="series_extension-Tuple{Matroid, Union{Char, Integer, String, fmpz}, Union{Char, Integer, String, fmpz}}" href="#series_extension-Tuple{Matroid, Union{Char, Integer, String, fmpz}, Union{Char, Integer, String, fmpz}}"><code>series_extension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">series_extension(M::Matroid, f::ElementType, e::ElementType)</code></pre><p>The <code>series extension</code> of a matroid <code>M</code> where the element <code>e</code> is added in series to <code>f</code>.</p><p>This is actually a coextension see also Section 7.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To add <code>e</code> in series to <code>1</code> in the uniform matroid U_{3,4} do</p><pre><code class="language-julia-repl hljs">julia&gt; M = uniform_matroid(1,4);

julia&gt; N = series_extension(M,1,&#39;e&#39;)
Matroid of rank 2 on 5 elements

julia&gt; cocircuits(N)[1]
2-element Vector{Any}:
 1
  &#39;e&#39;: ASCII/Unicode U+0065 (category Ll: Letter, lowercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="parallel_extension-Tuple{Matroid, Union{Char, Integer, String, fmpz}, Union{Char, Integer, String, fmpz}}" href="#parallel_extension-Tuple{Matroid, Union{Char, Integer, String, fmpz}, Union{Char, Integer, String, fmpz}}"><code>parallel_extension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parallel_extension(M::Matroid, f::ElementType, e::ElementType)</code></pre><p>The <code>parallel extension M +_{cl(f)} e</code> of a matroid <code>M</code> where the element <code>e</code> is added parallel to (the closure of) <code>f</code>.</p><p>See Section 7.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To add <code>e</code> parallel to <code>1</code> in the uniform matroid <code>U_{3,4}</code> do</p><pre><code class="language-julia-repl hljs">julia&gt; M = uniform_matroid(3,4);

julia&gt; N = parallel_extension(M,1,&#39;e&#39;)
Matroid of rank 3 on 5 elements

julia&gt; circuits(N)[1]
2-element Vector{Any}:
 1
  &#39;e&#39;: ASCII/Unicode U+0065 (category Ll: Letter, lowercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L692">source</a></section></article><h2 id="Properties"><a class="docs-heading-anchor" href="#Properties">Properties</a><a id="Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="matroid_groundset-Tuple{Matroid}" href="#matroid_groundset-Tuple{Matroid}"><code>matroid_groundset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_groundset(M::Matroid)</code></pre><p>The ground set <code>E</code> of a matroid <code>M</code>.</p><p>To obtain the ground set of the Fano matroid write:</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matroid_groundset(fano_matroid())
7-element Vector{Int64}:
 1
 2
 3
 4
 5
 6
 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/matroids.jl#L414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="length-Tuple{Matroid}" href="#length-Tuple{Matroid}"><code>length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(M::Matroid)</code></pre><p>Return the size of the ground set of the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; length(fano_matroid())
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="rank-Tuple{Matroid}" href="#rank-Tuple{Matroid}"><code>rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rank(M::Matroid)</code></pre><p>Return the rank of the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rank(fano_matroid())
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="rank-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#rank-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rank(M::Matroid, set::GroundsetType)</code></pre><p>Return the rank of <code>set</code> in the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; rank(M, [1,2,3])
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="bases-Tuple{Matroid}" href="#bases-Tuple{Matroid}"><code>bases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bases(M::Matroid)</code></pre><p>Return the list of bases of the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bases(uniform_matroid(2, 3))
3-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]
 [2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="nonbases-Tuple{Matroid}" href="#nonbases-Tuple{Matroid}"><code>nonbases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonbases(M::Matroid)</code></pre><p>Return the list of nonbases of the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nonbases(fano_matroid())
7-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [1, 4, 5]
 [1, 6, 7]
 [2, 4, 6]
 [2, 5, 7]
 [3, 4, 7]
 [3, 5, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="circuits-Tuple{Matroid}" href="#circuits-Tuple{Matroid}"><code>circuits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circuits(M::Matroid)</code></pre><p>Return the list of circuits of the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuits(uniform_matroid(2, 4))
4-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [1, 2, 4]
 [1, 3, 4]
 [2, 3, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="hyperplanes-Tuple{Matroid}" href="#hyperplanes-Tuple{Matroid}"><code>hyperplanes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hyperplanes(M::Matroid)</code></pre><p>Return the list of hyperplanes of the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; hyperplanes(fano_matroid())
7-element Vector{Vector{Int64}}:
 [3, 5, 6]
 [3, 4, 7]
 [2, 5, 7]
 [2, 4, 6]
 [1, 6, 7]
 [1, 4, 5]
 [1, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="flats" href="#flats"><code>flats</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flats(M::Matroid, [r::Int])</code></pre><p>Return the list of flats of the matroid <code>M</code>. By default all flats are returned. One may specify a rank <code>r</code> as the second parameter in which case only the flats of rank <code>r</code> are returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid()
Matroid of rank 3 on 7 elements

julia&gt; flats(M)
16-element Vector{Vector{T} where T}:
 Any[]
 [1]
 [2]
 [3]
 [4]
 [5]
 [6]
 [7]
 [1, 2, 3]
 [1, 4, 5]
 [1, 6, 7]
 [2, 4, 6]
 [2, 5, 7]
 [3, 5, 6]
 [3, 4, 7]
 [1, 2, 3, 4, 5, 6, 7]

julia&gt; flats(M, 2)
7-element Vector{Vector{T} where T}:
 [1, 2, 3]
 [1, 4, 5]
 [1, 6, 7]
 [2, 4, 6]
 [2, 5, 7]
 [3, 5, 6]
 [3, 4, 7]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cyclic_flats" href="#cyclic_flats"><code>cyclic_flats</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cyclic_flats(M::Matroid, [r::Int])</code></pre><p>Return the list of cyclic flats of the matroid <code>M</code>. These are the flats that are the union of cycles. See Section 2.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p>By default all cyclic flats are returned. One may specify a rank <code>r</code> as the second parameter. In this case only the cyclic flats of this rank are returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid()
Matroid of rank 3 on 7 elements

julia&gt; cyclic_flats(M)
9-element Vector{Vector{T} where T}:
 Any[]
 [1, 2, 3]
 [1, 4, 5]
 [1, 6, 7]
 [2, 4, 6]
 [2, 5, 7]
 [3, 5, 6]
 [3, 4, 7]
 [1, 2, 3, 4, 5, 6, 7]

julia&gt; cyclic_flats(M, 2)
7-element Vector{Vector{T} where T}:
 [1, 2, 3]
 [1, 4, 5]
 [1, 6, 7]
 [2, 4, 6]
 [2, 5, 7]
 [3, 5, 6]
 [3, 4, 7]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="closure-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#closure-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>closure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closure(M::Matroid, set::GroundsetType)</code></pre><p>Return the closure of <code>set</code> in the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; closure(fano_matroid(), [1,2])
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="nullity-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#nullity-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>nullity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nullity(M::Matroid, set::GroundsetType)</code></pre><p>Return the nullity of <code>set</code> in the matroid <code>M</code>. This is defined to be <code>|set| - rk(set)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; nullity(M, [1,2,3])
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fundamental_circuit-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, fmpz}}" href="#fundamental_circuit-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, fmpz}}"><code>fundamental_circuit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fundamental_circuit(M::Matroid, basis::GroundsetType, elem::ElementType)</code></pre><p>Return the unique circuit contained in the union of <code>basis</code> and <code>elem</code> of the matroid <code>M</code>. See Section 1.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>. Note that <code>elem</code> needs to be in the complement of the <code>basis</code> in this case.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; fundamental_circuit(M, [1,2,4], 7)
4-element Vector{Int64}:
 1
 2
 4
 7

julia&gt; fundamental_circuit(M, [1,2,4], 3)
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fundamental_cocircuit-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, fmpz}}" href="#fundamental_cocircuit-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, fmpz}}"><code>fundamental_cocircuit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fundamental_cocircuit(M::Matroid, cobasis::GroundsetType, elem::ElementType)</code></pre><p>Return the unique circuit of the dual matroid of <code>M</code> in the union of the complement of <code>basis</code> and <code>elem</code>. See Section 2.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>. Note that <code>elem</code> needs to be an element of the <code>basis</code> in this case.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fundamental_cocircuit(fano_matroid(), [1,2,4], 4)
4-element Vector{Int64}:
 4
 5
 6
 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="independent_sets-Tuple{Matroid}" href="#independent_sets-Tuple{Matroid}"><code>independent_sets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">independent_sets(M::Matroid)</code></pre><p>Return the list of independent sets of the matroid <code>M</code>. These are all subsets of the bases.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; independent_sets(uniform_matroid(2, 3))
7-element Vector{Vector{Integer}}:
 []
 [1]
 [2]
 [3]
 [1, 3]
 [2, 3]
 [1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="spanning_sets-Tuple{Matroid}" href="#spanning_sets-Tuple{Matroid}"><code>spanning_sets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spanning_sets(M::Matroid)</code></pre><p>Return the list of spanning sets of the matroid <code>M</code>. These are all sets containing a basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; spanning_sets(uniform_matroid(2, 3))
4-element Vector{Vector{Integer}}:
 [1, 2]
 [1, 3]
 [2, 3]
 [1, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cobases-Tuple{Matroid}" href="#cobases-Tuple{Matroid}"><code>cobases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cobases(M::Matroid)</code></pre><p>Return the bases of the dual matroid of <code>M</code>. See Section 2 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cobases(uniform_matroid(2, 3))
3-element Vector{Vector{Int64}}:
 [3]
 [2]
 [1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cocircuits-Tuple{Matroid}" href="#cocircuits-Tuple{Matroid}"><code>cocircuits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cocircuits(M::Matroid)</code></pre><p>Return the circuits of the dual matroid of <code>M</code>. See Section 2 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cocircuits(uniform_matroid(2, 5))
5-element Vector{Vector{Int64}}:
 [1, 2, 3, 4]
 [1, 2, 3, 5]
 [1, 2, 4, 5]
 [1, 3, 4, 5]
 [2, 3, 4, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cohyperplanes-Tuple{Matroid}" href="#cohyperplanes-Tuple{Matroid}"><code>cohyperplanes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cohyperplanes(M::Matroid)</code></pre><p>Return the hyperplanes of the dual matroid of <code>M</code>. See Section 2 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cohyperplanes(fano_matroid())
14-element Vector{Vector{Int64}}:
 [4, 5, 6, 7]
 [2, 3, 6, 7]
 [2, 3, 4, 5]
 [1, 3, 5, 7]
 [1, 3, 4, 6]
 [1, 2, 5, 6]
 [1, 2, 4, 7]
 [3, 5, 6]
 [3, 4, 7]
 [2, 5, 7]
 [2, 4, 6]
 [1, 6, 7]
 [1, 4, 5]
 [1, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="corank-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#corank-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>corank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">corank(M::Matroid, set::GroundsetType)</code></pre><p>Return the rank of <code>set</code> in the dual matroid of <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; corank(fano_matroid(), [1,2,3])
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_clutter-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}" href="#is_clutter-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}"><code>is_clutter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_clutter(sets::AbstractVector{T}) where T &lt;: GroundsetType</code></pre><p>Checks if the collection of subsets <code>sets</code> is a clutter. A collection of subsets is a clutter if none of the sets is a proper subset of another. See Section 2.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_clutter([[1,2], [1,2,3]])
false

julia&gt; is_clutter(circuits(fano_matroid()))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_regular-Tuple{Matroid}" href="#is_regular-Tuple{Matroid}"><code>is_regular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_regular(M::Matroid)</code></pre><p>Checks if the matroid <code>M</code> is regular, that is representable over every field. See Section 6.6 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_regular(uniform_matroid(2, 3))
true

julia&gt; is_regular(fano_matroid())
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_binary-Tuple{Matroid}" href="#is_binary-Tuple{Matroid}"><code>is_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_binary(M::Matroid)</code></pre><p>Checks if the matroid <code>M</code> is binary, that is representable over the finite field <code>F_2</code>. See Section 6.5 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_binary(uniform_matroid(2, 4))
false

julia&gt; is_binary(fano_matroid())
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_ternary-Tuple{Matroid}" href="#is_ternary-Tuple{Matroid}"><code>is_ternary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_ternary(M::Matroid)</code></pre><p>Checks if the matroid <code>M</code> is ternary, that is representable over the finite field <code>F_3</code>. See Section 4.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_ternary(uniform_matroid(2, 4))
true

julia&gt; is_ternary(fano_matroid())
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="n_connected_components-Tuple{Matroid}" href="#n_connected_components-Tuple{Matroid}"><code>n_connected_components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_connected_components(M::Matroid)</code></pre><p>Return the number of connected components of <code>M</code>. See Section 4.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n_connected_components(fano_matroid())
1

julia&gt; n_connected_components(uniform_matroid(3, 3))
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L593">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="connected_components-Tuple{Matroid}" href="#connected_components-Tuple{Matroid}"><code>connected_components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connected_components(M::Matroid)</code></pre><p>Return the connected components of <code>M</code>. The function returns a partition of the ground set where each part corresponds to one connected component.  See Section 4.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connected_components(fano_matroid())
1-element Vector{Vector{Int64}}:
 [1, 2, 3, 4, 5, 6, 7]

julia&gt; connected_components(uniform_matroid(3, 3))
3-element Vector{Vector{Int64}}:
 [1]
 [2]
 [3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_connected-Tuple{Matroid}" href="#is_connected-Tuple{Matroid}"><code>is_connected</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_connected(M::Matroid)</code></pre><p>Check if the matroid <code>M</code> is connected, that is has one connected component See Section 4.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_connected(fano_matroid())
true

julia&gt; is_connected(uniform_matroid(3, 3))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="loops-Tuple{Matroid}" href="#loops-Tuple{Matroid}"><code>loops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loops(M::Matroid)</code></pre><p>Return the loops of <code>M</code>. A loop is an element of the ground set that is not contained in any basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; loops(matroid_from_bases([[1,2]], 4))
2-element Vector{Int64}:
 3
 4

julia&gt; loops(fano_matroid())
Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="coloops-Tuple{Matroid}" href="#coloops-Tuple{Matroid}"><code>coloops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coloops(M::Matroid)</code></pre><p>Return the coloops of <code>M</code>. A coloop is an element of the ground set that is contained in every basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; coloops(matroid_from_bases([[1,2]], 4))
2-element Vector{Int64}:
 1
 2

julia&gt; coloops(fano_matroid())
Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_loopless-Tuple{Matroid}" href="#is_loopless-Tuple{Matroid}"><code>is_loopless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_loopless(M::Matroid)</code></pre><p>Check if <code>M</code> has a loop. Return <code>true</code> if <code>M</code> does not have a loop. See also <code>loops</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_loopless(matroid_from_bases([[1,2]], 4))
false

julia&gt; is_loopless(fano_matroid())
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_coloopless-Tuple{Matroid}" href="#is_coloopless-Tuple{Matroid}"><code>is_coloopless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_coloopless(M::Matroid)</code></pre><p>Check if <code>M</code> has a coloop. Return <code>true</code> if <code>M</code> does not have a coloop. See also <code>coloops</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_coloopless(matroid_from_bases([[1,2]], 4))
false

julia&gt; is_coloopless(fano_matroid())
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_simple-Tuple{Matroid}" href="#is_simple-Tuple{Matroid}"><code>is_simple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_simple(M::Matroid)</code></pre><p>Check if <code>M</code> has is simple. A matroid is simple if it doesn&#39;t have loops and doesn&#39;t have parallel elements. Return <code>true</code> if <code>M</code> is simple. See also <code>loops</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_simple(matroid_from_bases([[1,2]], 4))
false

julia&gt; is_simple(fano_matroid())
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L718">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="direct_sum_components-Tuple{Matroid}" href="#direct_sum_components-Tuple{Matroid}"><code>direct_sum_components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">direct_sum_components(M::Matroid)</code></pre><p>Return the connected components of <code>M</code> as a list of matroids. See Section 4.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; direct_sum_components(fano_matroid())
1-element Vector{Matroid}:
 Matroid of rank 3 on 7 elements

julia&gt; direct_sum_components(uniform_matroid(3, 3))
3-element Vector{Matroid}:
 Matroid of rank 1 on 1 elements
 Matroid of rank 1 on 1 elements
 Matroid of rank 1 on 1 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L736">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="connectivity_function-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#connectivity_function-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>connectivity_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connectivity_function(M::Matroid, set::GroundsetType)</code></pre><p>Return the value of the connectivity function of <code>set</code> in the matroid <code>M</code>. See Section 8.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connectivity_function(fano_matroid(), [1,2,4])
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L763">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_vertical_k_separation-Tuple{Matroid, Union{Integer, fmpz}, Union{AbstractSet, AbstractVector{T} where T}}" href="#is_vertical_k_separation-Tuple{Matroid, Union{Integer, fmpz}, Union{AbstractSet, AbstractVector{T} where T}}"><code>is_vertical_k_separation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_vertical_k_separation(M::Matroid, k::IntegerUnion, set::GroundsetType)</code></pre><p>Check if <code>set</code> together with its complement defines a <code>k</code> separation in <code>M</code> See Section 8.6 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_vertical_k_separation(fano_matroid(), 2, [1,2,4])
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L780">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_k_separation-Tuple{Matroid, Union{Integer, fmpz}, Union{AbstractSet, AbstractVector{T} where T}}" href="#is_k_separation-Tuple{Matroid, Union{Integer, fmpz}, Union{AbstractSet, AbstractVector{T} where T}}"><code>is_k_separation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_k_separation(M::Matroid, k::IntegerUnion, set::GroundsetType)</code></pre><p>Check if <code>set</code> together with its complement defines a <code>k</code> separation in <code>M</code> See Section 8.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_k_separation(fano_matroid(), 2, [1,2,4])
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L797">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="vertical_connectivity-Tuple{Matroid}" href="#vertical_connectivity-Tuple{Matroid}"><code>vertical_connectivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertical_connectivity(M::Matroid)</code></pre><p>If &#39;M&#39; has two disjoint cocircuits, its vertical connectivity is defined to be least positive integer k such that <code>M</code> has a vertical k separation. Otherwise its vertical connectivity is defined to be the rank of <code>M</code>. See Section 8.6 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vertical_connectivity(fano_matroid())
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L814">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="girth" href="#girth"><code>girth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">girth(M::Matroid, set::GroundsetType)</code></pre><p>Return the girth of <code>set</code> in the matroid <code>M</code>. This is the size of the smallest circuit contained in <code>set</code> and infintie otherwise. See Section 8.6 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; girth(fano_matroid(), [1,2,3,4])
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L845">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="tutte_connectivity-Tuple{Matroid}" href="#tutte_connectivity-Tuple{Matroid}"><code>tutte_connectivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tutte_connectivity(M::Matroid)</code></pre><p>The Tutte connectivity of <code>M</code> is the least integer k such that <code>M</code> has a k separation. It can be infinite if no k separation exists. See Section 8.6 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tutte_connectivity(fano_matroid())
3

julia&gt; tutte_connectivity(uniform_matroid(2,4))
PosInf()
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L861">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="tutte_polynomial-Tuple{Matroid}" href="#tutte_polynomial-Tuple{Matroid}"><code>tutte_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tutte_polynomial(M::Matroid)</code></pre><p>Return the Tutte polynomial of <code>M</code>. This is polynomial in the variables x and y with integral coefficients. See Section 15.3 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tutte_polynomial(fano_matroid())
x^3 + 4*x^2 + 7*x*y + 3*x + y^4 + 3*y^3 + 6*y^2 + 3*y
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L893">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="characteristic_polynomial-Tuple{Matroid}" href="#characteristic_polynomial-Tuple{Matroid}"><code>characteristic_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">characteristic_polynomial(M::Matroid)</code></pre><p>Return the characteristic polynomial of <code>M</code>. This is polynomial in the variable q with integral coefficients. It is computed as an evaluation of the Tutte polynmomial. See Section 15.2 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; characteristic_polynomial(fano_matroid())
q^3 - 7*q^2 + 14*q - 8
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L913">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="reduced_characteristic_polynomial-Tuple{Matroid}" href="#reduced_characteristic_polynomial-Tuple{Matroid}"><code>reduced_characteristic_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduced_characteristic_polynomial(M::Matroid)</code></pre><p>Return the reduced characteristic polynomial of <code>M</code>. This is the quotient of the characteristic polynomial by (q-1). See Section 15.2 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reduced_characteristic_polynomial(fano_matroid())
q^2 - 6*q + 8
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L933">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="revlex_basis_encoding-Tuple{Matroid}" href="#revlex_basis_encoding-Tuple{Matroid}"><code>revlex_basis_encoding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">revlex_basis_encoding(M::Matroid)</code></pre><p>Computes the revlex basis encoding and the minimal revlex basis encoding among isomorphic matroids </p><p><strong>Examples</strong></p><p>To get the revlex basis encoding of the fano matroid and to preduce a matrod form the encoding write:</p><pre><code class="language-julia-repl hljs">julia&gt; string1, string2 = revlex_basis_encoding(fano_matroid())
(&quot;0******0******0***0******0*0**0****&quot;, &quot;0******0******0***0******0*0**0****&quot;)

julia&gt; matroid_from_revlex_basis_encoding(string2, 3, 7)
Matroid of rank 3 on 7 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L987">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_isomorphic-Tuple{Matroid, Matroid}" href="#is_isomorphic-Tuple{Matroid, Matroid}"><code>is_isomorphic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_isomorphic(M1::Matroid, M2::Matroid)</code></pre><p>Checks if the matroid <code>M1</code> is isomorphic to the matroid <code>M2</code> under the action of the symmetric group that acts on their groundsets.</p><p><strong>Examples</strong></p><p>To compare two matrods write:</p><pre><code class="language-julia-repl hljs">julia&gt; H = [[1,2,4],[2,3,5],[1,3,6],[3,4,7],[1,5,7],[2,6,7],[4,5,6]];

julia&gt; M = matroid_from_hyperplanes(H,7);

julia&gt; is_isomorphic(M,fano_matroid())
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L1020">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_minor-Tuple{Matroid, Matroid}" href="#is_minor-Tuple{Matroid, Matroid}"><code>is_minor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_minor(M::Matroid, N::Matroid)</code></pre><p>Checks if the matroid <code>M</code> is isomorphic to a minor of the matroid <code>N</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_minor(direct_sum(uniform_matroid(0,1), uniform_matroid(2,2)), fano_matroid())
false

julia&gt; is_minor(direct_sum(uniform_matroid(0,1), uniform_matroid(2,2)), parallel_extension(uniform_matroid(3,4), 1, 5))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/properties.jl#L1044">source</a></section></article><h3 id="Chow-Rings"><a class="docs-heading-anchor" href="#Chow-Rings">Chow Rings</a><a id="Chow-Rings-1"></a><a class="docs-heading-anchor-permalink" href="#Chow-Rings" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="chow_ring-Tuple{Matroid}" href="#chow_ring-Tuple{Matroid}"><code>chow_ring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chow_ring(M::Matroid; ring::MPolyRing=nothing, extended::Bool=false)</code></pre><p>Return the Chow ring of a matroid, optionally also with the simplicial generators and the polynomial ring.</p><p>See <a href="../../references/#AHK18">Karim Adiprasito, June Huh, Eric Katz (2018)</a> and <a href="../../references/#BES19">Spencer Backman, Christopher Eur, Connor Simpson (2019)</a>. </p><p><strong>Examples</strong></p><p>The following computes the Chow ring of the Fano matroid.</p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; R = chow_ring(M);

julia&gt; R[1]*R[8]
-x_{3,4,7}^2</code></pre><p>The following computes the Chow ring of the Fano matroid including variables for the simplicial generators.</p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; R = chow_ring(M, extended=true);

julia&gt; f = R[22] + R[8] - R[29]
x_{1,2,3} + h_{1,2,3} - h_{1,2,3,4,5,6,7}

julia&gt; f==0
true</code></pre><p>The following computes the Chow ring of the free matroid on three elements in a given graded polynomial ring.</p><pre><code class="language-julia-repl hljs">julia&gt; M = uniform_matroid(3,3);

julia&gt; GR, _ = GradedPolynomialRing(QQ,[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]);

julia&gt; R = chow_ring(M, ring=GR);

julia&gt; hilbert_series_reduced(R)
(t^2 + 4*t + 1, 1) 
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/ChowRings.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="augmented_chow_ring-Tuple{Matroid}" href="#augmented_chow_ring-Tuple{Matroid}"><code>augmented_chow_ring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">augmented_chow_ring(M::Matroid)</code></pre><p>Return an augmented Chow ring of a matroid. As described in <a href="../../references/#BHMPW20">Tom Braden, June Huh, Jacob P. Matherne, Nicholas Proudfoot, Botong Wang (2020)</a>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; R = augmented_chow_ring(M);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d120727cd405bebc1fd1cb7045142c3432f74279/src/Combinatorics/Matroids/ChowRings.jl#L137">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../graphs/">« Graphs</a><a class="docs-footer-nextpage" href="../simplicialcomplexes/">Simplicial Complexes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 28 December 2022 12:51">Wednesday 28 December 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
