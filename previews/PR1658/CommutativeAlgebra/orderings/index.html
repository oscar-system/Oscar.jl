<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Monomial Orderings · Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../General/serialization/">Serialization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../Experimental/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/serialization/">Saving and loading</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/visualization/">Visualization</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox" checked/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../rings/">Creating Multivariate Rings</a></li><li class="is-active"><a class="tocitem" href>Monomial Orderings</a><ul class="internal"><li><a class="tocitem" href="#Monomial-Comparisons"><span>Monomial Comparisons</span></a></li><li><a class="tocitem" href="#Matrix-Orderings"><span>Matrix Orderings</span></a></li><li><a class="tocitem" href="#Predefined-Global-Orderings"><span>Predefined Global Orderings</span></a></li><li><a class="tocitem" href="#Predefined-Local-Orderings"><span>Predefined Local Orderings</span></a></li><li><a class="tocitem" href="#Weight-Orderings"><span>Weight Orderings</span></a></li><li><a class="tocitem" href="#Block-Orderings"><span>Block Orderings</span></a></li><li><a class="tocitem" href="#Elimination-Orderings"><span>Elimination Orderings</span></a></li><li><a class="tocitem" href="#Tests-on-Monomial-Orderings"><span>Tests on Monomial Orderings</span></a></li><li><a class="tocitem" href="#Module-Orderings"><span>Module Orderings</span></a></li></ul></li><li><a class="tocitem" href="../groebner_bases/">Gröbner and Standard Bases Over Fields</a></li><li><a class="tocitem" href="../groebner_bases_integers/">Gröbner and Standard Bases Over <span>$\mathbb Z$</span></a></li><li><a class="tocitem" href="../ideals/">Ideals in Multivariate Rings</a></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">Modules Over Multivariate Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/subquotients/">Subquotient Modules</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li></ul></li><li><a class="tocitem" href="../affine_algebras/">Affine Algebras</a></li><li><a class="tocitem" href="../binomial_ideals/">Binomial Primary Decomposition</a></li><li><a class="tocitem" href="../localizations/">Localization</a></li><li><a class="tocitem" href="../module_localizations/">Localizations of modules over computable rings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../TropicalGeometry/curve/">Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Standard Constructions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/StandardConstructions/standard_constructions/">Standard Constructions in Algebraic Geometry</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Finitely Presented Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/quotients/">Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-7" type="checkbox"/><label class="tocitem" for="menuitem-17-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Commutative Algebra</a></li><li class="is-active"><a href>Monomial Orderings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Monomial Orderings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/CommutativeAlgebra/orderings.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#Monomial-Orderings">Monomial Orderings</a></li><li class="no-marker"><ul><li><a href="#Monomial-Comparisons">Monomial Comparisons</a></li><li><a href="#Matrix-Orderings">Matrix Orderings</a></li><li><a href="#Predefined-Global-Orderings">Predefined Global Orderings</a></li><li><a href="#Predefined-Local-Orderings">Predefined Local Orderings</a></li><li><a href="#Weight-Orderings">Weight Orderings</a></li><li><a href="#Block-Orderings">Block Orderings</a></li><li><a href="#Elimination-Orderings">Elimination Orderings</a></li><li><a href="#Tests-on-Monomial-Orderings">Tests on Monomial Orderings</a></li><li><a href="#Module-Orderings">Module Orderings</a></li></ul></li></ul><h1 id="Monomial-Orderings"><a class="docs-heading-anchor" href="#Monomial-Orderings">Monomial Orderings</a><a id="Monomial-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Monomial-Orderings" title="Permalink"></a></h1><p>Given a coefficient ring <span>$C$</span> as in the previous section, let <span>$C[x]=C[x_1, \ldots, x_n]$</span> be the polynomial ring over <span>$C$</span> in the set of variables <span>$x=\{x_1, \ldots, x_n\}$</span>. Monomials in <span>$x=\{x_1, \ldots, x_n\}$</span> are written using multi–indices: If <span>$\alpha=(\alpha_1, \ldots, \alpha_n)\in \N^n$</span>, set <span>$x^\alpha=x_1^{\alpha_1}\cdots x_n^{\alpha_n}$</span> and</p><p class="math-container">\[\text{Mon}_n(x) :=  \text{Mon}(x_1, \ldots, x_n) := \{x^\alpha \mid \alpha \in \N^n\}.\]</p><p>A <em>monomial ordering</em> on <span>$\text{Mon}_n(x)$</span> is a total  ordering <span>$&gt;$</span> on <span>$\text{Mon}_n(x)$</span> such that</p><p class="math-container">\[x^\alpha &gt; x^\beta \Longrightarrow x^\gamma x^\alpha &gt; x^\gamma  x^\beta,
\; \text{ for all }\; \alpha, \beta, \gamma \in \mathbb N^n.\]</p><p>A monomial ordering <span>$&gt;$</span> on <span>$\text{Mon}_n(x)$</span> is called</p><ul><li><em>global</em> if <span>$x^\alpha &gt; 1$</span> for all <span>$\alpha \not = (0, \dots, 0)$</span>,</li><li><em>local</em> if  <span>$x^\alpha &lt; 1$</span> for all <span>$\alpha \not = (0, \dots, 0)$</span>, and</li><li><em>mixed</em> if it is neither global nor local.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>A monomial ordering on <span>$\text{Mon}_n(x)$</span> is global iff it is a well-ordering.</li><li>To give a monomial ordering on <span>$\text{Mon}_n(x)$</span> means to give a total ordering <span>$&gt;$</span> on $ \N^n$ such that  <span>$\alpha &gt; \beta$</span> implies $ \gamma + \alpha &gt; \gamma  + \beta$ for all <span>$\alpha , \beta, \gamma \in \N^n.$</span>  Rather than speaking of a monomial ordering on <span>$\text{Mon}_n(x)$</span>, we may, thus, also speak of a  (global, local, mixed) monomial ordering on <span>$\N^n$</span>.</li></ul></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The lexicograpical monomial ordering specifies the default way of storing and displaying multivariate polynomials in OSCAR (terms are sorted in descending order). The other orderings which can be attached to a multivariate polynomial ring are the degree lexicographical ordering  and the degree reverse lexicographical ordering. Independently of the attached orderings, Gröbner bases can be computed with respect to any monomial ordering. See the section on Gröbner bases.</p></div></div><p>In this section, we show how to create monomial orderings in OSCAR. After recalling that all monomial orderings can be realized as matrix orderings, we present a list of orderings which are predefined in OSCAR. Then we discuss weight and block orderings (product orderings). Finally, we address elimination orderings.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the convenient construction of block orderings on the set of monomials in the variables of a given multivariate polynomial ring, we allow to construct orderings on the monomials in blocks of variables, viewing these orderings as partial orderings on the monomials in all variables.</p></div></div><p>Here are some illustrating examples:</p><h5 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; S, (w, x) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;])</code><code class="nohighlight hljs ansi" style="display:block;">(Multivariate Polynomial Ring in w, x over Rational Field, fmpq_mpoly[w, x])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; o = lex([w, x])</code><code class="nohighlight hljs ansi" style="display:block;">lex([w, x])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; canonical_matrix(o)</code><code class="nohighlight hljs ansi" style="display:block;">[1   0]
[0   1]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cmp(o, w^2*x, x^3)</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])</code><code class="nohighlight hljs ansi" style="display:block;">(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; o1 = degrevlex([w, x])</code><code class="nohighlight hljs ansi" style="display:block;">degrevlex([w, x])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; is_global(o1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; canonical_matrix(o1)</code><code class="nohighlight hljs ansi" style="display:block;">[1    1   0   0]
[0   -1   0   0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; o2 = neglex([y, z])</code><code class="nohighlight hljs ansi" style="display:block;">neglex([y, z])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; is_local(o2)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; canonical_matrix(o2)</code><code class="nohighlight hljs ansi" style="display:block;">[0   0   -1    0]
[0   0    0   -1]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; o3 = o1*o2</code><code class="nohighlight hljs ansi" style="display:block;">degrevlex([w, x])*neglex([y, z])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; canonical_matrix(o3)</code><code class="nohighlight hljs ansi" style="display:block;">[1    1    0    0]
[0   -1    0    0]
[0    0   -1    0]
[0    0    0   -1]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; is_mixed(o3)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(collect(terms((1+w+x+y+z)^2, o3)))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching terms(::fmpq_mpoly, ::MonomialOrdering{FmpqMPolyRing})
Closest candidates are:
  terms(::MPolyElem{T}) where T&lt;:RingElement at /home/runner/.julia/packages/AbstractAlgebra/ZmWFo/src/MPoly.jl:475</code></pre><h2 id="Monomial-Comparisons"><a class="docs-heading-anchor" href="#Monomial-Comparisons">Monomial Comparisons</a><a id="Monomial-Comparisons-1"></a><a class="docs-heading-anchor-permalink" href="#Monomial-Comparisons" title="Permalink"></a></h2><p>The <code>cmp</code> function should be used for comparing two monomials with regard to a monomial ordering.</p><article class="docstring"><header><a class="docstring-binding" id="cmp-Tuple{MonomialOrdering, MPolyElem, MPolyElem}" href="#cmp-Tuple{MonomialOrdering, MPolyElem, MPolyElem}"><code>cmp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cmp(ord::MonomialOrdering, a::MPolyElem, b::MPolyElem)</code></pre><p>Compare monomials <code>a</code> and <code>b</code> with regard to the ordering <code>ord</code>: Return <code>-1</code> for <code>a &lt; b</code> and <code>1</code> for <code>a &gt; b</code> and <code>0</code> for <code>a == b</code>. An error is thrown if <code>ord</code> is a partial ordering that does not distinguish <code>a</code> from <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; cmp(lex([x,y]), x, one(R))
1

julia&gt; try cmp(lex([x,y]), z, one(R)); catch e; e; end
ErrorException(&quot;z and 1 are incomparable with respect to lex([x, y])&quot;)

julia&gt; cmp(lex([x,y,z]), z, one(R))
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L1397">source</a></section></article><p>The terms of a multivariate polynomials may be queried in an arbitrary ordering.</p><article class="docstring"><header><a class="docstring-binding" id="coefficients-Tuple{MPolyElem}" href="#coefficients-Tuple{MPolyElem}"><code>coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coefficients(f::MPolyElem; ordering::MonomialOrdering = default_ordering(parent(f)))</code></pre><p>Return an iterator for the coefficients of <code>f</code> with respect to the order <code>ordering</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/mpoly.jl#L917">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="coefficients_and_exponents-Tuple{MPolyElem}" href="#coefficients_and_exponents-Tuple{MPolyElem}"><code>coefficients_and_exponents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coefficients_and_exponents(f::MPolyElem; ordering::MonomialOrdering = default_ordering(parent(f)))</code></pre><p>Return an iterator whose elements are tuples of coefficients of <code>f</code> and exponent vectors (as <code>Vector{Int}</code>) with respect to the order <code>ordering</code>.</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; R, (x, y) = PolynomialRing(QQ, [:x, :y]);</p><p>julia&gt; coefficients<em>and</em>exponents((1 + x + 2<em>y)^2; ordering = neglex(R)) coefficients and exponents iterator of 1 + 4</em>y + 4<em>y^2 + 2</em>x + 4<em>x</em>y + x^2</p><p>julia&gt; collect(ans) 6-element Vector{Tuple{fmpq, Vector{Int64}}}:  (1, [0, 0])  (4, [0, 1])  (4, [0, 2])  (2, [1, 0])  (4, [1, 1])  (1, [2, 0])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/mpoly.jl#L936">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="exponents-Tuple{MPolyElem}" href="#exponents-Tuple{MPolyElem}"><code>exponents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exponents(f::MPolyElem; ordering::MonomialOrdering = default_ordering(parent(f)))</code></pre><p>Return an iterator for the exponent vectors (as <code>Vector{Int}</code>) of <code>f</code> with respect to the order <code>ordering</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/mpoly.jl#L972">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="monomials-Tuple{MPolyElem}" href="#monomials-Tuple{MPolyElem}"><code>monomials</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">monomials(f::MPolyElem; ordering::MonomialOrdering = default_ordering(parent(f)))</code></pre><p>Return an iterator for the monomials of <code>f</code> with respect to the order <code>ordering</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/mpoly.jl#L992">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="terms-Tuple{MPolyElem}" href="#terms-Tuple{MPolyElem}"><code>terms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">terms(f::MPolyElem; ordering::MonomialOrdering = default_ordering(parent(f)))</code></pre><p>Return an iterator for the terms of <code>f</code> with respect to the order <code>ordering</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/mpoly.jl#L1011">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="leading_coefficient-Tuple{MPolyElem}" href="#leading_coefficient-Tuple{MPolyElem}"><code>leading_coefficient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leading_coefficient(f::MPolyElem; ordering::MonomialOrdering = default_ordering(parent(f)))</code></pre><p>Return the leading coefficient of <code>f</code> with respect to the order <code>ordering</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/mpoly.jl#L1030">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="leading_exponent-Tuple{MPolyElem}" href="#leading_exponent-Tuple{MPolyElem}"><code>leading_exponent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leading_exponent(f::MPolyElem; ordering::MonomialOrdering = default_ordering(parent(f)))</code></pre><p>Return the leading exponent vector (as <code>Vector{Int}</code>) of <code>f</code> with respect to the order <code>ordering</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/mpoly.jl#L1039">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="leading_monomial-Tuple{MPolyElem}" href="#leading_monomial-Tuple{MPolyElem}"><code>leading_monomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leading_monomial(f::MPolyElem; ordering::MonomialOrdering = default_ordering(parent(f)))</code></pre><p>Return the leading monomial of <code>f</code> with respect to the order <code>ordering</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/mpoly.jl#L1051">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="leading_term-Tuple{MPolyElem}" href="#leading_term-Tuple{MPolyElem}"><code>leading_term</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leading_term(f::MPolyElem; ordering::MonomialOrdering = default_ordering(parent(f)))</code></pre><p>Return the leading term of <code>f</code> with respect to the order <code>ordering</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/mpoly.jl#L1060">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>As the above functions take an arbitrary ordering, they are much slower than the versions from AbstractAlgebra, which use the natural ordering in the parent polynomial ring: <code>default_ordering(parent(f))</code> is not necessarily this natural ordering. If this ordering of the parent is desired, or if the ordering is not important, it is recommended to use the following.</p><ul><li><code>AbstractAlgebra.coefficients(f)</code></li><li><code>zip(AbstractAlgebra.coefficients(f), AbstractAlgebra.exponent_vectors(f))</code></li><li><code>AbstractAlgebra.exponent_vectors(f)</code></li><li><code>AbstractAlgebra.monomials(f)</code></li><li><code>AbstractAlgebra.terms(f)</code></li><li><code>AbstractAlgebra.leading_coefficient(f)</code></li><li><code>AbstractAlgebra.leading_exponent_vector(f)</code></li><li><code>AbstractAlgebra.leading_monomial(f)</code></li><li><code>AbstractAlgebra.leading_term(f)</code></li></ul></div></div><h2 id="Matrix-Orderings"><a class="docs-heading-anchor" href="#Matrix-Orderings">Matrix Orderings</a><a id="Matrix-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Orderings" title="Permalink"></a></h2><p>Given a matrix <span>$M\in \text{Mat}(k\times n,\mathbb R)$</span> of rank <span>$n$</span>, with rows <span>$m_1,\dots,m_k$</span>, the <em>matrix ordering</em> defined by <span>$M$</span> is obtained by setting</p><p class="math-container">\[x^\alpha&gt;_M x^\beta  \Leftrightarrow  \;\exists\; 1\leq i\leq k:  m_1\alpha=m_1\beta,\ldots, 
m_{i-1}\alpha\ =m_{i-1}\beta,\ m_i\alpha&gt;m_i\beta\]</p><p>(here, <span>$\alpha$</span> and <span>$\beta$</span> are regarded as column vectors).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By a theorem of Robbiano, every monomial ordering arises as a matrix ordering as above with <span>$M\in \text{GL}(n,\mathbb R)$</span>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To create matrix orderings, OSCAR allows for matrices with integer coefficients as input matrices.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For orderings such as <code>lex</code> and <code>degrevlex</code> which are  predefined in OSCAR, using the predefined version is much faster than using a representation as a matrix ordering.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="matrix_ordering-Union{Tuple{T}, Tuple{MPolyRing, Union{MatElem{T}, Matrix{T}}}} where T" href="#matrix_ordering-Union{Tuple{T}, Tuple{MPolyRing, Union{MatElem{T}, Matrix{T}}}} where T"><code>matrix_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_ordering(R::MPolyRing, M::Union{Matrix{T}, MatElem{T}}; check = true) where T -&gt; MonomialOrdering</code></pre><p>Given an integer matrix <code>M</code> such that <code>nvars(R) = ncols(M) = rank(M)</code>,  return the matrix ordering on the set of variables of <code>R</code> which is defined by <code>M</code>.</p><pre><code class="nohighlight hljs">matrix_ordering(V::AbstractVector{&lt;:MPolyElem}, M::Union{Matrix{T}, MatElem{T}}; check = true) where T -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables and an integer matrix <code>M</code> such that <code>length(V) = ncols(M) = rank(M)</code>,  return the matrix ordering on the set of monomials in the given variables which is defined by <code>M</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The matrix <code>M</code> need not be square.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>check = false</code> is supplied, the rank check is omitted, and the resulting ordering may only be partial.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = QQ[&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;];

julia&gt; M =[1 1 1 1; 0 -1 -1 -1; 0 0 -1 -1; 0 0 0 -1]
4×4 Matrix{Int64}:
 1   1   1   1
 0  -1  -1  -1
 0   0  -1  -1
 0   0   0  -1

julia&gt; o1 = matrix_ordering(R, M)
matrix_ordering([w, x, y, z], [1 1 1 1; 0 -1 -1 -1; 0 0 -1 -1; 0 0 0 -1])

julia&gt; N =[1 1; 0 -1]
2×2 Matrix{Int64}:
 1   1
 0  -1

julia&gt; o2 = matrix_ordering([w, x], N)
matrix_ordering([w, x], [1 1; 0 -1])

julia&gt; canonical_matrix(o2)
[1    1   0   0]
[0   -1   0   0]

julia&gt; o3 = matrix_ordering(gens(R)[3:4], N)
matrix_ordering([y, z], [1 1; 0 -1])

julia&gt; o3 = matrix_ordering(gens(R)[3:4], N)
matrix_ordering([y, z], [1 1; 0 -1])

julia&gt; canonical_matrix(o3)
[0   0   1    1]
[0   0   0   -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L1061">source</a></section></article><p>As already shown above, OSCAR provides functions to recover defining matrices from given monomial orderings:</p><article class="docstring"><header><a class="docstring-binding" id="matrix-Tuple{MonomialOrdering}" href="#matrix-Tuple{MonomialOrdering}"><code>matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix(ord::MonomialOrdering)</code></pre><p>Return a matrix defining <code>ord</code> as a matrix ordering.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; o1 = degrevlex(R)
degrevlex([x, y, z])

julia&gt; matrix(o1)
[ 1    1    1]
[ 0    0   -1]
[ 0   -1    0]
[-1    0    0]

julia&gt; o2 = degrevlex([x, y])
degrevlex([x, y])

julia&gt; matrix(o2)
[ 1    1   0]
[ 0   -1   0]
[-1    0   0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L1219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="canonical_matrix-Tuple{MonomialOrdering}" href="#canonical_matrix-Tuple{MonomialOrdering}"><code>canonical_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">canonical_matrix(ord::MonomialOrdering)</code></pre><p>Return the canonical matrix defining <code>ord</code> as a matrix ordering.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; o1 = degrevlex(R)
degrevlex([x, y, z])

julia&gt; canonical_matrix(o1)
[1    1    1]
[0    0   -1]
[0   -1    0]

julia&gt; o2 = degrevlex([x, y])
degrevlex([x, y])

julia&gt; canonical_matrix(o2)
[1    1   0]
[0   -1   0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L1264">source</a></section></article><h2 id="Predefined-Global-Orderings"><a class="docs-heading-anchor" href="#Predefined-Global-Orderings">Predefined Global Orderings</a><a id="Predefined-Global-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Predefined-Global-Orderings" title="Permalink"></a></h2><h4 id="The-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Lexicographical-Ordering">The Lexicographical Ordering</a><a id="The-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>lexicographical ordering</em> <code>lex</code> is defined by setting</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;\exists \; 1 \leq i \leq n: \alpha_1 = \beta_1, \dots, \alpha_{i-1} = \beta_{i-1}, \alpha_i &gt; \beta_i.\]</p><article class="docstring"><header><a class="docstring-binding" id="lex-Tuple{MPolyRing}" href="#lex-Tuple{MPolyRing}"><code>lex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">lex(V::AbstractVector{&lt;:MPolyElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])

julia&gt; o1 = lex(R)
lex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[1   0   0   0]
[0   1   0   0]
[0   0   1   0]
[0   0   0   1]

julia&gt; o2 = lex([w, x])
lex([w, x])

julia&gt; o3 = lex(gens(R)[3:4])
lex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L203">source</a></section></article><h4 id="The-Degree-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Degree-Lexicographical-Ordering">The Degree Lexicographical Ordering</a><a id="The-Degree-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Degree-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>degree lexicographical ordering</em> <code>deglex</code> is defined by setting <span>$\;\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;  \deg(x^\alpha) &gt; \deg(x^\beta)  \;\text{ or }\; \exists \; 1 \leq i \leq n: \alpha_1 = \beta_1, \dots, \alpha_{i-1} = \beta_{i-1}, \alpha_i &gt; \beta_i.\]</p><article class="docstring"><header><a class="docstring-binding" id="deglex-Tuple{MPolyRing}" href="#deglex-Tuple{MPolyRing}"><code>deglex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deglex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the degree lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">deglex(V::AbstractVector{&lt;:MPolyElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the degree lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])

julia&gt; o1 = deglex(R)
deglex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[1    1    1    1]
[0   -1   -1   -1]
[0    0   -1   -1]
[0    0    0   -1]

julia&gt; o2 = deglex([w, x])
deglex([w, x])

julia&gt; o3 = deglex(gens(R)[3:4])
deglex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L267">source</a></section></article><h4 id="The-Reverse-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Reverse-Lexicographical-Ordering">The Reverse Lexicographical Ordering</a><a id="The-Reverse-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Reverse-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>reverse lexicographical ordering</em> <code>revlex</code> is defined by setting</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;\exists \; 1 \leq i \leq n: \alpha_n = \beta_n, \dots, \alpha_{i+1} = \beta_{i+1}, \alpha_i  &gt; \beta_i.\]</p><article class="docstring"><header><a class="docstring-binding" id="revlex-Tuple{MPolyRing}" href="#revlex-Tuple{MPolyRing}"><code>revlex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">revlex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the reverse lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">revlex(V::AbstractVector{&lt;:MPolyElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the reverse lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])

julia&gt; o1 = revlex(R)
revlex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[0   0   0   1]
[0   0   1   0]
[0   1   0   0]
[1   0   0   0]

julia&gt; o2 = revlex([w, x])
revlex([w, x])

julia&gt; o3 = revlex(gens(R)[3:4])
revlex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L411">source</a></section></article><h4 id="The-Degree-Reverse-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Degree-Reverse-Lexicographical-Ordering">The Degree Reverse Lexicographical Ordering</a><a id="The-Degree-Reverse-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Degree-Reverse-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>degree reverse lexicographical ordering</em> <code>degrevlex</code> is defined by setting <span>$\;\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \; \deg(x^\alpha) &gt; \deg(x^\beta)  \;\text{ or }\;\exists \; 1 \leq i \leq n: \alpha_n = \beta_n, \dots, \alpha_{i+1} = \beta_{i+1}, \alpha_i &lt; \beta_i.\]</p><article class="docstring"><header><a class="docstring-binding" id="degrevlex-Tuple{MPolyRing}" href="#degrevlex-Tuple{MPolyRing}"><code>degrevlex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degrevlex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the degree reverse lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">degrevlex(V::AbstractVector{&lt;:MPolyElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the degree reverse lexicographical ordering on the set of monomials in these variables</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])

julia&gt; o1 = degrevlex(R)
degrevlex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[1    1    1    1]
[0    0    0   -1]
[0    0   -1    0]
[0   -1    0    0]

julia&gt; o2 = degrevlex([w, x])
degrevlex([w, x])

julia&gt; o3 = degrevlex(gens(R)[3:4])
degrevlex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L339">source</a></section></article><h4 id="Weighted-Lexicographical-Orderings"><a class="docs-heading-anchor" href="#Weighted-Lexicographical-Orderings">Weighted Lexicographical Orderings</a><a id="Weighted-Lexicographical-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Weighted-Lexicographical-Orderings" title="Permalink"></a></h4><p>If <code>W</code> is a vector of positive integers  <span>$w_1, \dots, w_n$</span>, the corresponding <em>weighted lexicographical ordering</em> <code>wdeglex(W)</code>  is defined by setting <span>$\;\text{wdeg}(x^\alpha) = w_1\alpha_1 + \cdots + w_n\alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;  \text{wdeg}(x^\alpha) &gt; \text{wdeg}(x^\beta)  \;\text{ or }\;\\
(\text{wdeg}(x^\alpha) = \text{wdeg}(x^\beta)  \;\text{ and }\; \exists \; 1 \leq i \leq n: \alpha_1 = \beta_1, \dots, \alpha_{i-1} = \beta_{i-1}, \alpha_i &gt; \beta_i).\]</p><article class="docstring"><header><a class="docstring-binding" id="wdeglex-Tuple{MPolyRing, Vector{Int64}}" href="#wdeglex-Tuple{MPolyRing, Vector{Int64}}"><code>wdeglex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wdeglex(R::MPolyRing, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>If <code>W</code> is a vector of positive integers, return the corresponding weighted  lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">wdeglex(V::AbstractVector{&lt;:MPolyElem}, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables and a vector <code>W</code> of positive integers, return the corresponding weighted  lexicographical ordering on the set of monomials in the given variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])

julia&gt; o1 = wdeglex(R, [1, 2, 3, 4])
wdeglex([w, x, y, z], [1, 2, 3, 4])

julia&gt; canonical_matrix(o1)
[1    2    3    4]
[0   -2   -3   -4]
[0    0   -3   -4]
[0    0    0   -1]

julia&gt; o2 = wdeglex([w, x], [1, 2])
wdeglex([w, x], [1, 2])

julia&gt; o3 = wdeglex(gens(R)[3:4], [3, 4])
wdeglex([y, z], [3, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L781">source</a></section></article><h4 id="Weighted-Reverse-Lexicographical-Orderings"><a class="docs-heading-anchor" href="#Weighted-Reverse-Lexicographical-Orderings">Weighted Reverse Lexicographical Orderings</a><a id="Weighted-Reverse-Lexicographical-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Weighted-Reverse-Lexicographical-Orderings" title="Permalink"></a></h4><p>If <code>W</code> is a vector of positive integers  <span>$w_1, \dots, w_n$</span>, the corresponding <em>weighted reverse lexicographical ordering</em> <code>wdegrevlex</code>  is defined by setting <span>$\;\text{wdeg}(x^\alpha) = w_1\alpha_1 + \cdots + w_n\alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \; \text{wdeg}(x^\alpha) &gt; \text{wdeg}(x^\beta)  \;\text{ or }\;\\
(\text{wdeg}(x^\alpha) = \text{wdeg}(x^\beta)  \;\text{ and }\; \exists \; 1 \leq i \leq n: \alpha_n = \beta_n, \dots, \alpha_{i+1} = \beta_{i+1}, \alpha_i &lt; \beta_i).\]</p><article class="docstring"><header><a class="docstring-binding" id="wdegrevlex-Tuple{MPolyRing, Vector{Int64}}" href="#wdegrevlex-Tuple{MPolyRing, Vector{Int64}}"><code>wdegrevlex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wdegrevlex(R::MPolyRing, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>If <code>W</code> is a vector of positive integers, return the corresponding weighted reverse  lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">wdegrevlex(V::AbstractVector{&lt;:MPolyElem}, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables and a vector <code>W</code> of positive integers, return the corresponding weighted reverse  lexicographical ordering on the set of monomials in the given variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])

julia&gt; o1 = wdegrevlex(R, [1, 2, 3, 4])
wdegrevlex([w, x, y, z], [1, 2, 3, 4])

julia&gt; canonical_matrix(o1)
[1    2    3    4]
[0    0    0   -1]
[0    0   -1    0]
[0   -1    0    0]

julia&gt; o2 = wdegrevlex([w, x], [1, 2])
wdegrevlex([w, x], [1, 2])

julia&gt; o3 = wdegrevlex(gens(R)[3:4], [3, 4])
wdegrevlex([y, z], [3, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L850">source</a></section></article><h2 id="Predefined-Local-Orderings"><a class="docs-heading-anchor" href="#Predefined-Local-Orderings">Predefined Local Orderings</a><a id="Predefined-Local-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Predefined-Local-Orderings" title="Permalink"></a></h2><h4 id="The-Negative-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Negative-Lexicographical-Ordering">The Negative Lexicographical Ordering</a><a id="The-Negative-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Negative-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>negative lexicographical ordering</em> <code>neglex</code> is defined by setting</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;\exists \; 1 \leq i \leq n: \alpha_1 = \beta_1, \dots, \alpha_{i-1} = \beta_{i-1}, \alpha_i &lt; \beta_i.\]</p><article class="docstring"><header><a class="docstring-binding" id="neglex-Tuple{MPolyRing}" href="#neglex-Tuple{MPolyRing}"><code>neglex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neglex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the negative lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">neglex(V::AbstractVector{&lt;:MPolyElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the negative lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])

julia&gt; o1 = neglex(R)
neglex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[-1    0    0    0]
[ 0   -1    0    0]
[ 0    0   -1    0]
[ 0    0    0   -1]

julia&gt; o2 = neglex([w, x])
neglex([w, x])

julia&gt; o3 = neglex(gens(R)[3:4])
neglex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L475">source</a></section></article><h4 id="The-Negative-Degree-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Negative-Degree-Lexicographical-Ordering">The Negative Degree Lexicographical Ordering</a><a id="The-Negative-Degree-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Negative-Degree-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>negative degree lexicographical ordering</em> <code>negdeglex</code> is defined by setting <span>$\;\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;  \deg(x^\alpha) &lt; \deg(x^\beta)  \;\text{ or }\; \exists \; 1 \leq i \leq n: \alpha_1 = \beta_1, \dots, \alpha_{i-1} = \beta_{i-1}, \alpha_i &gt; \beta_i.\]</p><article class="docstring"><header><a class="docstring-binding" id="negdeglex-Tuple{MPolyRing}" href="#negdeglex-Tuple{MPolyRing}"><code>negdeglex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negdeglex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the negative degree lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">negdeglex(V::AbstractVector{&lt;:MPolyElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the negative degree lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])

julia&gt; o1 = negdeglex(R)
negdeglex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[-1   -1   -1   -1]
[ 0   -1   -1   -1]
[ 0    0   -1   -1]
[ 0    0    0   -1]

julia&gt; o2 = negdeglex([w, x])
negdeglex([w, x])

julia&gt; o3 = negdeglex(gens(R)[3:4])
negdeglex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L675">source</a></section></article><h4 id="The-Negative-Reverse-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Negative-Reverse-Lexicographical-Ordering">The Negative Reverse Lexicographical Ordering</a><a id="The-Negative-Reverse-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Negative-Reverse-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>negative reverse lexicographical ordering</em> <code>negrevlex</code> is defined by setting</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;\exists \; 1 \leq i \leq n: \alpha_n = \beta_n, \dots, \alpha_{i+1} = \beta_{i+1}, \alpha_i  &lt; \beta_i.\]</p><article class="docstring"><header><a class="docstring-binding" id="negrevlex-Tuple{MPolyRing}" href="#negrevlex-Tuple{MPolyRing}"><code>negrevlex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negrevlex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the negative reverse lexicographical ordering  on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">negrevlex(V::AbstractVector{&lt;:MPolyElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the negative reverse lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])

julia&gt; o1 = negrevlex(R)
negrevlex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[ 0    0    0   -1]
[ 0    0   -1    0]
[ 0   -1    0    0]
[-1    0    0    0]

julia&gt; o2 = negrevlex([w, x])
negrevlex([w, x])

julia&gt; o3 = negrevlex(gens(R)[3:4])
negrevlex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L539">source</a></section></article><h4 id="The-Negative-Degree-Reverse-Lexicographical-Ordering"><a class="docs-heading-anchor" href="#The-Negative-Degree-Reverse-Lexicographical-Ordering">The Negative Degree Reverse Lexicographical Ordering</a><a id="The-Negative-Degree-Reverse-Lexicographical-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#The-Negative-Degree-Reverse-Lexicographical-Ordering" title="Permalink"></a></h4><p>The <em>negative degree reverse lexicographical ordering</em> <code>negdegrevlex</code> is defined by setting <span>$\;\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \; \deg(x^\alpha) &lt; \deg(x^\beta)  \;\text{ or }\;\exists \; 1 \leq i \leq n: \alpha_n = \beta_n, \dots, \alpha_{i+1} = \beta_{i+1}, \alpha_i &lt; \beta_i.\]</p><article class="docstring"><header><a class="docstring-binding" id="negdegrevlex-Tuple{MPolyRing}" href="#negdegrevlex-Tuple{MPolyRing}"><code>negdegrevlex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negdegrevlex(R::MPolyRing) -&gt; MonomialOrdering</code></pre><p>Return the negative degree reverse lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">negdegrevlex(V::AbstractVector{&lt;:MPolyElem}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables, return the negative degree reverse lexicographical ordering on the set of monomials in these variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])

julia&gt; o1 = negdegrevlex(R)
negdegrevlex([w, x, y, z])

julia&gt; canonical_matrix(o1)
[-1   -1   -1   -1]
[ 0    0    0   -1]
[ 0    0   -1    0]
[ 0   -1    0    0]

julia&gt; o2 = negdegrevlex([w, x])
negdegrevlex([w, x])

julia&gt; o3 = negdegrevlex(gens(R)[3:4])
negdegrevlex([y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L603">source</a></section></article><h4 id="Negative-Weighted-Lexicographical-Orderings"><a class="docs-heading-anchor" href="#Negative-Weighted-Lexicographical-Orderings">Negative Weighted Lexicographical Orderings</a><a id="Negative-Weighted-Lexicographical-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Negative-Weighted-Lexicographical-Orderings" title="Permalink"></a></h4><p>If <code>W</code> is a vector of positive integers  <span>$w_1, \dots, w_n$</span>, the corresponding <em>negative weighted lexicographical ordering</em> <code>negwdeglex(W)</code>  is defined by setting <span>$\;\text{wdeg}(x^\alpha) = w_1\alpha_1 + \cdots + w_n\alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \;  \text{wdeg}(x^\alpha) &lt; \text{wdeg}(x^\beta)  \;\text{ or }\;\\
(\text{wdeg}(x^\alpha) = \text{wdeg}(x^\beta)  \;\text{ and }\; \exists \; 1 \leq i \leq n: \alpha_1 = \beta_1, \dots, \alpha_{i-1} = \beta_{i-1}, \alpha_i &gt; \beta_i).\]</p><article class="docstring"><header><a class="docstring-binding" id="negwdeglex-Tuple{MPolyRing, Vector{Int64}}" href="#negwdeglex-Tuple{MPolyRing, Vector{Int64}}"><code>negwdeglex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negwdeglex(R::MPolyRing, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>If <code>W</code> is a vector of positive integers, return the corresponding negative weighted  lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">negwdeglex(V::AbstractVector{&lt;:MPolyElem}, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables and a vector <code>W</code> of positive integers, return the corresponding negative weighted lexicographical ordering on the set of monomials in the given variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])

julia&gt; o1 = negwdeglex(R, [1, 2, 3, 4])
negwdeglex([w, x, y, z], [1, 2, 3, 4])

julia&gt; canonical_matrix(o1)
[-1   -2   -3   -4]
[ 0   -2   -3   -4]
[ 0    0   -3   -4]
[ 0    0    0   -1]

julia&gt; o2 = negwdeglex([w, x], [1, 2])
negwdeglex([w, x], [1, 2])

julia&gt; o3 = negwdeglex(gens(R)[3:4], [3, 4])
negwdeglex([y, z], [3, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L919">source</a></section></article><h4 id="Negative-Weighted-Reverse-Lexicographical-Orderings"><a class="docs-heading-anchor" href="#Negative-Weighted-Reverse-Lexicographical-Orderings">Negative Weighted Reverse Lexicographical Orderings</a><a id="Negative-Weighted-Reverse-Lexicographical-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Negative-Weighted-Reverse-Lexicographical-Orderings" title="Permalink"></a></h4><p>If <code>W</code> is a vector of positive integers  <span>$w_1, \dots, w_n$</span>, the corresponding <em>negative weighted reverse lexicographical ordering</em> <code>negwdegrevlex(W)</code>  is defined by setting <span>$\;\text{wdeg}(x^\alpha) = w_1\alpha_1 + \cdots + w_n\alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt; x^\beta \;  \Leftrightarrow \; \text{wdeg}(x^\alpha) &lt; \text{wdeg}(x^\beta)  \;\text{ or }\;\\
(\text{wdeg}(x^\alpha) = \text{wdeg}(x^\beta)  \;\text{ and }\; \exists \; 1 \leq i \leq n: \alpha_n = \beta_n, \dots, \alpha_{i+1} = \beta_{i+1}, \alpha_i &lt; \beta_i).\]</p><article class="docstring"><header><a class="docstring-binding" id="negwdegrevlex-Tuple{MPolyRing, Vector{Int64}}" href="#negwdegrevlex-Tuple{MPolyRing, Vector{Int64}}"><code>negwdegrevlex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negwdegrevlex(R::MPolyRing, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>If <code>W</code> is a vector of positive integers, return the corresponding negative weighted reverse lexicographical ordering on the set of monomials in the variables of <code>R</code>.</p><pre><code class="nohighlight hljs">negwdegrevlex(V::AbstractVector{&lt;:MPolyElem}, W::Vector{Int}) -&gt; MonomialOrdering</code></pre><p>Given a vector <code>V</code> of variables and a vector <code>W</code> of positive integers, return the corresponding negative weighted reverse lexicographical ordering on the set of monomials in the given variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])

julia&gt; o1 = negwdegrevlex(R, [1, 2, 3, 4])
negwdegrevlex([w, x, y, z], [1, 2, 3, 4])

julia&gt; canonical_matrix(o1)
[-1   -2   -3   -4]
[ 0    0    0   -1]
[ 0    0   -1    0]
[ 0   -1    0    0]

julia&gt; o2 = negwdegrevlex([w, x], [1, 2])
negwdegrevlex([w, x], [1, 2])

julia&gt; o3 = negwdegrevlex(gens(R)[3:4], [3, 4])
negwdegrevlex([y, z], [3, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L988">source</a></section></article><h2 id="Weight-Orderings"><a class="docs-heading-anchor" href="#Weight-Orderings">Weight Orderings</a><a id="Weight-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Weight-Orderings" title="Permalink"></a></h2><p>If <span>$W$</span> is a vector of integers  <span>$w_1, \dots, w_n$</span>, and <span>$&gt;$</span> is a monomial ordering on <span>$\text{Mon}_n(x)$</span>, then the corresponding <em>weight ordering</em> is defined by setting <span>$\;\text{wdeg}(x^\alpha) = w_1\alpha_1 + \cdots + w_n\alpha_n\;$</span> and</p><p class="math-container">\[x^\alpha &gt;_{W} x^\beta \;  \Leftrightarrow \; \text{wdeg}(x^\alpha) &gt; \text{wdeg}(x^\beta)  \;\text{ or }\;
(\text{wdeg}(x^\alpha) = \text{wdeg}(x^\beta)  \;\text{ and }\; x^\alpha &gt; x^\beta).\]</p><article class="docstring"><header><a class="docstring-binding" id="weight_ordering-Tuple{Vector{Int64}, MonomialOrdering}" href="#weight_ordering-Tuple{Vector{Int64}, MonomialOrdering}"><code>weight_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weight_ordering(W::Vector{Int}, ord::MonomialOrdering) -&gt; MonomialOrdering</code></pre><p>Given an integer vector <code>W</code> and a monomial ordering <code>ord</code> on a set of monomials in <code>length(W)</code> variables, return the monomial ordering <code>ord_W</code> on this set of monomials which is obtained by first comparing the <code>W</code>-weighted degrees and then using <code>ord</code>  in the case of a tie.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The ordering <code>ord_W</code> is   </p><ul><li>global if all entries of <code>W</code> are positive, or if they are all non-negative and <code>ord</code> is global,</li><li>an elimination ordering for the set of variables which correspond to positive entries of <code>W</code>.   </li></ul></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; W = [1, 0, -1];

julia&gt; o = lex(R)
lex([x, y, z])

julia&gt; matrix(o)
[1   0   0]
[0   1   0]
[0   0   1]

julia&gt; oW = weight_ordering(W, o)
matrix_ordering([x, y, z], [1 0 -1])*lex([x, y, z])

julia&gt; matrix(oW)
[1   0   -1]
[1   0    0]
[0   1    0]
[0   0    1]

julia&gt; canonical_matrix(oW)
[1   0   -1]
[0   0    1]
[0   1    0]

julia&gt; o2 = weight_ordering([1, -1], lex([x, z]))
matrix_ordering([x, z], [1 -1])*lex([x, z])

julia&gt; canonical_matrix(o2)
[1   0   -1]
[0   0    1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L1125">source</a></section></article><h2 id="Block-Orderings"><a class="docs-heading-anchor" href="#Block-Orderings">Block Orderings</a><a id="Block-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Orderings" title="Permalink"></a></h2><p>The concept of block orderings (product orderings) allows one to construct new monomial orderings from already given ones: If <span>$&gt;_1$</span> and <span>$&gt;_2$</span> are monomial orderings on <span>$\text{Mon}_s(x_1, \ldots, x_s)$</span> and <span>$\text{Mon}_{n-s}(x_{s+1}, \ldots, x_n)$</span>, respectively, then the <em>block ordering</em> <span>$&gt; \; = \; (&gt;_1, &gt;_2)$</span> on <span>$\text{Mon}_n(x)=\text{Mon}_n(x_1, \ldots, x_n)$</span> is defined by setting</p><p class="math-container">\[x^\alpha&gt;x^\beta  \;\Leftrightarrow\;  x_1^{\alpha_1}\cdots x_s^{\alpha_s} &gt;_1 x_1^{\beta_1}\cdots x_s^{\beta_s} \;\text{ or }\;
\bigl(x_1^{\alpha_1}\cdots x_s^{\alpha_s} = x_1^{\beta_1}\cdots x_s^{\beta_s} \text{ and }  x_{s+1}^{\alpha_{s+1}}\cdots x_n^{\alpha_n} &gt;_2
x_{s+1}^{\beta_{s+1}}\cdots x_n^{\beta_n}\bigr).\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The ordering  <span>$(&gt;_1, &gt;_2)$</span></p><ul><li>is global (local) iff both <span>$&gt;_1$</span> and <span>$&gt;_2$</span> are global (local). Mixed orderings arise by choosing one of <span>$&gt;_1$</span> and <span>$&gt;_2$</span> global and the other one local,</li><li>is an elimination ordering for the first block of variables iff <span>$&gt;_1$</span> is global.</li></ul></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>The definition of a block ordering above subdivides <span>$x$</span> into a block of initial variables and its complementary block of variables.   Block orderings for a subdivision of <span>$x$</span> into any block of variables and its complementary block are defined similarly and have similar properties.</li><li>Inductively, one obtains block orderings composed of more than two individual orderings.</li></ul></div></div><p>In OSCAR, block orderings are obtained by the concatenation of individual  orderings using the <code>*</code> operator.</p><h5 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])</code><code class="nohighlight hljs ansi" style="display:block;">(Multivariate Polynomial Ring in w, x, y, z over Rational Field, fmpq_mpoly[w, x, y, z])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; o = degrevlex([w, x])*degrevlex([y, z])</code><code class="nohighlight hljs ansi" style="display:block;">degrevlex([w, x])*degrevlex([y, z])</code></pre><h2 id="Elimination-Orderings"><a class="docs-heading-anchor" href="#Elimination-Orderings">Elimination Orderings</a><a id="Elimination-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Elimination-Orderings" title="Permalink"></a></h2><p>Let <span>$C[x]=C[x_1, \ldots, x_n]$</span> be a multivariate polynomial ring with coefficient ring <span>$C$</span>. Fix a subset <span>$\sigma\subset \{1,\dots, n\}$</span> and write <span>$x_\sigma$</span>  for the set of variables <span>$x_i$</span> with <span>$i\in\sigma$</span>. An <em>elimination ordering for <span>$x\smallsetminus x_\sigma$</span></em>  is a monomial ordering <span>$&gt;$</span> on <span>$\text{Mon}_n(x)$</span> which satisfies the following property: If <span>$a$</span> is a monomial involving one of the variables in <span>$x\smallsetminus x_\sigma$</span> , and <span>$b$</span> is a monomial depending only on the variables in  <span>$x_\sigma$</span>, then <span>$a &gt; b.$</span> Computing a Gröbner basis of <span>$I$</span> with respect to such an ordering provides one way of finding the intersection <span>$I\cap C[x_\sigma]$</span>, that is, of  <em>eliminating the variables in <span>$x\smallsetminus x_\sigma$</span> from <span>$I$</span></em>: The Gröbner basis elements which only depend on the variables in <span>$x_\sigma$</span> form a Gröbner basis for <span>$I\cap C[x_\sigma]$</span> with respect to the restriction of <span>$&gt;$</span> to the set of monomials in <span>$I\cap C[x_\sigma]$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The lexicographical ordering is an elimination ordering for each initial set of variables <span>$x_1, \dots, x_k$</span>. If only a fixed subset of variables is considered, suitable weight or block orderings as discussed above are more effective. The documentation of the <code>is_elimination_ordering</code> function below offers examples and non-examples.</p></div></div><h2 id="Tests-on-Monomial-Orderings"><a class="docs-heading-anchor" href="#Tests-on-Monomial-Orderings">Tests on Monomial Orderings</a><a id="Tests-on-Monomial-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-on-Monomial-Orderings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="is_elimination_ordering-Tuple{MonomialOrdering, Vector{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyElem}" href="#is_elimination_ordering-Tuple{MonomialOrdering, Vector{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyElem}"><code>is_elimination_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_elimination_ordering(ord::MonomialOrdering, V::Vector{&lt;:MPolyElem})</code></pre><p>Given a vector <code>V</code> of polynomials which are variables, return <code>true</code> if <code>ord</code> is an elimination ordering for the variables in <code>V</code>. Return <code>false</code>, otherwise.</p><pre><code class="nohighlight hljs">is_elimination_ordering(ord::MonomialOrdering, V:Vector{Int})</code></pre><p>Given a vector <code>V</code> of indices which specify variables, return <code>true</code> if <code>ord</code> is an elimination ordering for the specified variables. Return <code>false</code>, otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; o1 = lex(R)
lex([w, x, y, z])

julia&gt; is_elimination_ordering(o1, [w, x])
true

julia&gt; o2 = weight_ordering([1, 1, 0, 0], degrevlex(R))
matrix_ordering([w, x, y, z], [1 1 0 0])*degrevlex([w, x, y, z])

julia&gt; is_elimination_ordering(o2, [w, x])
true

julia&gt; o3 = weight_ordering([1, -1, 0, 0], degrevlex(R))
matrix_ordering([w, x, y, z], [1 -1 0 0])*degrevlex([w, x, y, z])

julia&gt; is_elimination_ordering(o3, [w, x])
false

julia&gt; o4 = degrevlex([w, x])*degrevlex([y, z])
degrevlex([w, x])*degrevlex([y, z])

julia&gt; is_elimination_ordering(o4, [w, x])
true

julia&gt; o5 = degrevlex([w, x])*negdegrevlex([y, z])
degrevlex([w, x])*negdegrevlex([y, z])

julia&gt; is_elimination_ordering(o5, [w, x])
true

julia&gt; o6 = negdegrevlex([w, x])*negdegrevlex([y, z])
negdegrevlex([w, x])*negdegrevlex([y, z])

julia&gt; is_elimination_ordering(o6, [w, x])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L1451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_global-Tuple{MonomialOrdering}" href="#is_global-Tuple{MonomialOrdering}"><code>is_global</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_global(ord::MonomialOrdering)</code></pre><p>Return <code>true</code> if <code>ord</code> is global, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; o = matrix_ordering(R, [1 1; 0 -1])
matrix_ordering([x, y], [1 1; 0 -1])

julia&gt; is_global(o)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L1311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_local-Tuple{MonomialOrdering}" href="#is_local-Tuple{MonomialOrdering}"><code>is_local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_local(ord::MonomialOrdering)</code></pre><p>Return <code>true</code> if <code>ord</code> is local, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; o = matrix_ordering(R, [-1 -1; 0 -1])
matrix_ordering([x, y], [-1 -1; 0 -1])

julia&gt; is_local(o)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L1337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_mixed-Tuple{MonomialOrdering}" href="#is_mixed-Tuple{MonomialOrdering}"><code>is_mixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_mixed(ord::MonomialOrdering)</code></pre><p>Return <code>true</code> if <code>ord</code> is mixed, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; o = matrix_ordering(R, [1 -1; 0 -1])
matrix_ordering([x, y], [1 -1; 0 -1])

julia&gt; is_mixed(o)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L1363">source</a></section></article><h2 id="Module-Orderings"><a class="docs-heading-anchor" href="#Module-Orderings">Module Orderings</a><a id="Module-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Orderings" title="Permalink"></a></h2><p>Let <span>$R = C[x]=C[x_1, \ldots, x_n]$</span> be a multivariate polynomial ring with coefficient ring <span>$C$</span>. Referring to the section on free modules for details, we recall that by a free <span>$R$</span>-module we mean a free module of type <span>$R^p$</span> , where we think of <span>$R^p$</span> as a free module with a given basis, namely the basis of standard unit vectors. In what follows, <span>$F$</span> will denote such free <span>$R$</span>-module, and <span>$\{e_1 ,\dots , e_p\}$</span> will denote the given basis.</p><p>A <em>monomial in <span>$F$</span></em>, involving the basis element <span>$e_i$</span>, is a monomial in <span>$R$</span> times <span>$e_i$</span>.  A term in <span>$F$</span> is a monomial in <span>$F$</span> multiplied by a coefficient <span>$c\in C$</span>. Every nonzero element <span>$f\in F$</span> can  be uniquely expressed as the sum of finitely many nonzero terms involving  distinct monomials. These terms (monomials)  are called the <em>terms (monomials} of <span>$f$</span>.</em></p><p>A <em>monomial ordering</em> on <span>$F$</span> is a total ordering <span>$&gt;$</span> on the set of monomials in <span>$F$</span> such that if <span>$x^\alpha e_i$</span> and <span>$x^\beta e_j$</span> are monomials in <span>$F$</span>, and <span>$x^\gamma$</span> is a monomial in <span>$R$</span>, then </p><p class="math-container">\[x^\alpha e_i &gt; x^\beta e_j \Longrightarrow x^\gamma x^\alpha e_i &gt; x^\gamma x^\beta e_j.\]</p><p>In OSCAR, we require in addition that</p><p class="math-container">\[x^\alpha e_i &gt; x^\beta e_i \;\text{ iff }\; x^\alpha e_j &gt; x^\beta e_j \;\text{ for all }\; i,j.\]</p><p>Then <span>$&gt;$</span> induces a unique monomial ordering on <span>$R$</span> in the obvious way, and we say that  <span>$&gt;$</span> is <em>global</em>, <em>local</em>, or <em>mixed</em> if the induced ordering on <span>$R$</span> is global, local, or mixed. </p><p>One way of getting a monomial ordering on <span>$F$</span> is to pick a monomial ordering <span>$&gt;$</span> on <span>$R$</span>, and extend it to <span>$F$</span>. For instance, setting</p><p class="math-container">\[x^\alpha e_i &gt;  x^\beta e_j \iff x^\alpha &gt; x^\beta \;\text{ or }\; (x^\alpha = x^\beta \;\text{ and }\; i &gt; j)\]</p><p>gives priority to the monomials in <span>$R$</span>, whereas the ordering defined below gives priority to the components of <span>$F$</span>:</p><p class="math-container">\[x^\alpha e_i &gt;  x^\beta e_j \iff i &gt; j \;\text{ or }\; (i = j\;\text{ and } x^\alpha &gt; x^\beta).\]</p><p>Alternatively, we may wish to use <span>$i &lt; j$</span> instead of <span>$i &gt; j$</span> in this definition.</p><p>In other words, these orderings are obtained by concatenating a monomial ordering on the monomials of <span>$R$</span> with a way of ordering the basis vectors of <span>$F$</span> or vice versa. In OSCAR, we refer to the <span>$i &lt; j$</span> ordering on the basis vectors as <em>lex</em>, and to the <span>$i &gt; j$</span> ordering as <em>revlex</em>. And, we use the <code>*</code> operator for concatenation. </p><h5 id="Examples-3"><a class="docs-heading-anchor" href="#Examples-3">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-3" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; F = free_module(R, 3)</code><code class="nohighlight hljs ansi" style="display:block;">Free module of rank 3 over Multivariate Polynomial Ring in w, x, y, z over Rational Field</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; o1 = degrevlex(R)*revlex(gens(F))</code><code class="nohighlight hljs ansi" style="display:block;">degrevlex([w, x, y, z])*revlex([gen(1), gen(2), gen(3)])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; o2 = revlex(gens(F))*degrevlex(R)</code><code class="nohighlight hljs ansi" style="display:block;">revlex([gen(1), gen(2), gen(3)])*degrevlex([w, x, y, z])</code></pre><p>The induced ordering on the given polynomial ring is recovered as follows:</p><article class="docstring"><header><a class="docstring-binding" id="induced_ring_ordering-Tuple{Oscar.Orderings.ModuleOrdering}" href="#induced_ring_ordering-Tuple{Oscar.Orderings.ModuleOrdering}"><code>induced_ring_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">induced_ring_ordering(ord::ModuleOrdering)</code></pre><p>Return the ring ordering induced by <code>ord</code>.  </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = PolynomialRing(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; F = free_module(R, 3)
Free module of rank 3 over Multivariate Polynomial Ring in w, x, y, z over Rational Field

julia&gt; o = revlex(gens(F))*degrevlex(R)
revlex([gen(1), gen(2), gen(3)])*degrevlex([w, x, y, z])

julia&gt; induced_ring_ordering(o)
degrevlex([w, x, y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/3bcee7b946ad4c9af3fa5f0307d538fe36589fac/src/Rings/orderings.jl#L1641">source</a></section></article><p>The comparison function <code>cmp</code> as well as the tests <code>is_global</code>, <code>is_local</code>, and <code>is_mixed</code> are also available for module orderings.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../rings/">« Creating Multivariate Rings</a><a class="docs-footer-nextpage" href="../groebner_bases/">Gröbner and Standard Bases Over Fields »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 15 November 2022 18:33">Tuesday 15 November 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
