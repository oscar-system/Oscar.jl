<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Localizations of commutative rings ¬∑ Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to Oscar</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6" type="checkbox"/><label class="tocitem" for="menuitem-3-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Basics</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Quadratic and hermitian lattices</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/serialization/">Saving and loading</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/visualization/">Visualization</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/graphs/">Graphs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../rings/">Creating Polynomial Rings</a></li><li><a class="tocitem" href="../ideals/">Ideals in Polynomial Rings</a></li><li><a class="tocitem" href="../modules/">Modules Over Polynomial Rings</a></li><li><a class="tocitem" href="../affine_algebras/">Affine Algebras</a></li><li><a class="tocitem" href="../binomial_ideals/">Binomial Primary Decomposition</a></li><li class="is-active"><a class="tocitem" href>Localizations of commutative rings</a><ul class="internal"><li><a class="tocitem" href="#The-localization-interface"><span>The localization interface</span></a></li><li><a class="tocitem" href="#Localizations-of-multivariate-polynomial-rings"><span>Localizations of multivariate polynomial rings</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-10-1" type="checkbox"/><label class="tocitem" for="menuitem-10-1"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ToricVarieties/intro/">Toric geometry in Julia</a></li><li><a class="tocitem" href="../../ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisors/">Toric Divisors</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Commutative Algebra</a></li><li class="is-active"><a href>Localizations of commutative rings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Localizations of commutative rings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/CommutativeAlgebra/localizations.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Localizations-of-commutative-rings"><a class="docs-heading-anchor" href="#Localizations-of-commutative-rings">Localizations of commutative rings</a><a id="Localizations-of-commutative-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Localizations-of-commutative-rings" title="Permalink"></a></h1><p>Suppose <span>$R$</span> is a commutative ring with unit and <span>$S \subset R$</span> is a <em>multiplicatively  closed set</em> containing <span>$1 \in R$</span>. Then we can form the <em>localization</em> of <span>$R$</span> at <span>$S$</span></p><p class="math-container">\[    R[S^{-1}] = \left\{ \frac{p}{q} : p,q \in R, \, q \in S \right\},\]</p><p>with its standard arithmetic for fractions. See, for instance, [Eis95] for an account on localizations.</p><p>Oscar provides a general framework for such localizations, originally intended to be used  with multivariate polynomial rings <span>$R$</span> over some base field <span>$\mathbb k$</span>, but also  applicable to more general commutative rings.</p><p>In the case of polynomials, the localization framework provides the structure for  certain algorithms using standard bases. Note that, in general, localizations of  polynomial algebras are not finitely generated  as algebras over <span>$\mathbb k$</span>; for instance when localizing at some maximal  ideal <span>$\mathfrak m \subset R$</span>. However, many ideal- and module-theoretic questions in the localization  <span>$R[S^{-1}]$</span>, such as e.g. the ideal membership, can be transformed to questions on  ideals and modules over the base ring <span>$R$</span> and then solved using Groebner- or standard-basis  techniques. This makes it important to regard localizations <span>$R[S^{-1}]$</span> as rings with  a history of creation from the original pair <span>$S \subset R$</span>. </p><h2 id="The-localization-interface"><a class="docs-heading-anchor" href="#The-localization-interface">The localization interface</a><a id="The-localization-interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-localization-interface" title="Permalink"></a></h2><h3 id="Localized-rings"><a class="docs-heading-anchor" href="#Localized-rings">Localized rings</a><a id="Localized-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Localized-rings" title="Permalink"></a></h3><p>The interface that needs to be implemented for any concrete  instance of localized rings is the following.  Multiplicatively closed sets are derived from the abstract type</p><article class="docstring"><header><a class="docstring-binding" id="AbsMultSet" href="#AbsMultSet"><code>AbsMultSet</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbsMultSet{RingType, RingElemType}</code></pre><p>Abstract type for a multiplicatively closed set in a commutative (Noetherian) ring  R of type <code>RingType</code> with elements of type <code>RingElemType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/localization_interface.jl#L23-L28">source</a></section></article><p>The basic functionality that has to be implemented for any concrete type derived from  this is to be able to check containment of elements via</p><article class="docstring"><header><a class="docstring-binding" id="in-Union{Tuple{RingElemType}, Tuple{RingType}, Tuple{RingElemType, AbsMultSet{RingType, RingElemType}}} where {RingType, RingElemType}" href="#in-Union{Tuple{RingElemType}, Tuple{RingType}, Tuple{RingElemType, AbsMultSet{RingType, RingElemType}}} where {RingType, RingElemType}"><code>in</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">in(f::RingElemType, S::AbsMultSet{RingType, RingElemType}) where {RingType, RingElemType}</code></pre><p>Returns <code>true</code> if <code>f</code> belongs to <code>S</code>; <code>false</code> otherwise.</p><p><strong>Note:</strong> If this routine is not implemented, the function call will default to the  execution of an error message. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/localization_interface.jl#L42-L49">source</a></section></article><p>This is supposed to be an extension of the methods of the function <code>Base.in</code>.</p><p>A localized ring should then be derived from </p><article class="docstring"><header><a class="docstring-binding" id="AbsLocalizedRing" href="#AbsLocalizedRing"><code>AbsLocalizedRing</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbsLocalizedRing{RingType, RingElemType, MultSetType}</code></pre><p>The localization R[S‚Åª¬π] of a ring R of type <code>RingType</code> with elements of type <code>RingElemType</code> at a  multiplicatively closed set S of type <code>MultSetType</code>. </p><p>In general, the arithmetic of such a localized ring R[S‚Åª¬π] should be implemented using fractions  of elements in the original ring R. The methods provided for the multiplicatively closed set S  can be used to check whether a given denominator is admissible for the specific localization. </p><p>Depending on the actual type of R and S, further functionality can then be provided using  different Groebner-basis driven backends. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/localization_interface.jl#L58-L70">source</a></section></article><p>The basic way to construct localized rings is to first  specify a multiplicative set <code>S</code> and then call </p><article class="docstring"><header><a class="docstring-binding" id="Localization-Tuple{AbsMultSet}" href="#Localization-Tuple{AbsMultSet}"><code>Localization</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Localization(S::AbsMultSet)</p><p>Returns the localization of the <code>ambient_ring</code> of <code>S</code> at <code>S</code> itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/localization_interface.jl#L93-L97">source</a></section></article><p>This method must be implemented with a dispatch depending on  the concrete type of <code>S</code>.</p><p>For any concrete instance of type <code>AbsLocalizedRing</code> the following methods must be implemented:</p><article class="docstring"><header><a class="docstring-binding" id="base_ring-Tuple{AbsLocalizedRing}" href="#base_ring-Tuple{AbsLocalizedRing}"><code>base_ring</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>base_ring(W::AbsLocalizedRing)</p><p>Returns the base ring R for a localized ring of the form W = R[S‚Åª¬π].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/localization_interface.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="inverted_set-Tuple{AbsLocalizedRing}" href="#inverted_set-Tuple{AbsLocalizedRing}"><code>inverted_set</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>inverted_set(W::AbsLocalizedRing)</p><p>Returns the set S of at which has been localized for a localized ring W = R[S‚Åª¬π].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/localization_interface.jl#L83-L87">source</a></section></article><p>Also, conversion of fractions to elements of localized rings must be implemented in the form  <code>(W::AbsLocalizedRing{RingType, RingElemType, MultSetType})(a::RingElemType) where {RingType, RingElemType, MultSetType}</code>, taking <span>$a$</span> to the element <span>$\frac{a}{1}$</span>. For more general fractions one needs <code>(W::AbsLocalizedRing{RingType, RingElemType, MultSetType})(a::RingElemType, b::RingElemType) where {RingType, RingElemType, MultSetType}</code>, mapping a pair <span>$(a, b)$</span> to the fraction <span>$\frac{a}{b}$</span>.</p><p>The <em>elements</em> of localized rings must be derived from </p><article class="docstring"><header><a class="docstring-binding" id="AbsLocalizedRingElem" href="#AbsLocalizedRingElem"><code>AbsLocalizedRingElem</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbsLocalizedRingElem{RingType, RingElemType, MultSetType}</code></pre><p>The abstract type of an element of the localization R[S‚Åª¬π] of a commutative ring  R of type <code>RingType</code> with elements of type <code>RingElemType</code> at a multiplicatively  closed set S of type <code>MultSetType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/localization_interface.jl#L137-L143">source</a></section></article><p>For any concrete instance <code>F</code> of <code>AbsLocalizedRingElem</code> there must be the following  methods:</p><article class="docstring"><header><a class="docstring-binding" id="numerator-Tuple{AbsLocalizedRingElem}" href="#numerator-Tuple{AbsLocalizedRingElem}"><code>numerator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>numerator(f::AbsLocalizedRingElem)</p><p>Returns the numerator of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/localization_interface.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="denominator-Tuple{AbsLocalizedRingElem}" href="#denominator-Tuple{AbsLocalizedRingElem}"><code>denominator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>denominator(f::AbsLocalizedRingElem)</p><p>Returns the denominator of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/localization_interface.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="parent-Tuple{AbsLocalizedRingElem}" href="#parent-Tuple{AbsLocalizedRingElem}"><code>parent</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>parent(f::AbsLocalizedRingElem)</p><p>Returns the parent ring R[S‚Åª¬π] of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/localization_interface.jl#L169-L173">source</a></section></article><p>A default version of the arithmetic is implemented on the generic level using the above  functionality and the arithmetic for the original ring.  Depending on the actual concrete instance, one might wish to provide more fine-tuned methods,  starting e.g. by implementing </p><article class="docstring"><header><a class="docstring-binding" id="reduce_fraction-Tuple{AbsLocalizedRingElem}" href="#reduce_fraction-Tuple{AbsLocalizedRingElem}"><code>reduce_fraction</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>reduce_fraction(a::AbsLocalizedRingElem)</p><p>Reduce the fraction a = p/q. <strong>Warning</strong>: The catchall-implementation does nothing!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/localization_interface.jl#L192-L196">source</a></section></article><p>Note that this is called after <em>every</em> arithmetic operation (addition, multiplication,...),  so the computations carried out here should be computationally cheap.</p><p>Two toy examples for implementations of this interface for localizations  of the integers <span>$\mathbb Z$</span> and rings of the form <span>$\mathbb Z/n\mathbb Z$</span>  can be found in the test files  <code>test/Rings/integer-localizations.jl</code> and <code>test/Rings/nmod-localizations.jl</code>.</p><p><strong>Note:</strong> Any concrete type for localized rings is also required to implement  the general <a href="../../AbstractAlgebra/ring_interface/#Ring-Interface">Ring Interface</a> of Oscar! This has not been done to a full extent  for the previous two examples, but for <code>MPolyLocalizedRing</code>; see below.</p><h3 id="Ideals-in-localized-rings"><a class="docs-heading-anchor" href="#Ideals-in-localized-rings">Ideals in localized rings</a><a id="Ideals-in-localized-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Ideals-in-localized-rings" title="Permalink"></a></h3><p>One of the main reasons to implement localizations in the first place  is that this process preserves the property of a ring to be Noetherian;  which is crucial for computer algebra. In this regard, we have </p><article class="docstring"><header><a class="docstring-binding" id="AbsLocalizedIdeal" href="#AbsLocalizedIdeal"><code>AbsLocalizedIdeal</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>AbsLocalizedIdeal{RingType, RingElemType, MultSetType}</p><p>Abstract type for finitely generated ideals <span>$I ‚äÇ R[S‚Åª¬π]$</span> in localized rings. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/localization_interface.jl#L346-L350">source</a></section></article><p>The required getter methods are</p><article class="docstring"><header><a class="docstring-binding" id="gens-Tuple{AbsLocalizedIdeal}" href="#gens-Tuple{AbsLocalizedIdeal}"><code>gens</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gens(A::AbsAlgAss, return_full_basis::Typel{Val{T}} = Val{false};
     thorough_search::Bool = false) where T
  -&gt; Vector{AbsAlgAssElem}</code></pre><p>Returns a subset of <code>basis(A)</code>, which generates <span>$A$</span> as an algebra over <code>base_ring(A)</code>. If <code>return_full_basis</code> is set to <code>Val{true}</code>, the function also returns a <code>Vector{AbsAlgAssElem}</code> containing a full basis consisting of monomials in the generators and a <code>Vector{Vector{Tuple{Int, Int}}}</code> containing the information on how these monomials are built. E. g.: If the function returns <code>g</code>, <code>full_basis</code> and <code>v</code>, then we have <code>full_basis[i] = prod( g[j]^k for (j, k) in v[i] )</code>. If <code>thorough_search</code> is <code>true</code>, the number of returned generators is possibly smaller. This will in general increase the runtime. It is not guaranteed that the number of generators is minimal in any case.</p></div></section><section><div><pre><code class="nohighlight hljs">gens(A::AlgGrp, return_full_basis::Type{Val{T}} = Val{false})
  -&gt; Vector{AlgGrpElem}</code></pre><p>Returns a subset of <code>basis(A)</code>, which generates <span>$A$</span> as an algebra over <code>base_ring(A)</code>. If <code>return_full_basis</code> is set to <code>Val{true}</code>, the function also returns a <code>Vector{AbsAlgAssElem}</code> containing a full basis consisting of monomials in the generators and a <code>Vector{Vector{Tuple{Int, Int}}}</code> containing the information on how these monomials are built. E. g.: If the function returns <code>g</code>, <code>full_basis</code> and <code>v</code>, then we have <code>full_basis[i] = prod( g[j]^k for (j, k) in v[i] )</code>.</p></div></section><section><div><pre><code class="nohighlight hljs">gens(M::SubQuo{T}) where T</code></pre><p>Return the generators of <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Modules/UngradedModules.jl#L1960">source</a></section><section><div><pre><code class="nohighlight hljs">gens(I::sideal)</code></pre><p>Return the generators in the internal representation of the ideal <span>$I$</span> as an array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="base_ring-Tuple{AbsLocalizedIdeal}" href="#base_ring-Tuple{AbsLocalizedIdeal}"><code>base_ring</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">base_ring(I::MPolyIdeal{S}) where {S}</code></pre><p>Return the ambient ring of <code>I</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])

julia&gt; I = ideal(R, [x, y])^2
ideal(x^2, x*y, y^2)

julia&gt; base_ring(I)
Multivariate Polynomial Ring in x, y over Rational Field</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/mpoly-ideals.jl#L963">source</a></section></article><p>The constructors to be implemented are</p><pre><code class="nohighlight hljs">   ideal(W::AbsLocalizedRing{RingType, RingElemType, MultSetType}, f::AbsLocalizedRingElem{RingType, RingElemType, MultSetType})
   ideal(W::AbsLocalizedRing{RingType, RingElemType, MultSetType}, f::RingElemType)
   ideal(W::AbsLocalizedRing{RingType, RingElemType, MultSetType}, v::Vector{AbsLocalizedRingElem{RingType, RingElemType, MultSetType}})
   ideal(W::AbsLocalizedRing{RingType, RingElemType, MultSetType}, v::Vector{RingElemType})</code></pre><p>for a single and a list of generators from both the <code>base_ring</code> of <code>W</code> and from <code>W</code> itself.</p><p>The minimal functionality which should be implemented for ideals is the test  for ideal membership</p><pre><code class="nohighlight hljs">Base.in(
    f::AbsLocalizedRingElem{RingType, RingElemType, MultSetType}, 
    I::AbsLocalizedIdeal{RingType, RingElemType, MultSetType}
  ) where {RingType, RingElemType, MultSetType}</code></pre><p>and again the same for elements <code>f</code> of type <code>RingElemType</code>.</p><p>Basic operations on ideals which are already implemented on the generic level are </p><pre><code class="nohighlight hljs">Base.:*(I::T, J::T) where {T&lt;:AbsLocalizedIdeal}
Base.:+(I::T, J::T) where {T&lt;:AbsLocalizedIdeal}</code></pre><p>Everything else, such as e.g. intersections of ideals, has to be implemented for the specific  types by the user.</p><h2 id="Localizations-of-multivariate-polynomial-rings"><a class="docs-heading-anchor" href="#Localizations-of-multivariate-polynomial-rings">Localizations of multivariate polynomial rings</a><a id="Localizations-of-multivariate-polynomial-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Localizations-of-multivariate-polynomial-rings" title="Permalink"></a></h2><p>The available types of multiplicative sets are </p><article class="docstring"><header><a class="docstring-binding" id="MPolyComplementOfPrimeIdeal" href="#MPolyComplementOfPrimeIdeal"><code>MPolyComplementOfPrimeIdeal</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>MPolyComplementOfPrimeIdeal{     BaseRingType,      BaseRingElemType,     RingType,     RingElemType   } &lt;: AbsMultSet{     RingType,     RingElemType   }</p><p>The complement of a prime ideal <code>P ‚äÇ ùïú[x‚ÇÅ,‚Ä¶,x‚Çô]</code> in a multivariate polynomial ring  with elements of type <code>RingElemType</code> over a base ring <code>ùïú</code> of type <code>BaseRingType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/mpoly-localizations.jl#L77-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPolyComplementOfKPointIdeal" href="#MPolyComplementOfKPointIdeal"><code>MPolyComplementOfKPointIdeal</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>MPolyComplementOfKPointIdeal{     BaseRingType,     BaseRingElemType,      RingType,     RingElemType   } &lt;: AbsMultSet{     RingType,      RingElemType   }</p><p>Complement of a maximal ideal <span>$ùî™ = ‚ü®x‚ÇÅ-a‚ÇÅ,‚Ä¶,x‚Çô-a‚Çô‚ü©‚äÇ ùïú[x‚ÇÅ,‚Ä¶x‚Çô]$</span> with <span>$a·µ¢‚àà ùïú$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/mpoly-localizations.jl#L150-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPolyPowersOfElement" href="#MPolyPowersOfElement"><code>MPolyPowersOfElement</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>MPolyPowersOfElement{     BaseRingType,     BaseRingElemType,      RingType,     RingElemType   } &lt;: AbsMultSet{     RingType,      RingElemType   }</p><p>The set <code>S = { a·µè : k ‚àà ‚Ñï‚ÇÄ }</code> for some <span>$a ‚àà R$</span> with <span>$R$</span> of type <code>BaseRingType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/mpoly-localizations.jl#L226-L238">source</a></section></article><p>Localizations of multivariate polynomial rings are of type </p><article class="docstring"><header><a class="docstring-binding" id="MPolyLocalizedRing" href="#MPolyLocalizedRing"><code>MPolyLocalizedRing</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>MPolyLocalizedRing{     BaseRingType,     BaseRingElemType,     RingType,     RingElemType,     MultSetType   } &lt;: AbsLocalizedRing{     RingType,     RingType,     MultSetType   }</p><p>The localization of a multivariate polynomial ring <span>$R = ùïú[x‚ÇÅ,‚Ä¶,x‚Çô]$</span> over a  base field <span>$ùïú$</span> of type <code>BaseRingType</code> and with elements of type <code>RingElemType</code>  at a multiplicative set <span>$S ‚äÇ R$</span> of type <code>MultSetType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/mpoly-localizations.jl#L300-L316">source</a></section></article><p>with elements of type</p><article class="docstring"><header><a class="docstring-binding" id="MPolyLocalizedRingElem" href="#MPolyLocalizedRingElem"><code>MPolyLocalizedRingElem</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>MPolyLocalizedRingElem{     BaseRingType,      BaseRingElemType,     RingType,     RingElemType,      MultSetType   } &lt;: AbsLocalizedRingElem{     RingType,     RingElemType,      MultSetType   } </p><p>Elements of localizations of polynomial rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/mpoly-localizations.jl#L400-L414">source</a></section></article><p>In order to make the <code>Singular</code> functionality available there is </p><article class="docstring"><header><a class="docstring-binding" id="LocalizedBiPolyArray" href="#LocalizedBiPolyArray"><code>LocalizedBiPolyArray</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>LocalizedBiPolyArray{BRT, BRET, RT, RET, MST}</p><p>Main workhorse for binding of ideals in localizations <span>$R[S‚Åª¬π]$</span> of  multivariate polynomial rings <span>$R = ùïú[x‚ÇÅ,‚Ä¶,x‚Çô]$</span> to Singular. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/mpoly-localizations.jl#L598-L603">source</a></section></article><p>which has a monomial ordering and a <code>Singular</code> ring associated to it.  This is also the type returned by any Groebner- or standard basis  computation.</p><p>Ideals in localizations of multivariate polynomial rings are of the type</p><article class="docstring"><header><a class="docstring-binding" id="MPolyLocalizedIdeal" href="#MPolyLocalizedIdeal"><code>MPolyLocalizedIdeal</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>MPolyLocalizedIdeal{BRT, BRET, RT, RET, MST} &lt;: AbsLocalizedIdeal{RT, RET, MST}</p><p>Ideals in localizations of polynomial rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/402b3dfcb6acaa5df2c61c4ba00d8676d6527f76/src/Rings/mpoly-localizations.jl#L718-L722">source</a></section></article><p>and can be constructed using <code>ideal(W::MPolyLocalizedRing, ...)</code>, either from single elements or a list of elements  from both the localized ring or its base ring before localization. </p><p>Groebner and standard bases of ideals can be computed for explicit  orderings using </p><pre><code class="nohighlight hljs">    groebner_basis(I::MPolyLocalizedIdeal, ord::Symbol)</code></pre><p>Note that depending on the type parameters of <code>I</code>, this method  is dispatched differently, which will also lead to different  interpretations of the ordering. For instance, for multiplicative  sets of type <code>MPolyComplementOfKPointIdeal</code>, a shift of variables  taking the geometric point to the origin is applied to all polynomials  when passing to the singular side. </p><p>If the second argument is omitted, a default ordering  will be chosen, depending on the type of the multiplicative set. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../binomial_ideals/">¬´ Binomial Primary Decomposition</a><a class="docs-footer-nextpage" href="../../InvariantTheory/intro/">Introduction ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 19 November 2021 12:43">Friday 19 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
