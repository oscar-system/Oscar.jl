<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Exact real and complex numbers · Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../padic/">Padics</a></li><li><a class="tocitem" href="../qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../Experimental/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/visualization/">Visualization</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/groebner_bases/">Gröbner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/groebner_bases_integers/">Gröbner/Standard Bases Over <span>$\mathbb Z$</span></a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ideals/">Ideals in Multivariate Rings</a></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">Modules Over Multivariate Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/">Subquotient Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/homological_algebra/">Homological Algebra</a></li></ul></li><li><a class="tocitem" href="../../CommutativeAlgebra/affine_algebras/">Affine Algebras</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/binomial_ideals/">Binomial Primary Decomposition</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/localizations/">Localization</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/module_localizations/">Localizations of modules over computable rings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../TropicalGeometry/curve/">Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Standard Constructions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/StandardConstructions/standard_constructions/">Standard Constructions in Algebraic Geometry</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/K3Surfaces/">Algebraic Surfaces</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Finitely Presented Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-7" type="checkbox"/><label class="tocitem" for="menuitem-17-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Exact real and complex numbers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Exact real and complex numbers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/Nemo/complex.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Exact-real-and-complex-numbers"><a class="docs-heading-anchor" href="#Exact-real-and-complex-numbers">Exact real and complex numbers</a><a id="Exact-real-and-complex-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-real-and-complex-numbers" title="Permalink"></a></h1><p>Exact real and complex numbers are provided by Calcium. Internally, a number <span>$z$</span> is represented as an element of an extension field of the rational numbers. That is,</p><p class="math-container">\[z \in \mathbb{Q}(a_1,\ldots,a_n)\]</p><p>where <span>$a_1, \ldots, a_n$</span> are symbolically defined algebraic or transcendental real or complex numbers such as <span>$\pi$</span>, <span>$\sqrt{2}$</span> or <span>$e^{\sqrt{2} \pi i}$</span>. The user does not normally need to worry about the details of the internal representation; Calcium constructs extension numbers and fields automatically as needed to perform operations.</p><p>The user must create a <code>CalciumField</code> instance which represents the mathematical domain <span>$\mathbb{C}$</span>. This parent object holds a cache of extension numbers and fields used to represent individual elements. It also stores various options for evaluation (documented further below).</p><table><tr><th style="text-align: right">Library</th><th style="text-align: right">Element type</th><th style="text-align: right">Parent type</th></tr><tr><td style="text-align: right">Calcium</td><td style="text-align: right"><code>ca</code></td><td style="text-align: right"><code>CalciumField</code></td></tr></table><p>Please note the following:</p><ul><li><p>It is in the nature of exact complex arithmetic that some operations must be implemented using incomplete heuristics. For example, testing whether an element is zero will not always succeed. When Calcium is unable to perform a task, Nemo will throw an exception. This ensures that Calcium fields behave exactly and never silently return wrong results.</p></li><li><p>Calcium elements can optionally hold special non-numerical values:</p><ul><li><p>Unsigned infinity <span>$\hat \infty$</span></p></li><li><p>Signed infinities (<span>$\pm \infty$</span>, <span>$\pm i \infty$</span>, and more generally <span>$e^{i \theta} \cdot \infty$</span>)</p></li><li><p>Undefined</p></li><li><p>Unknown</p></li></ul><p>By default, such special values are disallowed so that a <code>CalciumField</code> represents the mathematical field <span>$\mathbb{C}$</span>, and any operation that would result in a special value (for example, <span>$1 / 0 = \hat \infty$</span>) will throw an exception. To allow special values, pass <code>extended=true</code> to the <code>CalciumField</code> constructor.</p></li><li><p><code>CalciumField</code> instances only support single-threaded use. You must create a separate parent object for each thread to do parallel computation.</p></li><li><p>When performing an operation involving two <code>ca</code> operands with different parent objects, Nemo will arbitrarily coerce the operands (and hence the result) to one of the parents.</p></li></ul><h2 id="Calcium-field-options"><a class="docs-heading-anchor" href="#Calcium-field-options">Calcium field options</a><a id="Calcium-field-options-1"></a><a class="docs-heading-anchor-permalink" href="#Calcium-field-options" title="Permalink"></a></h2><p>The <code>CalciumField</code> parent stores various options that affect simplification power, performance, or appearance. The user can override any of the default values using <code>C = CalciumField(options=dict)</code> where <code>dict</code> is a dictionary with <code>Symbol =&gt; Int</code> pairs. To retrieve the option values as a dictionary (including any default values not set by the user), call <code>options(C)</code>.</p><p>The following options are supported:</p><table><tr><th style="text-align: right">Option</th><th style="text-align: right">Explanation</th></tr><tr><td style="text-align: right"><code>:verbose</code></td><td style="text-align: right">Enable debug output</td></tr><tr><td style="text-align: right"><code>:print_flags</code></td><td style="text-align: right">Flags controlling print style</td></tr><tr><td style="text-align: right"><code>:mpoly_ord</code></td><td style="text-align: right">Monomial order for polynomials</td></tr><tr><td style="text-align: right"><code>:prec_limit</code></td><td style="text-align: right">Precision limit for numerical evaluation</td></tr><tr><td style="text-align: right"><code>:qqbar_deg_limit</code></td><td style="text-align: right">Degree limit for algebraic numbers</td></tr><tr><td style="text-align: right"><code>:low_prec</code></td><td style="text-align: right">Initial precision for numerical evaluation</td></tr><tr><td style="text-align: right"><code>:smooth_limit</code></td><td style="text-align: right">Factor size limit for smooth integer factorization</td></tr><tr><td style="text-align: right"><code>:lll_prec</code></td><td style="text-align: right">Precision for integer relation detection</td></tr><tr><td style="text-align: right"><code>:pow_limit</code></td><td style="text-align: right">Maximum exponent for in-field powering</td></tr><tr><td style="text-align: right"><code>:use_gb</code></td><td style="text-align: right">Enable Gröbner basis computation</td></tr><tr><td style="text-align: right"><code>:gb_length_limit</code></td><td style="text-align: right">Maximum ideal basis length during Gröbner basis computation</td></tr><tr><td style="text-align: right"><code>:gb_poly_length_limit</code></td><td style="text-align: right">Maximum polynomial length during Gröbner basis computation</td></tr><tr><td style="text-align: right"><code>:gb_poly_bits_limit</code></td><td style="text-align: right">Maximum bit size during Gröbner basis computation</td></tr><tr><td style="text-align: right"><code>:gb_vieta_limit</code></td><td style="text-align: right">Maximum degree to use Vieta&#39;s formulas</td></tr><tr><td style="text-align: right"><code>:trig_form</code></td><td style="text-align: right">Default form of trigonometric functions</td></tr></table><p>An important function of these options is to control how hard Calcium will try to find an answer before it gives up. For example:</p><ul><li><p>Setting <code>:prec_limit =&gt; 65536</code> will allow Calcium to use up to 65536 bits of precision (instead of the default 4096) to prove inequalities.</p></li><li><p>Setting <code>:qqbar_deg_limit =&gt; typemax(Int)</code> (instead of the default 120) will force most calculations involving algebraic numbers to run to completion, no matter how long this will take.</p></li><li><p>Setting <code>:use_gb =&gt; 0</code> (instead of the default 1) disables use of Gröbner bases. In general, this will negatively impact Calcium&#39;s ability to simplify field elements and prove equalities, but it can speed up calculations where Gröbner bases are unnecessary.</p></li></ul><p>For a detailed explanation, refer to the following section in the Calcium documentation: <a href="https://fredrikj.net/calcium/ca.html#context-options">https://fredrikj.net/calcium/ca.html#context-options</a></p><h2 id="Basic-examples"><a class="docs-heading-anchor" href="#Basic-examples">Basic examples</a><a id="Basic-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-examples" title="Permalink"></a></h2><pre><code class="language-julia hljs">julia&gt; C = CalciumField()
Exact Complex Field

julia&gt; exp(C(pi) * C(1im)) + 1
0

julia&gt; log(C(-1))
3.14159*I {a*b where a = 3.14159 [Pi], b = I [b^2+1=0]}

julia&gt; log(C(-1)) ^ 2
-9.86960 {-a^2 where a = 3.14159 [Pi], b = I [b^2+1=0]}

julia&gt; log(C(10)^23) // log(C(100))
11.5000 {23/2}

julia&gt; 4*atan(C(1)//5) - atan(C(1)//239) == C(pi)//4
true

julia&gt; Cx, x = PolynomialRing(C, &quot;x&quot;)
(Univariate Polynomial Ring in x over Exact Complex Field, x)

julia&gt; (a, b) = (sqrt(C(2)), sqrt(C(3)))
(1.41421 {a where a = 1.41421 [a^2-2=0]}, 1.73205 {a where a = 1.73205 [a^2-3=0]})

julia&gt; (x-a-b)*(x-a+b)*(x+a-b)*(x+a+b)
x^4 + (-10)*x^2 + 1</code></pre><h2 id="Conversions-and-numerical-evaluation"><a class="docs-heading-anchor" href="#Conversions-and-numerical-evaluation">Conversions and numerical evaluation</a><a id="Conversions-and-numerical-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions-and-numerical-evaluation" title="Permalink"></a></h2><p>Calcium numbers can created from integers (<code>ZZ</code>), rationals (<code>QQ</code>) and algebraic numbers (<code>QQbar</code>), and through the application of arithmetic operations and transcendental functions.</p><p>Calcium numbers can be converted to integers, rational and algebraic fields provided that the values are integer, rational or algebraic. An exception is thrown if the value does not belong to the target domain, if Calcium is unable to prove that the value belongs to the target domain, or if Calcium is unable to compute the explicit value because of evaluation limits.</p><pre><code class="language-julia hljs">julia&gt; QQ(C(1))
1

julia&gt; QQBar(sqrt(C(2)) // 2)
Root 0.707107 of 2x^2 - 1

julia&gt; QQ(C(pi))
ERROR: unable to convert to a rational number

julia&gt; QQ(C(10) ^ C(10^9))
ERROR: unable to convert to a rational number</code></pre><p>To compute arbitrary-precision numerical enclosures, convert to <code>ArbField</code> or <code>AcbField</code>:</p><pre><code class="language-julia hljs">julia&gt; CC = AcbField(64);

julia&gt; CC(exp(C(1im)))
[0.54030230586813971740 +/- 9.37e-22] + [0.84147098480789650665 +/- 2.51e-21]*im</code></pre><p>The constructor</p><pre><code class="language-julia hljs">(R::AcbField)(a::ca; parts::Bool=false)</code></pre><p>returns an enclosure of the complex number <em>a</em>. It attempts to obtain a relative accuracy of <em>prec</em> bits where <em>prec</em> is the precision of the target field, but it is not guaranteed that this goal is achieved.</p><p>If <em>parts</em> is set to <em>true</em>, it attempts to achieve the target accuracy for both real and imaginary parts. This can be significantly more expensive if one part is smaller than the other, or if the number is nontrivially purely real or purely imaginary (in which case an exact proof attempt is made).</p><pre><code class="language-julia hljs">julia&gt; x = sin(C(1), form=:exponential)
0.841471 + 0e-24*I {(-a^2*b+b)/(2*a) where a = 0.540302 + 0.841471*I [Exp(1.00000*I {b})], b = I [b^2+1=0]}

julia&gt; AcbField(64)(x)
[0.84147098480789650665 +/- 2.51e-21] + [+/- 4.77e-29]*im

julia&gt; AcbField(64)(x, parts=true)
[0.84147098480789650665 +/- 2.51e-21]</code></pre><p>The constructor</p><pre><code class="language-julia hljs">(R::ArbField)(a::ca; check::Bool=true)</code></pre><p>returns a real enclosure. If <em>check</em> is set to <em>true</em> (default), the number <em>a</em> is verified to be real, and an exception is thrown if this cannot be determined. With <em>check</em> set to <em>false</em>, this function returns an enclosure of the real part of <em>a</em> without checking that the imaginary part is zero. This can be significantly faster.</p><h2 id="Comparisons-and-properties"><a class="docs-heading-anchor" href="#Comparisons-and-properties">Comparisons and properties</a><a id="Comparisons-and-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Comparisons-and-properties" title="Permalink"></a></h2><p>Except where otherwise noted, predicate functions such as <code>iszero</code>, <code>==</code>, <code>&lt;</code> and <code>isreal</code> act on the mathematical values of Calcium field elements. For example, although evaluating <span>$x = \sqrt{2} \sqrt{3}$</span> and <span>$y = \sqrt{6}$</span> results in different internal representations (<span>$x \in \mathbb{Q}(\sqrt{3}, \sqrt{2})$</span> and <span>$y \in \mathbb{Q}(\sqrt{6})$</span>), the numbers compare as equal:</p><pre><code class="language-julia hljs">julia&gt; x = sqrt(C(2)) * sqrt(C(3))
2.44949 {a*b where a = 1.73205 [a^2-3=0], b = 1.41421 [b^2-2=0]}

julia&gt; y = sqrt(C(6))
2.44949 {a where a = 2.44949 [a^2-6=0]}

julia&gt; x == y
true

julia&gt; iszero(x - y)
true

julia&gt; isinteger(x - y)
true</code></pre><p>Predicate functions return <em>true</em> if the property is provably true and <em>false</em> if the property if provably false. If Calcium is unable to prove the truth value, an exception is thrown. For example, with default settings, Calcium is currently able to prove that <span>$e^{e^{-1000}} \ne 1$</span>, but it fails to prove <span>$e^{e^{-3000}} \ne 1$</span>:</p><pre><code class="language-julia hljs">julia&gt; x = exp(exp(C(-1000)))
1.00000 {a where a = 1.00000 [Exp(5.07596e-435 {b})], b = 5.07596e-435 [Exp(-1000)]}

julia&gt; x == 1
false

julia&gt; x = exp(exp(C(-3000)))
1.00000 {a where a = 1.00000 [Exp(1.30784e-1303 {b})], b = 1.30784e-1303 [Exp(-3000)]}

julia&gt; x == 1
ERROR: Unable to perform operation (failed deciding truth of a predicate): isequal
...</code></pre><p>In this case, we can get an answer by allowing a higher working precision:</p><pre><code class="language-julia hljs">julia&gt; C2 = CalciumField(options=Dict(:prec_limit =&gt; 10^5));

julia&gt; exp(exp(C2(-3000))) == 1
false</code></pre><p>Real numbers can be ordered and sorted the usual way. We illustrate finding square roots that are well-approximated by integers:</p><pre><code class="language-julia hljs">julia&gt; sort([sqrt(C(n)) for n=0:10], by=x -&gt; abs(x - floor(x + C(1)//2)))
11-element Vector{ca}:
 0
 1
 2
 3
 3.16228 {a where a = 3.16228 [a^2-10=0]}
 2.82843 {2*a where a = 1.41421 [a^2-2=0]}
 2.23607 {a where a = 2.23607 [a^2-5=0]}
 1.73205 {a where a = 1.73205 [a^2-3=0]}
 2.64575 {a where a = 2.64575 [a^2-7=0]}
 1.41421 {a where a = 1.41421 [a^2-2=0]}
 2.44949 {a where a = 2.44949 [a^2-6=0]}</code></pre><p>As currently implemented, order comparisons involving nonreal numbers yield <em>false</em> (in both directions) rather than throwing an exception:</p><pre><code class="language-julia hljs">julia&gt; C(1im) &lt; C(1im)
false

julia&gt; C(1im) &gt; C(1im)
false</code></pre><p>This behavior may be changed or may become configurable in the future.</p><p><strong>Interface</strong></p><article class="docstring"><header><a class="docstring-binding" id="iszero-Tuple{ca}" href="#iszero-Tuple{ca}"><code>iszero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iszero(a::ca)</code></pre><p>Return whether <code>a</code> is the number 0.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="isone-Tuple{ca}" href="#isone-Tuple{ca}"><code>isone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isone(a::ca)</code></pre><p>Return whether <code>a</code> is the number 1.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_algebraic-Tuple{ca}" href="#is_algebraic-Tuple{ca}"><code>is_algebraic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_algebraic(a::ca)</code></pre><p>Return whether <code>a</code> is an algebraic number.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_rational-Tuple{ca}" href="#is_rational-Tuple{ca}"><code>is_rational</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_rational(a::ca)</code></pre><p>Return whether <code>a</code> is a rational number.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="isinteger-Tuple{ca}" href="#isinteger-Tuple{ca}"><code>isinteger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinteger(a::ca)</code></pre><p>Return whether <code>a</code> is an integer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="isreal-Tuple{ca}" href="#isreal-Tuple{ca}"><code>isreal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isreal(a::ca)</code></pre><p>Return whether <code>a</code> is a real number. This returns <code>false</code> if <code>a</code> is a pure real infinity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_imaginary-Tuple{ca}" href="#is_imaginary-Tuple{ca}"><code>is_imaginary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_imaginary(a::ca)</code></pre><p>Return whether <code>a</code> is an imaginary number. This returns <code>false</code> if <code>a</code> is a pure imaginary infinity.</p></div></section></article><h2 id="Infinities-and-special-values"><a class="docs-heading-anchor" href="#Infinities-and-special-values">Infinities and special values</a><a id="Infinities-and-special-values-1"></a><a class="docs-heading-anchor-permalink" href="#Infinities-and-special-values" title="Permalink"></a></h2><p>By default, <code>CalciumField</code> does not permit creating values that are not numbers, and any non-number value (unsigned infinity, signed infinity, Undefined) will result in an exception. This also applies to the special value Unknown, used in situations where Calcium is unable to prove that a value is a number. To enable special values, use <code>extended=true</code>.</p><pre><code class="language-julia hljs">julia&gt; C = CalciumField()
Exact Complex Field

julia&gt; 1 // C(0)
ERROR: DomainError with UnsignedInfinity:
Non-number result
...

julia&gt; Cext = CalciumField(extended=true)
Exact Complex Field (Extended)

julia&gt; 1 // Cext(0)
UnsignedInfinity</code></pre><p>Note that special values do not satisfy the properties of a mathematical ring or field. You will likely get meaningless results if you put infinities in matrices or polynomials.</p><article class="docstring"><header><a class="docstring-binding" id="unsigned_infinity-Tuple{CalciumField}" href="#unsigned_infinity-Tuple{CalciumField}"><code>unsigned_infinity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsigned_infinity(C::CalciumField)</code></pre><p>Return unsigned infinity (<span>$\hat \infty$</span>) as an element of <code>C</code>. This throws an exception if <code>C</code> does not allow special values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="infinity-Tuple{CalciumField}" href="#infinity-Tuple{CalciumField}"><code>infinity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">infinity(C::CalciumField)</code></pre><p>Return positive infinity (<span>$+\infty$</span>) as an element of <code>C</code>. This throws an exception if <code>C</code> does not allow special values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="infinity-Tuple{ca}" href="#infinity-Tuple{ca}"><code>infinity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">infinity(a::ca)</code></pre><p>Return the signed infinity (<span>$a \cdot \infty$</span>). This throws an exception if the parent of <code>a</code> does not allow special values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="undefined-Tuple{CalciumField}" href="#undefined-Tuple{CalciumField}"><code>undefined</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">undefined(C::CalciumField)</code></pre><p>Return the special value Undefined as an element of <code>C</code>. This throws an exception if <code>C</code> does not allow special values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="unknown-Tuple{CalciumField}" href="#unknown-Tuple{CalciumField}"><code>unknown</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unknown(C::CalciumField)</code></pre><p>Return the special meta-value Unknown as an element of <code>C</code>. This throws an exception if <code>C</code> does not allow special values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_number-Tuple{ca}" href="#is_number-Tuple{ca}"><code>is_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_number(a::ca)</code></pre><p>Return whether <code>a</code> is a number, i.e. not an infinity or undefined.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_undefined-Tuple{ca}" href="#is_undefined-Tuple{ca}"><code>is_undefined</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_undefined(a::ca)</code></pre><p>Return whether <code>a</code> is the special value <em>Undefined</em>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="isinf-Tuple{ca}" href="#isinf-Tuple{ca}"><code>isinf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinf(a::ca)</code></pre><p>Return whether <code>a</code> is any infinity (signed or unsigned).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_uinf-Tuple{ca}" href="#is_uinf-Tuple{ca}"><code>is_uinf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_uinf(a::ca)</code></pre><p>Return whether <code>a</code> is unsigned infinity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_signed_inf-Tuple{ca}" href="#is_signed_inf-Tuple{ca}"><code>is_signed_inf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_signed_inf(a::ca)</code></pre><p>Return whether <code>a</code> is any signed infinity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_unknown-Tuple{ca}" href="#is_unknown-Tuple{ca}"><code>is_unknown</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_unknown(a::ca)</code></pre><p>Return whether <code>a</code> is the special value <em>Unknown</em>. This is a representation property and not a mathematical predicate.</p></div></section></article><h2 id="Complex-parts"><a class="docs-heading-anchor" href="#Complex-parts">Complex parts</a><a id="Complex-parts-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-parts" title="Permalink"></a></h2><p>Functions for computing components of real and complex numbers will perform automatic symbolic simplifications in special cases. In general, such operations will introduce new extension numbers.</p><pre><code class="language-julia hljs">julia&gt; real(C(2+3im))
2

julia&gt; sign(C(2im))
1.00000*I {a where a = I [a^2+1=0]}

julia&gt; sign(C(2+3im))
0.554700 + 0.832050*I {a where a = 0.554700 + 0.832050*I [13*a^4+10*a^2+13=0]}

julia&gt; angle(C(2+2im))
0.785398 {(a)/4 where a = 3.14159 [Pi]}

julia&gt; angle(C(2+3im))
0.982794 {a where a = 0.982794 [Arg(2.00000 + 3.00000*I {3*b+2})], b = I [b^2+1=0]}

julia&gt; angle(C(2+3im)) == atan(C(3)//2)
true

julia&gt; floor(C(pi) ^ 100)
5.18785e+49 {51878483143196131920862615246303013562686760680405}

julia&gt; ZZ(floor(C(pi) ^ 100))
51878483143196131920862615246303013562686760680405</code></pre><p><strong>Interface</strong></p><article class="docstring"><header><a class="docstring-binding" id="real-Tuple{ca}" href="#real-Tuple{ca}"><code>real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real(a::ca)</code></pre><p>Return the real part of <code>a</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="imag-Tuple{ca}" href="#imag-Tuple{ca}"><code>imag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">imag(a::ca)</code></pre><p>Return the imaginary part of <code>a</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="angle-Tuple{ca}" href="#angle-Tuple{ca}"><code>angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angle(a::ca)</code></pre><p>Return the complex argument of <code>a</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="csgn-Tuple{ca}" href="#csgn-Tuple{ca}"><code>csgn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">csgn(a::ca)</code></pre><p>Return the extension of the real sign function taking the value 1 strictly in the right half plane, -1 strictly in the left half plane, and the sign of the imaginary part when on the imaginary axis. Equivalently, <span>$\operatorname{csgn}(x) = x / \sqrt{x^2}$</span> except that the value is 0 at zero.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="sign-Tuple{ca}" href="#sign-Tuple{ca}"><code>sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sign(a::ca)</code></pre><p>Return the complex sign of <code>a</code>, defined as zero if <code>a</code> is zero and as <span>$a / |a|$</span> for any other complex number. This function also extracts the sign when <code>a</code> is a signed infinity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="abs-Tuple{ca}" href="#abs-Tuple{ca}"><code>abs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs(a::ca)</code></pre><p>Return the absolute value of <code>a</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="conj-Tuple{ca}" href="#conj-Tuple{ca}"><code>conj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conj(a::ca; form::Symbol=:default)</code></pre><p>Return the complex conjugate of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:shallow</code> form, <span>$\overline{a}$</span> is introduced as a new extension number if it no straightforward simplifications are possible. In <code>:deep</code> form, complex conjugation is performed recursively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="floor-Tuple{ca}" href="#floor-Tuple{ca}"><code>floor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floor(a::ca)</code></pre><p>Return the floor function of <code>a</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ceil-Tuple{ca}" href="#ceil-Tuple{ca}"><code>ceil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ceil(a::ca)</code></pre><p>Return the ceiling function of <code>a</code>.</p></div></section></article><h2 id="Elementary-and-special-functions"><a class="docs-heading-anchor" href="#Elementary-and-special-functions">Elementary and special functions</a><a id="Elementary-and-special-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Elementary-and-special-functions" title="Permalink"></a></h2><p>Elementary and special functions generally create new extension numbers. In special cases, simplifications occur automatically.</p><pre><code class="language-julia hljs">julia&gt; exp(C(1))
2.71828 {a where a = 2.71828 [Exp(1)]}

julia&gt; exp(C(0))
1

julia&gt; atan(C(1))
0.785398 {(a)/4 where a = 3.14159 [Pi]}

julia&gt; cos(C(1))^2 + sin(C(1))^2
1

julia&gt; log(1 // exp(sqrt(C(2))+1)) == -sqrt(C(2)) - 1
true

julia&gt; gamma(C(2+3im))
-0.0823953 + 0.0917743*I {a where a = -0.0823953 + 0.0917743*I [Gamma(2.00000 + 3.00000*I {3*b+2})], b = I [b^2+1=0]}

julia&gt; gamma(C(5) // 2)
1.32934 {(3*a)/4 where a = 1.77245 [Sqrt(3.14159 {b})], b = 3.14159 [Pi]}

julia&gt; erf(C(1))
0.842701 {a where a = 0.842701 [Erf(1)]}

julia&gt; erf(C(1)) + erfc(C(1))
1</code></pre><p>Some functions allow representing the result in different forms:</p><pre><code class="language-julia hljs">julia&gt; s1 = sin(C(1))
0.841471 - 0e-24*I {(-a^2*b+b)/(2*a) where a = 0.540302 + 0.841471*I [Exp(1.00000*I {b})], b = I [b^2+1=0]}

julia&gt; s2 = sin(C(1), form=:direct)
0.841471 {a where a = 0.841471 [Sin(1)]}

julia&gt; s3 = sin(C(1), form=:exponential)
0.841471 - 0e-24*I {(-a^2*b+b)/(2*a) where a = 0.540302 + 0.841471*I [Exp(1.00000*I {b})], b = I [b^2+1=0]}

julia&gt; s4 = sin(C(1), form=:tangent)
0.841471 {(2*a)/(a^2+1) where a = 0.546302 [Tan(0.500000 {1/2})]}

julia&gt; s1 == s2 == s3 == s4
true

julia&gt; isreal(s1) &amp;&amp; isreal(s2) &amp;&amp; isreal(s3) &amp;&amp; isreal(s4)
true</code></pre><p>The exponential form is currently used by default since it tends to be the most useful for symbolic simplification. The <code>:direct</code> and <code>:tangent</code> forms are likely to be better for numerical evaluation. The default behavior of trigonometric functions can be changed using the <code>:trig_form</code> option of <code>CalciumField</code>.</p><p>Proving equalities involving transcendental function values is a difficult problem in general. Calcium will sometimes fail even in elementary cases. Here is an example of two constant trigonometric identities where the first succeeds and the second fails:</p><pre><code class="language-julia hljs">julia&gt; a = sqrt(C(2)) + 1;

julia&gt; cos(a) + cos(2*a) + cos(3*a) == sin(7*a//2)//(2*sin(a//2)) - C(1)//2
true

julia&gt; sin(3*a) == 4 * sin(a) * sin(C(pi)//3 - a) * sin(C(pi)//3 + a)
ERROR: Unable to perform operation (failed deciding truth of a predicate): isequal</code></pre><p>A possible workaround is to fall back on a numerical comparison:</p><pre><code class="language-julia hljs">julia&gt; abs(cos(a) + cos(2*a) + cos(3*a) - (sin(7*a//2)//(2*sin(a//2)) - C(1)//2)) &lt;= C(10)^-100
true</code></pre><p>Of course, this is not a rigorous proof that the numbers are equal, and <code>CalciumField</code> is overkill here; it would be far more efficient to use <code>ArbField</code> directly to check that the numbers are approximately equal.</p><p><strong>Interface</strong></p><article class="docstring"><header><a class="docstring-binding" id="const_pi-Tuple{CalciumField}" href="#const_pi-Tuple{CalciumField}"><code>const_pi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">const_pi(C::CalciumField)</code></pre><p>Return the constant <span>$\pi$</span> as an element of <code>C</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="const_euler-Tuple{CalciumField}" href="#const_euler-Tuple{CalciumField}"><code>const_euler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">const_euler(C::CalciumField)</code></pre><p>Return Euler&#39;s constant <span>$\gamma$</span> as an element of <code>C</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="onei-Tuple{CalciumField}" href="#onei-Tuple{CalciumField}"><code>onei</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onei(C::CalciumField)</code></pre><p>Return the imaginary unit <span>$i$</span> as an element of <code>C</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="sqrt-Tuple{ca}" href="#sqrt-Tuple{ca}"><code>sqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.sqrt(a::ca; check::Bool=true)</code></pre><p>Return the principal square root of <code>a</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="exp-Tuple{ca}" href="#exp-Tuple{ca}"><code>exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(a::ca)</code></pre><p>Return the exponential function of <code>a</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="log-Tuple{ca}" href="#log-Tuple{ca}"><code>log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log(a::ca)</code></pre><p>Return the natural logarithm of <code>a</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="pow-Tuple{ca, Int64}" href="#pow-Tuple{ca, Int64}"><code>pow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pow(a::ca, b::Int; form::Symbol=:default)</code></pre><p>Return <em>a</em> raised to the integer power <code>b</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, this is equivalent to <code>a ^ b</code>, which may create a new extension number <span>$a^b$</span> if the exponent <code>b</code> is too large (as determined by the parent option <code>:pow_limit</code> or <code>:prec_limit</code> depending on the case). In <code>:arithmetic</code> form, the exponentiation is performed arithmetically in the field of <code>a</code>, regardless of the size of the exponent <code>b</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="sin-Tuple{ca}" href="#sin-Tuple{ca}"><code>sin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sin(a::ca; form::Symbol=:default)</code></pre><p>Return the sine of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, the result is determined by the <code>:trig_form</code> option of the parent object. In <code>:exponential</code> form, the value is represented using complex exponentials. In <code>:tangent</code> form, the value is represented using tangents. In <code>:direct</code> form, the value is represented directly using a sine or cosine.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="cos-Tuple{ca}" href="#cos-Tuple{ca}"><code>cos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cos(a::ca; form::Symbol=:default)</code></pre><p>Return the cosine of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, the result is determined by the <code>:trig_form</code> option of the parent object. In <code>:exponential</code> form, the value is represented using complex exponentials. In <code>:tangent</code> form, the value is represented using tangents. In <code>:direct</code> form, the value is represented directly using a sine or cosine.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="tan-Tuple{ca}" href="#tan-Tuple{ca}"><code>tan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tan(a::ca; form::Symbol=:default)</code></pre><p>Return the tangent of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, the result is determined by the <code>:trig_form</code> option of the parent object. In <code>:exponential</code> form, the value is represented using complex exponentials. In <code>:direct</code> or <code>:tangent</code> form, the value is represented directly using tangents. In <code>:sine_cosine</code> form, the value is represented using sines or cosines.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="atan-Tuple{ca}" href="#atan-Tuple{ca}"><code>atan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atan(a::ca; form::Symbol=:default)</code></pre><p>Return the inverse tangent of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, the result is determined by the <code>:trig_form</code> option of the parent object. In <code>:logarithm</code> form, the value is represented using complex logarithms. In <code>:direct</code> or <code>:arctangent</code> form, the value is represented directly using arctangents.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="asin-Tuple{ca}" href="#asin-Tuple{ca}"><code>asin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">asin(a::ca; form::Symbol=:default)</code></pre><p>Return the inverse sine of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, the result is determined by the <code>:trig_form</code> option of the parent object. In <code>:logarithm</code> form, the value is represented using complex logarithms. In <code>:direct</code> form, the value is represented directly using an inverse sine or cosine.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="acos-Tuple{ca}" href="#acos-Tuple{ca}"><code>acos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">acos(a::ca; form::Symbol=:default)</code></pre><p>Return the inverse cosine of <code>a</code>. The optional <code>form</code> argument allows specifying the representation. In <code>:default</code> form, the result is determined by the <code>:trig_form</code> option of the parent object. In <code>:logarithm</code> form, the value is represented using complex logarithms. In <code>:direct</code> form, the value is represented directly using an inverse sine or cosine.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="gamma-Tuple{ca}" href="#gamma-Tuple{ca}"><code>gamma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gamma(a::ca)</code></pre><p>Return the gamma function of <code>a</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="erf-Tuple{ca}" href="#erf-Tuple{ca}"><code>erf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">erf(a::ca)</code></pre><p>Return the error function of <code>a</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="erfi-Tuple{ca}" href="#erfi-Tuple{ca}"><code>erfi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">erfi(a::ca)</code></pre><p>Return the imaginary error function of <code>a</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="erfc-Tuple{ca}" href="#erfc-Tuple{ca}"><code>erfc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">erfc(a::ca)</code></pre><p>Return the complementary error function of <code>a</code>.</p></div></section></article><h2 id="Rewriting-and-simplification"><a class="docs-heading-anchor" href="#Rewriting-and-simplification">Rewriting and simplification</a><a id="Rewriting-and-simplification-1"></a><a class="docs-heading-anchor-permalink" href="#Rewriting-and-simplification" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="complex_normal_form-Tuple{ca}" href="#complex_normal_form-Tuple{ca}"><code>complex_normal_form</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complex_normal_form(a::ca, deep::Bool=true)</code></pre><p>Returns the input rewritten using standardizing transformations over the complex numbers:</p><ul><li><p>Elementary functions are rewritten in terms of exponentials, roots and logarithms.</p></li><li><p>Complex parts are rewritten using logarithms, square roots, and (deep) complex conjugates.</p></li><li><p>Algebraic numbers are rewritten in terms of cyclotomic fields where applicable.</p></li></ul><p>If deep is set, the rewriting is applied recursively to the tower of extension numbers; otherwise, the rewriting is only applied to the top-level extension numbers.</p><p>The result is not a normal form in the strong sense (the same number can have many possible representations even after applying this transformation), but this transformation can nevertheless be a useful heuristic for simplification.</p></div></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 16 January 2023 15:50">Monday 16 January 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
