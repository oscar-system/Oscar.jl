<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gröbner/Standard Bases Over Fields · Oscar.jl</title><meta name="title" content="Gröbner/Standard Bases Over Fields · Oscar.jl"/><meta property="og:title" content="Gröbner/Standard Bases Over Fields · Oscar.jl"/><meta property="twitter:title" content="Gröbner/Standard Bases Over Fields · Oscar.jl"/><meta name="description" content="Documentation for Oscar.jl."/><meta property="og:description" content="Documentation for Oscar.jl."/><meta property="twitter:description" content="Documentation for Oscar.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Oscar.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../../General/serialization/">Saving and loading files</a></li><li><a class="tocitem" href="../../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../../Groups/action/">Group actions</a></li><li><a class="tocitem" href="../../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../../Groups/group_characters/">Group characters</a></li><li><a class="tocitem" href="../../../Groups/recog/">Group recognition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../../Nemo/finitefield/">Finite fields</a></li><li><a class="tocitem" href="../../../Nemo/algebraic/">Algebraic numbers</a></li><li><a class="tocitem" href="../../../Fields/algebraic_closure_fp/">Algebraic closure of finite prime fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../../NumberTheory/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li></ul></li><li><a class="tocitem" href="../../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox" checked/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro/">Introduction</a></li><li><a class="tocitem" href="../../rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../../affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../../localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../../ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li></ul></li><li><a class="tocitem" href="../../homological_algebra/">Homological Algebra</a></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox" checked/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Gröbner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../orderings/">Monomial Orderings</a></li><li class="is-active"><a class="tocitem" href>Gröbner/Standard Bases Over Fields</a><ul class="internal"><li><a class="tocitem" href="#Default-Orderings"><span>Default Orderings</span></a></li><li><a class="tocitem" href="#monomials_terms_more"><span>Monomials, Terms, and More</span></a></li><li><a class="tocitem" href="#Division-With-Remainder"><span>Division With Remainder</span></a></li><li><a class="tocitem" href="#Computing-Gröbner/Standard-Bases"><span>Computing Gröbner/Standard Bases</span></a></li><li><a class="tocitem" href="#Leading-Ideals"><span>Leading Ideals</span></a></li><li><a class="tocitem" href="#Normal-Forms"><span>Normal Forms</span></a></li><li><a class="tocitem" href="#Syzygies"><span>Syzygies</span></a></li></ul></li><li><a class="tocitem" href="../groebner_bases_integers/">Gröbner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-10" type="checkbox"/><label class="tocitem" for="menuitem-9-10"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../../FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../../InvariantTheory/tori/">Invariants of Tori</a></li><li><a class="tocitem" href="../../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/RationalPointsAffine/">Rational Points on Affine Schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveringsAndGluings/">Coverings</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/">Morphisms of covered schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/ProjectiveSchemes/">Projective schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/">Morphisms of projective schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/RationalPointsProjective/">Rational Points on Projective Schemes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Algebraic Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/">Affine Algebraic Sets</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/">Projective Algebraic Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Algebraic Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/AlgebraicVarieties/AffineVariety/">Affine Varieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/">Projective Varieties</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/AffinePlaneCurves/">Affine plane curves</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/ProjectiveCurves/">Projective Curves</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/ProjectivePlaneCurves/">Projective Plane Curves</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/ParametrizationPlaneCurves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/K3Surfaces/">Automorphism Groups of  K3 surfaces</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/AdjunctionProcess/">Adjunction Process for Surfaces</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/ParametrizationSurfaces/">Rational Parametrization of Rational Surfaces</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/SurfacesP4/">Nongeneral Type Surfaces in <span>$\mathbb P^4$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Sheaf Cohomology</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/SheafCohomology/sheaf_cohomology/">Sheaves on Projective Space</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-8" type="checkbox"/><label class="tocitem" for="menuitem-11-8"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricSchemes/">Toric Schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricIdealSheaves/">Toric Ideal Sheaves (Experimental)</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/BlowdownMorphisms/">Toric Blowdown Morphisms (Experimental)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-9" type="checkbox"/><label class="tocitem" for="menuitem-11-9"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Miscellaneous/miscellaneous/">Some Special Ideals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-10" type="checkbox"/><label class="tocitem" for="menuitem-11-10"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../../TropicalGeometry/semiring/">Tropical semirings, matrices, and polynomials</a></li><li><a class="tocitem" href="../../../TropicalGeometry/semiring_map/">Tropical semiring maps</a></li><li><a class="tocitem" href="../../../TropicalGeometry/variety/">Tropical varieties</a></li><li><a class="tocitem" href="../../../TropicalGeometry/hypersurface/">Tropical hypersurfaces</a></li><li><a class="tocitem" href="../../../TropicalGeometry/curve/">Tropical curves</a></li><li><a class="tocitem" href="../../../TropicalGeometry/linear_space/">Tropical linear spaces</a></li><li><a class="tocitem" href="../../../TropicalGeometry/groebner_theory/">Groebner theory</a></li><li><a class="tocitem" href="../../../TropicalGeometry/tropicalization/">Tropicalization of polynomial ideals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Noncommutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-13-2" type="checkbox"/><label class="tocitem" for="menuitem-13-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li><li><a class="tocitem" href="../../../Combinatorics/phylogenetic_trees/">Phylogenetic Trees</a></li><li><input class="collapse-toggle" id="menuitem-14-5" type="checkbox"/><label class="tocitem" for="menuitem-14-5"><span class="docs-label">Enumerative combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Combinatorics/EnumerativeCombinatorics/partitions/">Partitions</a></li><li><a class="tocitem" href="../../../Combinatorics/EnumerativeCombinatorics/tableaux/">Tableaux</a></li><li><a class="tocitem" href="../../../Combinatorics/EnumerativeCombinatorics/schur_polynomials/">Schur polynomials</a></li><li><a class="tocitem" href="../../../Combinatorics/EnumerativeCombinatorics/compositions/">Compositions</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../../references/">References</a></li><li><a class="tocitem" href="../../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-18" type="checkbox"/><label class="tocitem" for="menuitem-18"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/printing_details/">Printing in OSCAR</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/caching/">Caching parent objects in OSCAR</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/serialization/">Serialization</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/gap_integration/">GAP Integration</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/release/">Release management</a></li><li><input class="collapse-toggle" id="menuitem-18-11" type="checkbox"/><label class="tocitem" for="menuitem-18-11"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-19" type="checkbox"/><label class="tocitem" for="menuitem-19"><span class="docs-label">Experimental</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/intro/">Adding new projects to experimental</a></li><li><input class="collapse-toggle" id="menuitem-19-2" type="checkbox"/><label class="tocitem" for="menuitem-19-2"><span class="docs-label">Algebraic Statistics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/AlgebraicStatistics/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/AlgebraicStatistics/graphical_models/">Graphical Models</a></li><li><a class="tocitem" href="../../../Experimental/AlgebraicStatistics/gaussian_graphical_models/">Gaussian Graphical Models</a></li><li><a class="tocitem" href="../../../Experimental/AlgebraicStatistics/ci/">Conditional independence statements</a></li><li><a class="tocitem" href="../../../Experimental/AlgebraicStatistics/markov/">Discrete random variables</a></li><li><a class="tocitem" href="../../../Experimental/AlgebraicStatistics/phylogenetics/">Algebraic Phylogenetics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-3" type="checkbox"/><label class="tocitem" for="menuitem-19-3"><span class="docs-label">Double complexes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/DoubleAndHyperComplexes/user_interface/">Double complexes – the user&#39;s interface</a></li><li><a class="tocitem" href="../../../Experimental/DoubleAndHyperComplexes/advice_for_the_programmer/">Advice for the programmer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-4" type="checkbox"/><label class="tocitem" for="menuitem-19-4"><span class="docs-label">Linear Quotients</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/LinearQuotients/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/LinearQuotients/linear_quotients/">Construction and basic functionality</a></li><li><a class="tocitem" href="../../../Experimental/LinearQuotients/cox_rings/">Cox rings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-5" type="checkbox"/><label class="tocitem" for="menuitem-19-5"><span class="docs-label">Matroid Realization Spaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/MatroidRealizationSpaces/introduction/">Matroid Realization Spaces</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-6" type="checkbox"/><label class="tocitem" for="menuitem-19-6"><span class="docs-label">Orthogonal discriminants</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/OrthogonalDiscriminants/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/OrthogonalDiscriminants/access/">Access to precomputed OD data</a></li><li><a class="tocitem" href="../../../Experimental/OrthogonalDiscriminants/compute/">Criteria for computing orthogonal discriminants</a></li><li><a class="tocitem" href="../../../Experimental/OrthogonalDiscriminants/misc/">Miscellaneous functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-7" type="checkbox"/><label class="tocitem" for="menuitem-19-7"><span class="docs-label">Quadratic forms and isometries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/QuadFormAndIsom/introduction/">Quadratic forms and isometries</a></li><li><a class="tocitem" href="../../../Experimental/QuadFormAndIsom/spacewithisom/">Quadratic spaces with isometry</a></li><li><a class="tocitem" href="../../../Experimental/QuadFormAndIsom/latwithisom/">Lattices with isometry</a></li><li><a class="tocitem" href="../../../Experimental/QuadFormAndIsom/enumeration/">Enumeration of isometries</a></li><li><a class="tocitem" href="../../../Experimental/QuadFormAndIsom/primembed/">Nikulin&#39;s theory on primitive embeddings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-8" type="checkbox"/><label class="tocitem" for="menuitem-19-8"><span class="docs-label">Standard Finite Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/StandardFiniteFields/introduction/">-</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-9" type="checkbox"/><label class="tocitem" for="menuitem-19-9"><span class="docs-label">Lie Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/LieAlgebras/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/LieAlgebras/lie_algebras/">Lie algebras</a></li><li><a class="tocitem" href="../../../Experimental/LieAlgebras/ideals_and_subalgebras/">Ideals and Lie subalgebras</a></li><li><a class="tocitem" href="../../../Experimental/LieAlgebras/lie_algebra_homs/">Lie algebra homomorphisms</a></li><li><a class="tocitem" href="../../../Experimental/LieAlgebras/modules/">Lie algebra modules</a></li><li><a class="tocitem" href="../../../Experimental/LieAlgebras/module_homs/">Lie algebra module homomorphisms</a></li><li><a class="tocitem" href="../../../Experimental/LieAlgebras/cartan_matrix/">Cartan Matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-10" type="checkbox"/><label class="tocitem" for="menuitem-19-10"><span class="docs-label">Bases for highest weight modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/BasisLieHighestWeight/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/BasisLieHighestWeight/user_functions/">Functions for a monomial basis of highest weight modules</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-11" type="checkbox"/><label class="tocitem" for="menuitem-19-11"><span class="docs-label">Partitioned Permutations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/PartitionedPermutations/introduction/">Partitioned Permutations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-12" type="checkbox"/><label class="tocitem" for="menuitem-19-12"><span class="docs-label">F-Theory Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/FTheoryTools/introduction/">Welcome to FTheoryTools</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/generalities/">Functionality for all F-theory models</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/weierstrass/">Weierstrass models</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/tate/">Global Tate models</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/hypersurface/">Hypersurface models</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/literature/">Literature constructions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Commutative Algebra</a></li><li><a class="is-disabled">Gröbner/Standard Bases</a></li><li class="is-active"><a href>Gröbner/Standard Bases Over Fields</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gröbner/Standard Bases Over Fields</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/oscar-system/Oscar.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/CommutativeAlgebra/GroebnerBases/groebner_bases.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="gb_fields"><a class="docs-heading-anchor" href="#gb_fields">Gröbner/Standard Bases Over Fields</a><a id="gb_fields-1"></a><a class="docs-heading-anchor-permalink" href="#gb_fields" title="Permalink"></a></h1><p>We fix our notation in the context of standard (Gröbner) bases and present relevant OSCAR functions.</p><p>Let <span>$K[x] = K[x_1, \dots, x_n]$</span> be a polynomial ring over a field <span>$K$</span>, and let <span>$&gt;$</span> be a monomial ordering on <span>$\text{Mon}_n(x)$</span>.</p><p>Given a polynomial <span>$f\in K[x]\setminus \{0\}$</span>, write <span>$f$</span> as the sum of its nonzero terms as follows:</p><p class="math-container">\[f = a_\alpha x^\alpha + a_{\beta_1} x^{\beta_1} + \dots + a_{\beta_s} x^{\beta_s},\quad x^\alpha &gt; x^{\beta_1} &gt; \dots &gt; x^{\beta_s} .\]</p><p>Then, with respect to <span>$&gt;$</span>, we refer to <span>$\text{LT}_&gt;(f) = a_\alpha x^\alpha$</span>, <span>$\text{LM}_&gt;(f) = x^\alpha$</span>, <span>$\text{LE}_&gt;(f) = \alpha$</span>, <span>$\text{LC}_&gt;(f) = a_\alpha$</span>, and <span>$\text{tail}_&gt;(f) = f - \text{LT}_&gt;(f)$</span> as the  <em>leading term</em>, the <em>leading monomial</em>, the <em>leading exponent</em>, the <em>leading coefficient</em>, and the <em>tail</em> of <span>$f$</span>, respectively.</p><p>Next note that the set</p><p class="math-container">\[U_&gt;:= \{u\in K[x]\setminus \{0\} \mid {\text{LM}}_&gt;(u)=1 \}\]</p><p>is a multiplicatively closed subset of <span>$K[x]$</span>. Consider the localization</p><p class="math-container">\[K[x]_&gt;:= K[x][U^{-1}] = \left\{ \frac{f}{u} \:\bigg|\: f \in K[x], \, u\in U_&gt;\right\}.\]</p><p>Then <span>$K[x]\subseteq K[x]_&gt;\subseteq K[x]_{\langle x \rangle},$</span> where <span>$K[x]_{\langle x \rangle}$</span> is the localization of <span>$K[x] $ at the maximal ideal $\langle x \rangle .$</span> Moreover,</p><ul><li><p><span>$K[x] = K[x]_&gt;$</span> iff <span>$&gt;$</span> is global, and</p></li><li><p><span>$K[x]_&gt; = K[x]_{\langle x \rangle}$</span> iff <span>$&gt;$</span> is local.</p></li></ul><p>Extending the notation introduced for polynomials, let now <span>$f\in K[x]_&gt;\setminus \{0\}$</span>. Choose <span>$u\in U_&gt;$</span> such that <span>$uf\in K[x]$</span>. Then, with respect to <span>$&gt;$</span>, the  <em>leading term</em>  of <span>$f$</span> is defined to be <span>$\text{LT}_&gt;(f) = \text{LT}_&gt;(uf)$</span> (this definition is independent of the choice of <span>$u$</span>). The <em>leading monomial</em> <span>$\text{LM}_&gt;(f)$</span>, the <em>leading exponent</em> <span>$\text{LE}_&gt;(f)$</span>, the <em>leading coefficient</em> <span>$\text{LC}_&gt;(f)$</span>, and the <em>tail</em> <span>$\text{tail}_&gt;(f)$</span> of <span>$f$</span> are defined similarly.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Given a monomial ordering <span>$&gt;$</span> on a free <span>$K[x]$</span>-module <span>$F = K[x]^p$</span> with basis <span>$e_1, \dots, e_p$</span>, the above notation extends naturally to elements of  <span>$K[x]^p$</span> and <span>$K[x]_&gt;^p$</span>, respectively. There is one particularity: Given an element <span>$f = K[x]^p\setminus \{0\}$</span> with leading term <span>$\text{LT}(f) = x^\alpha e_i$</span>, we write <span>$\text{LE}_&gt;(f) = (\alpha, i)$</span>.</p></div></div><h2 id="Default-Orderings"><a class="docs-heading-anchor" href="#Default-Orderings">Default Orderings</a><a id="Default-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Default-Orderings" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The OSCAR functions discussed in this section depend on a monomial <code>ordering</code> which is entered as a keyword argument. Given a polynomial ring <span>$R$</span>, the <code>default_ordering</code> for this is <code>degrevlex</code> except if <span>$R$</span> is <span>$\mathbb Z$</span>-graded with positive weights. Then the corresponding <code>wdegrevlex</code> ordering is used. Given a free <span>$R$</span>-module <span>$F$</span>, the <code>default_ordering</code> is <code>default_ordering(R)*lex(gens(F))</code>.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="default_ordering-Tuple{MPolyRing}" href="#default_ordering-Tuple{MPolyRing}"><code>default_ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_ordering(R::MPolyRing)</code></pre><p>Return the monomial ordering that is used for computations with ideals in <code>R</code> if no other ordering is specified – either directly by the user or by requirements of a specific algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/mpoly.jl#L66-L72">source</a></section></article><p>Here are some illustrating OSCAR examples:</p><h5 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h5><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; default_ordering(R)
degrevlex([x, y, z])

julia&gt; F = free_module(R, 2)
Free module of rank 2 over R

julia&gt; default_ordering(F)
degrevlex([x, y, z])*lex([gen(1), gen(2)])

julia&gt; S, _ = grade(R, [1, 2, 3])
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])

julia&gt; default_ordering(S)
wdegrevlex([x, y, z], [1, 2, 3])</code></pre><p>Expert users may temporarily choose a different default ordering for a given ring.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="with_ordering" href="#with_ordering"><code>with_ordering</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">with_ordering(f, R::MPolyRing, o::MonomialOrdering)</code></pre><p>Use the monomial ordering <code>o</code> for computations in <code>R</code> during the execution of <code>f</code>. This may be used with <code>do</code> block syntax, see the example.</p><p>This functionality is meant for advanced users. In general it should not be necessary to explicitly set a monomial ordering. Further, there is no guarantee that <code>o</code> is actually used. For example, if an algorithm requires an elimination ordering, <code>o</code> might be ignored.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = QQ[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;];

julia&gt; f = x + y^2;

julia&gt; I = ideal(R, [y^2 - z, x - z^2]);

julia&gt; normal_form(f, I) # this uses degrevlex
x + z

julia&gt; with_ordering(R, lex(R)) do
           # this uses lex
           normal_form(f, I)
       end
z^2 + z</code></pre><p>Notice that in this small example we could have achieved the same by using the keyword argument <code>ordering</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; normal_form(f, I, ordering = lex(R))
z^2 + z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/mpoly.jl#L84-L119">source</a></section></article><h2 id="monomials_terms_more"><a class="docs-heading-anchor" href="#monomials_terms_more">Monomials, Terms, and More</a><a id="monomials_terms_more-1"></a><a class="docs-heading-anchor-permalink" href="#monomials_terms_more" title="Permalink"></a></h2><p>Here are examples which indicate how to recover monomials, terms, and more from a given polynomial.</p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; f = 3*z^3+2*x*y+1
2*x*y + 3*z^3 + 1

julia&gt; terms(f)
terms iterator of 3*z^3 + 2*x*y + 1

julia&gt; collect(ans)
3-element Vector{QQMPolyRingElem}:
 3*z^3
 2*x*y
 1

julia&gt; monomials(f, ordering = lex(R))
monomials iterator of 2*x*y + 3*z^3 + 1

julia&gt; coefficients(f)
coefficients iterator of 3*z^3 + 2*x*y + 1

julia&gt; exponents(f, ordering = neglex(R))
exponents iterator of 1 + 3*z^3 + 2*x*y

julia&gt; coefficients_and_exponents(f)
coefficients and exponents iterator of 3*z^3 + 2*x*y + 1

julia&gt; collect(ans)
3-element Vector{Tuple{QQFieldElem, Vector{Int64}}}:
 (3, [0, 0, 3])
 (2, [1, 1, 0])
 (1, [0, 0, 0])

julia&gt; leading_term(f)
3*z^3

julia&gt; leading_monomial(f, ordering = lex(R))
x*y

julia&gt; leading_exponent(f, ordering = neglex(R))
3-element Vector{Int64}:
 0
 0
 0

julia&gt; leading_coefficient(f)
3

julia&gt; tail(f)
2*x*y + 1</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; F = free_module(R, 3)
Free module of rank 3 over R

julia&gt; f = (5*x*y^2-y^10+3)*F[1]+(4*x^3+2*y) *F[2]+16*x*F[3]
(5*x*y^2 - y^10 + 3)*e[1] + (4*x^3 + 2*y)*e[2] + 16*x*e[3]

julia&gt; default_ordering(F)
degrevlex([x, y])*lex([gen(1), gen(2), gen(3)])

julia&gt; collect(terms(f))
6-element Vector{FreeModElem{QQMPolyRingElem}}:
 -y^10*e[1]
 4*x^3*e[2]
 5*x*y^2*e[1]
 16*x*e[3]
 2*y*e[2]
 3*e[1]

julia&gt; collect(terms(f, ordering = lex(F)*lex(R)))
6-element Vector{FreeModElem{QQMPolyRingElem}}:
 5*x*y^2*e[1]
 -y^10*e[1]
 3*e[1]
 4*x^3*e[2]
 2*y*e[2]
 16*x*e[3]

julia&gt; tail(f)
(5*x*y^2 + 3)*e[1] + (4*x^3 + 2*y)*e[2] + 16*x*e[3]

julia&gt; leading_exponent(f)
([0, 10], 1)

julia&gt; leading_exponent(f, ordering = lex(F)*lex(R))
([1, 2], 1)</code></pre><h2 id="Division-With-Remainder"><a class="docs-heading-anchor" href="#Division-With-Remainder">Division With Remainder</a><a id="Division-With-Remainder-1"></a><a class="docs-heading-anchor-permalink" href="#Division-With-Remainder" title="Permalink"></a></h2><p>The computation of Gröbner (standard) bases relies on multivariate division with remainder which is interesting in its own right. If a monomial ordering <span>$&gt;$</span> is given, the basic idea is to mimic Euclidean division with remainder, allowing more than one divisor: At each step of the resulting process, this amounts to removing the leading term of the intermediate dividend, using the leading term of <em>some</em> divisor by which it is divisible. In its basic form, the process works well if <span>$&gt;$</span> is global, but may not terminate for local and mixed orderings. In the latter case, Mora&#39;s division algorithm, which relies on a more restricted selection strategy for the divisors to be used, comes to our rescue.</p><p>We discuss this in more detail:</p><p>First suppose that <span>$&gt;$</span> is global and let polynomials <span>$g\in K[x]$</span> and <span>$f_1, \dots, f_r\in K[x]\setminus \{0\}$</span> be given. In this situation, multivariate division with remainder allows us to compute expressions</p><p class="math-container">\[g = q_1f_1+\dots q_rf_r + h, \; h\in K[x], \;\text{ all }\; q_i \in K[x]\]</p><p>such that:</p><ul><li><span>$\text{LM}_&gt;(g) \ge \text{LM}_&gt;(q_if_i)$</span> whenever both sides are nonzero.</li><li>If <span>$h$</span> is nonzero, then <span>$\text{LM}_&gt;(h)$</span> is not divisible by any <span>$\text{LM}_&gt;(f_i)$</span>.</li></ul><p>Each such expression is called a <em>standard representation</em> for <span>$g$</span> with <em>quotients</em> <span>$q_i$</span> and <em>remainder</em> <span>$h$</span> (on division by the <span>$f_i$</span>, with respect to <span>$&gt;$</span>). If, at each step of the division process, we allow to remove some term of the current dividend instead of just focusing on its leading term, then the algorithm will return a standard expression in which the remainder is <em>fully reduced</em>. That is, <span>$h$</span> satisfies the stronger condition below:</p><ul><li>If <span>$h$</span> is nonzero, then no term of <span>$h$</span> is divisible by any <span>$\text{LM}_&gt;(f_i)$</span>.</li></ul><p>Without restrictions on  <span>$&gt;$</span>, let elements <span>$g\in K[x]_&gt;$</span> and <span>$f_1, \dots, f_r\in K[x]\setminus \{0\}$</span> be given. In this situation, Mora division with remainder allows us to compute expressions</p><p class="math-container">\[ug = q_1f_1+\dots q_rf_r + h, \; h\in K[x]_&gt;, \;\text{ all }\; q_i \in K[x]_&gt;\]</p><p>such that:</p><ul><li><span>$u$</span> is a unit of <span>$K[x]_&gt;$</span>, that is, <span>$\text{LM}_&gt;(u)=1$</span>.</li><li><span>$\text{LM}_&gt;(g) \ge \text{LM}_&gt;(q_if_i)$</span> whenever both sides are nonzero.</li><li>If <span>$h$</span> is nonzero, then <span>$\text{LM}_&gt;(h)$</span> is not divisible by any <span>$\text{LM}_&gt;(f_i)$</span>.</li></ul><p>Each such expression is called a <em>weak standard representation</em> for <span>$g$</span> with <em>quotients</em> <span>$q_i$</span> and <em>remainder</em> <span>$h$</span> (on division by the <span>$f_i$</span>, with respect to <span>$&gt;$</span>). If <span>$g\in K[x]$</span>, we speak of a <em>polynomial weak standard representation</em> if <span>$u$</span> and the <span>$q_i$</span> are elements of <span>$K[x].$</span> Using power series expansions, it makes still sense to speak of fully reduced remainders. However, even if we start from polynomial data, such remainders may not be computable (in finitely many steps).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Given a monomial ordering <span>$&gt;$</span> on a free <span>$K[x]$</span>-module <span>$F = K[x]^p$</span> with basis <span>$e_1, \dots, e_p$</span>, the above notation and the division algorithms extend naturally to <span>$K[x]^p$</span> and <span>$K[x]_&gt;^p$</span>, respectively.</p></div></div><p>The OSCAR functions discussed below compute standard representations and polynomial weak standard representations, respectively.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="reduce-Union{Tuple{T}, Tuple{T, Vector{T}}} where T&lt;:MPolyRingElem" href="#reduce-Union{Tuple{T}, Tuple{T, Vector{T}}} where T&lt;:MPolyRingElem"><code>reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(g::T, F::Union{Vector{T}, IdealGens{T}};
       ordering::MonomialOrdering = default_ordering(g)), complete_reduction::Bool = false) where T &lt;: MPolyRingElem</code></pre><p>If <code>ordering</code> is global, return the remainder in a standard representation for <code>g</code> on division by the polynomials in <code>F</code> with respect to <code>ordering</code>. Otherwise, return the remainder in a <em>weak</em> standard representation for <code>g</code> on division by the polynomials in <code>F</code> with respect to <code>ordering</code>.</p><pre><code class="nohighlight hljs">reduce(G::Vector{T}, F::Union{Vector{T}, IdealGens{T}};
       ordering::MonomialOrdering = default_ordering(parent(G[1])), complete_reduction::Bool = false) where T &lt;: MPolyRingElem</code></pre><p>Return a <code>Vector</code> which contains, for each element <code>g</code> of <code>G</code>, a remainder as above.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The returned remainders are fully reduced if <code>complete_reduction</code> is set to <code>true</code> and <code>ordering</code> is global.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The reduction strategy behind the <code>reduce</code> function and the reduction strategy behind the functions  <code>reduce_with_quotients</code> and <code>reduce_with_quotients_and_unit</code> differ. As a consequence, the computed remainders may differ.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (z, y, x) = polynomial_ring(QQ, [&quot;z&quot;, &quot;y&quot;, &quot;x&quot;]);

julia&gt; f1 = y-x^2; f2 = z-x^3;

julia&gt; g = x^3*y-3*y^2*z^2+x*y*z;

julia&gt; reduce(g, [f1, f2], ordering = lex(R))
-3*x^10 + x^6 + x^5</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; f1 = x^2+x^2*y; f2 = y^3+x*y*z; f3 = x^3*y^2+z^4;

julia&gt; g = x^3*y+x^5+x^2*y^2*z^2+z^6;

julia&gt; reduce(g, [f1, f2, f3], ordering = lex(R))
x^5 + x^3*y + x^2*y^2*z^2 + z^6

julia&gt; reduce(g, [f1,f2, f3], ordering = lex(R), complete_reduction = true)
x^5 - x^3 + y^6 + z^6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L640-L686">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="reduce_with_quotients-Union{Tuple{T}, Tuple{T, Vector{T}}} where T&lt;:MPolyRingElem" href="#reduce_with_quotients-Union{Tuple{T}, Tuple{T, Vector{T}}} where T&lt;:MPolyRingElem"><code>reduce_with_quotients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_with_quotients(g::T, F::Union{Vector{T}, IdealGens{T}};
       ordering::MonomialOrdering = default_ordering(parent(g)), complete_reduction::Bool = false) where T &lt;: MPolyRingElem</code></pre><p>If <code>ordering</code> is global, return the quotients and the remainder in a standard representation for <code>g</code> on division by the polynomials in <code>F</code> with respect to <code>ordering</code>. Otherwise, return the quotients and the remainder in a <em>weak</em> standard representation for <code>g</code> on division by the polynomials in <code>F</code> with respect to <code>ordering</code>.</p><pre><code class="nohighlight hljs">reduce_with_quotients(G::Vector{T}, F::Union{Vector{T}, IdealGens{T}};
       ordering::MonomialOrdering = default_ordering(parent(G[1])), complete_reduction::Bool = false) where T &lt;: MPolyRingElem</code></pre><p>Return a <code>Vector</code> which contains, for each element <code>g</code> of <code>G</code>, quotients and a remainder as above.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The returned remainders are fully reduced if <code>complete_reduction</code> is set to <code>true</code> and <code>ordering</code> is global.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; f1 = x^2+x^2*y; f2 = y^3+x*y*z; f3 = x^3*y^2+z^4;

julia&gt; g = x^3*y+x^5+x^2*y^2*z^2+z^6;

julia&gt; Q, h = reduce_with_quotients(g, [f1,f2, f3], ordering = lex(R));

julia&gt; h
x^5 - x^3 + y^6 + z^6

julia&gt; g == Q[1]*f1+Q[2]*f2+Q[3]*f3+h
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L919-L951">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="reduce_with_quotients_and_unit-Union{Tuple{T}, Tuple{T, Vector{T}}} where T&lt;:MPolyRingElem" href="#reduce_with_quotients_and_unit-Union{Tuple{T}, Tuple{T, Vector{T}}} where T&lt;:MPolyRingElem"><code>reduce_with_quotients_and_unit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_with_quotients_and_unit(g::T, F::Union{Vector{T}, IdealGens{T}};
       ordering::MonomialOrdering = default_ordering(parent(g)), complete_reduction::Bool = false) where T &lt;: MPolyRingElem</code></pre><p>Return the unit, the quotients and the remainder in a weak standard representation for <code>g</code> on division by the polynomials in <code>F</code> with respect to <code>ordering</code>.</p><pre><code class="nohighlight hljs">reduce_with_quotients_and_unit(G::Vector{T}, F::Union{Vector{T}, IdealGens{T}};
       ordering::MonomialOrdering = default_ordering(parent(G[1])), complete_reduction::Bool = false) where T &lt;: MPolyRingElem</code></pre><p>Return a <code>Vector</code> which contains, for each element <code>g</code> of <code>G</code>, a unit, quotients, and a remainder as above.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The returned remainders are fully reduced if <code>complete_reduction</code> is set to <code>true</code> and <code>ordering</code> is global.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The reduction strategy behind the <code>reduce</code> function and the reduction strategy behind the functions  <code>reduce_with_quotients</code> and <code>reduce_with_quotients_and_unit</code> differ. As a consequence, the computed remainders may differ.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; f1 = x^2+x^2*y; f2 = y^3+x*y*z; f3 = x^3*y^2+z^4;

julia&gt; g = x^3*y+x^5+x^2*y^2*z^2+z^6;

julia&gt; u, Q, h =reduce_with_quotients_and_unit(g, [f1,f2, f3], ordering = lex(R));

julia&gt; u
[1]

julia&gt; G = [g, x*y^3-3*x^2*y^2*z^2];

julia&gt; U, Q, H = reduce_with_quotients_and_unit(G, [f1, f2, f3], ordering = negdegrevlex(R));

julia&gt; U
[y + 1       0]
[    0   y + 1]

julia&gt; Q
[  x^3 - x*y^2*z^2 + x*y + y^2*z^2                            0   y*z^2 + z^2]
[x*y*z^2 + y^3*z - 3*y^2*z^2 - y*z   -x^2*y*z - x^2*z + x*y + x             0]

julia&gt; H
2-element Vector{QQMPolyRingElem}:
 0
 0

julia&gt; U*G == Q*[f1, f2, f3]+H
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L716-L768">source</a></section></article><h2 id="Computing-Gröbner/Standard-Bases"><a class="docs-heading-anchor" href="#Computing-Gröbner/Standard-Bases">Computing Gröbner/Standard Bases</a><a id="Computing-Gröbner/Standard-Bases-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Gröbner/Standard-Bases" title="Permalink"></a></h2><p>Still keeping the notation introduced at the beginning of this section, let <span>$G$</span> be a subset of <span>$K[x]_&gt;$</span>. Then the <em>leading ideal</em> of <span>$G$</span> is the ideal of <span>$K[x]$</span> defined by</p><p class="math-container">\[\text{L}_&gt;(G)=\langle \text{LT}_&gt;(g) \mid g\in G\setminus\{0\}\rangle\subset K[x].\]</p><p>A finite subset <span>$G$</span> of an ideal <span>$I\subset K[x]_&gt;$</span> is called a <em>standard basis</em> of <span>$I$</span> (with respect to <span>$&gt;$</span>) if <span>$\text{L}_&gt;(G) = \text{L}_&gt;(I)$</span>.  A finite subset of <span>$K[x]_&gt;$</span> is a <em>standard basis</em> if it is a standard basis of the ideal it generates. A standard basis with respect to a global monomial ordering is also called a <em>Gröbner basis</em>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Every standard basis of <span>$I$</span> generates <span>$I$</span>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Gröbner bases (standard bases) can be computed using Buchberger&#39;s algorithm (Buchberger&#39;s algorithm as enhanced by Mora).</p></div></div><p>We call a standard basis <span>$G = \{g_1,\dots, g_r\}\subset K[x]_&gt;\setminus \{0\}$</span> <em>minimal</em>  if <span>$\text{LM}_&gt;(g_i)\neq \text{LM}_&gt;(g_j)$</span> for <span>$i\neq j$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The definition of minimal above deviates from the definition in most textbooks as we do not ask that the leading coefficients of the standard basis elements are 1.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The standard bases returned by OSCAR are always minimal in the sense above.</p></div></div><p>We call a standard basis <span>$G = \{g_1,\dots, g_r\}$</span> with respect to a global monomial ordering <em>reduced</em> if it is minimal and no term of <span>$g_i$</span> is divisible by <span>$\text{LM}_&gt;(g_j)$</span>, for <span>$i\neq j$</span>. Using power series expansions, we may extend this notion to local and mixed orderings. However, while reduced standard bases can be computed in the global case, they may not be computable (in finitely many steps) in the other cases.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Given a monomial ordering <span>$&gt;$</span> on a free <span>$K[x]$</span>-module <span>$F = K[x]^p$</span> with basis <span>$e_1, \dots, e_p$</span>, the above notation and results extend naturally to submodules of <span>$K[x]_&gt;^p$</span>.</p></div></div><p>Here are the relevant OSCAR functions for computing Gröbner and standard bases. The elements of a computed basis can be retrieved by using the <code>elements</code> function or its alias <code>gens</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="groebner_basis-Tuple{MPolyIdeal}" href="#groebner_basis-Tuple{MPolyIdeal}"><code>groebner_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">groebner_basis(I::MPolyIdeal;
  ordering::MonomialOrdering = default_ordering(base_ring(I)),
  complete_reduction::Bool = false, algorithm::Symbol = :buchberger)</code></pre><p>If <code>ordering</code> is global, return a Gröbner basis of <code>I</code> with respect to <code>ordering</code>.</p><p>The keyword <code>algorithm</code> can be set to</p><ul><li><code>:buchberger</code> (implementation of Buchberger&#39;s algorithm in <em>Singular</em>),</li><li><code>:hilbert</code> (implementation of a Hilbert driven Gröbner basis computation in <em>Singular</em>),</li><li><code>:fglm</code> (implementation of the FGLM algorithm in <em>Singular</em>), and</li><li><code>:f4</code> (implementation of Faugère&#39;s F4 algorithm in the <em>msolve</em> package).</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>See the description of the functions <code>groebner_basis_hilbert_driven</code>, <code>fglm</code>,  and <code>f4</code> in the OSCAR documentation for some more details and for restrictions     on the input data when using these versions of the standard basis algorithm.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The returned Gröbner basis is reduced if <code>complete_reduction = true</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; I = ideal(R, [y-x^2, z-x^3]);

julia&gt; G = groebner_basis(I)
Gröbner basis with elements
1 -&gt; y^2 - x*z
2 -&gt; x*y - z
3 -&gt; x^2 - y
with respect to the ordering
degrevlex([x, y, z])

julia&gt; elements(G)
3-element Vector{QQMPolyRingElem}:
 -x*z + y^2
 x*y - z
 x^2 - y

julia&gt; elements(G) == gens(G)
true

julia&gt; groebner_basis(I, ordering = lex(R))
Gröbner basis with elements
1 -&gt; y^3 - z^2
2 -&gt; x*z - y^2
3 -&gt; x*y - z
4 -&gt; x^2 - y
with respect to the ordering
lex([x, y, z])</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;], [1, 3]);

julia&gt; I = ideal(R, [x*y-3*x^4,y^3-2*x^6*y]);

julia&gt; groebner_basis(I)
Gröbner basis with elements
1 -&gt; 3*x^4 - x*y
2 -&gt; 2*x^3*y^2 - 3*y^3
3 -&gt; x*y^3
4 -&gt; y^4
with respect to the ordering
wdegrevlex([x, y], [1, 3])</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; V = [3*x^3*y+x^3+x*y^3+y^2*z^2, 2*x^3*z-x*y-x*z^3-y^4-z^2,
               2*x^2*y*z-2*x*y^2+x*z^2-y^4];

julia&gt; I = ideal(R, V);

julia&gt; G = groebner_basis(I, ordering = lex(R), algorithm = :fglm);

julia&gt; length(G)
8

julia&gt; total_degree(G[8])
34

julia&gt; leading_coefficient(G[8])
-91230304237130414552564280286681870842473427917231798336639893796481988733936505735341479640589040146625319419037353645834346047404145021391726185993823650399589880820226804328750</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L209-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="standard_basis-Tuple{MPolyIdeal}" href="#standard_basis-Tuple{MPolyIdeal}"><code>standard_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">standard_basis(I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(base_ring(I)),
               complete_reduction::Bool = false, algorithm::Symbol = :buchberger)</code></pre><p>Return a standard basis of <code>I</code> with respect to <code>ordering</code>.</p><p>The keyword <code>algorithm</code> can be set to</p><ul><li><code>:buchberger</code> (implementation of Buchberger&#39;s algorithm in <em>Singular</em>),</li><li><code>:f4</code> (implementation of Faugère&#39;s F4 algorithm in the <em>msolve</em> package),</li><li><code>:fglm</code> (implementation of the FGLM algorithm in <em>Singular</em>),</li><li><code>:hc</code> (implementation of Buchberger&#39;s algorithm in <em>Singular</em> trying to first compute the highest corner modulo some prime), and</li><li><code>:hilbert</code> (implementation of a Hilbert driven Gröbner basis computation in <em>Singular</em>).</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>See the description of the functions <code>groebner_basis_hilbert_driven</code>, <code>fglm</code>,  and <code>f4</code> in the OSCAR documentation for some more details and for restrictions     on the input data when using these versions of the standard basis algorithm.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The returned standard basis is reduced if <code>ordering</code> is <code>global</code> and <code>complete_reduction = true</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R,(x,y) = polynomial_ring(QQ, [&quot;x&quot;,&quot;y&quot;]);

julia&gt; I = ideal([x*(x+1), x^2-y^2+(x-2)*y]);

julia&gt; standard_basis(I, ordering = negdegrevlex(R))
Standard basis with elements
1 -&gt; x
2 -&gt; y
with respect to the ordering
negdegrevlex([x, y])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L118-L152">source</a></section></article><h3 id="Gröbner-Bases-with-transformation-matrix"><a class="docs-heading-anchor" href="#Gröbner-Bases-with-transformation-matrix">Gröbner Bases with transformation matrix</a><a id="Gröbner-Bases-with-transformation-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Gröbner-Bases-with-transformation-matrix" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="groebner_basis_with_transformation_matrix-Tuple{MPolyIdeal}" href="#groebner_basis_with_transformation_matrix-Tuple{MPolyIdeal}"><code>groebner_basis_with_transformation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">groebner_basis_with_transformation_matrix(I::MPolyIdeal;
  ordering::MonomialOrdering = default_ordering(base_ring(I)),
  complete_reduction::Bool=false)</code></pre><p>Return a pair <code>G</code>, <code>T</code>, say, where <code>G</code> is a Gröbner basis of <code>I</code> with respect to <code>ordering</code>, and <code>T</code>  is a transformation matrix from <code>gens(I)</code> to <code>G</code>. That is, <code>gens(I)*T == G</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The returned Gröbner basis is reduced if <code>complete_reduction = true</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R,(x,y) = polynomial_ring(QQ,[&quot;x&quot;,&quot;y&quot;]);

julia&gt; I = ideal([x*y^2-1,x^3+y^2+x*y]);

julia&gt; G, T = groebner_basis_with_transformation_matrix(I)
(Gröbner basis with elements
1 -&gt; x*y^2 - 1
2 -&gt; x^3 + x*y + y^2
3 -&gt; y^4 + x^2 + y
with respect to the ordering
degrevlex([x, y]), [1 0 -x^2-y; 0 1 y^2])

julia&gt; gens(I)*T == gens(G)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L464-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="standard_basis_with_transformation_matrix-Tuple{MPolyIdeal}" href="#standard_basis_with_transformation_matrix-Tuple{MPolyIdeal}"><code>standard_basis_with_transformation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">standard_basis_with_transformation_matrix(I::MPolyIdeal;
  ordering::MonomialOrdering = default_ordering(base_ring(I)),
  complete_reduction::Bool=false)</code></pre><p>Return a pair <code>G</code>, <code>T</code>, say, where <code>G</code> is a standard basis of <code>I</code> with respect to <code>ordering</code>, and <code>T</code>  is a transformation matrix from <code>gens(I)</code> to <code>G</code>. That is, <code>gens(I)*T == G</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The returned Gröbner basis is reduced if <code>ordering</code> is a global monomial odering and <code>complete_reduction = true</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R,(x,y) = polynomial_ring(QQ,[&quot;x&quot;,&quot;y&quot;]);

julia&gt; I = ideal([x*y^2-1,x^3+y^2+x*y]);

julia&gt; G, T = standard_basis_with_transformation_matrix(I, ordering=neglex(R))
(Standard basis with elements
1 -&gt; 1 - x*y^2
with respect to the ordering
neglex([x, y]), [-1; 0])

julia&gt; gens(I)*T == gens(G)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L429-L455">source</a></section></article><h3 id="Gröbner-Basis-Conversion-Algorithms"><a class="docs-heading-anchor" href="#Gröbner-Basis-Conversion-Algorithms">Gröbner Basis Conversion Algorithms</a><a id="Gröbner-Basis-Conversion-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Gröbner-Basis-Conversion-Algorithms" title="Permalink"></a></h3><p>The performance of Buchberger&#39;s Gröbner basis algorithm is sensitive to the choice of monomial ordering. A Gröbner basis computation with respect to a less favorable ordering such as <code>lex</code> may easily run out of time or memory even in cases where a Gröbner basis computation with respect to a more efficient  ordering such as <code>degrevlex</code> is very well feasible. <em>Gröbner basis conversion algorithms</em> and the <em>Hilbert driven Buchberger algorithm</em>  discussed subsequently take their cue from this observation.</p><p>Gröbner basis conversion algorithms proceed along the following lines:</p><ul><li>Given an ideal <span>$I$</span> of a multivariate polynomial ring over a field and a slow <code>destination_ordering</code>, compute a Gröbner basis for <span>$I$</span> with respect to an appropriately chosen fast <code>start_ordering</code>.</li><li>Convert the result to a Gröbner basis with respect to the given slow <code>destination_ordering</code>.</li></ul><p>The algorithms differ in how they perform the conversion.</p><h4 id="The-FGLM-Algorithm"><a class="docs-heading-anchor" href="#The-FGLM-Algorithm">The FGLM Algorithm</a><a id="The-FGLM-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-FGLM-Algorithm" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="fglm-Tuple{MPolyIdeal}" href="#fglm-Tuple{MPolyIdeal}"><code>fglm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fglm(I::MPolyIdeal; start_ordering::MonomialOrdering = default_ordering(base_ring(I)),
                    destination_ordering::MonomialOrdering)</code></pre><p>Given a <strong>zero-dimensional</strong> ideal <code>I</code>, return the reduced Gröbner basis of <code>I</code> with respect to <code>destination_ordering</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Both <code>start_ordering</code> and <code>destination_ordering</code> must be global and the base ring of <code>I</code> must be a polynomial ring over a field.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function implements the Gröbner basis conversion algorithm by <strong>F</strong>augère, <strong>G</strong>ianni, <strong>L</strong>azard, and <strong>M</strong>ora. See [<a href="../../../references/#FGLM93">FGLM93</a>] for more information.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (a, b, c, d, e) = polynomial_ring(QQ, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]);

julia&gt; f1 = a+b+c+d+e;

julia&gt; f2 = a*b+b*c+c*d+a*e+d*e;

julia&gt; f3 = a*b*c+b*c*d+a*b*e+a*d*e+c*d*e;

julia&gt; f4 = b*c*d+a*b*c*e+a*b*d*e+a*c*d*e+b*c*d*e;

julia&gt; f5 = a*b*c*d*e-1;

julia&gt; I = ideal(R, [f1, f2, f3, f4, f5]);

julia&gt; G = fglm(I, destination_ordering = lex(R));

julia&gt; length(G)
8

julia&gt; total_degree(G[8])
60

julia&gt; leading_coefficient(G[8])
83369589588385815165248207597941242098312973356252482872580035860533111990678631297423089011608753348453253671406641805924218003925165995322989635503951507226650115539638517111445927746874479234</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L1304-L1343">source</a></section></article><h4 id="Gröbner-Walk-Algorithms"><a class="docs-heading-anchor" href="#Gröbner-Walk-Algorithms">Gröbner Walk Algorithms</a><a id="Gröbner-Walk-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Gröbner-Walk-Algorithms" title="Permalink"></a></h4><h3 id="The-Hilbert-driven-Buchberger-Algorithm"><a class="docs-heading-anchor" href="#The-Hilbert-driven-Buchberger-Algorithm">The Hilbert driven Buchberger Algorithm</a><a id="The-Hilbert-driven-Buchberger-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-Hilbert-driven-Buchberger-Algorithm" title="Permalink"></a></h3><p>Calling the functions <code>standard_basis</code> and <code>groebner_basis</code> with <code>algorithm = :hilbert</code> in OSCAR triggers a version of the Hilbert driven Gröbner basis algorithm which proceeds along the following lines.</p><ol><li><p>Given an ideal <span>$I$</span> of a multivariate polynomial ring <span>$R$</span> over a field <span>$K$</span> and a slow <code>destination_ordering</code>, check whether <span>$I$</span> is homogeneous with respect to the standard <span>$\mathbb Z$</span>-grading on <span>$R$</span>. If so, set <code>start_ordering</code> to <code>degrevlex</code> and go to step 3.</p></li><li><p>Check whether there exists a <span>$\mathbb Z$</span>-grading on <span>$R$</span> with positive weights such that <span>$I$</span> is homogeneous with respect to this grading. If so, let <code>start_ordering</code> be the corresponding weight ordering. If not, go to step 5.</p></li><li><p>Compute a Gröbner basis of <span>$I$</span> with respect to <code>start_ordering</code> and use this Gröbner basis to compute the Hilbert function of <span>$R/I$</span>.</p></li><li><p>Compute a Gröbner basis with respect to <code>destination_ordering</code>,  proceeding by increasing (weighted) degree, and skipping all further Buchberger tests in a given (weighted) degree as soon as the leading terms found so far account for the Hilbert function in that (weighted) degree. Return the computed Gröbner basis.</p></li><li><p>Extend <span>$R$</span> to a polynomial ring <span>$S$</span> by appending an extra variable, equip <span>$S$</span> with the standard <span>$\mathbb Z$</span>-grading, and let <span>$I^{h}\subset S$</span> be the homogenization of <span>$I$</span> with respect to the extra variable. Compute a Gröbner basis of <span>$I$</span> with respect to <code>degrevlex</code> on <code>R</code>, and homogenize its elements to obtain a Gröbner basis of <span>$I^{h}$</span> with respect to <code>degrevlex</code> on <span>$S$</span>. Use the latter basis to compute the Hilbert function of <span>$S/I^{h}$</span>. Extend <code>destination_ordering</code> to a block ordering on <code>S</code>. Following the recipe in step 4, compute a Gröbner basis of <span>$S/I^{h}$</span> with respect to the extended ordering. Return the dehomogenization of this basis with respect to the extra variable.</p></li></ol><p>If the characteristic of <span>$K$</span> is zero,  by semi-continuity of the Hilbert function, it is sufficient to perform step 3 for the reduction of <span>$I$</span> modulo a conveniently chosen prime number rather than for <span>$I$</span> itself.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If appropriate weights and/or the Hilbert function with respect to appropriate weights are already known to the user, this information can be entered when calling the Hilbert driven Gröbner basis algorithm as follows:</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="groebner_basis_hilbert_driven-Union{Tuple{MPolyIdeal{P}}, Tuple{P}} where P&lt;:MPolyRingElem" href="#groebner_basis_hilbert_driven-Union{Tuple{MPolyIdeal{P}}, Tuple{P}} where P&lt;:MPolyRingElem"><code>groebner_basis_hilbert_driven</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">groebner_basis_hilbert_driven(I::MPolyIdeal{P}; destination_ordering::MonomialOrdering,
                complete_reduction::Bool = false,
                weights::Vector{Int} = ones(Int, ngens(base_ring(I))),
                hilbert_numerator::Union{Nothing, ZZPolyRingElem} = nothing) 
                where {P &lt;: MPolyRingElem}</code></pre><p>Return a Gröbner basis of <code>I</code> with respect to <code>destination_ordering</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function implements a version of the Hilbert driven Gröbner basis algorithm. See the corresponding section of the OSCAR documentation for some details.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All weights must be positive. If no weight vector is entered by the user, all weights  are set to 1. An error is thrown if the generators of <code>I</code> are not homogeneous with  respect to the corresponding (weighted) degree.  </p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <span>$R$</span> denotes the parent ring of <span>$I$</span>, and <span>$p, q\in\mathbb Z[t]$</span> are polynomials such that <span>$p/q$</span> represents the Hilbert series of <span>$R/I$</span> as a rational function with  denominator <span>$q = (1-t^{w_1})\cdots (1-t^{w_n}),$</span> where <span>$n$</span> is the number of variables  of <span>$R$</span>, and <span>$w_1, \dots, w_n$</span> are the assigned weights, then <code>hilbert_numerator</code> is  meant to be <span>$p$</span>. If this numerator is not entered by the user, it will be computed  internally.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (a, b, c, d, e, f, g) = polynomial_ring(QQ, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]);

julia&gt; V = [-3*a^2+2*f*b+3*f*d, (3*g*b+3*g*e)*a-3*f*c*b,
                      -3*g^2*a^2-c*b^2*a-g^2*f*e-g^4, e*a-f*b-d*c];

julia&gt; I = ideal(R, V);

julia&gt; o = degrevlex([a, b, c])*degrevlex([d, e, f, g]);

julia&gt; G = groebner_basis_hilbert_driven(I, destination_ordering = o);

julia&gt; length(G)
296

julia&gt; total_degree(G[49])
30</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(GF(32003), [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; f1 = x^2*y+169*y^21+151*x*y*z^10;

julia&gt; f2 = 6*x^2*y^4+x*z^14+3*z^24;

julia&gt; f3 = 11*x^3+5*x*y^10*z^10+2*y^20*z^10+y^10*z^20;

julia&gt; I = ideal(R, [f1, f2,f3]);

julia&gt; W = [10, 1, 1];

julia&gt; GB = groebner_basis_hilbert_driven(I, destination_ordering = lex(R), weights = W);

julia&gt; length(GB)
40</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(GF(32003), [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; f1 = x^2*y+169*y^21+151*x*y*z^10;

julia&gt; f2 = 6*x^2*y^4+x*z^14+3*z^24;

julia&gt; f3 = 11*x^3+5*x*y^10*z^10+2*y^20*z^10+y^10*z^20;

julia&gt; I = ideal(R, [f1, f2,f3]);

julia&gt; W = [10, 1, 1];

julia&gt; S, t = polynomial_ring(ZZ, &quot;t&quot;)
(Univariate polynomial ring in t over ZZ, t)

julia&gt; hn = -t^75 + t^54 + t^51 + t^45 - t^30 - t^24 - t^21 + 1
-t^75 + t^54 + t^51 + t^45 - t^30 - t^24 - t^21 + 1

julia&gt; GB = groebner_basis_hilbert_driven(I, destination_ordering = lex(R), weights = W, hilbert_numerator = hn);

julia&gt; length(GB)
40</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L1412-L1501">source</a></section></article><h3 id="Faugère&#39;s-F4-Algorithm"><a class="docs-heading-anchor" href="#Faugère&#39;s-F4-Algorithm">Faugère&#39;s F4 Algorithm</a><a id="Faugère&#39;s-F4-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Faugère&#39;s-F4-Algorithm" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Expert function for computing Gröbner bases</header><div class="admonition-body"><p>With many adjustable keyword arguments, the following function provides low-level implementations of various versions of the Gröbner basis algorithm. Use these functions only if you know what you are doing.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="groebner_basis_f4-Tuple{MPolyIdeal}" href="#groebner_basis_f4-Tuple{MPolyIdeal}"><code>groebner_basis_f4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">groebner_basis_f4(I::MPolyIdeal, &lt;keyword arguments&gt;)</code></pre><p>Compute a Gröbner basis of <code>I</code> with respect to <code>degrevlex</code> using Faugère&#39;s F4 algorithm. See [<a href="../../../references/#Fau99">Fau99</a>] for more information.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>At current state only prime fields of characteristic <code>0 &lt; p &lt; 2^{31}</code> are supported.</p></div></div><p><strong>Possible keyword arguments</strong></p><ul><li><code>initial_hts::Int=17</code>: initial hash table size <code>log_2</code>.</li><li><code>nr_thrds::Int=1</code>: number of threads for parallel linear algebra.</li><li><code>max_nr_pairs::Int=0</code>: maximal number of pairs per matrix, only bounded by minimal degree if <code>0</code>.</li><li><code>la_option::Int=2</code>: linear algebra option: exact sparse-dense (<code>1</code>), exact sparse (<code>2</code>, default), probabilistic sparse-dense (<code>42</code>), probabilistic sparse(<code>44</code>).</li><li><code>eliminate::Int=0</code>: size of first block of variables to be eliminated.</li><li><code>complete_reduction::Bool=true</code>: compute a reduced Gröbner basis for <code>I</code></li><li><code>info_level::Int=0</code>: info level printout: off (<code>0</code>, default), summary (<code>1</code>), detailed (<code>2</code>).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R,(x,y,z) = polynomial_ring(GF(101), [&quot;x&quot;,&quot;y&quot;,&quot;z&quot;])
(Multivariate polynomial ring in 3 variables over GF(101), FqMPolyRingElem[x, y, z])

julia&gt; I = ideal(R, [x+2*y+2*z-1, x^2+2*y^2+2*z^2-x, 2*x*y+2*y*z-y])
Ideal generated by
  x + 2*y + 2*z + 100
  x^2 + 100*x + 2*y^2 + 2*z^2
  2*x*y + 2*y*z + 100*y

julia&gt; groebner_basis_f4(I)
Gröbner basis with elements
1 -&gt; x + 2*y + 2*z + 100
2 -&gt; y*z + 82*z^2 + 10*y + 40*z
3 -&gt; y^2 + 60*z^2 + 20*y + 81*z
4 -&gt; z^3 + 28*z^2 + 64*y + 13*z
with respect to the ordering
degrevlex([x, y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L327-L365">source</a></section></article><h2 id="Leading-Ideals"><a class="docs-heading-anchor" href="#Leading-Ideals">Leading Ideals</a><a id="Leading-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Leading-Ideals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="leading_ideal-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:MPolyRingElem" href="#leading_ideal-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:MPolyRingElem"><code>leading_ideal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leading_ideal(G::Vector{T}; ordering::MonomialOrdering = default_ordering(parent(G[1]))) 
                            where T &lt;: MPolyRingElem</code></pre><p>Return the leading ideal of <code>G</code> with respect to <code>ordering</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; L = leading_ideal([x*y^2-3*x, x^3-14*y^5], ordering=degrevlex(R))
Ideal generated by
  x*y^2
  y^5

julia&gt; L = leading_ideal([x*y^2-3*x, x^3-14*y^5], ordering=lex(R))
Ideal generated by
  x*y^2
  x^3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L525-L546">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="leading_ideal-Tuple{MPolyIdeal}" href="#leading_ideal-Tuple{MPolyIdeal}"><code>leading_ideal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leading_ideal(I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(base_ring(I)))</code></pre><p>Return the leading ideal of <code>I</code> with respect to <code>ordering</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; I = ideal(R,[x*y^2-3*x, x^3-14*y^5])
Ideal generated by
  x*y^2 - 3*x
  x^3 - 14*y^5

julia&gt; L = leading_ideal(I, ordering=degrevlex(R))
Ideal generated by
  x*y^2
  x^4
  y^5

julia&gt; L = leading_ideal(I, ordering=lex(R))
Ideal generated by
  y^7
  x*y^2
  x^3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L560-L587">source</a></section></article><h2 id="Normal-Forms"><a class="docs-heading-anchor" href="#Normal-Forms">Normal Forms</a><a id="Normal-Forms-1"></a><a class="docs-heading-anchor-permalink" href="#Normal-Forms" title="Permalink"></a></h2><p>Given a polynomial <span>$g\in K[x]$</span>, an ideal <span>$I\subset K[x]$</span>, and a global monomial ordering <span>$&gt;$</span> on the monomials in <span>$x$</span>, the fully reduced remainder <span>$h$</span> in a standard expression on division by the elements of a Gröbner basis of <span>$I$</span> with respect to <span>$&gt;$</span> is uniquely determined by <span>$g$</span>, <span>$I$</span>, and <span>$&gt;$</span> (and does not depend on the choice of Gröbner basis). We refer to such a remainder as the <em>normal form</em>  of <span>$g$</span> mod <span>$I$</span>, with respect to <span>$&gt;$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="normal_form-Union{Tuple{T}, Tuple{T, MPolyIdeal}} where T&lt;:MPolyRingElem" href="#normal_form-Union{Tuple{T}, Tuple{T, MPolyIdeal}} where T&lt;:MPolyRingElem"><code>normal_form</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normal_form(g::T, I::MPolyIdeal; 
  ordering::MonomialOrdering = default_ordering(base_ring(I))) where T &lt;: MPolyRingElem</code></pre><p>Compute the normal form of <code>g</code> mod <code>I</code> with respect to <code>ordering</code>.</p><pre><code class="nohighlight hljs">normal_form(G::Vector{T}, I::MPolyIdeal; 
  ordering::MonomialOrdering = default_ordering(base_ring(I))) where T &lt;: MPolyRingElem</code></pre><p>Return a <code>Vector</code> which contains for each element <code>g</code> of <code>G</code> a normal form as above.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R,(a,b,c) = polynomial_ring(QQ,[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[a, b, c])

julia&gt; J = ideal(R,[-1+c+b,-1+b+c*a+2*a*b])
Ideal generated by
  b + c - 1
  2*a*b + a*c + b - 1

julia&gt; gens(groebner_basis(J))
2-element Vector{QQMPolyRingElem}:
 b + c - 1
 a*c - 2*a + c

julia&gt; normal_form(-1+c+b+a^3, J)
a^3

julia&gt; R,(a,b,c) = polynomial_ring(QQ,[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[a, b, c])

julia&gt; A = [-1+c+b+a^3,-1+b+c*a+2*a^3,5+c*b+c^2*a]
3-element Vector{QQMPolyRingElem}:
 a^3 + b + c - 1
 2*a^3 + a*c + b - 1
 a*c^2 + b*c + 5

julia&gt; J = ideal(R,[-1+c+b,-1+b+c*a+2*a*b])
Ideal generated by
  b + c - 1
  2*a*b + a*c + b - 1

julia&gt; gens(groebner_basis(J))
2-element Vector{QQMPolyRingElem}:
 b + c - 1
 a*c - 2*a + c

julia&gt; normal_form(A, J)
3-element Vector{QQMPolyRingElem}:
 a^3
 2*a^3 + 2*a - 2*c
 4*a - 2*c^2 - c + 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L992-L1046">source</a></section></article><h2 id="Syzygies"><a class="docs-heading-anchor" href="#Syzygies">Syzygies</a><a id="Syzygies-1"></a><a class="docs-heading-anchor-permalink" href="#Syzygies" title="Permalink"></a></h2><p>We refer to the section on <a href="../../ModulesOverMultivariateRings/intro/#modules_multivariate">modules</a> for more on syzygies.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="syzygy_generators-Tuple{Vector{&lt;:MPolyRingElem}}" href="#syzygy_generators-Tuple{Vector{&lt;:MPolyRingElem}}"><code>syzygy_generators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">syzygy_generators(G::Vector{&lt;:MPolyRingElem})</code></pre><p>Return generators for the syzygies on the polynomials given as elements of <code>G</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; S = syzygy_generators([x^3+y+2,x*y^2-13*x^2,y-14])
3-element Vector{FreeModElem{QQMPolyRingElem}}:
 (-y + 14)*e[2] + (-13*x^2 + x*y^2)*e[3]
 (-169*y + 2366)*e[1] + (-13*x*y + 182*x - 196*y + 2744)*e[2] + (13*x^2*y^2 - 2548*x^2 + 196*x*y^2 + 169*y + 338)*e[3]
 (-13*x^2 + 196*x)*e[1] + (-x^3 - 16)*e[2] + (x^4*y + 14*x^4 + 13*x^2 + 16*x*y + 28*x)*e[3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/bfad10c18148dc5127a2220cb5fdb71f4fe77d13/src/Rings/groebner.jl#L499-L515">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../orderings/">« Monomial Orderings</a><a class="docs-footer-nextpage" href="../groebner_bases_integers/">Gröbner/Standard Bases Over <span>$\mathbb Z$</span> »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 24 June 2024 21:20">Monday 24 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
