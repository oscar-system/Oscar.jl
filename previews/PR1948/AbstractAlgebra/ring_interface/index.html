<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ring Interface · Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../Experimental/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/homological_algebra/">Homological Algebra</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">Gröbner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/groebner_bases/">Gröbner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/groebner_bases_integers/">Gröbner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../TropicalGeometry/curve/">Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Standard Constructions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/StandardConstructions/standard_constructions/">Standard Constructions in Algebraic Geometry</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/K3Surfaces/">Algebraic Surfaces</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Finitely Presented Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-7" type="checkbox"/><label class="tocitem" for="menuitem-17-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Ring Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ring Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/AbstractAlgebra/ring_interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Ring-Interface"><a class="docs-heading-anchor" href="#Ring-Interface">Ring Interface</a><a id="Ring-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Ring-Interface" title="Permalink"></a></h1><p>AbstractAlgebra.jl generic code makes use of a standardised set of functions which it expects to be implemented for all rings. Here we document this interface. All libraries which want to make use of the generic capabilities of AbstractAlgebra.jl must supply all of the required functionality for their rings.</p><p>In addition to the required functions, there are also optional functions which can be provided for certain types of rings, e.g. GCD domains or fields, etc. If implemented, these allow the generic code to provide additional functionality for those rings, or in some cases, to select more efficient algorithms.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>Most rings must supply two types:</p><ul><li>a type for the parent object (representing the ring itself)</li><li>a type for elements of that ring</li></ul><p>For example, the generic univariate polynomial type in AbstractAlgebra.jl provides two types in generic/GenericTypes.jl:</p><ul><li><code>Generic.PolyRing{T}</code> for the parent objects</li><li><code>Generic.Poly{T}</code> for the actual polynomials</li></ul><p>The parent type must belong to <code>Ring</code> and the element type must belong to <code>RingElem</code>. Of course, the types may belong to these abstract types transitively, e.g. <code>Poly{T}</code> actually belongs to <code>PolyElem{T}</code> which in turn belongs to <code>RingElem</code>.</p><p>For parameterised rings, we advise that the types of both the parent objects and element objects to be parameterised by the types of the elements of the base ring (see the function <code>base_ring</code> below for a definition).</p><p>There can be variations on this theme: e.g. in some areas of mathematics there is a notion of a coefficient domain, in which case it may make sense to parameterise all types by the type of elements of this coefficient domain. But note that this may have implications for the ad hoc operators one might like to explicitly implement.</p><h2 id="RingElement-type-union"><a class="docs-heading-anchor" href="#RingElement-type-union">RingElement type union</a><a id="RingElement-type-union-1"></a><a class="docs-heading-anchor-permalink" href="#RingElement-type-union" title="Permalink"></a></h2><p>Because of its lack of multiple inheritance, Julia does not allow Julia Base types to belong to <code>RingElem</code>. To allow us to work equally with AbstractAlgebra and Julia types that represent elements of rings we define a union type <code>RingElement</code> in <code>src/julia/JuliaTypes</code>.</p><p>So far, in addition to <code>RingElem</code> the  union type <code>RingElement</code> includes the Julia types <code>Integer</code>, <code>Rational</code> and <code>AbstractFloat</code>.</p><p>Most of the generic code in AbstractAlgebra makes use of the union type <code>RingElement</code> instead of <code>RingElem</code> so that the generic functions also accept the Julia Base ring types.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>One must be careful when defining ad hoc binary operations for ring element types. It is often necessary to define separate versions of the functions for <code>RingElem</code> then for each of the Julia types separately in order to avoid ambiguity warnings.</p></div></div><p>Note that even though <code>RingElement</code> is a union type we still have the following inclusion</p><pre><code class="language-julia hljs">RingElement &lt;: NCRingElement</code></pre><h2 id="Parent-object-caches"><a class="docs-heading-anchor" href="#Parent-object-caches">Parent object caches</a><a id="Parent-object-caches-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-object-caches" title="Permalink"></a></h2><p>In many cases, it is desirable to have only one object in the system to represent each ring. This means that if the same ring is constructed twice, elements of the two rings will be compatible as far as arithmetic is concerned.</p><p>In order to facilitate this, global caches of rings are stored in AbstractAlgebra.jl, usually implemented using dictionaries. For example, the <code>Generic.PolyRing</code> parent objects are looked up in a dictionary <code>PolyID</code> to see if they have been previously defined.</p><p>Whether these global caches are provided or not, depends on both mathematical and algorithmic considerations. E.g. in the case of number fields, it isn&#39;t desirable to identify all number fields with the same defining polynomial, as they may be considered with distinct embeddings into one another. In other cases, identifying whether two rings are the same may be prohibitively expensive. Generally, it may only make sense algorithmically to identify two rings if they were constructed from identical data.</p><p>If a global cache is provided, it must be optionally possible to construct the parent objects without caching. This is done by passing a boolean value <code>cached</code> to the inner constructor of the parent object. See <code>generic/GenericTypes.jl</code> for examples of how to construct and handle such caches.</p><h2 id="Required-functions-for-all-rings"><a class="docs-heading-anchor" href="#Required-functions-for-all-rings">Required functions for all rings</a><a id="Required-functions-for-all-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Required-functions-for-all-rings" title="Permalink"></a></h2><p>In the following, we list all the functions that are required to be provided for rings in AbstractAlgebra.jl or by external libraries wanting to use AbstractAlgebra.jl.</p><p>We give this interface for fictitious types <code>MyParent</code> for the type of the ring parent object <code>R</code> and <code>MyElem</code> for the type of the elements of the ring.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Generic functions in AbstractAlgebra.jl may not rely on the existence of functions that are not documented here. If they do, those functions will only be available for rings that implement that additional functionality, and should be documented as such.</p></div></div><h3 id="Data-type-and-parent-object-methods"><a class="docs-heading-anchor" href="#Data-type-and-parent-object-methods">Data type and parent object methods</a><a id="Data-type-and-parent-object-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Data-type-and-parent-object-methods" title="Permalink"></a></h3><pre><code class="language-julia hljs">parent_type(::Type{MyElem})</code></pre><p>Return the type of the corresponding parent object for the given element type. For example, <code>parent_type(Generic.Poly{T})</code> will return <code>Generic.PolyRing{T}</code>.</p><pre><code class="language-julia hljs">elem_type(::Type{MyParent})</code></pre><p>Return the type of the elements of the ring whose parent object has the given type. This is the inverse of the <code>parent_type</code> function, i.e. <code>elem_type(Generic.PolyRing{T})</code> will return <code>Generic.Poly{T}</code>.</p><pre><code class="language-julia hljs">base_ring(R::MyParent)</code></pre><p>Given a parent object <code>R</code>, representing a ring, this function returns the parent object of any base ring that parameterises this ring. For example, the base ring of the ring of polynomials over the integers would be the integer ring.</p><p>If the ring is not parameterised by another ring, this function must return <code>Union{}</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There is a distinction between a base ring and other kinds of parameters. For example, in the ring <span>$\mathbb{Z}/n\mathbb{Z}$</span>, the modulus <span>$n$</span> is a parameter, but the only base ring is <span>$\mathbb{Z}$</span>. We consider the ring <span>$\mathbb{Z}/n\mathbb{Z}$</span> to have been constructed from the base ring <span>$\mathbb{Z}$</span> by taking its quotient by a (principal) ideal.</p></div></div><pre><code class="language-julia hljs">parent(f::MyElem)</code></pre><p>Return the parent object of the given element, i.e. return the ring to which the given element belongs.</p><p>This is usually stored in a field <code>parent</code> in each ring element. (If the parent objects have <code>mutable struct</code> types, the internal overhead here is just an additional machine pointer stored in each element of the ring.)</p><p>For some element types it isn&#39;t necessary to append the parent object as a field of every element. This is the case when the parent object can be reconstructed just given the type of the elements. For example, this is the case for the ring of integers and in fact for any ring element type that isn&#39;t parameterised or generic in any way.</p><pre><code class="language-julia hljs">is_domain_type(::Type{MyElem})</code></pre><p>Return <code>true</code> if every element of the given element type (which may be parameterised or an abstract type) necessarily has a parent that is an integral domain, otherwise if this cannot be guaranteed, the function returns <code>false</code>.</p><p>For example, if <code>MyElem</code> was the type of elements of generic residue rings of a polynomial ring, the answer to the question would depend on the modulus of the residue ring. Therefore <code>is_domain_type</code> would have to return <code>false</code>, since we cannot guarantee that we are dealing with elements of an integral domain in general. But if the given element type was for rational integers, the answer would be <code>true</code>, since every rational integer has as parent the ring of rational integers, which is an integral domain.</p><p>Note that this function depends only on the type of an element and cannot access information about the object itself, or its parent.</p><pre><code class="language-julia hljs">is_exact_type(::Type{MyElem})</code></pre><p>Return <code>true</code> if every element of the given type is represented exactly. For example, <span>$p$</span>-adic numbers, real and complex floating point numbers and power series are not exact, as we can only represent them in general with finite truncations. Similarly polynomials and matrices over inexact element types are themselves inexact.</p><p>Integers, rationals, finite fields and polynomials and matrices over them are always exact.</p><p>Note that <code>MyElem</code> may be parameterised or an abstract type, in which case every element of every type represented by <code>MyElem</code> must be exact, otherwise the function must return <code>false</code>.</p><pre><code class="language-julia hljs">Base.hash(f::MyElem, h::UInt)</code></pre><p>Return a hash for the object <span>$f$</span> of type <code>UInt</code>. This is used as a hopefully cheap way to distinguish objects that differ arithmetically.</p><p>If the object has components, e.g. the coefficients of a polynomial or elements of a matrix, these should be hashed recursively, passing the same parameter <code>h</code> to all levels. Each component should then be xor&#39;d with <code>h</code> before combining the individual component hashes to give the final hash.</p><p>The hash functions in AbstractAlgebra.jl usually start from some fixed 64 bit hexadecimal  value that has been picked at random by the library author for that type. That is then truncated to fit a <code>UInt</code> (in case the latter is not 64 bits). This ensures that objects that are the same arithmetically (or that have the same components), but have different types (or structures), are unlikely to hash to the same value.</p><pre><code class="language-julia hljs">deepcopy_internal(f::MyElem, dict::ObjectIdDict)</code></pre><p>Return a copy of the given element, recursively copying all components of the object.</p><p>Obviously the parent, if it is stored in the element, should not be copied. The new element should have precisely the same parent as the old object.</p><p>For types that cannot self-reference themselves anywhere internally, the <code>dict</code> argument may be ignored.</p><p>In the case that internal self-references are possible, please consult the Julia documentation on how to implement <code>deepcopy_internal</code>.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><p>Outer constructors for most AbstractAlgebra types are provided by overloading the call syntax for parent objects.</p><p>If <code>R</code> is a parent object for a given ring we provide the following constructors.</p><pre><code class="language-julia hljs">(R::MyParent)()</code></pre><p>Return the zero object of the given ring.</p><pre><code class="language-julia hljs">(R::MyParent)(a::Integer)</code></pre><p>Coerce the given integer into the given ring.</p><pre><code class="language-julia hljs">(R::MyParent)(a::MyElem)</code></pre><p>If <span>$a$</span> belongs to the given ring, the function returns it (without making a copy). Otherwise an error is thrown.</p><p>For parameterised rings we also require a function to coerce from the base ring into the parent ring.</p><pre><code class="language-julia hljs">(R::MyParent{T})(a::T) where T &lt;: RingElem</code></pre><p>Coerce <span>$a$</span> into the ring <span>$R$</span> if <span>$a$</span> belongs to the base ring of <span>$R$</span>.</p><h3 id="Basic-manipulation-of-rings-and-elements"><a class="docs-heading-anchor" href="#Basic-manipulation-of-rings-and-elements">Basic manipulation of rings and elements</a><a id="Basic-manipulation-of-rings-and-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation-of-rings-and-elements" title="Permalink"></a></h3><pre><code class="language-julia hljs">zero(R::MyParent)</code></pre><p>Return the zero element of the given ring.</p><pre><code class="language-julia hljs">one(R::MyParent)</code></pre><p>Return the multiplicative identity of the given ring.</p><pre><code class="language-julia hljs">iszero(f::MyElem)</code></pre><p>Return <code>true</code> if the given element is the zero element of the ring it belongs to.</p><pre><code class="language-julia hljs">isone(f::MyElem)</code></pre><p>Return <code>true</code> if the given element is the multiplicative identity of the ring it belongs to.</p><h3 id="Canonicalisation"><a class="docs-heading-anchor" href="#Canonicalisation">Canonicalisation</a><a id="Canonicalisation-1"></a><a class="docs-heading-anchor-permalink" href="#Canonicalisation" title="Permalink"></a></h3><pre><code class="language-julia hljs">canonical_unit(f::MyElem)</code></pre><p>When fractions are created with two elements of the given type, it is nice to be able to represent them in some kind of canonical form. This is of course not always possible. But for example, fractions of integers can be canonicalised by first removing any common factors of the numerator and denominator, then making the denominator positive.</p><p>In AbstractAlgebra.jl, the denominator would be made positive by dividing both the numerator and denominator by the canonical unit of the denominator. For a negative denominator, this would be <span>$-1$</span>.</p><p>For elements of a field, <code>canonical_unit</code> simply returns the element itself. In general, <code>canonical_unit</code> of an invertible element should be that element. Finally, if <span>$a = ub$</span> we should have the identity <code>canonical_unit(a) = canonical_unit(u)*canonical_unit(b)</code>.</p><p>For some rings, it is completely impractical to implement this function, in which case it may return <span>$1$</span> in the given ring. The function must however always exist, and always return an element of the ring.</p><h3 id="String-I/O"><a class="docs-heading-anchor" href="#String-I/O">String I/O</a><a id="String-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#String-I/O" title="Permalink"></a></h3><pre><code class="language-julia hljs">show(io::IO, R::MyParent)</code></pre><p>This should print an English description of the parent ring (to the given IO object). If the ring is parameterised, it can call the corresponding <code>show</code> function for any rings it depends on.</p><pre><code class="language-julia hljs">show(io::IO, f::MyElem)</code></pre><p>This should print a human readable, textual representation of the object (to the given IO object). It can recursively call the corresponding <code>show</code> functions for any of its components.</p><h3 id="Expressions"><a class="docs-heading-anchor" href="#Expressions">Expressions</a><a id="Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions" title="Permalink"></a></h3><p>To obtain best results when printing composed types derived from other types, e.g., polynomials, the following method should be implemented.</p><pre><code class="language-julia hljs">expressify(f::MyElem; context = nothing)</code></pre><p>which must return either <code>Expr</code>, <code>Symbol</code>, <code>Integer</code> or <code>String</code>.</p><p>For a type which implements  <code>expressify</code>, one can automatically derive <code>show</code> methods supporting output as plain text, LaTeX and <code>html</code> by using the following:</p><pre><code class="language-julia hljs">@enable_all_show_via_expressify MyElem</code></pre><p>This defines the following show methods for the specified type <code>MyElem</code>:</p><pre><code class="language-julia hljs">function Base.show(io::IO, a::MyElem)
  show_via_expressify(io, a)
end

function Base.show(io::IO, mi::MIME&quot;text/plain&quot;, a::MyElem)
  show_via_expressify(io, mi, a)
end

function Base.show(io::IO, mi::MIME&quot;text/latex&quot;, a::MyElem)
  show_via_expressify(io, mi, a)
end

function Base.show(io::IO, mi::MIME&quot;text/html&quot;, a::MyElem)
  show_via_expressify(io, mi, a)
end</code></pre><p>As an example, assume that an object <code>f</code> of type <code>MyElem</code> has two components <code>f.a</code> and <code>f.b</code> of integer type, which should be printed as <code>a^b</code>, this can be implemented as</p><pre><code class="language-julia hljs">expressify(f::MyElem; context = nothing) = Expr(:call, :^, f.a, f.b)</code></pre><p>If <code>f.a</code> and <code>f.b</code> themselves are objects that can be expressified, this can be implemented as</p><pre><code class="language-julia hljs">function expressify(f::MyElem; context = nothing)
  return Expr(:call, :^, expressify(f.a, context = context),
                         expressify(f.b, context = context))
end</code></pre><p>As noted above, expressify should return an <code>Expr</code>, <code>Symbol</code>, <code>Integer</code> or <code>String</code>. The rendering of such expressions with a particular MIME type to an output context is controlled by the following rules which are subject to change slightly in future versions of AbstracAlgebra.</p><p><code>Integer</code>: The printing of integers is straightforward and automatically includes transformations such as <code>1 + (-2)*x =&gt; 1 - 2*x</code> as this is cumbersome to implement per-type.</p><p><code>Symbol</code>: Since variable names are stored as mere symbols in AbstractAlgebra, some transformations related to subscripts are applied to symbols automatically in latex output. The <code>\operatorname{</code> in the following table is actually replaced with the more portable <code>\mathop{\mathrm{</code>.</p><table><tr><th style="text-align: left">expressify</th><th style="text-align: left">latex output</th></tr><tr><td style="text-align: left"><code>Symbol(&quot;a&quot;)</code></td><td style="text-align: left"><code>a</code></td></tr><tr><td style="text-align: left"><code>Symbol(&quot;α&quot;)</code></td><td style="text-align: left"><code>{\alpha}</code></td></tr><tr><td style="text-align: left"><code>Symbol(&quot;x1&quot;)</code></td><td style="text-align: left"><code>\operatorname{x1}</code></td></tr><tr><td style="text-align: left"><code>Symbol(&quot;xy_1&quot;)</code></td><td style="text-align: left"><code>\operatorname{xy}_{1}</code></td></tr><tr><td style="text-align: left"><code>Symbol(&quot;sin&quot;)</code></td><td style="text-align: left"><code>\operatorname{sin}</code></td></tr><tr><td style="text-align: left"><code>Symbol(&quot;sin_cos&quot;)</code></td><td style="text-align: left"><code>\operatorname{sin\_cos}</code></td></tr><tr><td style="text-align: left"><code>Symbol(&quot;sin_1&quot;)</code></td><td style="text-align: left"><code>\operatorname{sin}_{1}</code></td></tr><tr><td style="text-align: left"><code>Symbol(&quot;sin_cos_1&quot;)</code></td><td style="text-align: left"><code>\operatorname{sin\_cos}_{1}</code></td></tr><tr><td style="text-align: left"><code>Symbol(&quot;αaβb_1_2&quot;)</code></td><td style="text-align: left"><code>\operatorname{{\alpha}a{\beta}b}_{1,2}</code></td></tr></table><p><code>Expr</code>: These are the most versatile as the <code>Expr</code> objects themselves contain a symbolic head and any number of arguments. What looks like <code>f(a,b)</code> in textual output is <code>Expr(:call, :f, :a, :b)</code> under the hood. AbstractAlgebra currently contains the following printing rules for such expressions.</p><table><tr><th style="text-align: left">expressify</th><th style="text-align: left">output</th><th style="text-align: left">latex notes</th></tr><tr><td style="text-align: left"><code>Expr(:call, :+, a, b)</code></td><td style="text-align: left"><code>a + b</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Expr(:call, :*, a, b)</code></td><td style="text-align: left"><code>a*b</code></td><td style="text-align: left">one space for implied multiplication</td></tr><tr><td style="text-align: left"><code>Expr(:call, :cdot, a, b)</code></td><td style="text-align: left"><code>a * b</code></td><td style="text-align: left">a real <code>\cdot</code> is used</td></tr><tr><td style="text-align: left"><code>Expr(:call, :^, a, b)</code></td><td style="text-align: left"><code>a^b</code></td><td style="text-align: left">may include some courtesy parentheses</td></tr><tr><td style="text-align: left"><code>Expr(:call, ://, a, b)</code></td><td style="text-align: left"><code>a//b</code></td><td style="text-align: left">will create a fraction box</td></tr><tr><td style="text-align: left"><code>Expr(:call, :/, a, b)</code></td><td style="text-align: left"><code>a/b</code></td><td style="text-align: left">will not create a fraction box</td></tr><tr><td style="text-align: left"><code>Expr(:call, a, b, c)</code></td><td style="text-align: left"><code>a(b, c)</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Expr(:ref, a, b, c)</code></td><td style="text-align: left"><code>a[b, c]</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Expr(:vcat, a, b)</code></td><td style="text-align: left"><code>[a; b]</code></td><td style="text-align: left">actually vertical</td></tr><tr><td style="text-align: left"><code>Expr(:vect, a, b)</code></td><td style="text-align: left"><code>[a, b]</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Expr(:tuple, a, b)</code></td><td style="text-align: left"><code>(a, b)</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Expr(:list, a, b)</code></td><td style="text-align: left"><code>{a, b}</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Expr(:series, a, b)</code></td><td style="text-align: left"><code>a, b</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Expr(:sequence, a, b)</code></td><td style="text-align: left"><code>ab</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Expr(:row, a, b)</code></td><td style="text-align: left"><code>a b</code></td><td style="text-align: left">combine with <code>:vcat</code> to make matrices</td></tr><tr><td style="text-align: left"><code>Expr(:hcat, a, b)</code></td><td style="text-align: left"><code>a b</code></td><td style="text-align: left"></td></tr></table><p><code>String</code>: Strings are printed verbatim and should only be used as a last resort as they provide absolutely no precedence information on their contents.</p><h3 id="Unary-operations"><a class="docs-heading-anchor" href="#Unary-operations">Unary operations</a><a id="Unary-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Unary-operations" title="Permalink"></a></h3><pre><code class="language-julia hljs">-(f::MyElem)</code></pre><p>Return <span>$-f$</span>.</p><h3 id="Binary-operations"><a class="docs-heading-anchor" href="#Binary-operations">Binary operations</a><a id="Binary-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-operations" title="Permalink"></a></h3><pre><code class="language-julia hljs">+(f::MyElem, g::MyElem)
-(f::MyElem, g::MyElem)
*(f::MyElem, g::MyElem)</code></pre><p>Return <span>$f + g$</span>, <span>$f - g$</span> or <span>$fg$</span>, respectively.</p><h3 id="Comparison"><a class="docs-heading-anchor" href="#Comparison">Comparison</a><a id="Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison" title="Permalink"></a></h3><pre><code class="nohighlight hljs">==(f::MyElem, g::MyElem)</code></pre><p>Return <code>true</code> if <span>$f$</span> and <span>$g$</span> are arithmetically equal. In the case where the two elements are inexact, the function returns <code>true</code> if they agree to the minimum precision of the two.</p><pre><code class="nohighlight hljs">isequal(f::MyElem, g::MyElem)</code></pre><p>For exact rings, this should return the same thing as <code>==</code> above. For inexact rings, this returns <code>true</code> only if the two elements are arithmetically equal and have the same precision.</p><h3 id="Powering"><a class="docs-heading-anchor" href="#Powering">Powering</a><a id="Powering-1"></a><a class="docs-heading-anchor-permalink" href="#Powering" title="Permalink"></a></h3><pre><code class="language-julia hljs">^(f::MyElem, e::Int)</code></pre><p>Return <span>$f^e$</span>. The function should throw a <code>DomainError()</code> if negative exponents don&#39;t make sense but are passed to the function.</p><h3 id="Exact-division"><a class="docs-heading-anchor" href="#Exact-division">Exact division</a><a id="Exact-division-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-division" title="Permalink"></a></h3><pre><code class="language-julia hljs">divexact(f::MyElem, g::MyElem; check::Bool=true)</code></pre><p>Return <span>$f/g$</span>, though note that Julia uses <code>/</code> for floating point division. Here we mean exact division in the ring, i.e. return <span>$q$</span> such that <span>$f = gq$</span>. A <code>DivideError()</code> should be thrown if <span>$g$</span> is zero.</p><p>If <code>check=true</code> the function should check that the division is exact and throw an exception if not.</p><p>If <code>check=false</code> the check may be omitted for performance reasons. The behaviour is then undefined if a division is performed that is not exact. This may include throwing an exception, returning meaningless results, hanging or crashing. The function should only be called with <code>check=false</code> if it is already known that the division will be exact.</p><h3 id="Inverse"><a class="docs-heading-anchor" href="#Inverse">Inverse</a><a id="Inverse-1"></a><a class="docs-heading-anchor-permalink" href="#Inverse" title="Permalink"></a></h3><pre><code class="language-julia hljs">inv(f::MyElem)</code></pre><p>Return the inverse of <span>$f$</span>, i.e. <span>$1/f$</span>, though note that Julia uses <code>/</code> for floating point division. Here we mean exact division in the ring.</p><p>A fallback for this function is provided in terms of <code>divexact</code> so an implementation can be omitted if preferred.</p><h3 id="Unsafe-operators"><a class="docs-heading-anchor" href="#Unsafe-operators">Unsafe operators</a><a id="Unsafe-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Unsafe-operators" title="Permalink"></a></h3><p>To speed up polynomial and matrix arithmetic, it sometimes makes sense to mutate values in place rather than replace them with a newly created object every time they are modified.</p><p>For this purpose, certain mutating operators are required. In order to support immutable types (struct in Julia) and systems that don&#39;t have in-place operators, all unsafe operators must return the (ostensibly) mutated value. Only the returned value is used in computations, so this lifts the requirement that the unsafe operators actually mutate the value.</p><p>Note the exclamation point is a convention, which indicates that the object may be mutated in-place.</p><p>To make use of these functions, one must be certain that no other references are held to the object being mutated, otherwise those values will also be changed!</p><p>The results of <code>deepcopy</code> and all arithmetic operations, including powering and division can be assumed to be new objects without other references being held, as can objects returned from constructors.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is important to recognise that <code>R(a)</code> where <code>R</code> is the ring <code>a</code> belongs to, does not create a new value. For this case, use <code>deepcopy(a)</code>.</p></div></div><pre><code class="language-julia hljs">zero!(f::MyElem)</code></pre><p>Set the value <span>$f$</span> to zero in place. Return the mutated value.</p><pre><code class="language-julia hljs">mul!(c::MyElem, a::MyElem, b::MyElem)</code></pre><p>Set <span>$c$</span> to the value <span>$ab$</span> in place. Return the mutated value. Aliasing is permitted.</p><pre><code class="language-julia hljs">add!(c::MyElem, a::MyElem, b::MyElem)</code></pre><p>Set <span>$c$</span> to the value <span>$a + b$</span> in place. Return the mutated value. Aliasing is permitted.</p><pre><code class="language-julia hljs">addeq!(a::MyElem, b::MyElem)</code></pre><p>Set <span>$a$</span> to <span>$a + b$</span> in place. Return the mutated value. Aliasing is permitted.</p><h3 id="Random-generation"><a class="docs-heading-anchor" href="#Random-generation">Random generation</a><a id="Random-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-generation" title="Permalink"></a></h3><p>The random functions are only used for test code to generate test data. They therefore don&#39;t need to provide any guarantees on uniformity, and in fact, test values that are known to be a good source of corner cases can be supplied.</p><pre><code class="language-julia hljs">rand(R::MyParent, v...)</code></pre><p>Return a random element in the given ring of the specified size.</p><p>There can be as many arguments as is necessary to specify the size of the test example which is being produced.</p><h3 id="Promotion-rules"><a class="docs-heading-anchor" href="#Promotion-rules">Promotion rules</a><a id="Promotion-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Promotion-rules" title="Permalink"></a></h3><p>AbstractAlgebra currently has a very simple coercion model. With few exceptions only simple coercions are supported. For example if <span>$x \in \mathbb{Z}$</span> and <span>$y \in \mathbb{Z}[x]$</span> then <span>$x + y$</span> can be computed by coercing <span>$x$</span> into the same ring as <span>$y$</span> and then adding in that ring.</p><p>Complex coercions such as adding elements of <span>$\mathbb{Q}$</span> and <span>$\mathbb{Z}[x]$</span> are not supported, as this would require finding and creating a common overring in which the elements could be added.</p><p>AbstractAlgebra supports simple coercions by overloading parent object call syntax <code>R(x)</code> to coerce the object <code>x</code> into the ring <code>R</code>. However, to coerce elements up a tower of rings, one needs to also have a promotion system similar to Julia&#39;s type promotion system.</p><p>As for Julia, AbstractAlgebra&#39;s promotion system only specifies what happens to types. It is the coercions themselves that must deal with the mathematical situation at the level of rings, including checking that the object can even be coerced into the given ring.</p><p>We now describe the required AbstractAlgebra type promotion rules.</p><p>For every ring, one wants to be able to coerce integers into the ring. And for any ring constructed over a base ring, one would like to be able to coerce from the base ring into the ring.</p><p>The required promotion rules to support this look a bit different depending on whether the element type is parameterised or not and whether it is built on a base ring.</p><p>For ring element types <code>MyElem</code> that are neither parameterised nor built over a base ring, the promotion rules can be defined as follows:</p><pre><code class="language-julia hljs">promote_rule(::Type{MyElem}, ::Type{T}) where {T &lt;: Integer} = MyElem</code></pre><p>For ring element types <code>MyElem</code> that aren&#39;t parameterised, but which have a base ring with concrete element type <code>T</code> the promotion rules can be defined as follows:</p><pre><code class="language-julia hljs">promote_rule(::Type{MyElem}, ::Type{U}) where U &lt;: Integer = MyElem</code></pre><pre><code class="language-julia hljs">promote_rule(::Type{MyElem}, ::Type{T}) = MyElem</code></pre><p>For ring element types <code>MyElem{T}</code> that are parameterised by the type of elements of the base ring, the promotion rules can be defined as follows:</p><pre><code class="language-julia hljs">promote_rule(::Type{MyElem{T}}, ::Type{MyElem{T}}) where T &lt;: RingElement = MyElem{T}</code></pre><pre><code class="language-julia hljs">function promote_rule(::Type{MyElem{T}}, ::Type{U}) where {T &lt;: RingElement, U &lt;: RingElement}
   promote_rule(T, U) == T ? MyElem{T} : Union{}
end</code></pre><h2 id="Required-functionality-for-inexact-rings"><a class="docs-heading-anchor" href="#Required-functionality-for-inexact-rings">Required functionality for inexact rings</a><a id="Required-functionality-for-inexact-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Required-functionality-for-inexact-rings" title="Permalink"></a></h2><h3 id="Approximation-(floating-point-and-ball-arithmetic-only)"><a class="docs-heading-anchor" href="#Approximation-(floating-point-and-ball-arithmetic-only)">Approximation (floating point and ball arithmetic only)</a><a id="Approximation-(floating-point-and-ball-arithmetic-only)-1"></a><a class="docs-heading-anchor-permalink" href="#Approximation-(floating-point-and-ball-arithmetic-only)" title="Permalink"></a></h3><pre><code class="language-julia hljs">isapprox(f::MyElem, g::MyElem; atol::Real=sqrt(eps()))</code></pre><p>This is used by test code that uses rings involving floating point or ball arithmetic. The function should return <code>true</code> if all components of <span>$f$</span> and <span>$g$</span> are equal to within the square root of the Julia epsilon, since numerical noise may make an exact comparison impossible.</p><p>For parameterised rings over an inexact ring, we also require the following ad hoc approximation functionality.</p><pre><code class="language-julia hljs">isapprox(f::MyElem{T}, g::T; atol::Real=sqrt(eps())) where T &lt;: RingElem</code></pre><pre><code class="language-julia hljs">isapprox(f::T, g::MyElem{T}; atol::Real=sqrt(eps())) where T &lt;: RingElem</code></pre><p>These notionally coerce the element of the base ring into the parameterised ring and do a full comparison.</p><h2 id="Optional-functionality"><a class="docs-heading-anchor" href="#Optional-functionality">Optional functionality</a><a id="Optional-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-functionality" title="Permalink"></a></h2><p>Some functionality is difficult or impossible to implement for all rings in the system. If it is provided, additional functionality or performance may become available. Here is a list of all functions that are considered optional and can&#39;t be relied on by generic functions in the AbstractAlgebra Ring interface.</p><p>It may be that no algorithm, or no efficient algorithm is known to implement these functions. As these functions are optional, they do not need to exist. Julia will already inform the user that the function has not been implemented if it is called but doesn&#39;t exist.</p><h3 id="Optional-basic-manipulation-functionality"><a class="docs-heading-anchor" href="#Optional-basic-manipulation-functionality">Optional basic manipulation functionality</a><a id="Optional-basic-manipulation-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-basic-manipulation-functionality" title="Permalink"></a></h3><pre><code class="language-julia hljs">is_unit(f::MyElem)</code></pre><p>Return <code>true</code> if the given element is a unit in the ring it belongs to.</p><pre><code class="language-julia hljs">is_zero_divisor(f::MyElem)</code></pre><p>Return <code>true</code> if the given element is a zero divisor in the ring it belongs to. When this function does not exist for a given ring then the total ring of fractions may not be usable over that ring. All fields in the system have a fallback defined for this function.</p><pre><code class="language-julia hljs">characteristic(R::MyParent)</code></pre><p>Return the characteristic of the ring. The function should not be defined if it is not possible to unconditionally give the characteristic. AbstractAlgebra will raise an exception is such cases.</p><h3 id="Optional-binary-ad-hoc-operators"><a class="docs-heading-anchor" href="#Optional-binary-ad-hoc-operators">Optional binary ad hoc operators</a><a id="Optional-binary-ad-hoc-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-binary-ad-hoc-operators" title="Permalink"></a></h3><p>By default, ad hoc operations are handled by AbstractAlgebra.jl if they are not defined explicitly, by coercing both operands into the same ring and then performing the required operation.</p><p>In some cases, e.g. for matrices, this leads to very inefficient behaviour. In such cases, it is advised to implement some of these operators explicitly.</p><p>It can occasionally be worth adding a separate set of ad hoc binary operators for the type <code>Int</code>, if this can be done more efficiently than for arbitrary Julia Integer types.</p><pre><code class="language-julia hljs">+(f::MyElem, c::Integer)
-(f::MyElem, c::Integer)
*(f::MyElem, c::Integer)</code></pre><pre><code class="language-julia hljs">+(c::Integer, f::MyElem)
-(c::Integer, f::MyElem)
*(c::Integer, f::MyElem)</code></pre><p>For parameterised types, it is also sometimes more performant to provide explicit ad hoc operators with elements of the base ring.</p><pre><code class="language-julia hljs">+(f::MyElem{T}, c::T) where T &lt;: RingElem
-(f::MyElem{T}, c::T) where T &lt;: RingElem
*(f::MyElem{T}, c::T) where T &lt;: RingElem</code></pre><pre><code class="language-julia hljs">+(c::T, f::MyElem{T}) where T &lt;: RingElem
-(c::T, f::MyElem{T}) where T &lt;: RingElem
*(c::T, f::MyElem{T}) where T &lt;: RingElem</code></pre><h3 id="Optional-ad-hoc-comparisons"><a class="docs-heading-anchor" href="#Optional-ad-hoc-comparisons">Optional ad hoc comparisons</a><a id="Optional-ad-hoc-comparisons-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-ad-hoc-comparisons" title="Permalink"></a></h3><pre><code class="language-julia hljs">==(f::MyElem, c::Integer)</code></pre><pre><code class="language-julia hljs">==(c::Integer, f::MyElem)</code></pre><pre><code class="language-julia hljs">==(f::MyElem{T}, c:T) where T &lt;: RingElem</code></pre><pre><code class="language-julia hljs">==(c::T, f::MyElem{T}) where T &lt;: RingElem</code></pre><h3 id="Optional-ad-hoc-exact-division-functions"><a class="docs-heading-anchor" href="#Optional-ad-hoc-exact-division-functions">Optional ad hoc exact division functions</a><a id="Optional-ad-hoc-exact-division-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-ad-hoc-exact-division-functions" title="Permalink"></a></h3><pre><code class="language-julia hljs">divexact(a::MyElem{T}, b::T) where T &lt;: RingElem</code></pre><pre><code class="language-julia hljs">divexact(a::MyElem, b::Integer)</code></pre><h3 id="Optional-powering-functions"><a class="docs-heading-anchor" href="#Optional-powering-functions">Optional powering functions</a><a id="Optional-powering-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-powering-functions" title="Permalink"></a></h3><pre><code class="language-julia hljs">^(f::MyElem, e::BigInt)</code></pre><p>In case <span>$f$</span> cannot explode in size when powered by a very large integer, and it is practical to do so, one may provide this function to support powering with <code>BigInt</code> exponents (or for external modules, any other big integer type).</p><h3 id="Optional-unsafe-operators"><a class="docs-heading-anchor" href="#Optional-unsafe-operators">Optional unsafe operators</a><a id="Optional-unsafe-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-unsafe-operators" title="Permalink"></a></h3><pre><code class="language-julia hljs">addmul!(c::MyElem, a::MyElem, b::MyElem, t::MyElem)</code></pre><p>Set <span>$c = c + ab$</span> in-place. Return the mutated value. The value <span>$t$</span> should be a temporary of the same type as <span>$a$</span>, <span>$b$</span> and <span>$c$</span>, which can be used arbitrarily by the implementation to speed up the computation. Aliasing between <span>$a$</span>, <span>$b$</span> and <span>$c$</span> is permitted.</p><h2 id="Minimal-example-of-ring-implementation"><a class="docs-heading-anchor" href="#Minimal-example-of-ring-implementation">Minimal example of ring implementation</a><a id="Minimal-example-of-ring-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-example-of-ring-implementation" title="Permalink"></a></h2><p>Here is a minimal example of implementing the Ring Interface for a constant polynomial type (i.e. polynomials of degree less than one).</p><pre><code class="language-julia hljs"># ConstPoly.jl : Implements constant polynomials

using AbstractAlgebra

using Random: Random, SamplerTrivial, GLOBAL_RNG
using RandomExtensions: RandomExtensions, Make2, AbstractRNG

import AbstractAlgebra: parent_type, elem_type, base_ring, parent, is_domain_type,
       is_exact_type, canonical_unit, isequal, divexact, zero!, mul!, add!, addeq!,
       get_cached!, is_unit, characteristic, Ring, RingElem, expressify

import Base: show, +, -, *, ^, ==, inv, isone, iszero, one, zero, rand,
             deepcopy_internal, hash

mutable struct ConstPolyRing{T &lt;: RingElement} &lt;: Ring
   base_ring::Ring

   function ConstPolyRing{T}(R::Ring, cached::Bool) where T &lt;: RingElement
      return get_cached!(ConstPolyID, R, cached) do
         new{T}(R)
      end::ConstPolyRing{T}
   end
end

const ConstPolyID = AbstractAlgebra.CacheDictType{Ring, ConstPolyRing}()
   
mutable struct ConstPoly{T &lt;: RingElement} &lt;: RingElem
   c::T
   parent::ConstPolyRing{T}

   function ConstPoly{T}(c::T) where T &lt;: RingElement
      return new(c)
   end
end

# Data type and parent object methods

parent_type(::Type{ConstPoly{T}}) where T &lt;: RingElement = ConstPolyRing{T}

elem_type(::Type{ConstPolyRing{T}}) where T &lt;: RingElement = ConstPoly{T}

base_ring(R::ConstPolyRing) = R.base_ring

parent(f::ConstPoly) = f.parent

is_domain_type(::Type{ConstPoly{T}}) where T &lt;: RingElement = is_domain_type(T)

is_exact_type(::Type{ConstPoly{T}}) where T &lt;: RingElement = is_exact_type(T)

function hash(f::ConstPoly, h::UInt)
   r = 0x65125ab8e0cd44ca
   return xor(r, hash(f.c, h))
end

function deepcopy_internal(f::ConstPoly{T}, d::IdDict) where T &lt;: RingElement
   r = ConstPoly{T}(deepcopy_internal(f.c, d))
   r.parent = f.parent # parent should not be deepcopied
   return r
end

# Basic manipulation

zero(R::ConstPolyRing) = R()

one(R::ConstPolyRing) = R(1)

iszero(f::ConstPoly) = iszero(f.c)

isone(f::ConstPoly) = isone(f.c)

is_unit(f::ConstPoly) = is_unit(f.c)

characteristic(R::ConstPolyRing) = characteristic(base_ring(R))

# Canonical unit

canonical_unit(f::ConstPoly) = canonical_unit(f.c)

# String I/O

function show(io::IO, R::ConstPolyRing)
   print(io, &quot;Constant polynomials over &quot;)
   show(io, base_ring(R))
end

function show(io::IO, f::ConstPoly)
   print(io, f.c)
end

# Expressification (optional)

function expressify(R::ConstPolyRing; context = nothing)
   return Expr(:sequence, Expr(:text, &quot;Constant polynomials over &quot;),
                          expressify(base_ring(R), context = context))
end

function expressify(f::ConstPoly; context = nothing)
   return expressify(f.c, context = context)
end

# Unary operations

function -(f::ConstPoly)
   R = parent(f)
   return R(-f.c)
end

# Binary operations

function +(f::ConstPoly{T}, g::ConstPoly{T}) where T &lt;: RingElement
   parent(f) != parent(g) &amp;&amp; error(&quot;Incompatible rings&quot;)
   R = parent(f)
   return R(f.c + g.c)
end

function -(f::ConstPoly{T}, g::ConstPoly{T}) where T &lt;: RingElement
   parent(f) != parent(g) &amp;&amp; error(&quot;Incompatible rings&quot;)
   R = parent(f)
   return R(f.c - g.c)
end

function *(f::ConstPoly{T}, g::ConstPoly{T}) where T &lt;: RingElement
   parent(f) != parent(g) &amp;&amp; error(&quot;Incompatible rings&quot;)
   R = parent(f)
   return R(f.c*g.c)
end

# Comparison

function ==(f::ConstPoly{T}, g::ConstPoly{T}) where T &lt;: RingElement
   parent(f) != parent(g) &amp;&amp; error(&quot;Incompatible rings&quot;)
   return f.c == g.c
end

function isequal(f::ConstPoly{T}, g::ConstPoly{T}) where T &lt;: RingElement
   parent(f) != parent(g) &amp;&amp; error(&quot;Incompatible rings&quot;)
   return isequal(f.c, g.c)
end

# Powering need not be implemented if * is

# Exact division

function divexact(f::ConstPoly{T}, g::ConstPoly{T}; check::Bool = true) where T &lt;: RingElement
   parent(f) != parent(g) &amp;&amp; error(&quot;Incompatible rings&quot;)
   R = parent(f)
   return R(divexact(f.c, g.c, check = check))
end

# Inverse

function inv(f::ConstPoly)
   R = parent(f)
   return R(AbstractAlgebra.inv(f.c))
end

# Unsafe operators

function zero!(f::ConstPoly)
   f.c = zero(base_ring(parent(f)))
   return f
end

function mul!(f::ConstPoly{T}, g::ConstPoly{T}, h::ConstPoly{T}) where T &lt;: RingElement
   f.c = g.c*h.c
   return f
end

function add!(f::ConstPoly{T}, g::ConstPoly{T}, h::ConstPoly{T}) where T &lt;: RingElement
   f.c = g.c + h.c
   return f
end

function addeq!(f::ConstPoly{T}, g::ConstPoly{T}) where T &lt;: RingElement
   f.c += g.c
   return f
end

# Random generation

RandomExtensions.maketype(R::ConstPolyRing, _) = elem_type(R)

rand(rng::AbstractRNG, sp::SamplerTrivial{&lt;:Make2{ConstPoly,ConstPolyRing}}) =
        sp[][1](rand(rng, sp[][2]))

rand(rng::AbstractRNG, R::ConstPolyRing, n::UnitRange{Int}) = R(rand(rng, n))

rand(R::ConstPolyRing, n::UnitRange{Int}) = rand(Random.GLOBAL_RNG, R, n)

# Promotion rules

promote_rule(::Type{ConstPoly{T}}, ::Type{ConstPoly{T}}) where T &lt;: RingElement = ConstPoly{T}

function promote_rule(::Type{ConstPoly{T}}, ::Type{U}) where {T &lt;: RingElement, U &lt;: RingElement}
   promote_rule(T, U) == T ? ConstPoly{T} : Union{}
end

# Constructors

function (R::ConstPolyRing{T})() where T &lt;: RingElement
   r = ConstPoly{T}(base_ring(R)(0))
   r.parent = R
   return r
end

function (R::ConstPolyRing{T})(c::Integer) where T &lt;: RingElement
   r = ConstPoly{T}(base_ring(R)(c))
   r.parent = R
   return r
end

# Needed to prevent ambiguity
function (R::ConstPolyRing{T})(c::T) where T &lt;: Integer
   r = ConstPoly{T}(base_ring(R)(c))
   r.parent = R
   return r
end

function (R::ConstPolyRing{T})(c::T) where T &lt;: RingElement
   base_ring(R) != parent(c) &amp;&amp; error(&quot;Unable to coerce element&quot;)
   r = ConstPoly{T}(c)
   r.parent = R
   return r
end

function (R::ConstPolyRing{T})(f::ConstPoly{T}) where T &lt;: RingElement
   R != parent(f) &amp;&amp; error(&quot;Unable to coerce element&quot;)
   return f
end

# Parent constructor

function ConstantPolynomialRing(R::Ring, cached::Bool=true)
   T = elem_type(R)
   return ConstPolyRing{T}(R, cached)
end</code></pre><p>The above implementation of <code>ConstantPolynomialRing</code> may be tested as follows.</p><pre><code class="language-julia hljs">using Test
include(joinpath(pathof(AbstractAlgebra), &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;Rings-conformance-tests.jl&quot;))

S, _ = PolynomialRing(QQ, &quot;x&quot;)

function test_elem(R::ConstPolyRing{elem_type(S)})
   return R(rand(base_ring(R), 1:6, -999:999))
end

test_Ring_interface(ConstantPolynomialRing(S))</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 16 February 2023 16:40">Thursday 16 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
