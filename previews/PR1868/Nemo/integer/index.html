<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integers · Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../padic/">Padics</a></li><li><a class="tocitem" href="../qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../Experimental/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/visualization/">Visualization</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/">Subquotient Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/homological_algebra/">Homological Algebra</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">Gröbner Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/groebner_bases/">Gröbner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/groebner_bases_integers/">Gröbner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../TropicalGeometry/curve/">Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Standard Constructions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/StandardConstructions/standard_constructions/">Standard Constructions in Algebraic Geometry</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/K3Surfaces/">Algebraic Surfaces</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Finitely Presented Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-7" type="checkbox"/><label class="tocitem" for="menuitem-17-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Integers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Integers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/Nemo/integer.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Integers"><a class="docs-heading-anchor" href="#Integers">Integers</a><a id="Integers-1"></a><a class="docs-heading-anchor-permalink" href="#Integers" title="Permalink"></a></h1><p>The default integer type in Nemo is provided by Flint. The associated ring of integers is represented by the constant parent object called <code>FlintZZ</code>.</p><p>For convenience we define</p><pre><code class="nohighlight hljs">ZZ = FlintZZ</code></pre><p>so that integers can be constructed using <code>ZZ</code> instead of <code>FlintZZ</code>. Note that this is the name of a specific parent object, not the name of its type.</p><p>The types of the integer ring parent objects and elements of the associated rings of integers are given in the following table according to the library providing them.</p><table><tr><th style="text-align: right">Library</th><th style="text-align: right">Element type</th><th style="text-align: right">Parent type</th></tr><tr><td style="text-align: right">Flint</td><td style="text-align: right"><code>fmpz</code></td><td style="text-align: right"><code>FlintIntegerRing</code></td></tr></table><p>All integer element types belong directly to the abstract type <code>RingElem</code> and all the integer ring parent object types belong to the abstract type <code>Ring</code>.</p><p>A lot of code will want to accept both <code>fmpz</code> integers and Julia integers, that is, subtypes of <code>Base.Integer</code>. Thus for convenience we define</p><pre><code class="nohighlight hljs">IntegerUnion = Union{Integer,fmpz}</code></pre><h2 id="Integer-functionality"><a class="docs-heading-anchor" href="#Integer-functionality">Integer functionality</a><a id="Integer-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Integer-functionality" title="Permalink"></a></h2><p>Nemo integers provide all of the ring and Euclidean ring functionality of AbstractAlgebra.jl.</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/stable/ring">https://nemocas.github.io/AbstractAlgebra.jl/stable/ring</a></p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/stable/euclidean_interface">https://nemocas.github.io/AbstractAlgebra.jl/stable/euclidean_interface</a></p><p>Below, we describe the functionality that is specific to the Nemo/Flint integer ring.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><pre><code class="language-julia hljs">ZZ(n::Integer)</code></pre><p>Coerce a Julia integer value into the integer ring.</p><pre><code class="language-julia hljs">ZZ(n::String)</code></pre><p>Parse the given string as an integer.</p><pre><code class="language-julia hljs">ZZ(n::Float64)
ZZ(n::Float32)
ZZ(n::Float16)
ZZ(n::BigFloat)</code></pre><p>Coerce the given floating point number into the integer ring, assuming that it can be exactly represented as an integer.</p><h3 id="Basic-manipulation"><a class="docs-heading-anchor" href="#Basic-manipulation">Basic manipulation</a><a id="Basic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="sign-Tuple{fmpz}" href="#sign-Tuple{fmpz}"><code>sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sign(a::fmpz)</code></pre><p>Return the sign of <span>$a$</span>, i.e. <span>$+1$</span>, <span>$0$</span> or <span>$-1$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="size-Tuple{fmpz}" href="#size-Tuple{fmpz}"><code>size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(a::fmpz)</code></pre><p>Return the number of limbs required to store the absolute value of <span>$a$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="fits-Tuple{Type{UInt64}, fmpz}" href="#fits-Tuple{Type{UInt64}, fmpz}"><code>fits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fits(::Type{UInt}, a::fmpz)</code></pre><p>Return <code>true</code> if <span>$a$</span> fits into a <code>UInt</code>, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="fits-Tuple{Type{Int64}, fmpz}" href="#fits-Tuple{Type{Int64}, fmpz}"><code>fits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fits(::Type{Int}, a::fmpz)</code></pre><p>Return <code>true</code> if <span>$a$</span> fits into an <code>Int</code>, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="denominator-Tuple{fmpz}" href="#denominator-Tuple{fmpz}"><code>denominator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">denominator(a::fmpz)</code></pre><p>Return the denominator of <span>$a$</span> thought of as a rational. Always returns <span>$1$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="numerator-Tuple{fmpz}" href="#numerator-Tuple{fmpz}"><code>numerator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">numerator(a::fmpz)</code></pre><p>Return the numerator of <span>$a$</span> thought of as a rational. Always returns <span>$a$</span>.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">a = ZZ(12)

is_unit(a)
sign(a)
s = size(a)
fits(Int, a)
n = numerator(a)
d = denominator(a)</code></pre><h3 id="Euclidean-division"><a class="docs-heading-anchor" href="#Euclidean-division">Euclidean division</a><a id="Euclidean-division-1"></a><a class="docs-heading-anchor-permalink" href="#Euclidean-division" title="Permalink"></a></h3><p>Nemo also provides a large number of Euclidean division operations. Recall that for a dividend <span>$a$</span> and divisor <span>$b$</span>, we can write <span>$a = bq + r$</span> with <span>$0 \leq |r| &lt; |b|$</span>. We call <span>$q$</span> the quotient and <span>$r$</span> the remainder.</p><p>We distinguish three cases. If <span>$q$</span> is rounded towards zero, <span>$r$</span> will have the same sign as <span>$a$</span>. If <span>$q$</span> is rounded towards plus infinity, <span>$r$</span> will have the opposite sign to <span>$b$</span>. Finally, if <span>$q$</span> is rounded towards minus infinity, <span>$r$</span> will have the same sign as <span>$b$</span>.</p><p>In the following table we list the division functions and their rounding behaviour. We also give the return value of the function, with <span>$q$</span> representing return of the quotient and <span>$r$</span> representing return of the remainder.</p><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Return</th><th style="text-align: right">Rounding of the quotient</th></tr><tr><td style="text-align: right"><code>mod</code></td><td style="text-align: right">r</td><td style="text-align: right">towards minus infinity</td></tr><tr><td style="text-align: right"><code>rem</code></td><td style="text-align: right">r</td><td style="text-align: right">towards zero</td></tr><tr><td style="text-align: right"><code>div</code></td><td style="text-align: right">q</td><td style="text-align: right">towards minus infinity</td></tr><tr><td style="text-align: right"><code>divrem(a::fmpz, b::fmpz)</code></td><td style="text-align: right">q, r</td><td style="text-align: right">towards minus infinity</td></tr><tr><td style="text-align: right"><code>tdivrem(a::fmpz, b::fmpz)</code></td><td style="text-align: right">q, r</td><td style="text-align: right">towards zero</td></tr><tr><td style="text-align: right"><code>fdivrem(a::fmpz, b::fmpz)</code></td><td style="text-align: right">q, r</td><td style="text-align: right">towards minus infinity</td></tr><tr><td style="text-align: right"><code>cdivrem(a::fmpz, b::fmpz)</code></td><td style="text-align: right">q, r</td><td style="text-align: right">towards plus infinity</td></tr><tr><td style="text-align: right"><code>ntdivrem(a::fmpz, b::fmpz)</code></td><td style="text-align: right">q, r</td><td style="text-align: right">nearest integer, ties toward zero</td></tr><tr><td style="text-align: right"><code>nfdivrem(a::fmpz, b::fmpz)</code></td><td style="text-align: right">q, r</td><td style="text-align: right">nearest integer, ties toward minus infinity</td></tr><tr><td style="text-align: right"><code>ncdivrem(a::fmpz, b::fmpz)</code></td><td style="text-align: right">q, r</td><td style="text-align: right">nearest integer, ties toward plus infinity</td></tr></table><p>N.B: the internal definition of <code>Nemo.div</code> and <code>Nemo.divrem</code> are the same as <code>fdiv</code> and <code>fdivrem</code>. The definitions in the table are of <code>Base.div</code> and <code>Base.divrem</code> which agree with Julia&#39;s definitions of <code>div</code> and <code>divrem</code>.</p><p>Nemo also offers the following ad hoc division operators. The notation and description is as for the other Euclidean division functions.</p><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Return</th><th style="text-align: right">Rounding</th></tr><tr><td style="text-align: right"><code>mod(a::fmpz, b::Int)</code></td><td style="text-align: right">r</td><td style="text-align: right">towards minus infinity</td></tr><tr><td style="text-align: right"><code>rem(a::fmpz, b::Int)</code></td><td style="text-align: right">r</td><td style="text-align: right">towards zero</td></tr><tr><td style="text-align: right"><code>div(a::fmpz, b::Int)</code></td><td style="text-align: right">q</td><td style="text-align: right">towards zero</td></tr><tr><td style="text-align: right"><code>tdiv(a::fmpz, b::Int)</code></td><td style="text-align: right">q</td><td style="text-align: right">towards zero</td></tr><tr><td style="text-align: right"><code>fdiv(a::fmpz, b::Int)</code></td><td style="text-align: right">q</td><td style="text-align: right">towards minus infinity</td></tr><tr><td style="text-align: right"><code>cdiv(a::fmpz, b::Int)</code></td><td style="text-align: right">q</td><td style="text-align: right">towards plus infinity</td></tr></table><p>N.B: the internal definition of <code>Nemo.div</code> is the same as <code>fdiv</code>. The definition in the table is <code>Base.div</code> which agrees with Julia&#39;s definition of <code>div</code>.</p><p>The following functions are also available, for the case where one is dividing by a power of <span>$2$</span>. In other words, for Euclidean division of the form <span>$a = b2^{d} + r$</span>. These are useful for bit twiddling.</p><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Return</th><th style="text-align: right">Rounding</th></tr><tr><td style="text-align: right"><code>tdivpow2(a::fmpz, d::Int)</code></td><td style="text-align: right">q</td><td style="text-align: right">towards zero</td></tr><tr><td style="text-align: right"><code>fdivpow2(a::fmpz, d::Int)</code></td><td style="text-align: right">q</td><td style="text-align: right">towards minus infinity</td></tr><tr><td style="text-align: right"><code>fmodpow2(a::fmpz, d::Int)</code></td><td style="text-align: right">r</td><td style="text-align: right">towards minus infinity</td></tr><tr><td style="text-align: right"><code>cdivpow2(a::fmpz, d::Int)</code></td><td style="text-align: right">q</td><td style="text-align: right">towards plus infinity</td></tr></table><p><strong>Examples</strong></p><pre><code class="language-julia hljs">a = fmpz(12)
b = fmpz(5)

q, r = divrem(a, b)
c = cdiv(a, b)
d = fdiv(a, b)
f = tdivpow2(a, 2)
g = fmodpow2(a, 3)</code></pre><h3 id="Comparison"><a class="docs-heading-anchor" href="#Comparison">Comparison</a><a id="Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison" title="Permalink"></a></h3><p>Instead of <code>isless</code> we implement a function <code>cmp(a, b)</code> which returns a positive value if <span>$a &gt; b$</span>, zero if <span>$a == b$</span> and a negative value if <span>$a &lt; b$</span>. We then implement all the other operators, including <code>==</code> in terms of <code>cmp</code>.</p><p>For convenience we also implement a <code>cmpabs(a, b)</code> function which returns a positive value if <span>$|a| &gt; |b|$</span>, zero if <span>$|a| == |b|$</span> and a negative value if <span>$|a| &lt; |b|$</span>. This can be slightly faster than a call to <code>cmp</code> or one of the comparison operators when comparing nonnegative values for example.</p><p>Here is a list of the comparison functions implemented, with the understanding that <code>cmp</code> provides all of the comparison operators listed above.</p><table><tr><th style="text-align: right">Function</th></tr><tr><td style="text-align: right"><code>cmp(a::fmpz, b::fmpz)</code></td></tr><tr><td style="text-align: right"><code>cmpabs(a::fmpz, b::fmpz)</code></td></tr></table><p>We also provide the following ad hoc comparisons which again provide all of the comparison operators mentioned above.</p><table><tr><th style="text-align: right">Function</th></tr><tr><td style="text-align: right"><code>cmp(a::fmpz, b::Int)</code></td></tr><tr><td style="text-align: right"><code>cmp(a::Int, b::fmpz)</code></td></tr><tr><td style="text-align: right"><code>cmp(a::fmpz, b::UInt)</code></td></tr><tr><td style="text-align: right"><code>cmp(a::UInt, b::fmpz)</code></td></tr></table><p><strong>Examples</strong></p><pre><code class="language-julia hljs">a = ZZ(12)
b = ZZ(3)

a &lt; b
a != b
a &gt; 4
5 &lt;= b
cmpabs(a, b)</code></pre><h3 id="Shifting"><a class="docs-heading-anchor" href="#Shifting">Shifting</a><a id="Shifting-1"></a><a class="docs-heading-anchor-permalink" href="#Shifting" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="&lt;&lt;-Tuple{fmpz, Int64}" href="#&lt;&lt;-Tuple{fmpz, Int64}"><code>&lt;&lt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&lt;&lt;(x::fmpz, c::Int)</code></pre><p>Return <span>$2^cx$</span> where <span>$c \geq 0$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="&gt;&gt;-Tuple{fmpz, Int64}" href="#&gt;&gt;-Tuple{fmpz, Int64}"><code>&gt;&gt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&gt;&gt;(x::fmpz, c::Int)</code></pre><p>Return <span>$x/2^c$</span>, discarding any remainder, where <span>$c \geq 0$</span>.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia hljs">a = fmpz(12)

a &lt;&lt; 3
a &gt;&gt; 5</code></pre><h3 id="Modular-arithmetic"><a class="docs-heading-anchor" href="#Modular-arithmetic">Modular arithmetic</a><a id="Modular-arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Modular-arithmetic" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="sqrtmod-Tuple{fmpz, fmpz}" href="#sqrtmod-Tuple{fmpz, fmpz}"><code>sqrtmod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sqrtmod(x::fmpz, m::fmpz)</code></pre><p>Return a square root of <span>$x (\mod m)$</span> if one exists. The remainder will be in the range <span>$[0, m)$</span>. We require that <span>$m$</span> is prime, otherwise the algorithm may not terminate.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="crt" href="#crt"><code>crt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">crt(r1::fmpz, m1::fmpz, r2::fmpz, m2::fmpz, signed=false; check::Bool=true)
crt(r1::fmpz, m1::fmpz, r2::Union{Int, UInt}, m2::Union{Int, UInt}, signed=false; check::Bool=true)
crt(r::Vector{fmpz}, m::Vector{fmpz}, signed=false; check::Bool=true)
crt_with_lcm(r1::fmpz, m1::fmpz, r2::fmpz, m2::fmpz, signed=false; check::Bool=true)
crt_with_lcm(r1::fmpz, m1::fmpz, r2::Union{Int, UInt}, m2::Union{Int, UInt}, signed=false; check::Bool=true)
crt_with_lcm(r::Vector{fmpz}, m::Vector{fmpz}, signed=false; check::Bool=true)</code></pre><p>As per the AbstractAlgebra <code>crt</code> interface, with the following option. If <code>signed = true</code>, the solution is the range <span>$(-m/2, m/2]$</span>, otherwise it is in the range <span>$[0,m)$</span>, where <span>$m$</span> is the least common multiple of the moduli.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia hljs">c = sqrtmod(ZZ(12), ZZ(13))
d = crt(ZZ(5), ZZ(13), ZZ(7), ZZ(37), true)
d = crt(ZZ(5), ZZ(13), 7, 37, true)</code></pre><h3 id="Integer-logarithm"><a class="docs-heading-anchor" href="#Integer-logarithm">Integer logarithm</a><a id="Integer-logarithm-1"></a><a class="docs-heading-anchor-permalink" href="#Integer-logarithm" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="flog-Tuple{fmpz, fmpz}" href="#flog-Tuple{fmpz, fmpz}"><code>flog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flog(x::fmpz, c::fmpz)</code></pre><p>Return the floor of the logarithm of <span>$x$</span> to base <span>$c$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="flog-Tuple{fmpz, Int64}" href="#flog-Tuple{fmpz, Int64}"><code>flog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flog(x::fmpz, c::Int)</code></pre><p>Return the floor of the logarithm of <span>$x$</span> to base <span>$c$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="clog-Tuple{fmpz, fmpz}" href="#clog-Tuple{fmpz, fmpz}"><code>clog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clog(x::fmpz, c::fmpz)</code></pre><p>Return the ceiling of the logarithm of <span>$x$</span> to base <span>$c$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="clog-Tuple{fmpz, Int64}" href="#clog-Tuple{fmpz, Int64}"><code>clog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clog(x::fmpz, c::Int)</code></pre><p>Return the ceiling of the logarithm of <span>$x$</span> to base <span>$c$</span>.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia hljs">a = fmpz(12)
b = fmpz(2)

c = flog(a, b)
d = clog(a, 3)</code></pre><h3 id="Integer-roots"><a class="docs-heading-anchor" href="#Integer-roots">Integer roots</a><a id="Integer-roots-1"></a><a class="docs-heading-anchor-permalink" href="#Integer-roots" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="isqrt-Tuple{fmpz}" href="#isqrt-Tuple{fmpz}"><code>isqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isqrt(x::fmpz)</code></pre><p>Return the floor of the square root of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="isqrtrem-Tuple{fmpz}" href="#isqrtrem-Tuple{fmpz}"><code>isqrtrem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isqrtrem(x::fmpz)</code></pre><p>Return a tuple <span>$s, r$</span> consisting of the floor <span>$s$</span> of the square root of <span>$x$</span> and the remainder <span>$r$</span>, i.e. such that <span>$x = s^2 + r$</span>. We require <span>$x \geq 0$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="root-Tuple{fmpz, Int64}" href="#root-Tuple{fmpz, Int64}"><code>root</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">root(x::fmpz, n::Int; check::Bool=true)</code></pre><p>Return the <span>$n$</span>-the root of <span>$x$</span>. We require <span>$n &gt; 0$</span> and that <span>$x \geq 0$</span> if <span>$n$</span> is even. By default the function tests whether the input was a perfect <span>$n$</span>-th power and if not raises an exception. If <code>check=false</code> this check is omitted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="iroot-Tuple{fmpz, Int64}" href="#iroot-Tuple{fmpz, Int64}"><code>iroot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iroot(x::fmpz, n::Int)</code></pre><p>Return the integer truncation of the <span>$n$</span>-the root of <span>$x$</span> (round towards zero). We require <span>$n &gt; 0$</span> and that <span>$x \geq 0$</span> if <span>$n$</span> is even.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia hljs">a = ZZ(13)
b = ZZ(27)

c = isqrt(a)
s, r = isqrtrem(a)
d = iroot(a, 3)
k = root(b, 3; check=true)</code></pre><h3 id="Number-theoretic-functionality"><a class="docs-heading-anchor" href="#Number-theoretic-functionality">Number theoretic functionality</a><a id="Number-theoretic-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Number-theoretic-functionality" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="divisible-Tuple{fmpz, Int64}" href="#divisible-Tuple{fmpz, Int64}"><code>divisible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">divisible(x::fmpz, y::Int)</code></pre><p>Return <code>true</code> if <span>$x$</span> is divisible by <span>$y$</span>, otherwise return <code>false</code>. We require <span>$x \neq 0$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="divisible-Tuple{fmpz, fmpz}" href="#divisible-Tuple{fmpz, fmpz}"><code>divisible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">divisible(x::fmpz, y::fmpz)</code></pre><p>Return <code>true</code> if <span>$x$</span> is divisible by <span>$y$</span>, otherwise return <code>false</code>. We require <span>$x \neq 0$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_square-Tuple{fmpz}" href="#is_square-Tuple{fmpz}"><code>is_square</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_square(f::PolyElem{T}) where T &lt;: RingElement</code></pre><p>Return <code>true</code> if <span>$f$</span> is a perfect square.</p></div></section><section><div><pre><code class="language-julia hljs">is_square(a::FracElem{T}) where T &lt;: RingElem</code></pre><p>Return <code>true</code> if <span>$a$</span> is a square.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_prime-Tuple{fmpz}" href="#is_prime-Tuple{fmpz}"><code>is_prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_prime(x::fmpz)</code></pre><p>Return <code>true</code> if <span>$x$</span> is a prime number, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_probable_prime-Tuple{fmpz}" href="#is_probable_prime-Tuple{fmpz}"><code>is_probable_prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_probable_prime(x::fmpz)</code></pre><p>Return <code>true</code> if <span>$x$</span> is very probably a prime number, otherwise return <code>false</code>. No counterexamples are known to this test, but it is conjectured that infinitely many exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="factor-Tuple{fmpz}" href="#factor-Tuple{fmpz}"><code>factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factor(a::fmpz)
factor(a::UInt)
factor(a::Int)</code></pre><p>Return a factorisation of <span>$a$</span> using a <code>Fac</code> struct (see the documentation on factorisation in Nemo).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="divisor_lenstra-Tuple{fmpz, fmpz, fmpz}" href="#divisor_lenstra-Tuple{fmpz, fmpz, fmpz}"><code>divisor_lenstra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">divisor_lenstra(n::fmpz, r::fmpz, m::fmpz)</code></pre><p>If <span>$n$</span> has a factor which lies in the residue class <span>$r (\mod m)$</span> for <span>$0 &lt; r &lt; m &lt; n$</span>, this function returns such a factor. Otherwise it returns <span>$0$</span>. This is only efficient if <span>$m$</span> is at least the cube root of <span>$n$</span>. We require gcd<span>$(r, m) = 1$</span> and this condition is not checked.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="factorial-Tuple{fmpz}" href="#factorial-Tuple{fmpz}"><code>factorial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factorial(x::fmpz)</code></pre><p>Return the factorial of <span>$x$</span>, i.e. <span>$x! = 1.2.3\ldots x$</span>. We require <span>$x \geq 0$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rising_factorial-Tuple{fmpz, fmpz}" href="#rising_factorial-Tuple{fmpz, fmpz}"><code>rising_factorial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rising_factorial(x::fmpz, n::fmpz)</code></pre><p>Return the rising factorial of <span>$x$</span>, i.e. <span>$x(x + 1)(x + 2)\cdots (x + n - 1)$</span>. If <span>$n &lt; 0$</span> we throw a <code>DomainError()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rising_factorial-Tuple{fmpz, Int64}" href="#rising_factorial-Tuple{fmpz, Int64}"><code>rising_factorial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rising_factorial(x::fmpz, n::Int)</code></pre><p>Return the rising factorial of <span>$x$</span>, i.e. <span>$x(x + 1)(x + 2)\ldots (x + n - 1)$</span>. If <span>$n &lt; 0$</span> we throw a <code>DomainError()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rising_factorial-Tuple{Int64, Int64}" href="#rising_factorial-Tuple{Int64, Int64}"><code>rising_factorial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rising_factorial(x::Int, n::Int)</code></pre><p>Return the rising factorial of <span>$x$</span>, i.e. <span>$x(x + 1)(x + 2)\ldots (x + n - 1)$</span>. If <span>$n &lt; 0$</span> we throw a <code>DomainError()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="primorial-Tuple{fmpz}" href="#primorial-Tuple{fmpz}"><code>primorial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primorial(x::fmpz)</code></pre><p>Return the primorial of <span>$x$</span>, i.e. the product of all primes less than or equal to <span>$x$</span>. If <span>$x &lt; 0$</span> we throw a <code>DomainError()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="primorial-Tuple{Int64}" href="#primorial-Tuple{Int64}"><code>primorial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primorial(x::Int)</code></pre><p>Return the primorial of <span>$x$</span>, i.e. the product of all primes less than or equal to <span>$x$</span>. If <span>$x &lt; 0$</span> we throw a <code>DomainError()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="fibonacci-Tuple{Int64}" href="#fibonacci-Tuple{Int64}"><code>fibonacci</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fibonacci(x::Int)</code></pre><p>Return the <span>$x$</span>-th Fibonacci number <span>$F_x$</span>. We define <span>$F_1 = 1$</span>, <span>$F_2 = 1$</span> and <span>$F_{i + 1} = F_i + F_{i - 1}$</span> for all integers <span>$i$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="fibonacci-Tuple{fmpz}" href="#fibonacci-Tuple{fmpz}"><code>fibonacci</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fibonacci(x::fmpz)</code></pre><p>Return the <span>$x$</span>-th Fibonacci number <span>$F_x$</span>. We define <span>$F_1 = 1$</span>, <span>$F_2 = 1$</span> and <span>$F_{i + 1} = F_i + F_{i - 1}$</span> for all integers <span>$i$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="bell-Tuple{fmpz}" href="#bell-Tuple{fmpz}"><code>bell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bell(x::fmpz)</code></pre><p>Return the Bell number <span>$B_x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="bell-Tuple{Int64}" href="#bell-Tuple{Int64}"><code>bell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bell(x::Int)</code></pre><p>Return the Bell number <span>$B_x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="binomial-Tuple{fmpz, fmpz}" href="#binomial-Tuple{fmpz, fmpz}"><code>binomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">binomial(n::fmpz, k::fmpz)</code></pre><p>Return the binomial coefficient <span>$\frac{n (n-1) \cdots (n-k+1)}{k!}$</span>. If <span>$k &lt; 0$</span> we return <span>$0$</span>, and the identity <code>binomial(n, k) == binomial(n - 1, k - 1) + binomial(n - 1, k)</code> always holds for integers <code>n</code> and <code>k</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="binomial-Tuple{UInt64, UInt64, FlintIntegerRing}" href="#binomial-Tuple{UInt64, UInt64, FlintIntegerRing}"><code>binomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">binomial(n::UInt, k::UInt, ::FlintIntegerRing)</code></pre><p>Return the binomial coefficient <span>$\frac{n!}{(n - k)!k!}$</span> as an <code>fmpz</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="moebius_mu-Tuple{Int64}" href="#moebius_mu-Tuple{Int64}"><code>moebius_mu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moebius_mu(x::Int)</code></pre><p>Return the Moebius mu function of <span>$x$</span> as an <code>Int</code>. The value returned is either <span>$-1$</span>, <span>$0$</span> or <span>$1$</span>. If <span>$x \leq 0$</span> we throw a <code>DomainError()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="moebius_mu-Tuple{fmpz}" href="#moebius_mu-Tuple{fmpz}"><code>moebius_mu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moebius_mu(x::fmpz)</code></pre><p>Return the Moebius mu function of <span>$x$</span> as an <code>Int</code>. The value returned is either <span>$-1$</span>, <span>$0$</span> or <span>$1$</span>. If <span>$x \leq 0$</span> we throw a <code>DomainError()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="jacobi_symbol-Tuple{Int64, Int64}" href="#jacobi_symbol-Tuple{Int64, Int64}"><code>jacobi_symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jacobi_symbol(x::Int, y::Int)</code></pre><p>Return the value of the Jacobi symbol <span>$\left(\frac{x}{y}\right)$</span>. The modulus <span>$y$</span> must be odd and positive, otherwise a <code>DomainError</code> is thrown.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="jacobi_symbol-Tuple{fmpz, fmpz}" href="#jacobi_symbol-Tuple{fmpz, fmpz}"><code>jacobi_symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jacobi_symbol(x::fmpz, y::fmpz)</code></pre><p>Return the value of the Jacobi symbol <span>$\left(\frac{x}{y}\right)$</span>. The modulus <span>$y$</span> must be odd and positive, otherwise a <code>DomainError</code> is thrown.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="kronecker_symbol-Tuple{Int64, Int64}" href="#kronecker_symbol-Tuple{Int64, Int64}"><code>kronecker_symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kronecker_symbol(x::fmpz, y::fmpz)
kronecker_symbol(x::Int, y::Int)</code></pre><p>Return the value of the Kronecker symbol <span>$\left(\frac{x}{y}\right)$</span>. The definition is as per Henri Cohen&#39;s book, &quot;A Course in Computational Algebraic Number Theory&quot;, Definition 1.4.8.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="divisor_sigma-Tuple{Int64, Int64}" href="#divisor_sigma-Tuple{Int64, Int64}"><code>divisor_sigma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">divisor_sigma(x::Int, y::Int)</code></pre><p>Return the value of the sigma function, i.e. <span>$\sum_{0 &lt; d \;| x} d^y$</span>. If <span>$x \leq 0$</span> or <span>$y &lt; 0$</span> we throw a <code>DomainError()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="divisor_sigma-Tuple{fmpz, Int64}" href="#divisor_sigma-Tuple{fmpz, Int64}"><code>divisor_sigma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">divisor_sigma(x::fmpz, y::Int)</code></pre><p>Return the value of the sigma function, i.e. <span>$\sum_{0 &lt; d \;| x} d^y$</span>. If <span>$x \leq 0$</span> or <span>$y &lt; 0$</span> we throw a <code>DomainError()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="divisor_sigma-Tuple{fmpz, fmpz}" href="#divisor_sigma-Tuple{fmpz, fmpz}"><code>divisor_sigma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">divisor_sigma(x::fmpz, y::fmpz)</code></pre><p>Return the value of the sigma function, i.e. <span>$\sum_{0 &lt; d \;| x} d^y$</span>. If <span>$x \leq 0$</span> or <span>$y &lt; 0$</span> we throw a <code>DomainError()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="euler_phi-Tuple{Int64}" href="#euler_phi-Tuple{Int64}"><code>euler_phi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">euler_phi(x::Int)</code></pre><p>Return the value of the Euler phi function at <span>$x$</span>, i.e. the number of positive integers up to <span>$x$</span> (inclusive) that are coprime with <span>$x$</span>. An exception is raised if <span>$x \leq 0$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="euler_phi-Tuple{fmpz}" href="#euler_phi-Tuple{fmpz}"><code>euler_phi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">euler_phi(x::fmpz)</code></pre><p>Return the value of the Euler phi function at <span>$x$</span>, i.e. the number of positive integers up to <span>$x$</span> (inclusive) that are coprime with <span>$x$</span>. An exception is raised if <span>$x \leq 0$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="number_of_partitions-Tuple{Int64}" href="#number_of_partitions-Tuple{Int64}"><code>number_of_partitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_of_partitions(x::Int)</code></pre><p>Return the number of partitions of <span>$x$</span>. This function is not available on Windows 64.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="number_of_partitions-Tuple{fmpz}" href="#number_of_partitions-Tuple{fmpz}"><code>number_of_partitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_of_partitions(x::fmpz)</code></pre><p>Return the number of partitions of <span>$x$</span>. This function is not available on Windows 64.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_perfect_power-Tuple{fmpz}" href="#is_perfect_power-Tuple{fmpz}"><code>is_perfect_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_perfect_power(a::IntegerUnion)</code></pre><p>Returns whether <span>$a$</span> is a perfect power, that is, whether <span>$a = m^r$</span> for some integer <span>$m$</span> and <span>$r &gt; 1$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_prime_power-Tuple{fmpz}" href="#is_prime_power-Tuple{fmpz}"><code>is_prime_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_prime_power(q::IntegerUnion) -&gt; Bool</code></pre><p>Returns whether <span>$q$</span> is a prime power.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_prime_power_with_data-Tuple{fmpz}" href="#is_prime_power_with_data-Tuple{fmpz}"><code>is_prime_power_with_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_prime_power_with_data(q::IntegerUnion) -&gt; Bool, fmpz, Int</code></pre><p>Returns a flag indicating whether <span>$q$</span> is a prime power and integers <span>$p, e$</span> such that <span>$q = p^e$</span>. If <span>$q$</span> is a prime power, than <span>$p$</span> is a prime.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia hljs">is_prime(ZZ(13))
n = factorial(ZZ(100))
s = divisor_sigma(ZZ(128), 10)
a = euler_phi(ZZ(12480))
p = number_of_partitions(ZZ(1000))
f = factor(ZZ(12))</code></pre><h3 id="Digits-and-bases"><a class="docs-heading-anchor" href="#Digits-and-bases">Digits and bases</a><a id="Digits-and-bases-1"></a><a class="docs-heading-anchor-permalink" href="#Digits-and-bases" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="bin-Tuple{fmpz}" href="#bin-Tuple{fmpz}"><code>bin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bin(n::fmpz)</code></pre><p>Return <span>$n$</span> as a binary string.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="oct-Tuple{fmpz}" href="#oct-Tuple{fmpz}"><code>oct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oct(n::fmpz)</code></pre><p>Return <span>$n$</span> as a octal string.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="dec-Tuple{fmpz}" href="#dec-Tuple{fmpz}"><code>dec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dec(n::fmpz)</code></pre><p>Return <span>$n$</span> as a decimal string.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="hex-Tuple{fmpz}" href="#hex-Tuple{fmpz}"><code>hex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hex(n::fmpz) = base(n, 16)</code></pre><p>Return <span>$n$</span> as a hexadecimal string.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="base-Tuple{fmpz, Integer}" href="#base-Tuple{fmpz, Integer}"><code>base</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">base(n::fmpz, b::Integer)</code></pre><p>Return <span>$n$</span> as a string in base <span>$b$</span>. We require <span>$2 \leq b \leq 62$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ndigits-Tuple{fmpz, Integer}" href="#ndigits-Tuple{fmpz, Integer}"><code>ndigits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ndigits(x::fmpz, b::Integer)</code></pre><p>Return the number of digits of <span>$x$</span> in the base <span>$b$</span> (default is <span>$b = 10$</span>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="nbits-Tuple{fmpz}" href="#nbits-Tuple{fmpz}"><code>nbits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nbits(x::fmpz)</code></pre><p>Return the number of binary bits of <span>$x$</span>. We return zero if <span>$x = 0$</span>.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia hljs">a = fmpz(12)

s1 = bin(a)
s2 = base(a, 13)
n1 = nbits(a)
n2 = ndigits(a, 3)</code></pre><h3 id="Bit-twiddling"><a class="docs-heading-anchor" href="#Bit-twiddling">Bit twiddling</a><a id="Bit-twiddling-1"></a><a class="docs-heading-anchor-permalink" href="#Bit-twiddling" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="popcount-Tuple{fmpz}" href="#popcount-Tuple{fmpz}"><code>popcount</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">popcount(x::fmpz)</code></pre><p>Return the number of ones in the binary representation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="prevpow2-Tuple{fmpz}" href="#prevpow2-Tuple{fmpz}"><code>prevpow2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prevpow2(x::fmpz)</code></pre><p>Return the previous power of <span>$2$</span> up to including <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="nextpow2-Tuple{fmpz}" href="#nextpow2-Tuple{fmpz}"><code>nextpow2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nextpow2(x::fmpz)</code></pre><p>Return the next power of <span>$2$</span> that is at least <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="trailing_zeros-Tuple{fmpz}" href="#trailing_zeros-Tuple{fmpz}"><code>trailing_zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trailing_zeros(x::fmpz)</code></pre><p>Return the number of trailing zeros in the binary representation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="clrbit!-Tuple{fmpz, Int64}" href="#clrbit!-Tuple{fmpz, Int64}"><code>clrbit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clrbit!(x::fmpz, c::Int)</code></pre><p>Clear bit <span>$c$</span> of <span>$x$</span>, where the least significant bit is the <span>$0$</span>-th bit. Note that this function modifies its input in-place.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="setbit!-Tuple{fmpz, Int64}" href="#setbit!-Tuple{fmpz, Int64}"><code>setbit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setbit!(x::fmpz, c::Int)</code></pre><p>Set bit <span>$c$</span> of <span>$x$</span>, where the least significant bit is the <span>$0$</span>-th bit. Note that this function modifies its input in-place.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="combit!-Tuple{fmpz, Int64}" href="#combit!-Tuple{fmpz, Int64}"><code>combit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">combit!(x::fmpz, c::Int)</code></pre><p>Complement bit <span>$c$</span> of <span>$x$</span>, where the least significant bit is the <span>$0$</span>-th bit. Note that this function modifies its input in-place.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="tstbit-Tuple{fmpz, Int64}" href="#tstbit-Tuple{fmpz, Int64}"><code>tstbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tstbit(x::fmpz, c::Int)</code></pre><p>Return bit <span>$i$</span> of x (numbered from 0) as <code>true</code> for 1 or <code>false</code> for 0.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia hljs">a = fmpz(12)

p = popcount(a)
b = nextpow2(a)
combit!(a, 2)</code></pre><h3 id="Random-generation"><a class="docs-heading-anchor" href="#Random-generation">Random generation</a><a id="Random-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-generation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="rand_bits-Tuple{FlintIntegerRing, Int64}" href="#rand_bits-Tuple{FlintIntegerRing, Int64}"><code>rand_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_bits(::FlintIntegerRing, b::Int)</code></pre><p>Return a random signed integer whose absolute value has <span>$b$</span> bits.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rand_bits_prime-Tuple{FlintIntegerRing, Int64, Bool}" href="#rand_bits_prime-Tuple{FlintIntegerRing, Int64, Bool}"><code>rand_bits_prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_bits_prime(::FlintIntegerRing, n::Int, proved::Bool=true)</code></pre><p>Return a random prime number with the given number of bits. If only a probable prime is required, one can pass <code>proved=false</code>.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia hljs">a = rand_bits(ZZ, 23)
b = rand_bits_prime(ZZ, 7)</code></pre><h1 id="Complex-Integers"><a class="docs-heading-anchor" href="#Complex-Integers">Complex Integers</a><a id="Complex-Integers-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-Integers" title="Permalink"></a></h1><p>The Gaussian integer type in Nemo is provided by a pair of Flint integers. The associated ring of integers and the fraction field can be retrieved by <code>Nemo.GaussianIntegers()</code> and <code>Nemo.GaussianRationals()</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ZZi = Nemo.GaussianIntegers()
a = ZZ(5)*im
b = ZZi(3, 4)

is_unit(a)
factor(a)
a//b
abs2(a//b)</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 20 January 2023 13:00">Friday 20 January 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
