<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multivariate Polynomial Ring Interface · Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../Experimental/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/visualization/">Visualization</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/homological_algebra/">Homological Algebra</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">Gröbner Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/groebner_bases/">Gröbner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/groebner_bases_integers/">Gröbner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../TropicalGeometry/curve/">Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Standard Constructions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/StandardConstructions/standard_constructions/">Standard Constructions in Algebraic Geometry</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/K3Surfaces/">Algebraic Surfaces</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Finitely Presented Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-7" type="checkbox"/><label class="tocitem" for="menuitem-17-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Multivariate Polynomial Ring Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multivariate Polynomial Ring Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/AbstractAlgebra/mpoly_interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Multivariate-Polynomial-Ring-Interface"><a class="docs-heading-anchor" href="#Multivariate-Polynomial-Ring-Interface">Multivariate Polynomial Ring Interface</a><a id="Multivariate-Polynomial-Ring-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-Polynomial-Ring-Interface" title="Permalink"></a></h1><p>Multivariate polynomial rings are supported in AbstractAlgebra.jl, and in addition to the standard Ring interface, numerous additional functions are provided.</p><p>Unlike other kinds of rings, even complex operations such as GCD depend heavily on the multivariate representation. Therefore AbstractAlgebra.jl cannot provide much in the way of additional functionality to external multivariate implementations.</p><p>This means that external libraries must be able to implement their multivariate formats in whatever way they see fit. The required interface here should be implemented, even if it is not optimal. But it can be extended, either by implementing one of the optional interfaces, or by extending the required interface in some other way.</p><p>Naturally, any multivariate polynomial ring implementation provides the full Ring interface, in order to be treated as a ring for the sake of AbstractAlgebra.jl.</p><p>Considerations which make it impossible for AbstractAlgebra.jl to provide generic functionality on top of an arbitrary multivariate module include:</p><ul><li>orderings (lexical, degree, weighted, block, arbitrary)</li><li>sparse or dense representation</li><li>distributed or recursive representation</li><li>packed or unpacked exponents</li><li>exponent bounds (and whether adaptive or not)</li><li>random access or iterators</li><li>whether monomials and polynomials have the same type</li><li>whether special cache aware data structures such as Geobuckets are used</li></ul><h2 id="Types-and-parents"><a class="docs-heading-anchor" href="#Types-and-parents">Types and parents</a><a id="Types-and-parents-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-parents" title="Permalink"></a></h2><p>AbstractAlgebra.jl provides two abstract types for multivariate polynomial rings and their elements:</p><ul><li><code>MPolyRing{T}</code> is the abstract type for multivariate polynomial ring parent types</li><li><code>MPolyElem{T}</code> is the abstract type for multivariate polynomial types</li></ul><p>We have that <code>MPolyRing{T} &lt;: Ring</code> and <code>MPolyElem{T} &lt;: RingElem</code>.</p><p>Note that both abstract types are parameterised. The type <code>T</code> should usually be the type of elements of the coefficient ring of the polynomial ring. For example, in the case of <span>$\mathbb{Z}[x, y]$</span> the type <code>T</code> would be the type of an integer, e.g. <code>BigInt</code>.</p><p>Multivariate polynomial rings should be made unique on the system by caching parent objects (unless an optional <code>cache</code> parameter is set to <code>false</code>). Multivariate polynomial rings should at least be distinguished based on their base (coefficient) ring and number of variables. But if they have the same base ring, symbols (for their variables/generators) and ordering, they should certainly have the same parent object.</p><p>See <code>src/generic/GenericTypes.jl</code> for an example of how to implement such a cache (which usually makes use of a dictionary).</p><h2 id="Required-functionality-for-multivariate-polynomials"><a class="docs-heading-anchor" href="#Required-functionality-for-multivariate-polynomials">Required functionality for multivariate polynomials</a><a id="Required-functionality-for-multivariate-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Required-functionality-for-multivariate-polynomials" title="Permalink"></a></h2><p>In addition to the required functionality for the Ring interface, the Multivariate Polynomial interface has the following required functions.</p><p>We suppose that <code>R</code> is a fictitious base ring (coefficient ring) and that <code>S</code> is a multivariate polynomial ring over <code>R</code> (i.e. <span>$S = R[x, y, \ldots]$</span>) with parent object <code>S</code> of type <code>MyMPolyRing{T}</code>. We also assume the polynomials in the ring have type <code>MyMPoly{T}</code>, where <code>T</code> is the type of elements of the base (coefficient) ring.</p><p>Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.</p><p>Note that the type <code>T</code> must (transitively) belong to the abstract type <code>RingElem</code> or more generally the union type <code>RingElement</code> which includes the Julia integer, rational and floating point types.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><p>To construct a multivariate polynomial ring, there is the following constructor.</p><pre><code class="language-julia hljs">PolynomialRing(R::Ring, s::Vector{AbstractString}; ordering=:lex, cached=true)</code></pre><p>Return a tuple, <code>S, vars</code> consisting of a polynomial ring <span>$S$</span> and an array of generators (variables) which print according to the strings in the supplied vector <span>$s$</span>. The ordering can at present be <code>:lex</code>, <code>:deglex</code> or <code>:degrevlex</code>. By default, the polynomial ring is cached, and creating a polynomial ring with the same data will return the same ring object <span>$S$</span>. If this caching is not desired, it can be switched off by setting <code>cached=false</code>.</p><p>Polynomials in a given ring can be constructed using the generators and basic polynomial arithmetic. However, this is inefficient and the following build context is provided for building polynomials term-by-term. It assumes the polynomial data type is random access, and so the constructor functions must be reimplemented for all other types of polynomials.</p><pre><code class="language-julia hljs">MPolyBuildCtx(R::MPolyRing)</code></pre><p>Return a build context for creating polynomials in the given polynomial ring.</p><pre><code class="language-julia hljs">push_term!(M::MPolyBuildCtx, c::RingElem, v::Vector{Int})</code></pre><p>Add the term with coefficient <span>$c$</span> and exponent vector <span>$v$</span> to the polynomial under construction in the build context <span>$M$</span>.</p><pre><code class="language-julia hljs">finish(M::MPolyBuildCtx)</code></pre><p>Finish construction of the polynomial, sort the terms, remove duplicate and zero terms and return the created polynomial.</p><h3 id="Data-type-and-parent-object-methods"><a class="docs-heading-anchor" href="#Data-type-and-parent-object-methods">Data type and parent object methods</a><a id="Data-type-and-parent-object-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Data-type-and-parent-object-methods" title="Permalink"></a></h3><pre><code class="language-julia hljs">symbols(S::MyMPolyRing{T}) where T &lt;: RingElem</code></pre><p>Return an array of <code>Symbol</code>s representing the variables (generators) of the polynomial ring. Note that these are <code>Symbol</code>s not <code>String</code>s, though their string values will usually be used when printing polynomials.</p><pre><code class="language-julia hljs">nvars(f::MyMPolyRing{T}) where T &lt;: RingElem</code></pre><p>Return the number of variables of the polynomial ring.</p><pre><code class="language-julia hljs">gens(S::MyMPolyRing{T}) where T &lt;: RingElem</code></pre><p>Return an array of all the generators (variables) of the given polynomial ring (as polynomials).</p><p>The first entry in the array will be the variable with most significance with respect to the ordering.</p><pre><code class="language-julia hljs">gen(S::MyMPolyRing{T}, i::Int) where T &lt;: RingElem</code></pre><p>Return the <span>$i$</span>-th generator (variable) of the given polynomial ring (as a polynomial).</p><pre><code class="language-julia hljs">ordering(S::MyMPolyRing{T})</code></pre><p>Return the ordering of the given polynomial ring as a symbol. Supported values currently include <code>:lex</code>, <code>:deglex</code> and <code>:degrevlex</code>.</p><h3 id="Basic-manipulation-of-rings-and-elements"><a class="docs-heading-anchor" href="#Basic-manipulation-of-rings-and-elements">Basic manipulation of rings and elements</a><a id="Basic-manipulation-of-rings-and-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation-of-rings-and-elements" title="Permalink"></a></h3><pre><code class="language-julia hljs">length(f::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return the number of nonzero terms of the given polynomial. The length of the zero polynomial is defined to be <span>$0$</span>. The return value should be of type <code>Int</code>.</p><pre><code class="language-julia hljs">degrees(f::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return an array of the degrees of the polynomial <span>$f$</span> in each of the variables.</p><pre><code class="language-julia hljs">total_degree(f::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return the total degree of the polynomial <span>$f$</span>, i.e. the highest sum of exponents occurring in any term of <span>$f$</span>.</p><pre><code class="language-julia hljs">is_gen(x::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return <code>true</code> if <span>$x$</span> is a generator of the polynomial ring.</p><pre><code class="language-julia hljs">coefficients(p::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return an iterator for the coefficients of the polynomial <span>$p$</span>, starting with the coefficient of the most significant term with respect to the ordering. Generic code will provide this function automatically for random access polynomials that implement the <code>coeff</code> function.</p><pre><code class="language-julia hljs">monomials(p::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return an iterator for the monomials of the polynomial <span>$p$</span>, starting with the monomial of the most significant term with respect to the ordering. Monomials in AbstractAlgebra are defined to have coefficient <span>$1$</span>. See the function <code>terms</code> if you also require the coefficients, however note that only monomials can be compared. Generic code will provide this function automatically for random access polynomials that implement the <code>monomial</code> function.</p><pre><code class="language-julia hljs">terms(p::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return an iterator for the terms of the polynomial <span>$p$</span>, starting with the most significant term with respect to the ordering. Terms in AbstractAlgebra include the coefficient. Generic code will provide this function automatically for random access polynomials that implement the <code>term</code> function.</p><pre><code class="language-julia hljs">exponent_vectors(a::MyMPoly{T}) where T &lt;: RingElement</code></pre><p>Return an iterator for the exponent vectors for each of the terms of the polynomial starting with the most significant term with respect to the ordering. Each exponent vector is an array of <code>Int</code>s, one for each variable, in the order given when the polynomial ring was created. Generic code will provide this function automatically for random access polynomials that implement the <code>exponent_vector</code> function.</p><h3 id="Exact-division"><a class="docs-heading-anchor" href="#Exact-division">Exact division</a><a id="Exact-division-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-division" title="Permalink"></a></h3><p>For any ring that implements exact division, the following can be implemented.</p><pre><code class="language-julia hljs">divexact(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return the exact quotient of <span>$f$</span> by <span>$g$</span> if it exists, otherwise throw an error.</p><pre><code class="language-julia hljs">divides(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return a tuple <code>(flag, q)</code> where <code>flag</code> is <code>true</code> if <span>$g$</span> divides <span>$f$</span>, in which case <span>$q$</span> will be the exact quotient, or <code>flag</code> is false and <span>$q$</span> is set to zero.</p><pre><code class="language-julia hljs">remove(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return a tuple <span>$(v, q)$</span> such that the highest power of <span>$g$</span> that divides <span>$f$</span> is <span>$g^v$</span> and the cofactor is <span>$q$</span>.</p><pre><code class="language-julia hljs">valuation(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return <span>$v$</span> such that the highest power of <span>$g$</span> that divides <span>$f$</span> is <span>$g^v$</span>.</p><h3 id="Ad-hoc-exact-division"><a class="docs-heading-anchor" href="#Ad-hoc-exact-division">Ad hoc exact division</a><a id="Ad-hoc-exact-division-1"></a><a class="docs-heading-anchor-permalink" href="#Ad-hoc-exact-division" title="Permalink"></a></h3><p>For any ring that implements exact division, the following can be implemented.</p><pre><code class="language-julia hljs">divexact(f::MyMPoly{T}, c::Integer) where T &lt;: RingElem
divexact(f::MyMPoly{T}, c::Rational) where T &lt;: RingElem
divexact(f::MyMPoly{T}, c::T) where T &lt;: RingElem</code></pre><p>Divide the polynomial exactly by the constant <span>$c$</span>.</p><h3 id="Euclidean-division"><a class="docs-heading-anchor" href="#Euclidean-division">Euclidean division</a><a id="Euclidean-division-1"></a><a class="docs-heading-anchor-permalink" href="#Euclidean-division" title="Permalink"></a></h3><p>Although multivariate polynomial rings are not in general Euclidean, it is possible to define a quotient with remainder function that depends on the polynomial ordering in the case that the quotient ring is a field or a Euclidean domain. In the case that a polynomial <span>$g$</span> divides a polynomial <span>$f$</span>, the result no longer depends on the ordering and the remainder is zero, with the quotient agreeing with the exact quotient.</p><pre><code class="language-julia hljs">divrem(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return a tuple <span>$(q, r)$</span> such that <span>$f = qg + r$</span>, where the coefficients of terms of <span>$r$</span> whose monomials are divisible by the leading monomial of <span>$g$</span> are reduced modulo the leading coefficient of <span>$g$</span> (according to the Euclidean function on the coefficients).</p><p>Note that the result of this function depends on the ordering of the polynomial ring.</p><pre><code class="language-julia hljs">div(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>As per the <code>divrem</code> function, but returning the quotient only. Especially when the quotient happens to be exact, this function can be exceedingly fast.</p><h3 id="GCD"><a class="docs-heading-anchor" href="#GCD">GCD</a><a id="GCD-1"></a><a class="docs-heading-anchor-permalink" href="#GCD" title="Permalink"></a></h3><p>In cases where there is a meaningful Euclidean structure on the coefficient ring, it is possible to compute the GCD of multivariate polynomials.</p><pre><code class="language-julia hljs">gcd(f::MyMPoly{T}, g::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return a greatest common divisor of <span>$f$</span> and <span>$g$</span>.</p><h3 id="Square-root"><a class="docs-heading-anchor" href="#Square-root">Square root</a><a id="Square-root-1"></a><a class="docs-heading-anchor-permalink" href="#Square-root" title="Permalink"></a></h3><p>Over rings for which an exact square root is available, it is possible to take the square root of a polynomial or test whether it is a square.</p><pre><code class="language-julia hljs">sqrt(f::MyMPoly{T}, check::Bool=true) where T &lt;: RingElem</code></pre><p>Return the square root of the polynomial <span>$f$</span> and raise an exception if it is not a square. If <code>check</code> is set to <code>false</code>, the input is assumed to be a perfect square and this assumption is not fully checked. This can be significantly faster.</p><pre><code class="language-julia hljs">is_square(::MyMPoly{T}) where T &lt;: RingElem</code></pre><p>Return <code>true</code> if <span>$f$</span> is a square.</p><h2 id="Interface-for-sparse-distributed,-random-access-multivariates"><a class="docs-heading-anchor" href="#Interface-for-sparse-distributed,-random-access-multivariates">Interface for sparse distributed, random access multivariates</a><a id="Interface-for-sparse-distributed,-random-access-multivariates-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-for-sparse-distributed,-random-access-multivariates" title="Permalink"></a></h2><p>The following additional functions should be implemented by libraries that provide a sparse distributed polynomial format, stored in a representation for which terms can be accessed in constant time (e.g. where arrays are used to store coefficients and exponent vectors).</p><h3 id="Sparse-distributed,-random-access-constructors"><a class="docs-heading-anchor" href="#Sparse-distributed,-random-access-constructors">Sparse distributed, random access constructors</a><a id="Sparse-distributed,-random-access-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-distributed,-random-access-constructors" title="Permalink"></a></h3><p>In addition to the standard constructors, the following constructor, taking arrays of coefficients and exponent vectors, should be provided.</p><pre><code class="language-julia hljs">(S::MyMPolyRing{T})(A::Vector{T}, m::Vector{Vector{Int}}) where T &lt;: RingElem</code></pre><p>Create the polynomial in the given ring with nonzero coefficients specified by the elements of <span>$A$</span> and corresponding exponent vectors given by the elements of <span>$m$</span>.</p><p>There is no assumption about coefficients being nonzero or terms being in order or unique. Zero terms are removed by the function, duplicate terms are combined (added) and the terms are sorted so that they are in the correct order.</p><p>Each exponent vector uses a separate integer for each exponent field, the first of which should be the exponent for the most significant variable with respect to the ordering. All exponents must be non-negative.</p><p>A library may also optionally provide an interface that makes use of <code>BigInt</code> (or any other big integer type) for exponents instead of <code>Int</code>.</p><h3 id="Sparse-distributed,-random-access-basic-manipulation"><a class="docs-heading-anchor" href="#Sparse-distributed,-random-access-basic-manipulation">Sparse distributed, random access basic manipulation</a><a id="Sparse-distributed,-random-access-basic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-distributed,-random-access-basic-manipulation" title="Permalink"></a></h3><pre><code class="language-julia hljs">coeff(f::MyMPoly{T}, n::Int) where T &lt;: RingElem</code></pre><p>Return the coefficient of the <span>$n$</span>-th term of <span>$f$</span>. The first term should be the most significant term with respect to the ordering.</p><pre><code class="language-julia hljs">coeff(a::MyMPoly{T}, exps::Vector{Int}) where T &lt;: RingElement</code></pre><p>Return the coefficient of the term with the given exponent vector, or zero if there is no such term.</p><pre><code class="language-julia hljs">monomial(f::MyMPoly{T}, n::Int) where T &lt;: RingElem
monomial!(m::MyMPoly{T}, f::MyMPoly{T}, n::Int) where T &lt;: RingElem</code></pre><p>Return the <span>$n$</span>-th monomial of <span>$f$</span> or set <span>$m$</span> to the <span>$n$</span>-th monomial of <span>$f$</span>, respectively. The first monomial should be the most significant term with respect to the ordering. Monomials have coefficient <span>$1$</span> in AbstractAlgebra. See the function <code>term</code> if you also require the coefficient, however, note that only monomials can be compared.</p><pre><code class="language-julia hljs">term(f::MyMPoly{T}, n::Int) where T &lt;: RingElem</code></pre><p>Return the <span>$n$</span>-th term of <span>$f$</span>. The first term should be the one whose monomial is most significant with respect to the ordering.</p><pre><code class="language-julia hljs">exponent(f::MyMPoly{T}, i::Int, j::Int) where T &lt;: RingElem</code></pre><p>Return the exponent of the <span>$j$</span>-th variable in the <span>$i$</span>-th term of the polynomial <span>$f$</span>. The first term is the one with whose monomial is most significant with respect to the ordering.</p><pre><code class="language-julia hljs">exponent_vector(a::MyMPoly{T}, i::Int) where T &lt;: RingElement</code></pre><p>Return a vector of exponents, corresponding to the exponent vector of the i-th term of the polynomial. Term numbering begins at <span>$1$</span> and the exponents are given in the order of the variables for the ring, as supplied when the ring was created.</p><pre><code class="language-julia hljs">setcoeff!(a::MyMPoly, exps::Vector{Int}, c::S) where S &lt;: RingElement</code></pre><p>Set the coefficient of the term with the given exponent vector to the given value <span>$c$</span>. If no such term exists (and <span>$c \neq 0$</span>), one will be inserted. This function takes <span>$O(\log n)$</span> operations if a term with the given exponent already exists and <span>$c \neq 0$</span>, or if the term is inserted at the end of the polynomial. Otherwise it can take <span>$O(n)$</span> operations in the worst case. This function must return the modified polynomial.</p><h3 id="Unsafe-functions"><a class="docs-heading-anchor" href="#Unsafe-functions">Unsafe functions</a><a id="Unsafe-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Unsafe-functions" title="Permalink"></a></h3><p>The following functions must be provided, but are considered unsafe, as they may leave the polynomials in an inconsistent state and they mutate their inputs. As usual, such functions should only be applied on polynomials that have no references elsewhere in the system and are mainly intended to be used in carefully written library code, rather than by users.</p><p>Users should instead build polynomials using the constructors described above.</p><pre><code class="language-julia hljs">fit!(f::MyMPoly{T}, n::Int) where T &lt;: RingElem</code></pre><p>Ensure that the polynomial <span>$f$</span> internally has space for <span>$n$</span> nonzero terms. This function must mutate the function in-place if it is mutable. It does not return the mutated polynomial. Immutable types can still be supported by defining this function to do nothing.</p><pre><code class="language-julia hljs">setcoeff!(a::MyMPoly{T}, i::Int, c::T) where T &lt;: RingElement
setcoeff!(a::MyMPoly{T}, i::Int, c::U) where {T &lt;: RingElement, U &lt;: Integer}</code></pre><p>Set the <span>$i$</span>-th coefficient of the polynomial <span>$a$</span> to <span>$c$</span>. No check is performed on the index <span>$i$</span> or for <span>$c = 0$</span>. It may be necessary to call <code>combine_like_terms</code> after calls to this function, to remove zero terms. The function must return the modified polynomial.</p><pre><code class="language-julia hljs">combine_like_terms!(a::MyMPoly{T}) where T &lt;: RingElement</code></pre><p>Remove zero terms and combine any adjacent terms with the same exponent vector (by adding them). It is assumed that all the exponent vectors are already in the correct order with respect to the ordering. The function must return the resulting polynomial.</p><pre><code class="language-julia hljs">set_exponent_vector!(a::MyMPoly{T}, i::Int, exps::Vector{Int}) where T &lt;: RingElement</code></pre><p>Set the <span>$i$</span>-th exponent vector to the given exponent vector. No check is performed on the index <span>$i$</span>, which is assumed to be valid (or that the polynomial has enough space allocated). No sorting of exponents is performed by this function. To sort the terms after setting any number of exponents with this function, run the <code>sort_terms!</code> function. The function must return the modified polynomial.</p><pre><code class="language-julia hljs">sort_terms!(a::MyMPoly{T}) where {T &lt;: RingElement}</code></pre><p>Sort the terms of the given polynomial according to the polynomial ring ordering. Zero terms and duplicate exponents are ignored. To deal with those call <code>combine_like_terms</code>. The sorted polynomial must be returned by the function.</p><h2 id="Optional-functionality-for-multivariate-polynomials"><a class="docs-heading-anchor" href="#Optional-functionality-for-multivariate-polynomials">Optional functionality for multivariate polynomials</a><a id="Optional-functionality-for-multivariate-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-functionality-for-multivariate-polynomials" title="Permalink"></a></h2><p>The following functions can optionally be implemented for multivariate polynomial types.</p><h3 id="Reduction-by-an-ideal"><a class="docs-heading-anchor" href="#Reduction-by-an-ideal">Reduction by an ideal</a><a id="Reduction-by-an-ideal-1"></a><a class="docs-heading-anchor-permalink" href="#Reduction-by-an-ideal" title="Permalink"></a></h3><pre><code class="language-julia hljs">divrem(f::MyMPoly{T}, G::Vector{MyMPoly{T}}) where T &lt;: RingElem</code></pre><p>As per the <code>divrem</code> function above, except that each term of <span>$r$</span> starting with the most significant term, is reduced modulo the leading terms of each of the polynomials in the array <span>$G$</span> for which the leading monomial is a divisor.</p><p>A tuple <span>$(Q, r)$</span> is returned from the function, where <span>$Q$</span> is an array of polynomials of the same length as <span>$G$</span>, and such that <span>$f = r + \sum Q[i]G[i]$</span>.</p><p>The result is again dependent on the ordering in general, but if the polynomials in <span>$G$</span> are over a field and the reduced generators of a Groebner basis, then the result is unique.</p><h3 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h3><pre><code class="language-julia hljs">evaluate(a::MyMPoly{T}, A::Vector{T}) where T &lt;: RingElem</code></pre><p>Evaluate the polynomial at the given values in the coefficient ring of the polynomial. The result should be an element of the coefficient ring.</p><pre><code class="language-julia hljs">evaluate(f::MyMPoly{T}, A::Vector{U}) where {T &lt;: RingElem, U &lt;: Integer}</code></pre><p>Evaluate the polynomial <span>$f$</span> at the values specified by the entries of the array <span>$A$</span>.</p><pre><code class="language-julia hljs">(a::MyMPoly{T})(vals::Union{NCRingElem, RingElement}...) where T &lt;: RingElement</code></pre><p>Evaluate the polynomial at the given arguments. This provides functional notation for polynomial evaluation, i.e. <span>$f(a, b, c)$</span>. It must be defined for each supported polynomial type (Julia does not allow functional notation to be defined for an abstract type).</p><p>The code for this function in MPoly.jl can be used when implementing this as it provides the most general possible evaluation, which is much more general than the case of evaluation at elements of the same ring.</p><p>The evaluation should succeed for any set of values for which a multiplication is defined with the product of a coefficient and all the values before it.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The values at which a polynomial is evaluated may be in non-commutative rings. Products are performed in the order of the variables in the polynomial ring that the polynomial belongs to, preceded by a multiplication by the coefficient on the left.</p></div></div><h3 id="Derivations"><a class="docs-heading-anchor" href="#Derivations">Derivations</a><a id="Derivations-1"></a><a class="docs-heading-anchor-permalink" href="#Derivations" title="Permalink"></a></h3><p>The following function allows to compute derivations of multivariate polynomials of type MPoly.</p><pre><code class="language-julia hljs">derivative(f::MyMPoly{T}, j::Int) where T &lt;: RingElem</code></pre><p>Compute the derivative of <span>$f$</span> with respect to the <span>$j$</span>-th variable of the polynomial ring.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 9 February 2023 11:47">Thursday 9 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
