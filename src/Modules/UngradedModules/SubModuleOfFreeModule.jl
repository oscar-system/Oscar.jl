###############################################################################
# SubModuleOfFreeModule
###############################################################################
@doc raw"""
    SubModuleOfFreeModule(F::FreeMod{R}, gens::Vector{<:FreeModElem}) where {R}

Construct the submodule of `F` generated by the elements of `gens` (the elements of 
`gens` must live in `F`, if not, an exception is thrown).
"""
function SubModuleOfFreeModule(F::FreeMod{R}, gens::Vector{<:FreeModElem}) where {R}
  @assert all(x -> parent(x) === F, gens)
  return SubModuleOfFreeModule(F, ModuleGens(gens, F))
end

@doc raw"""
    SubModuleOfFreeModule(F::FreeMod{R}, gens::Vector{<:FreeModElem}, default_ordering::ModuleOrdering) where {R}

Construct the submodule of `F` generated by the elements of `gens` (the elements of 
`gens` must live in `F`, if not, an exception is thrown). 
Moreover, set the default ordering to `default_ordering`.
"""
function SubModuleOfFreeModule(F::FreeMod{R}, gens::Vector{<:FreeModElem}, default_ordering::ModuleOrdering) where {R}
  @assert all(x -> parent(x) === F, gens)
  return SubModuleOfFreeModule(F, ModuleGens(gens, F, default_ordering))
end

function SubModuleOfFreeModule(F::FreeMod{R}, singular_module::Singular.smodule) where {R} 
  return SubModuleOfFreeModule(F, ModuleGens(F, singular_module))
end

@doc raw"""
    SubModuleOfFreeModule(F::FreeMod{R}, gens::ModuleGens{R}) where {R}

Construct the submodule of `F` generated by `gens`.
"""
function SubModuleOfFreeModule(F::FreeMod{R}, gens::ModuleGens{R}) where {R} 
  subModule = SubModuleOfFreeModule{R}(F)
  subModule.gens = gens
  return subModule
end

@doc raw"""
    SubModuleOfFreeModule(F::FreeMod{L}, A::MatElem{L}) where {L}

Construct the submodule generated by the rows of `A`. The embedding free
module is `F`. In particular, `rank(F) == ncols(A)` must hold.
"""
function SubModuleOfFreeModule(F::FreeMod{L}, A::MatElem{L}) where {L} 
  subModule = SubModuleOfFreeModule{L}(F)
  O = [FreeModElem(sparse_row(A[i:i,:]), F) for i in 1:nrows(A)]
  subModule.gens = ModuleGens(O, F)
  subModule.matrix = A
  return subModule
end

@doc raw"""
    SubModuleOfFreeModule(F::FreeMod{L}, A::MatElem{L}, default_ordering::ModuleOrdering) where {L}

Construct the submodule generated by the rows of `A`. The embedding free
module is `F`. In particular, `rank(F) == ncols(A)` must hold.
Moreover, set the default ordering to `default_ordering`.
"""
function SubModuleOfFreeModule(F::FreeMod{L}, A::MatElem{L}, default_ordering::ModuleOrdering) where {L} 
  subModule = SubModuleOfFreeModule{L}(F)
  O = [FreeModElem(sparse_row(A[i,:]), F) for i in 1:nrows(A)]
  subModule.gens = ModuleGens(O, F, default_ordering)
  subModule.matrix = A
  return subModule
end

@doc raw"""
    SubModuleOfFreeModule(A::MatElem{L}) where {L} 

Construct the submodule generated by the rows of `A`.

!!! note

    The ambient free module of the submodule is constructed by the function and therefore
    not compatible with free modules that are defined by the user or by other functions. 
    For compatibility, use `SubModuleOfFreeModule(F::FreeMod{L}, A::MatElem{L}) where {L}`.
"""
function SubModuleOfFreeModule(A::MatElem{L}) where {L} 
  R = base_ring(A)
  F = FreeMod(R, ncols(A))
  return SubModuleOfFreeModule(F, A)
end


@doc raw"""
    SubModuleOfFreeModule(A::MatElem{L}, default_ordering::ModuleOrdering) where {L} 

Construct the submodule generated by the rows of `A`.

!!! note

    The ambient free module of the submodule is constructed by the function and therefore
    not compatible with free modules that are defined by the user or by other functions. 
    For compatibility, use `SubModuleOfFreeModule(F::FreeMod{L}, A::MatElem{L}) where {L}`.
"""
function SubModuleOfFreeModule(A::MatElem{L}, default_ordering::ModuleOrdering) where {L} 
  R = base_ring(A)
  F = FreeMod(R, ncols(A))
  return SubModuleOfFreeModule(F, A, default_ordering)
end

function getindex(M::SubModuleOfFreeModule, i::Int)
  return oscar_generators(M.gens)[i]
end

@doc raw"""
    iszero(M::SubModuleOfFreeModule)

Check if `M` is zero.
"""
function iszero(M::SubModuleOfFreeModule)
  return iszero(M.gens)
end

@doc raw"""
    base_ring(M::SubModuleOfFreeModule)

Return the base ring of `M`.
"""
function base_ring(M::SubModuleOfFreeModule)
  return base_ring(M.F)
end

base_ring_type(::Type{SubModuleOfFreeModule{T}}) where {T} = base_ring_type(FreeMod{T})


@doc raw"""
    ambient_free_module(M::SubModuleOfFreeModule)

Return the ambient free module of `M`.
"""
function ambient_free_module(M::SubModuleOfFreeModule)
  return M.F
end

@doc raw"""
    default_ordering(M::SubModuleOfFreeModule)

Get the default ordering of `M`.
"""
function default_ordering(M::SubModuleOfFreeModule)
  return default_ordering(ambient_free_module(M))
  if !isdefined(M, :default_ordering)
    ord = default_ordering(ambient_free_module(M))
    set_default_ordering!(M, ord)
    return M.default_ordering
  end
  return M.default_ordering
end

@doc raw"""
    set_default_ordering!(M::SubModuleOfFreeModule, ord::ModuleOrdering)

Set the default ordering in `M` to `ord`.
"""
function set_default_ordering!(M::SubModuleOfFreeModule, ord::ModuleOrdering)
  M.default_ordering = ord
end

@doc raw"""
    standard_basis(submod::SubModuleOfFreeModule; ordering::ModuleOrdering = default_ordering(submod))

Compute a standard basis of `submod` with respect to the given `ordering`.
The return type is `ModuleGens`.
"""
function standard_basis(submod::SubModuleOfFreeModule; ordering::Union{ModuleOrdering, Nothing} = default_ordering(submod))
  # This is to circumvent hashing of the ordering in the obviously avoidable cases
  if ordering===default_ordering(submod)
    for (ord, gb) in submod.groebner_basis
      ord === ordering && return gb
    end
  end
    
  @req is_exact_type(elem_type(base_ring(submod))) "This functionality is only supported over exact fields."
  gb = get!(submod.groebner_basis, ordering) do
    return compute_standard_basis(submod, ordering)
  end::ModuleGens
  return gb
end

@doc raw"""
    groebner_basis(submod::SubModuleOfFreeModule; ordering::ModuleOrdering = default_ordering(submod))

Compute a Gröbner of `submod` with respect to the given `ordering`.
The ordering must be global. The return type is `ModuleGens`.
"""
function groebner_basis(submod::SubModuleOfFreeModule, ordering::ModuleOrdering = default_ordering(submod))
  @assert is_global(ordering)
  return standard_basis(submod, ordering=ordering)
end

@doc raw"""
    reduced_groebner_basis(submod::SubModuleOfFreeModule, ordering::ModuleOrdering = default_ordering(submod))

Compute a reduced Gröbner basis with respect to the given `ordering`. The return type is `ModuleGens`.
"""
function reduced_groebner_basis(submod::SubModuleOfFreeModule, ordering::ModuleOrdering = default_ordering(submod))
  @assert is_global(ordering)

  gb = get!(submod.groebner_basis, ordering) do
    return compute_standard_basis(submod, ordering, true)
  end::ModuleGens
  gb.is_reduced && return gb
  return get_attribute!(gb, :reduced_groebner_basis) do
    return compute_standard_basis(submod, ordering, true)
  end::ModuleGens
end

function leading_module(submod::SubModuleOfFreeModule, ordering::ModuleOrdering = default_ordering(submod))
  gb = standard_basis(submod, ordering=ordering)
  return SubModuleOfFreeModule(submod.F, leading_monomials(gb))
end

@doc raw"""
    compute_standard_basis(submod::SubModuleOfFreeModule, ordering::ModuleOrdering = default_ordering(submod), reduced::Bool=false)

Compute a standard basis of `submod` with respect to the given ordering.
Allowed orderings are those that are allowed as orderings for Singular polynomial rings.
In case `reduced` is `true` and the ordering is global, a reduced Gröbner basis is computed.
"""
function compute_standard_basis(submod::SubModuleOfFreeModule, ordering::ModuleOrdering = default_ordering(submod), reduced::Bool=false)
  if reduced
    @assert is_global(ordering)
  end
  mg = ModuleGens(oscar_generators(submod.gens), submod.F , ordering)
  gb = standard_basis(mg, reduced)
  gb.isGB = true
  gb.S.isGB = true
  gb.ordering = ordering
  gb.is_reduced = reduced
  return gb
end

function show_gb(io::IO, GB::ModuleGens)
  if isdefined(GB, :quo_GB)
    show_relative_groebner_basis(io, GB, GB.quo_GB, GB.is_reduced)
  else
    show_non_relative_groebner_basis(io, GB, GB.is_reduced)
  end
end

function show_groebner_basis_helper(io::IO, sub::ModuleGens, init::String)
  print(io, init)
  for g in oscar_generators(sub)
    print(io, "\n")
    print(io, OscarPair(g, sub.ordering))
  end
end

function show_non_relative_groebner_basis(io::IO, sub::ModuleGens, reduced::Bool = false)
  init = "Gröbner basis with elements"
  if reduced
    init = "Reduced " * init
  end
  show_groebner_basis_helper(io, sub, init)
  print(io, "\n with respect to the ordering\n")
  print(io, sub.ordering)
end

function show_relative_groebner_basis(io::IO, sub::ModuleGens, quo::ModuleGens, reduced::Bool = false)
  init = "Gröbner basis with elements"
  if reduced
    init = "Reduced relative " * init
  else
    init = "Relative " * init
  end
  show_groebner_basis_helper(io, sub, init)
  print(io, "\n")
  show_groebner_basis_helper(io, quo, "\nwith quotient Gröbner basis defined by the elements")
  print(io, "\n with respect to the ordering\n")
  print(io, sub.ordering)
end

@doc raw"""
    generator_matrix(submod::SubModuleOfFreeModule)

Return the generators of `submod` in matrix-form, that is the rows of the 
matrix generate `submod`.
"""
function generator_matrix(submod::SubModuleOfFreeModule)
  if !isdefined(submod, :matrix)
    R = base_ring(submod)
    matrix = zero_matrix(R, length(submod.gens), rank(submod.F))
    for i = 1:nrows(matrix), j = 1:ncols(matrix)
      matrix[i,j] = submod.gens[i][j] 
    end
    submod.matrix = matrix
  end
  return submod.matrix
end

@doc raw"""
    is_generated_by_standard_unit_vectors(M::SubModuleOfFreeModule)

Check if `M` is generated by the standard unit vectors.
"""
function is_generated_by_standard_unit_vectors(M::SubModuleOfFreeModule)
  return issubset(gens(M.F), gens(M))
end

function show(io::IO, M::SubModuleOfFreeModule)
  @show_name(io, M)
  @show_special(io, M)
#  if !is_terse(io)
    if is_graded(M)
      io_compact = IOContext(io, :compact => true)
      print(terse(io_compact), "Graded submodule of ", M.F)
    else
      #Todo: Use again once the printing of rings is fixed
      #print(io_compact, "Submodule of ", M.F)
      print(io, "Submodule")
    end
    if ngens(M) == 1
      print(io, " with ", ngens(M), " generator")
    else
      print(io, " with ", ngens(M), " generators")
    end
#  end
  io = pretty(io)
  print(io, Indent())
  for i=1:ngens(M)
    if isassigned(M.gens.O, i)
        print(io, "\n", i, ": ", M[i])
    end
  end
  print(io, Dedent())
end

function length(M::SubModuleOfFreeModule)
  error("use ngens() instead of length()")
  return length(M.gens)
end

@doc raw"""
    number_of_generators(M::SubModuleOfFreeModule)

Return the number of generators of `M`.
"""
function number_of_generators(M::SubModuleOfFreeModule)
  return number_of_generators(M.gens)
end

@doc raw"""
    gens(M::SubModuleOfFreeModule)

Return the generators of `M` as an array of `FreeModElem`s.
"""
function gens(M::SubModuleOfFreeModule)
  return oscar_generators(M.gens)
end

@doc raw"""
    gen(M::SubModuleOfFreeModule, i::Int)

Return the `i`th generator of `M`.
"""
function gen(M::SubModuleOfFreeModule, i::Int)
  return oscar_generators(M.gens)[i]
end

@doc raw"""
    sum(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule)

Compute $M+N$.
"""
function sum(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule)
  @assert M.F === N.F
  return SubModuleOfFreeModule(M.F, vcat(collect(M.gens), collect(N.gens)))
end

@doc raw"""
    issubset(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule)

Check if `M` is a subset of `N`. For this their embedding free modules must be 
identical (`===`).
"""
function issubset(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule)
  if M.F !== N.F
    return false
  end
  M_mod_N = reduce(M, N)
  return iszero(M_mod_N)
end

@doc raw"""
    ==(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule)

Check for equality. For two submodules of free modules to be equal their embedding 
free modules must be identical (`===`) and the generators must generate equal submodules.
"""
function (==)(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule)
  if M === N
    return true
  end
  if M.F !== N.F
    return false
  end
  #TODO should there be a check for === up to permutation in order to avoid std-computation?
  # If yes, this could also be incorporated in the `in`-function.
  all(in(N), gens(M)) || return false
  all(in(M), gens(N)) || return false 
  return true
end

function Base.hash(M::SubModuleOfFreeModule, h::UInt)
  # this hash function is very stupid, but it at least hashes the ambient free module,
  # that must be equal for equal SubModuleOfFreeModules
  return hash(M.F, h)
end

@doc raw"""
    is_canonically_isomorphic(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule)

Check if `M` are canonically isomorphic. This means that if `F = ambient_free_module(M)` is 
isomorphic to `G = ambient_free_module(N)` and the image of `M` under `canonical_isomorphism(F, G)`
is equal to `N`.
"""
function is_canonically_isomorphic(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule)
  F = ambient_free_module(M)
  G = ambient_free_module(N)
  if !is_isomorphic(F, G)
    return false
  end
  f = canonical_isomorphism(F,G)
  return SubModuleOfFreeModule(G, [f(v) for v in gens(M)]) == N
end

Base.:+(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule) = sum(M, N)

function lift_std(M::SubModuleOfFreeModule)
  if haskey(M.groebner_basis, default_ordering(M))
    gb = M.groebner_basis[default_ordering(M)]
    transform = get_attribute(gb, :transformation_matrix)
    if transform !== nothing
      return gb, transform
    end
  end
  for gb in values(M.groebner_basis)
    transform = get_attribute(gb, :transformation_matrix)
    if transform !== nothing
      return gb, transform
    end
  end
  gb, transform = lift_std(M.gens, default_ordering(M))
  M.groebner_basis[default_ordering(M)] = gb
  return gb, transform
end

@doc raw"""
    coordinates(a::FreeModElem, SQ::SubquoModule, task::Symbol = :auto)

Compute a sparse row `r` such that `a` is a representative of `SubquoModuleElem(r, SQ)`.
If no such `r` exists, an exception is thrown.
For `task` there are the following options:
- `:auto` (default option): Use `:via_transform` if coefficient ring of base ring is a field, 
else use `:via_lift` 
- `:via_transform`: Compute first a Gröbner basis with a transformation matrix representing
the Gröbner basis in terms of the generators and cache the data
- `:via_lift`: Compute the lift and do not cache the auxiliary data
Note: `:via_lift` is typically faster than `:via_transform` for a single vector while the latter
is faster if many vectors are lifted
"""
function coordinates(a::FreeModElem, SQ::SubquoModule, task::Symbol = :auto)
  coords = coordinates(a, SQ.sum, task)
  return coords[1:ngens(SQ)]
end

@doc raw"""
    in(a::FreeModElem, M::SubModuleOfFreeModule)

Check if `a` is an element of `M`.
"""
function in(a::FreeModElem, M::SubModuleOfFreeModule)
  iszero(a) && return true
  any(==(a), gens(M)) && return true
  return in_atomic(a, M)
end

function in_atomic(a::FreeModElem{T}, M::SubModuleOfFreeModule) where {S<:Union{ZZRingElem,FieldElem}, T<:MPolyRingElem{S}}
  F = ambient_free_module(M)
  return iszero(reduce(a, standard_basis(M, ordering=default_ordering(F))))
end

@attr Any function solve_ctx(M::SubModuleOfFreeModule)
  F = ambient_free_module(M)
  d, n = rank(F), ngens(M)
  R = base_ring(F)
  mat = zero_matrix(R, n, d)
  for (j, g) in enumerate(gens(M)), (i, val) in coordinates(g)
    mat[j, i] = val
  end
  return solve_init(mat)
end

function in_atomic(a::FreeModElem{T}, M::SubModuleOfFreeModule) where {T<:Union{ZZRingElem, FieldElem}}
  ctx = solve_ctx(M)
  vec_a = dense_row(coordinates(a), rank(ambient_free_module(M)))
  return can_solve(ctx, vec_a; side=:left)
end

function in_atomic(a::FreeModElem, M::SubModuleOfFreeModule)
  error("Membership test 'in' is not implemented for modules over rings of type $(typeof(base_ring(ambient_free_module(M))))")
end


function normal_form(M::SubModuleOfFreeModule{T}, N::SubModuleOfFreeModule{T}) where {T <: MPolyRingElem}
  @assert is_global(default_ordering(N))
  # TODO reduced flag to be implemented in Singular.jl
  #return SubModuleOfFreeModule(M.F, normal_form(M.gens, standard_basis(N), reduced = true))
  error("Not yet implemented")
end

function normal_form(v::AbstractFreeModElem{T}, N::SubModuleOfFreeModule{T}) where {T <: MPolyRingElem}
  @assert is_global(default_ordering(N))
  # TODO reduced flag to be implemented in Singular.jl
  #return normal_form(v, N.gens, reduced = true)
  error("Not yet implemented")
end

@doc raw"""
    reduce(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule)

Reduce `M` with respect to `N`, that is with respect to a Gröbner basis of `N` (the Gröbner basis is computed for this).
"""
function reduce(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule)
  return SubModuleOfFreeModule(M.F, reduce(M.gens, groebner_basis(N, default_ordering(M))))
end

@doc raw"""
    reduce(v::FreeModElem, GB::ModuleGens)

Reduce the element `v` with respect to the Gröbner basis `GB`.
"""
function reduce(v::AbstractFreeModElem, GB::ModuleGens)
  @assert GB.isGB
  @assert is_global(GB.ordering)
  return normal_form(v, GB)
end

@doc raw"""
    reduce(v::FreeModElem, N::SubModuleOfFreeModule)

Reduce the element `v` with respect to a Gröbner basis of `N`.
"""
function reduce(v::AbstractFreeModElem, N::SubModuleOfFreeModule)
  return reduce(v, groebner_basis(N))
end

zero(M::SubModuleOfFreeModule) = zero(ambient_free_module(M))
