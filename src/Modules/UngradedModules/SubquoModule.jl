###############################################################################
# SubquoModule constructors
###############################################################################

@doc raw"""
    SubquoModule(sub::SubModuleOfFreeModule{R}) where {R}

Construct the module `sub` as a subquotient.
"""
function SubquoModule(sub::SubModuleOfFreeModule{R}) where {R}
  subquo = SubquoModule{R}(ambient_free_module(sub))
  subquo.sub = sub
  subquo.sum = sub
  return subquo
end

@doc raw"""
    SubquoModule(sub::SubModuleOfFreeModule{R}, quo::SubModuleOfFreeModule{R}) where {R}

Construct the subquotient module $\texttt{sub} + texttt{quo} / \texttt{quo}$. 
`sub` and `quo` must be submodules of the same free module.
"""
function SubquoModule(sub::SubModuleOfFreeModule{R}, quo::SubModuleOfFreeModule{R}) where {R}
  F = ambient_free_module(sub)
  @assert F === ambient_free_module(quo)
  subquo = SubquoModule{R}(F)
  subquo.sub = sub
  subquo.quo = quo
  subquo.sum = sum(subquo.sub, subquo.quo)
  return subquo
end

@doc raw"""
    SubquoModule(F::FreeMod{R}, O::Vector{<:FreeModElem}) where {R}

Construct the module generated by the elements of `O` as a subquotient.
The elements of `O` must live in `F`.

# Examples
```jldoctest
julia> R, (x,y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> F = FreeMod(R,2)
Free module of rank 2 over Multivariate polynomial ring in 2 variables over QQ

julia> O = [x*F[1]+F[2],y*F[2]]
2-element Vector{FreeModElem{QQMPolyRingElem}}:
 x*e[1] + e[2]
 y*e[2]

julia> M = SubquoModule(F, O)
Submodule with 2 generators
1 -> x*e[1] + e[2]
2 -> y*e[2]
represented as subquotient with no relations.

```
"""
function SubquoModule(F::FreeMod{R}, O::Vector{<:FreeModElem}) where {R} 
  sub = SubModuleOfFreeModule(F, O)
  return SubquoModule(sub)
end

@doc raw"""
    SubquoModule(S::SubquoModule{L}, O::Vector{<:FreeModElem}) where {L}

Construct a subquotient where the generators are those of `S` and the relations are 
the union of `O` and the relations of `S`.
"""
function SubquoModule(S::SubquoModule{L}, O::Vector{<:FreeModElem}) where {L}
  F = ambient_free_module(S)
  subquo = SubquoModule{L}(F)
  subquo.sub = S.sub
  O_as_submodule = SubModuleOfFreeModule(F, O)
  subquo.quo = isdefined(S,:quo) ? sum(S.quo,O_as_submodule) : O_as_submodule
  subquo.sum = sum(subquo.sub, subquo.quo)
  return subquo
end

function SubquoModule(F::FreeMod{R}, s::Singular.smodule) where {R}
  subquo = SubquoModule{R}(F)
  subquo.sub = SubModuleOfFreeModule(F, s)
  subquo.sum = subquo.sub
  return subquo
end

function SubquoModule(F::FreeMod{R}, s::Singular.smodule, t::Singular.smodule) where {R}
  subquo = SubquoModule{R}(F)
  subquo.sub = SubModuleOfFreeModule(F, s)
  subquo.quo = SubModuleOfFreeModule(F, t)
  subquo.sum = sum(subquo.sub, subquo.quo)
  return subquo
end

@doc raw"""
    SubquoModule(F::FreeMod{R}, A::MatElem{R}, B::MatElem{R}) where {R}

Given matrices `A` and `B` with entries in a ring `R` representing maps 
of free $R$-modules with the same codomain `F`, return the subquotient 
$(\text{im } A + \text{im }  B)/\text{im }  B$.
"""
function SubquoModule(F::FreeMod{R}, A::MatElem{R}, B::MatElem{R}) where {R}
  @assert ncols(A) == ncols(B) == rank(F)
  return SubquoModule(SubModuleOfFreeModule(F, A), SubModuleOfFreeModule(F, B))
end

@doc raw"""
    SubquoModule(A::MatElem{R}, B::MatElem{R}) where {R}

Given matrices `A` and `B` with entries in a ring `R` 
representing maps of free $R$-modules with the same codomain,
return the subquotient $(\text{im } A + \text{im }  B)/\text{im }  B.$ 

!!! note

    The ambient free module of the subquotient is constructed by the function and therefore
    not compatible with free modules defined by the user or by other functions. 
    For compatibility, use `SubquoModule(F::FreeMod{R}, A::MatElem{R}, B::MatElem{R})`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> A = R[x; y]
[x]
[y]

julia> B = R[x^2; x*y; y^2; z^4]
[x^2]
[x*y]
[y^2]
[z^4]

julia> M = SubquoModule(A, B)
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 4 generators
1 -> x^2*e[1]
2 -> x*y*e[1]
3 -> y^2*e[1]
4 -> z^4*e[1]
```
"""
function SubquoModule(A::MatElem{R}, B::MatElem{R}) where {R}
  @assert ncols(A) == ncols(B)
  S = base_ring(A)
  F = FreeMod(S, ncols(A))
  return SubquoModule(SubModuleOfFreeModule(F, A), SubModuleOfFreeModule(F, B))
end

@doc raw"""
    SubquoModule(F::FreeMod{T}, g::Vector{FreeModElem{T}}, q::Vector{FreeModElem{T}}) where {T<:RingElem} 

Construct the subquotient with ambient free module `F`, generators `g`
and relations `q`.
"""
function SubquoModule(F::FreeMod{T}, g::Vector{FreeModElem{T}}, q::Vector{FreeModElem{T}}) where {T<:RingElem} 
  return SubquoModule(SubModuleOfFreeModule(F, g), SubModuleOfFreeModule(F, q))
end

#######################################################
@doc raw"""
    subquotient(a::FreeModuleHom, b::FreeModuleHom)

Given homomorphisms `a` and `b` between free modules such that 
`codomain(a) === codomain(b)`, 
return $(\text{im } a + \text{im } b)/\text{im } b$.

    subquotient(F::FreeMod{T}, A::MatElem{T}, B::MatElem{T}) where T

Given matrices `A` and `B` with rank `F` columns, return  
$(\text{im } a + \text{im } b)/\text{im } b$,
where `a` and `b` are free module homomorphisms with codomain `F` represented by `A` and `B`.

    subquotient(A::MatElem{T}, B::MatElem{T}) where T

Given matrices `A` and `B` with the same number of columns, create a free module `F` whose rank 
is that number, and return $(\text{im } a + \text{im } b)/\text{im } b$, where `a` and `b` are 
free module homomorphisms with codomain `F` represented by `A` and `B`.

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> FR = free_module(R, 1)
Free module of rank 1 over Multivariate polynomial ring in 3 variables over QQ

julia> AR = R[x; y]
[x]
[y]

julia> BR = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> MR = SubquoModule(FR, AR, BR)
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> P = ideal(R, [x, y, z]);

julia> U = complement_of_prime_ideal(P);

julia> RL, _ = localization(R, U);

julia> FRL = free_module(RL, 1)
Free module of rank 1 over Localization of multivariate polynomial ring in 3 variables over QQ at complement of prime ideal (x, y, z)

julia> ARL = RL[x; y]
[x]
[y]

julia> BRL = RL[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> MRL = SubquoModule(FRL, ARL, BRL)
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> RQ, _ = quo(R, ideal(R, [2*x^2-y^3, 2*x^2-y^5]));

julia> FRQ = free_module(RQ, 1)
Free module of rank 1 over RQ

julia> ARQ = RQ[x; y]
[x]
[y]

julia> BRQ = RQ[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> MRQ = SubquoModule(FRQ, ARQ, BRQ)
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> 2*x^2*e[1]
3 -> z^4*e[1]

julia> RQL, _ = localization(RQ, U);

julia> FRQL = free_module(RQL, 1)
Free module of rank 1 over Localization of RQ at complement of prime ideal

julia> ARQL = RQL[x; y]
[x]
[y]

julia> BRQL = RQL[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> MRQL = SubquoModule(FRQL, ARQL, BRQL)
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 3 generators
1 -> 0
2 -> 0
3 -> z^4*e[1]
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> F1 = graded_free_module(Rg, [2,2,2]);

julia> F2 = graded_free_module(Rg, [2]);

julia> G = graded_free_module(Rg, [1,1]);

julia> V1 = [y*G[1], (x+y)*G[1]+y*G[2], z*G[2]]
3-element Vector{FreeModElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:
 y*e[1]
 (x + y)*e[1] + y*e[2]
 z*e[2]

julia> V2 = [z*G[2]+y*G[1]]
1-element Vector{FreeModElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:
 y*e[1] + z*e[2]

julia> a1 = hom(F1, G, V1)
F1 -> G
e[1] -> y*e[1]
e[2] -> (x + y)*e[1] + y*e[2]
e[3] -> z*e[2]
Homogeneous module homomorphism

julia> a2 = hom(F2, G, V2)
F2 -> G
e[1] -> y*e[1] + z*e[2]
Homogeneous module homomorphism

julia> V = subquotient(a1,a2)
Graded subquotient of submodule of G generated by
1 -> y*e[1]
2 -> (x + y)*e[1] + y*e[2]
3 -> z*e[2]
by submodule of G generated by
1 -> y*e[1] + z*e[2]

julia> A1 = Rg[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]

julia> A2 = Rg[x^3 x^2*y; (2*x^2+x*y)*x (2*y^3+y*x^2)]
[          x^3           x^2*y]
[2*x^3 + x^2*y   x^2*y + 2*y^3]

julia> B = Rg[4*x*y^3 (2*x+y)^4]
[4*x*y^3   16*x^4 + 32*x^3*y + 24*x^2*y^2 + 8*x*y^3 + y^4]

julia> F2 = graded_free_module(Rg,[0,0])
Graded free module Rg^2([0]) of rank 2 over Rg

julia> M1 = SubquoModule(F2, A1, B)
Graded subquotient of submodule of F2 generated by
1 -> x*e[1] + y*e[2]
2 -> 2*x^2*e[1] + 3*y^2*e[2]
by submodule of F2 generated by
1 -> 4*x*y^3*e[1] + (16*x^4 + 32*x^3*y + 24*x^2*y^2 + 8*x*y^3 + y^4)*e[2]
```
"""
function subquotient(a::FreeModuleHom, b::FreeModuleHom)
  F = codomain(a)
  @assert F === codomain(b)
  A = matrix(a)
  B = matrix(b)
  return SubquoModule(F, A, B)
end
subquotient(F::FreeMod{T}, A::MatElem{T}, B::MatElem{T}) where {T} = SubquoModule(F, A, B)
subquotient(A::MatElem{T}, B::MatElem{T}) where {T} = SubquoModule(A, B)
#######################################################

function show(io::IO, SQ::SubquoModule)
  @show_name(io, SQ)
  @show_special(io, SQ)
  io_compact = IOContext(io, :compact => true)

  if is_graded(SQ)
      if isdefined(SQ, :quo) && !iszero(SQ.quo)
          print(io, "Graded subquotient")
          print(io_compact, " of submodule of ", SQ.F, " generated by", SQ.sub, "\nby submodule of ", SQ.F, " generated by", SQ.quo)
      else
          print(io_compact, "Graded submodule of ", SQ.F)
          print(io_compact, SQ.sub, "\n")
          print(io, "represented as subquotient with no relations")
      end
  else
      # Todo: Use again once the printing of rings is fixed
      # if isdefined(SQ, :quo) && !iszero(SQ.quo)
      #     print(io, "Subquotient")
      #     print(io_compact, " of submodule of ", SQ.F, " generated by", SQ.sub, "\nby submodule of ", SQ.F, " generated by", SQ.quo)
      # else
      #     print(io_compact, "Submodule of ", SQ.F)
      #     print(io_compact, SQ.sub, "\n")
      #     print(io, "represented as subquotient with no relations")
      # end
      if isdefined(SQ, :quo) && !iszero(SQ.quo)
        print(io, "Subquotient of ", SQ.sub, "\nby ", SQ.quo)
      else
        print(io, SQ.sub, "\n")
        print(io, "represented as subquotient with no relations.")
      end
  end
end

@doc raw"""
    show_subquo(SQ::SubquoModule)

Show `SQ` as a subquotient of *matrices* `A` and `B`.
"""
function show_subquo(SQ::SubquoModule)
  #@show_name(io, SQ)
  #@show_special(io, SQ)
  io_compact = IOContext(stdout, :compact => true)
  if isdefined(SQ, :quo)
    if is_generated_by_standard_unit_vectors(SQ.sub)
      if is_graded(SQ)
        println("Graded cokernel of")
      else
        println("Cokernel of")
      end
      show(stdout, "text/plain", generator_matrix(SQ.quo))
    else
      if is_graded(SQ)
        println("Graded subquotient of")
      else
        println("Subquotient of")
      end
      show(stdout, "text/plain", generator_matrix(SQ.sub))
      println("\nby image of")
      show(stdout, "text/plain", generator_matrix(SQ.quo))
    end
  else
    if is_graded(SQ)
      println("Graded image of")
    else
      println("Image of")
    end
    show(stdout, "text/plain", generator_matrix(SQ.sub))
  end
  print(io_compact, "\nwith ambient free module ", SQ.F)
end

function show_morphism_as_map(f::ModuleFPHom, print_non_zero_only = false)
  io_compact = IOContext(stdout, :compact => true)
  print(io_compact, domain(f), " -> ", codomain(f))
  print("\n")
  D = domain(f)
  for i in 1:ngens(D)
    generator = gen(D, i)
    im = f(generator)
    if !(print_non_zero_only && iszero(im))
      print(generator, " -> ", f(generator))
      if i < ngens(D)
        print("\n")
      end
    end
  end
  print("\n")
  if is_graded(f)
    A = grading_group(f)
    if degree(f)==A[0] 
      print("Homogeneous homomorphism")
    else
      print(io_compact,"Graded homomorphism of degree ", degree(f))
    end
  else
    print("Homomorphism")
  end
return
end

@doc raw"""
    cokernel(a::ModuleFPHom)

Return the cokernel of `a` as an object of type `SubquoModule`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = free_module(R, 3);

julia> G = free_module(R, 2);

julia> W = R[y 0; x y; 0 z]
[y   0]
[x   y]
[0   z]

julia> a = hom(F, G, W);

julia> cokernel(a)
Subquotient of Submodule with 2 generators
1 -> e[1]
2 -> e[2]
by Submodule with 3 generators
1 -> y*e[1]
2 -> x*e[1] + y*e[2]
3 -> z*e[2]
```

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = free_module(R, 1);

julia> A = R[x; y]
[x]
[y]

julia> B = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> M = SubquoModule(F, A, B)
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> N = M;

julia> V = [y^2*N[1], x*N[2]]
2-element Vector{SubquoModuleElem{QQMPolyRingElem}}:
 x*y^2*e[1]
 x*y*e[1]

julia> a = hom(M, N, V);

julia> cokernel(a)
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 5 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]
4 -> x*y^2*e[1]
5 -> x*y*e[1]
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = graded_free_module(Rg, 3);

julia> G = graded_free_module(Rg, 2);

julia> W = Rg[y 0; x y; 0 z]
[y   0]
[x   y]
[0   z]

julia> a = hom(F, G, W)
F -> G
e[1] -> y*e[1]
e[2] -> x*e[1] + y*e[2]
e[3] -> z*e[2]
Graded module homomorphism of degree [1]

julia> M = cokernel(a)
Graded subquotient of submodule of G generated by
1 -> e[1]
2 -> e[2]
by submodule of G generated by
1 -> y*e[1]
2 -> x*e[1] + y*e[2]
3 -> z*e[2]

```
"""
function cokernel(f::ModuleFPHom{T1, T2}) where {T1, T2}
  return quo(codomain(f), image(f)[1], :module)::SubquoModule{elem_type(base_ring_type(T2))}
end

@doc raw"""
    cokernel(F::FreeMod{R}, A::MatElem{R}) where R

Return the cokernel of `A` as an object of type `SubquoModule` with ambient free module `F`.

# Examples
```jldoctest
julia> R, (x,y,z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = free_module(R, 2)
Free module of rank 2 over Multivariate polynomial ring in 3 variables over QQ

julia> A = R[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]
 
julia> M = cokernel(F, A)
Subquotient of Submodule with 2 generators
1 -> e[1]
2 -> e[2]
by Submodule with 2 generators
1 -> x*e[1] + y*e[2]
2 -> 2*x^2*e[1] + 3*y^2*e[2]

julia> ambient_free_module(M) === F
true

```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = graded_free_module(Rg, [8,8])
Graded free module Rg^2([-8]) of rank 2 over Rg

julia> A = Rg[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]
 
julia> M = cokernel(F, A)
Graded subquotient of submodule of F generated by
1 -> e[1]
2 -> e[2]
by submodule of F generated by
1 -> x*e[1] + y*e[2]
2 -> 2*x^2*e[1] + 3*y^2*e[2]

julia> ambient_free_module(M) === F
true

julia> degrees_of_generators(M)
2-element Vector{FinGenAbGroupElem}:
 [8]
 [8]
```
"""
function cokernel(F::FreeMod{R}, A::MatElem{R}) where R
  return is_graded(F) ? cokernel(graded_map(F, A)) : cokernel(map(F, A))
end

@doc raw"""
    cokernel(A::MatElem)

Return the cokernel of `A` as an object of type `SubquoModule`.

# Examples
```jldoctest
julia> R, (x,y,z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> A = R[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]
 
julia> M = cokernel(A)
Subquotient of Submodule with 2 generators
1 -> e[1]
2 -> e[2]
by Submodule with 2 generators
1 -> x*e[1] + y*e[2]
2 -> 2*x^2*e[1] + 3*y^2*e[2]

```
"""
function cokernel(A::MatElem)
  return cokernel(map(A))
end

@doc raw"""
    image(F::FreeMod{R}, A::MatElem{R}) where R

Return the image of `A` as an object of type `SubquoModule` with ambient free module `F`.

# Examples
```jldoctest
julia> R, (x,y,z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = free_module(R, 2)
Free module of rank 2 over Multivariate polynomial ring in 3 variables over QQ

julia> A = R[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]
 
julia> M = image(F, A)
Submodule with 2 generators
1 -> x*e[1] + y*e[2]
2 -> 2*x^2*e[1] + 3*y^2*e[2]
represented as subquotient with no relations.

julia> ambient_free_module(M) === F
true
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = graded_free_module(Rg, [8,8])
Graded free module Rg^2([-8]) of rank 2 over Rg

julia> A = Rg[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]
 
julia> M = image(F, A)
Graded submodule of F
1 -> x*e[1] + y*e[2]
2 -> 2*x^2*e[1] + 3*y^2*e[2]
represented as subquotient with no relations

julia> ambient_free_module(M) === F
true

julia> degrees_of_generators(M)
2-element Vector{FinGenAbGroupElem}:
 [9]
 [10]
```
"""
function image(F::FreeMod{R}, A::MatElem{R}) where R
  return is_graded(F) ? image(graded_map(F, A))[1] : image(map(F, A))[1]
end

@doc raw"""
    image(A::MatElem)

Return the image of `A` as an object of type `SubquoModule`.

# Examples
```jldoctest
julia> R, (x,y,z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> A = R[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]
 
julia> M = image(A)
Submodule with 2 generators
1 -> x*e[1] + y*e[2]
2 -> 2*x^2*e[1] + 3*y^2*e[2]
represented as subquotient with no relations.
```
"""
function image(A::MatElem)
  return image(map(A))[1]
end

@doc raw"""
    default_ordering(M::SubquoModule)    

Return the default ordering of `M`.
"""
function default_ordering(M::SubquoModule)
  if !isdefined(M.sub, :default_ordering)
    ord = default_ordering(ambient_free_module(M))
    set_default_ordering!(M, ord)
    return default_ordering(M.sub)
  end
  return default_ordering(M.sub)
end

@doc raw"""
    set_default_ordering!(M::SubquoModule, ord::ModuleOrdering)

Set the default ordering in `M` to `ord`.
"""
function set_default_ordering!(M::SubquoModule, ord::ModuleOrdering)
  set_default_ordering!(M.sub, ord)
  if isdefined(M, :quo)
    set_default_ordering!(M.quo, ord)
  end
  set_default_ordering!(M.sum, ord)
end

function standard_basis(M::SubquoModule; ordering::ModuleOrdering = default_ordering(M))
  @req is_exact_type(elem_type(base_ring(M))) "This functionality is only supported over exact fields."
  if !haskey(M.groebner_basis, ordering)
    if isdefined(M, :quo)
      quo_gb = standard_basis(M.quo, ordering=ordering)
      sub_union_gb_of_quo = SubModuleOfFreeModule(M.F, ModuleGens(vcat(M.sub.gens.O, quo_gb.O), M.F))
      gb = compute_standard_basis(sub_union_gb_of_quo, ordering)
      rel_gb_list = Vector{elem_type(ambient_free_module(M))}()

      for i in 1:length(gb.O)
        v = gb.S[i]
        if !iszero(_reduce(v, quo_gb.S))
          push!(rel_gb_list, gb.O[i])
        end
      end

      rel_gb_ModuleGens = ModuleGens(rel_gb_list, M.F)
      rel_gb_ModuleGens.isGB = true
      rel_gb_ModuleGens.ordering = ordering
      rel_gb_ModuleGens.quo_GB = quo_gb
      M.groebner_basis[ordering] = rel_gb_ModuleGens
    else
      M.groebner_basis[ordering] = standard_basis(M.sub, ordering=ordering)
    end
  end
  return M.groebner_basis[ordering]
end

function groebner_basis(M::SubquoModule; ordering::ModuleOrdering = default_ordering(M))
  @assert is_global(ordering)
  return standard_basis(M, ordering=ordering)
end

function reduced_groebner_basis(M::SubquoModule, ord::ModuleOrdering = default_ordering(M))
  if !haskey(M.groebner_basis, ord) || !(M.groebner_basis[ord].is_reduced)
    if !isdefined(M, :quo)
      M.groebner_basis[ord] = reduced_groebner_basis(M.sub, ord)
    else
      quo_gb = reduced_groebner_basis(M.quo, ord)
      sub_union_gb_of_quo = SubModuleOfFreeModule(M.F, ModuleGens(vcat(M.sub.gens.O, quo_gb.O), M.F))
      gb = reduced_groebner_basis(sub_union_gb_of_quo, ord)
      rel_gb_list = Vector{elem_type(ambient_free_module(M))}()

      for i in 1:length(gb.O)
        v = gb.S[i]
        if !iszero(_reduce(v, quo_gb.S))
          push!(rel_gb_list, gb.O[i])
        end
      end

      rel_gb_ModuleGens = ModuleGens(rel_gb_list, M.F)
      rel_gb_ModuleGens.isGB = true
      rel_gb_ModuleGens.is_reduced = true
      rel_gb_ModuleGens.quo_GB = quo_gb
      if !haskey(M.groebner_basis, ord)
        M.groebner_basis[ord] = rel_geb_ModuleGens
      else
        set_attribute!(M.groebner_basis[ord], :reduced_groebner_basis => rel_gb_ModuleGens)
        return rel_geb_ModuleGens
      end
    end
  end
  return M.groebner_basis[ord]
end

function leading_module(M::SubquoModule, ord::ModuleOrdering = default_ordering(M))
  @assert (!isdefined(M, :quo) || length(relations(M)) == 0)
  return SubquoModule(leading_module(M.sub, ord))
end

@doc raw"""
    is_subset(M::SubquoModule{T}, N::SubquoModule{T}) where T

Given subquotients `M` and `N` such that `ambient_module(M) == ambient_module(N)`,
return `true` if `M` is contained in `N`, where `M` and `N` are regarded as submodules 
of the common ambient module.

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> F = free_module(R, 1)
Free module of rank 1 over Multivariate polynomial ring in 3 variables over QQ

julia> AM = R[x;]
[x]

julia> BM = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> M = SubquoModule(F, AM, BM)
Subquotient of Submodule with 1 generator
1 -> x*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> AN = R[x; y]
[x]
[y]

julia> BN = R[x^2+y^4; y^3; z^4]
[x^2 + y^4]
[      y^3]
[      z^4]

julia> N = SubquoModule(F, AN, BN)
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 3 generators
1 -> (x^2 + y^4)*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> is_subset(M, N)
true
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = graded_free_module(Rg, 2);

julia> O1 = [x*F[1]+y*F[2],y*F[2]];

julia> O1a = [x*F[1],y*F[2]];

julia> O2 = [x^2*F[1]+y^2*F[2],y^2*F[2]];

julia> M1 = SubquoModule(F, O1, O2)
Graded subquotient of submodule of F generated by
1 -> x*e[1] + y*e[2]
2 -> y*e[2]
by submodule of F generated by
1 -> x^2*e[1] + y^2*e[2]
2 -> y^2*e[2]

julia> M2 = SubquoModule(F, O1a, O2)
Graded subquotient of submodule of F generated by
1 -> x*e[1]
2 -> y*e[2]
by submodule of F generated by
1 -> x^2*e[1] + y^2*e[2]
2 -> y^2*e[2]

julia> is_subset(M1,M2)
true

julia> is_subset(M2,M1)
true

julia> M1 == M2
true
```
"""
function is_subset(M::SubquoModule{T}, N::SubquoModule{T}) where T
  if !isdefined(M, :quo) 
    if !isdefined(N, :quo)
      return issubset(M.sub, N.sub)
    else
      return iszero(N.quo) && issubset(M.sub, N.sub)
    end
  else
    if !isdefined(N, :quo)
      return iszero(M.quo) && issubset(M.sub, N.sub)
    else
      return M.quo == N.quo && issubset(M.sum, N.sum)
    end
  end
end

function compare_helper(M::SubquoModule{T}, N::SubquoModule{T}, comparer::Function) where {T}
  if !isdefined(M, :quo) 
    if !isdefined(N, :quo)
      return comparer(M.sub, N.sub)
    else
      return iszero(N.quo) && comparer(M.sub, N.sub)
    end
  else
    if !isdefined(N, :quo)
      return iszero(M.quo) && comparer(M.sub, N.sub)
    else
      return comparer(M.quo, N.quo) && comparer(M.sum, N.sum)
    end
  end
end

@doc raw"""
    ==(M::SubquoModule{T}, N::SubquoModule{T}) where {T}

Given subquotients `M` and `N` such that `ambient_module(M) == ambient_module(N)`,
return `true` if `M` equals `N`, where `M` and `N` are regarded as submodules 
of the common ambient module.

Here, `ambient_module(M) == ambient_module(N)` if

- `ambient_free_module(M) === ambient_free_module(N)`, and
- the submodules of the common ambient free module generated by the relations of `M` and `N`, respectively, are equal.

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> F = free_module(R, 1)
Free module of rank 1 over Multivariate polynomial ring in 3 variables over QQ

julia> AM = R[x;]
[x]

julia> BM = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> M = SubquoModule(F, AM, BM)
Subquotient of Submodule with 1 generator
1 -> x*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> AN = R[x; y]
[x]
[y]

julia> BN = R[x^2+y^4; y^3; z^4]
[x^2 + y^4]
[      y^3]
[      z^4]

julia> N = SubquoModule(F, AN, BN)
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 3 generators
1 -> (x^2 + y^4)*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> M == N
false
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = graded_free_module(Rg, 2);

julia> O1 = [x*F[1]+y*F[2],y*F[2]];

julia> O1a = [x*F[1],y*F[2]];

julia> O2 = [x^2*F[1]+y^2*F[2],y^2*F[2]];

julia> M1 = SubquoModule(F, O1, O2)
Graded subquotient of submodule of F generated by
1 -> x*e[1] + y*e[2]
2 -> y*e[2]
by submodule of F generated by
1 -> x^2*e[1] + y^2*e[2]
2 -> y^2*e[2]

julia> M2 = SubquoModule(F, O1a, O2)
Graded subquotient of submodule of F generated by
1 -> x*e[1]
2 -> y*e[2]
by submodule of F generated by
1 -> x^2*e[1] + y^2*e[2]
2 -> y^2*e[2]

julia> M1 == M2
true
```
"""
function (==)(M::SubquoModule{T}, N::SubquoModule{T}) where {T} # TODO replace implementation by two inclusion checks?
  return compare_helper(M, N, (==))
end

@doc raw"""
    is_canonically_isomorphic(M::SubquoModule{T}, N::SubquoModule{T}) where {T}

Check if `M` and `N` are isomorphic under `canonical_isomorphism(F, G)` where
`F` and `G` are the ambient free modules of `M` and `N` respectively.
Return `false` if the ambient free modules are not isomorphic.

```jldoctest
julia> Rg, (x, y) = graded_polynomial_ring(QQ, ["x", "y"]);

julia> F1 = graded_free_module(Rg,[2,3, 4])
Graded free module Rg^1([-2]) + Rg^1([-3]) + Rg^1([-4]) of rank 3 over Rg

julia> A1 = Rg[x^3 x^2 x; (2*x^2+x*y)*x^2 (2*y^2+x^2)*x x^2]
[          x^3             x^2     x]
[2*x^4 + x^3*y   x^3 + 2*x*y^2   x^2]

julia> M1 = image(F1, A1)
Graded submodule of F1
1 -> x^3*e[1] + x^2*e[2] + x*e[3]
2 -> (2*x^4 + x^3*y)*e[1] + (x^3 + 2*x*y^2)*e[2] + x^2*e[3]
represented as subquotient with no relations

julia> F2 = graded_free_module(Rg,[2,4, 3])
Graded free module Rg^1([-2]) + Rg^1([-4]) + Rg^1([-3]) of rank 3 over Rg

julia> A2 = Rg[x^3 x x^2; (2*x^2+x*y)*x^2 x^2 (2*y^2+x^2)*x]
[          x^3     x             x^2]
[2*x^4 + x^3*y   x^2   x^3 + 2*x*y^2]

julia> M2 = image(F2, A2)
Graded submodule of F2
1 -> x^3*e[1] + x*e[2] + x^2*e[3]
2 -> (2*x^4 + x^3*y)*e[1] + x^2*e[2] + (x^3 + 2*x*y^2)*e[3]
represented as subquotient with no relations

julia> is_canonically_isomorphic(M1, M2)
true

```
"""
function is_canonically_isomorphic(M::SubquoModule{T}, N::SubquoModule{T}) where {T}
  F = ambient_free_module(M)
  G = ambient_free_module(N)
  if !is_isomorphic(F, G)
    return false
  end
  return compare_helper(M, N, is_canonically_isomorphic)
end

@doc raw"""
    is_canonically_isomorphic_with_map(M::SubquoModule{T}, N::SubquoModule{T}) where {T}

Check if `M` and `N` are isomorphic under `canonical_isomorphism(F, G)` where
`F` and `G` are the ambient free modules of `M` and `N` respectively.
Moreover, if `M` and `N` are canonically isomorphic then return also the isomorphism, 
otherwise return the zero map.

```jldoctest
julia> Rg, (x, y) = graded_polynomial_ring(QQ, ["x", "y"]);

julia> F1 = graded_free_module(Rg,[2,3, 4])
Graded free module Rg^1([-2]) + Rg^1([-3]) + Rg^1([-4]) of rank 3 over Rg

julia> A1 = Rg[x^3 x^2 x; (2*x^2+x*y)*x^2 (2*y^2+x^2)*x x^2]
[          x^3             x^2     x]
[2*x^4 + x^3*y   x^3 + 2*x*y^2   x^2]

julia> M1 = image(F1, A1)
Graded submodule of F1
1 -> x^3*e[1] + x^2*e[2] + x*e[3]
2 -> (2*x^4 + x^3*y)*e[1] + (x^3 + 2*x*y^2)*e[2] + x^2*e[3]
represented as subquotient with no relations

julia> F2 = graded_free_module(Rg,[2,4, 3])
Graded free module Rg^1([-2]) + Rg^1([-4]) + Rg^1([-3]) of rank 3 over Rg

julia> A2 = Rg[x^3 x x^2; (2*x^2+x*y)*x^2 x^2 (2*y^2+x^2)*x]
[          x^3     x             x^2]
[2*x^4 + x^3*y   x^2   x^3 + 2*x*y^2]

julia> M2 = image(F2, A2)
Graded submodule of F2
1 -> x^3*e[1] + x*e[2] + x^2*e[3]
2 -> (2*x^4 + x^3*y)*e[1] + x^2*e[2] + (x^3 + 2*x*y^2)*e[3]
represented as subquotient with no relations

julia> is_canonically_isomorphic_with_map(M1, M2)
(true, M1 -> M2
x^3*e[1] + x^2*e[2] + x*e[3] -> x^3*e[1] + x*e[2] + x^2*e[3]
(2*x^4 + x^3*y)*e[1] + (x^3 + 2*x*y^2)*e[2] + x^2*e[3] -> (2*x^4 + x^3*y)*e[1] + x^2*e[2] + (x^3 + 2*x*y^2)*e[3]
Homogeneous module homomorphism)

```
"""
function is_canonically_isomorphic_with_map(M::SubquoModule{T}, N::SubquoModule{T}) where {T}
  is_canonically_iso = is_canonically_isomorphic(M, N)
  if is_canonically_iso
    F = ambient_free_module(M)
    G = ambient_free_module(N)
    f = canonical_isomorphism(F, G)
    f = induced_map(f, M, false) # is certainly well-defined
    f = restrict_codomain(f, N)
    return true, f
  else
    return false, hom(M, N, [zero(N) for _ in 1:gens(M)])
  end
end

@doc raw"""
    sum(M::SubquoModule{T},N::SubquoModule{T}) where T

Given subquotients `M` and `N` such that `ambient_module(M) == ambient_module(N)`,
return the sum of `M` and `N` regarded as submodules of the common ambient module.

Additionally, return the inclusion maps `M` $\to$ `M + N` and `N` $\to$ `M + N`.

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> F = free_module(R, 1)
Free module of rank 1 over Multivariate polynomial ring in 3 variables over QQ

julia> AM = R[x;]
[x]

julia> BM = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> M = SubquoModule(F, AM, BM)
Subquotient of Submodule with 1 generator
1 -> x*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> AN = R[y;]
[y]

julia> BN = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> N = SubquoModule(F, AN, BN)
Subquotient of Submodule with 1 generator
1 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> O = sum(M, N);

julia> O[1]
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> O[2]
Map with following data
Domain:
=======
Subquotient of Submodule with 1 generator
1 -> x*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]
Codomain:
=========
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> O[3]
Map with following data
Domain:
=======
Subquotient of Submodule with 1 generator
1 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]
Codomain:
=========
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = graded_free_module(Rg, 1);

julia> AM = Rg[x;];

julia> BM = Rg[x^2; y^3; z^4];

julia> M = SubquoModule(F, AM, BM)
Graded subquotient of submodule of F generated by
1 -> x*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> AN = Rg[y;];

julia> BN = Rg[x^2; y^3; z^4];

julia> N = SubquoModule(F, AN, BN)
Graded subquotient of submodule of F generated by
1 -> y*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> sum(M, N)
(Graded subquotient of submodule of F generated by
1 -> x*e[1]
2 -> y*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1], M -> Graded subquotient of submodule of F generated by
1 -> x*e[1]
2 -> y*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]
x*e[1] -> x*e[1]
Homogeneous module homomorphism, N -> Graded subquotient of submodule of F generated by
1 -> x*e[1]
2 -> y*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]
y*e[1] -> y*e[1]
Homogeneous module homomorphism)

```
"""
function sum(M::SubquoModule{T},N::SubquoModule{T}) where T
  @assert ambient_free_module(M) === ambient_free_module(N)

  if !isdefined(M, :quo) && !isdefined(N, :quo)
    SQ = SubquoModule(sum(M.sub,N.sub))
  else

    M_quo = isdefined(M, :quo) ? M.quo : SubModuleOfFreeModule(ambient_free_module(M), Vector{elem_type(ambient_free_module(M))}())
    N_quo = isdefined(N, :quo) ? N.quo : SubModuleOfFreeModule(ambient_free_module(N), Vector{elem_type(ambient_free_module(N))}())
  
    if M_quo == N_quo
      SQ = SubquoModule(sum(M.sub,N.sub),M_quo)
    else
      error("Relations are not equal")
    end
  end

  iM = SubQuoHom(M,SQ,[SQ[i] for i=1:ngens(M)])
  iN = SubQuoHom(N,SQ,[SQ[i] for i=ngens(M)+1:ngens(SQ)])

  register_morphism!(iM)
  register_morphism!(iN)

  SQ_simplified, _, s_proj = simplify_light(SQ)
  return SQ_simplified, iM*s_proj, iN*s_proj
end

@doc raw"""
    +(M::SubquoModule{T},N::SubquoModule{T}) where T

Given subquotients `M` and `N` such that `ambient_module(M) == ambient_module(N)`,
return the sum of `M` and `N` regarded as submodules of the common ambient module. 

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> F = free_module(R, 1)
Free module of rank 1 over Multivariate polynomial ring in 3 variables over QQ

julia> AM = R[x;]
[x]

julia> BM = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> M = SubquoModule(F, AM, BM)
Subquotient of Submodule with 1 generator
1 -> x*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> AN = R[y;]
[y]

julia> BN = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> N = SubquoModule(F, AN, BN)
Subquotient of Submodule with 1 generator
1 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> O = M + N
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = graded_free_module(Rg, 1);

julia> AM = Rg[x;];

julia> BM = Rg[x^2; y^3; z^4];

julia> M = SubquoModule(F, AM, BM)
Graded subquotient of submodule of F generated by
1 -> x*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> AN = Rg[y;];

julia> BN = Rg[x^2; y^3; z^4];

julia> N = SubquoModule(F, AN, BN)
Graded subquotient of submodule of F generated by
1 -> y*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> M + N
Graded subquotient of submodule of F generated by
1 -> x*e[1]
2 -> y*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

```
"""
function +(M::SubquoModule{T},N::SubquoModule{T}) where T
  return sum(M,N)[1]
end

@doc raw"""
    intersect(M::SubquoModule{T}, N::SubquoModule{T}) where T

Given subquotients `M` and `N` such that `ambient_module(M) == ambient_module(N)`,
return the intersection of `M` and `N` regarded as submodules of the common ambient module.

Additionally, return the inclusion maps `M` $\cap$ `N` $\to$ `M` and `M` $\cap$ `N` $\to$ `N`.

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> F = free_module(R, 1)
Free module of rank 1 over Multivariate polynomial ring in 3 variables over QQ

julia> AM = R[x;]
[x]

julia> BM = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> M = SubquoModule(F, AM, BM)
Subquotient of Submodule with 1 generator
1 -> x*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> AN = R[y;]
[y]

julia> BN = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> N = SubquoModule(F, AN, BN)
Subquotient of Submodule with 1 generator
1 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> intersect(M, N)
(Subquotient of Submodule with 2 generators
1 -> -x*y*e[1]
2 -> x*z^4*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1], Map with following data
Domain:
=======
Subquotient of Submodule with 2 generators
1 -> -x*y*e[1]
2 -> x*z^4*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]
Codomain:
=========
Subquotient of Submodule with 1 generator
1 -> x*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1], Map with following data
Domain:
=======
Subquotient of Submodule with 2 generators
1 -> -x*y*e[1]
2 -> x*z^4*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]
Codomain:
=========
Subquotient of Submodule with 1 generator
1 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1])
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = graded_free_module(Rg, 1);

julia> AM = Rg[x;];

julia> BM = Rg[x^2; y^3; z^4];

julia> M = SubquoModule(F, AM, BM)
Graded subquotient of submodule of F generated by
1 -> x*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> AN = Rg[y;];

julia> BN = Rg[x^2; y^3; z^4];

julia> N = SubquoModule(F, AN, BN)
Graded subquotient of submodule of F generated by
1 -> y*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> intersect(M, N)
(Graded subquotient of submodule of F generated by
1 -> -x*y*e[1]
2 -> x*z^4*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1], Graded subquotient of submodule of F generated by
1 -> -x*y*e[1]
2 -> x*z^4*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1] -> M
-x*y*e[1] -> -x*y*e[1]
x*z^4*e[1] -> x*z^4*e[1]
Homogeneous module homomorphism, Graded subquotient of submodule of F generated by
1 -> -x*y*e[1]
2 -> x*z^4*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1] -> N
-x*y*e[1] -> x*y*e[1]
x*z^4*e[1] -> 0
Homogeneous module homomorphism)

```
"""
function intersect(M::SubquoModule{T}, N::SubquoModule{T}) where T
  #TODO allow task as argument?
  @assert ambient_free_module(M) === ambient_free_module(N)
  M_quo = isdefined(M, :quo) ? M.quo : SubModuleOfFreeModule(ambient_free_module(M), Vector{elem_type(ambient_free_module(M))}())
  N_quo = isdefined(N, :quo) ? N.quo : SubModuleOfFreeModule(ambient_free_module(N), Vector{elem_type(ambient_free_module(N))}())
  R = base_ring(M)

  if M_quo == N_quo

    F1 = FreeMod(R, ngens(M.sub) + ngens(N.sub) + ngens(M_quo))
    F2 = ambient_free_module(M)
    phi = FreeModuleHom(F1,F2,vcat(gens(M.sub),gens(N.sub),gens(M_quo)))
    K,i = kernel(phi)

    intersection_gens_array_with_zeros = [sum([repres(k)[i]*M.sub[i] for i=1:ngens(M.sub)]; init=zero(ambient_free_module(M))) for k in gens(K)]
    iszero_array = map(!iszero, intersection_gens_array_with_zeros)

    intersection_gens = SubModuleOfFreeModule(ambient_free_module(M), intersection_gens_array_with_zeros[iszero_array] )
    SQ = SubquoModule(intersection_gens,M_quo)

    m = ngens(M)
    M_hom = SubQuoHom(SQ,M,[sum([repres(k)[i]*M[i] for i=1:m]; init=zero(M)) for k in gens(K)][iszero_array])
    N_hom = SubQuoHom(SQ,N,[sum([repres(k)[i]*N[i-m] for i=m+1:m+ngens(N)]; init=zero(N)) for k in gens(K)][iszero_array])

    register_morphism!(M_hom)
    register_morphism!(N_hom)

    SQ_simplified, s_inj, _ = simplify_light(SQ)
    return SQ_simplified, s_inj*M_hom, s_inj*N_hom
  end
  throw(ArgumentError("Relations of M and N are not equal."))
end

@doc raw"""
    represents_element(a::FreeModElem, SQ::SubquoModule)

Check if `a` represents an element `SQ`.
"""
function represents_element(a::FreeModElem, SQ::SubquoModule)
  return in(a, SQ.sum)
end



@doc raw"""
    reduce(v::FreeModElem, N::SubquoModule)

Let `N` be a submodule of a free module (that is, `N` has no quotient).
Reduce the element `v` with respect to a Gröbner basis of `N`.
"""
function reduce(v::AbstractFreeModElem, N::SubquoModule)
  @assert !(isdefined(N, :quo))
  return reduce(v, groebner_basis(N))
end

@doc raw"""
    ambient_free_module(M::SubquoModule)

Return the ambient free module of `M`.
"""
function ambient_free_module(M::SubquoModule)
  return M.F
end

@doc raw"""
    ambient_module(M::SubquoModule, task = :none)

If $M = (P + Q) / Q$ then return $F / Q$ where `F == ambient_free_module(M)`.
If $M$ is a submodule of a free module, then the (ambient) free module is returned.

If `task == :with_morphism`, return also the canonical inclusion.
"""
function ambient_module(M::SubquoModule, task = :none)
  if !isdefined(M, :quo)
    if task == :none
      return F
    else
      return F, hom(M,F,[repres(v) for v in gens(M)])
    end
  end
  F = ambient_free_module(M)
  g = SubModuleOfFreeModule(F,basis(F))
  SQ = SubquoModule(g, M.quo)
  if task == :none
    return SQ
  else
    return SQ, hom(M,SQ,[SubquoModuleElem(coordinates(repres(v)), SQ) for v in gens(M)])
  end
end

@doc raw"""
    ambient_representatives_generators(M::SubquoModule)

Return elements of the ambient free module of `M` which represent the generators of `M`.
"""
function ambient_representatives_generators(M::SubquoModule)
  G = ambient_free_module(M)
  return [FreeModElem(coordinates(repres(x)), G) for x in gens(M)]
end


@doc raw"""
    rels(M::SubquoModule)

Return the relations of `M`.
"""
rels(M::SubquoModule) = isdefined(M, :quo) ? collect(M.quo.gens) : elem_type(M.F)[]

@doc raw"""
    relations(M::SubquoModule)

Return the relations of `M`.
"""
relations(M::SubquoModule) = rels(M)

# the two methods below are needed for the implementation of is_surjective
function (==)(G::SubquoModule, F::FreeMod)
  return F == G
end

function (==)(F::FreeMod, G::SubquoModule)
  base_ring(F) === base_ring(G) || return false
  ambient_free_module(G) === F || return false
  if isdefined(G, :quo) 
    iszero(G.quo) || return false
  end
  all(e -> e in G, gens(F)) || return false
  return true
end
