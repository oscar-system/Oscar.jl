###############################################################################
# SubquoModule constructors
###############################################################################

@doc raw"""
    SubquoModule(sub::SubModuleOfFreeModule{R}) where {R}

Construct the module `sub` as a subquotient.
"""
function SubquoModule(sub::SubModuleOfFreeModule{R}) where {R}
  subquo = SubquoModule{R}(ambient_free_module(sub))
  subquo.sub = sub
  subquo.sum = sub
  return subquo
end

@doc raw"""
    SubquoModule(sub::SubModuleOfFreeModule{R}, quo::SubModuleOfFreeModule{R}) where {R}

Construct the subquotient module $\texttt{sub} + texttt{quo} / \texttt{quo}$. 
`sub` and `quo` must be submodules of the same free module.
"""
function SubquoModule(sub::SubModuleOfFreeModule{R}, quo::SubModuleOfFreeModule{R}) where {R}
  F = ambient_free_module(sub)
  @assert F === ambient_free_module(quo)
  subquo = SubquoModule{R}(F)
  subquo.sub = sub
  subquo.quo = quo
  subquo.sum = sum(subquo.sub, subquo.quo)
  return subquo
end

@doc raw"""
    SubquoModule(F::FreeMod{R}, O::Vector{<:FreeModElem}) where {R}

Construct the module generated by the elements of `O` as a subquotient.
The elements of `O` must live in `F`.

# Examples
```jldoctest
julia> R, (x,y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> F = FreeMod(R,2)
Free module of rank 2 over R

julia> O = [x*F[1]+F[2],y*F[2]]
2-element Vector{FreeModElem{QQMPolyRingElem}}:
 x*e[1] + e[2]
 y*e[2]

julia> M = SubquoModule(F, O)
Submodule with 2 generators
  1: x*e[1] + e[2]
  2: y*e[2]
represented as subquotient with no relations

```
"""
function SubquoModule(F::FreeMod{R}, O::Vector{<:FreeModElem}) where {R} 
  sub = SubModuleOfFreeModule(F, O)
  return SubquoModule(sub)
end

@doc raw"""
    SubquoModule(S::SubquoModule{L}, O::Vector{<:FreeModElem}) where {L}

Construct a subquotient where the generators are those of `S` and the relations are 
the union of `O` and the relations of `S`.
"""
function SubquoModule(S::SubquoModule{L}, O::Vector{<:FreeModElem}) where {L}
  F = ambient_free_module(S)
  subquo = SubquoModule{L}(F)
  subquo.sub = S.sub
  O_as_submodule = SubModuleOfFreeModule(F, O)
  subquo.quo = isdefined(S,:quo) ? sum(S.quo,O_as_submodule) : O_as_submodule
  subquo.sum = sum(subquo.sub, subquo.quo)
  return subquo
end

function SubquoModule(F::FreeMod{R}, s::Singular.smodule) where {R}
  subquo = SubquoModule{R}(F)
  subquo.sub = SubModuleOfFreeModule(F, s)
  subquo.sum = subquo.sub
  return subquo
end

function SubquoModule(F::FreeMod{R}, s::Singular.smodule, t::Singular.smodule) where {R}
  subquo = SubquoModule{R}(F)
  subquo.sub = SubModuleOfFreeModule(F, s)
  subquo.quo = SubModuleOfFreeModule(F, t)
  subquo.sum = sum(subquo.sub, subquo.quo)
  return subquo
end

@doc raw"""
    SubquoModule(F::FreeMod{R}, A::MatElem{R}, B::MatElem{R}) where {R}

Given matrices `A` and `B` with entries in a ring `R` representing maps 
of free $R$-modules with the same codomain `F`, return the subquotient 
$(\text{im } A + \text{im }  B)/\text{im }  B$.
"""
function SubquoModule(F::FreeMod{R}, A::MatElem{R}, B::MatElem{R}) where {R}
  @assert ncols(A) == ncols(B) == rank(F)
  return SubquoModule(SubModuleOfFreeModule(F, A), SubModuleOfFreeModule(F, B))
end

@doc raw"""
    SubquoModule(A::MatElem{R}, B::MatElem{R}) where {R}

Given matrices `A` and `B` with entries in a ring `R` 
representing maps of free $R$-modules with the same codomain,
return the subquotient $(\text{im } A + \text{im }  B)/\text{im }  B.$ 

!!! note

    The ambient free module of the subquotient is constructed by the function and therefore
    not compatible with free modules defined by the user or by other functions. 
    For compatibility, use `SubquoModule(F::FreeMod{R}, A::MatElem{R}, B::MatElem{R})`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> A = R[x; y]
[x]
[y]

julia> B = R[x^2; x*y; y^2; z^4]
[x^2]
[x*y]
[y^2]
[z^4]

julia> M = subquotient(A, B)
Subquotient of submodule with 2 generators
  1: x*e[1]
  2: y*e[1]
by submodule with 4 generators
  1: x^2*e[1]
  2: x*y*e[1]
  3: y^2*e[1]
  4: z^4*e[1]
```
"""
function SubquoModule(A::MatElem{R}, B::MatElem{R}) where {R}
  @assert ncols(A) == ncols(B)
  S = base_ring(A)
  F = FreeMod(S, ncols(A))
  return SubquoModule(SubModuleOfFreeModule(F, A), SubModuleOfFreeModule(F, B))
end

@doc raw"""
    SubquoModule(F::FreeMod{T}, g::Vector{FreeModElem{T}}, q::Vector{FreeModElem{T}}) where {T<:RingElem} 

Construct the subquotient with ambient free module `F`, generators `g`
and relations `q`.
"""
function SubquoModule(F::FreeMod{T}, g::Vector{FreeModElem{T}}, q::Vector{FreeModElem{T}}) where {T<:AdmissibleModuleFPRingElem} 
  return SubquoModule(SubModuleOfFreeModule(F, g), SubModuleOfFreeModule(F, q))
end

#######################################################
@doc raw"""
    subquotient(a::FreeModuleHom, b::FreeModuleHom)

Given homomorphisms `a` and `b` between free modules such that 
`codomain(a) === codomain(b)`, 
return $(\text{im } a + \text{im } b)/\text{im } b$.

    subquotient(F::FreeMod{T}, A::MatElem{T}, B::MatElem{T}) where T

Given matrices `A` and `B` with rank `F` columns, return  
$(\text{im } a + \text{im } b)/\text{im } b$,
where `a` and `b` are free module homomorphisms with codomain `F` represented by `A` and `B`.

    subquotient(A::MatElem{T}, B::MatElem{T}) where T

Given matrices `A` and `B` with the same number of columns, create a free module `F` whose rank 
is that number, and return $(\text{im } a + \text{im } b)/\text{im } b$, where `a` and `b` are 
free module homomorphisms with codomain `F` represented by `A` and `B`.
    
    subquotient(F::FreeMod{T}, G::Vector{FreeModElem{T}}, R::Vector{FreeModElem{T}}) where T 

Given vectors `G` and `R` of elements of `F`, return the subquotient whose ambient representatives 
of the generators are the entries of `G`, and whose relations are the entries of `R`.

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> FR = free_module(R, 1)
Free module of rank 1 over R

julia> AR = R[x; y]
[x]
[y]

julia> BR = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> MR = subquotient(FR, AR, BR)
Subquotient of submodule with 2 generators
  1: x*e[1]
  2: y*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> P = ideal(R, [x, y, z]);

julia> U = complement_of_prime_ideal(P);

julia> RL, _ = localization(R, U);

julia> FRL = free_module(RL, 1)
Free module of rank 1 over localization of R at complement of prime ideal (x, y, z)

julia> ARL = RL[x; y]
[x]
[y]

julia> BRL = RL[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> MRL = subquotient(FRL, ARL, BRL)
Subquotient of submodule with 2 generators
  1: x*e[1]
  2: y*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> RQ, _ = quo(R, ideal(R, [2*x^2-y^3, 2*x^2-y^5]));

julia> FRQ = free_module(RQ, 1)
Free module of rank 1 over RQ

julia> ARQ = RQ[x; y]
[x]
[y]

julia> BRQ = RQ[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> MRQ = subquotient(FRQ, ARQ, BRQ)
Subquotient of submodule with 2 generators
  1: x*e[1]
  2: y*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: 2*x^2*e[1]
  3: z^4*e[1]

julia> RQL, _ = localization(RQ, U);

julia> FRQL = free_module(RQL, 1)
Free module of rank 1 over localization of RQ at complement of prime ideal

julia> ARQL = RQL[x; y]
[x]
[y]

julia> BRQL = RQL[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> MRQL = subquotient(FRQL, ARQL, BRQL)
Subquotient of submodule with 2 generators
  1: x*e[1]
  2: y*e[1]
by submodule with 3 generators
  1: 0
  2: 0
  3: z^4*e[1]
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> F1 = graded_free_module(Rg, [2,2,2]);

julia> F2 = graded_free_module(Rg, [2]);

julia> G = graded_free_module(Rg, [1,1]);

julia> V1 = [y*G[1], (x+y)*G[1]+y*G[2], z*G[2]]
3-element Vector{FreeModElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:
 y*e[1]
 (x + y)*e[1] + y*e[2]
 z*e[2]

julia> V2 = [z*G[2]+y*G[1]]
1-element Vector{FreeModElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:
 y*e[1] + z*e[2]

julia> a1 = hom(F1, G, V1)
Homogeneous module homomorphism
  from F1
  to G
defined by
  e[1] -> y*e[1]
  e[2] -> (x + y)*e[1] + y*e[2]
  e[3] -> z*e[2]

julia> a2 = hom(F2, G, V2)
Homogeneous module homomorphism
  from F2
  to G
defined by
  e[1] -> y*e[1] + z*e[2]

julia> V = subquotient(a1,a2)
Graded subquotient of graded submodule of G with 3 generators
  1: y*e[1]
  2: (x + y)*e[1] + y*e[2]
  3: z*e[2]
by graded submodule of G with 1 generator
  1: y*e[1] + z*e[2]

julia> A1 = Rg[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]

julia> A2 = Rg[x^3 x^2*y; (2*x^2+x*y)*x (2*y^3+y*x^2)]
[          x^3           x^2*y]
[2*x^3 + x^2*y   x^2*y + 2*y^3]

julia> B = Rg[4*x*y^3 (2*x+y)^4]
[4*x*y^3   16*x^4 + 32*x^3*y + 24*x^2*y^2 + 8*x*y^3 + y^4]

julia> F2 = graded_free_module(Rg,[0,0])
Graded free module Rg^2([0]) of rank 2 over Rg

julia> M1 = subquotient(F2, A1, B)
Graded subquotient of graded submodule of F2 with 2 generators
  1: x*e[1] + y*e[2]
  2: 2*x^2*e[1] + 3*y^2*e[2]
by graded submodule of F2 with 1 generator
  1: 4*x*y^3*e[1] + (16*x^4 + 32*x^3*y + 24*x^2*y^2 + 8*x*y^3 + y^4)*e[2]
```
"""
function subquotient(a::FreeModuleHom, b::FreeModuleHom)
  F = codomain(a)
  @assert F === codomain(b)
  A = matrix(a)
  B = matrix(b)
  return SubquoModule(F, A, B)
end
subquotient(F::FreeMod{T}, A::MatElem{T}, B::MatElem{T}) where {T} = SubquoModule(F, A, B)
subquotient(A::MatElem{T}, B::MatElem{T}) where {T} = SubquoModule(A, B)
subquotient(F::FreeMod{T}, G::Vector{FreeModElem{T}}, R::Vector{FreeModElem{T}}) where T = SubquoModule(F, G, R)
#######################################################

function show(io::IO, SQ::SubquoModule)
  @show_name(io, SQ)
  @show_special(io, SQ)
  io = pretty(io)

  if is_graded(SQ)
      io_compact = IOContext(io, :compact => true)
      if isdefined(SQ, :quo) && !iszero(SQ.quo)
          print(io, "Graded subquotient")
          println(io_compact, " of ", Lowercase(), SQ.sub)
          print(io_compact, "by ", Lowercase(), SQ.quo)
      else
          println(io_compact, SQ.sub)
          print(io, "represented as subquotient with no relations")
      end
  else
      # Todo: Use again once the printing of rings is fixed
      # if isdefined(SQ, :quo) && !iszero(SQ.quo)
      #     print(io, "Subquotient")
      #     print(io_compact, " of submodule of ", SQ.F, " generated by ", SQ.sub, "\nby submodule of ", SQ.F, " generated by", SQ.quo)
      # else
      #     print(io_compact, "Submodule of ", SQ.F)
      #     print(io_compact, SQ.sub, "\n")
      #     print(io, "represented as subquotient with no relations")
      # end
      if isdefined(SQ, :quo) && !iszero(SQ.quo)
        println(io, "Subquotient of ", Lowercase(), SQ.sub)
        print(io, "by ", Lowercase(), SQ.quo)
      else
        println(io, SQ.sub)
        print(io, "represented as subquotient with no relations")
      end
  end
end

@doc raw"""
    show_subquo(SQ::SubquoModule)

Show `SQ` as a subquotient of *matrices* `A` and `B`.
"""
function show_subquo(SQ::SubquoModule)
  #@show_name(io, SQ)
  #@show_special(io, SQ)
  if isdefined(SQ, :quo)
    if is_generated_by_standard_unit_vectors(SQ.sub)
      if is_graded(SQ)
        println("Graded cokernel of")
      else
        println("Cokernel of")
      end
      show(stdout, "text/plain", generator_matrix(SQ.quo))
    else
      if is_graded(SQ)
        println("Graded subquotient of")
      else
        println("Subquotient of")
      end
      show(stdout, "text/plain", generator_matrix(SQ.sub))
      println("\nby image of")
      show(stdout, "text/plain", generator_matrix(SQ.quo))
    end
  else
    if is_graded(SQ)
      println("Graded image of")
    else
      println("Image of")
    end
    show(stdout, "text/plain", generator_matrix(SQ.sub))
  end
  print(terse(io), "\nwith ambient free module ", SQ.F)
end

function show_morphism_as_map(f::ModuleFPHom, print_non_zero_only = false)
  io_compact = terse(stdout)
  print(io_compact, domain(f), " -> ", codomain(f))
  print("\n")
  D = domain(f)
  for i in 1:ngens(D)
    generator = gen(D, i)
    im = f(generator)
    if !(print_non_zero_only && iszero(im))
      print(generator, " -> ", f(generator))
      if i < ngens(D)
        print("\n")
      end
    end
  end
  print("\n")
  if is_graded(f)
    A = grading_group(f)
    if degree(f)==A[0] 
      print("Homogeneous homomorphism")
    else
      print(io_compact, "Graded homomorphism of degree ", degree(f))
    end
  else
    print("Homomorphism")
  end
return
end

@doc raw"""
    cokernel(a::ModuleFPHom)

Return the cokernel of `a` as an object of type `SubquoModule`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> F = free_module(R, 3);

julia> G = free_module(R, 2);

julia> W = R[y 0; x y; 0 z]
[y   0]
[x   y]
[0   z]

julia> a = hom(F, G, W);

julia> cokernel(a)
Subquotient of submodule with 2 generators
  1: e[1]
  2: e[2]
by submodule with 3 generators
  1: y*e[1]
  2: x*e[1] + y*e[2]
  3: z*e[2]
```

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> F = free_module(R, 1);

julia> A = R[x; y]
[x]
[y]

julia> B = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> M = subquotient(F, A, B)
Subquotient of submodule with 2 generators
  1: x*e[1]
  2: y*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> N = M;

julia> V = [y^2*N[1], x*N[2]]
2-element Vector{SubquoModuleElem{QQMPolyRingElem}}:
 x*y^2*e[1]
 x*y*e[1]

julia> a = hom(M, N, V);

julia> cokernel(a)
Subquotient of submodule with 2 generators
  1: x*e[1]
  2: y*e[1]
by submodule with 5 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]
  4: x*y^2*e[1]
  5: x*y*e[1]
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> F = graded_free_module(Rg, 3);

julia> G = graded_free_module(Rg, 2);

julia> W = Rg[y 0; x y; 0 z]
[y   0]
[x   y]
[0   z]

julia> a = hom(F, G, W)
Graded module homomorphism of degree [1]
  from F
  to G
defined by
  e[1] -> y*e[1]
  e[2] -> x*e[1] + y*e[2]
  e[3] -> z*e[2]

julia> M = cokernel(a)
Graded subquotient of graded submodule of G with 2 generators
  1: e[1]
  2: e[2]
by graded submodule of G with 3 generators
  1: y*e[1]
  2: x*e[1] + y*e[2]
  3: z*e[2]

```
"""
function cokernel(f::ModuleFPHom{T1, T2}) where {T1, T2}
  return quo_object(codomain(f), image(f)[1])::SubquoModule{elem_type(base_ring_type(T2))}
end

@doc raw"""
    cokernel(F::FreeMod{R}, A::MatElem{R}) where R

Return the cokernel of `A` as an object of type `SubquoModule` with ambient free module `F`.

# Examples
```jldoctest
julia> R, (x,y,z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> F = free_module(R, 2)
Free module of rank 2 over R

julia> A = R[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]
 
julia> M = cokernel(F, A)
Subquotient of submodule with 2 generators
  1: e[1]
  2: e[2]
by submodule with 2 generators
  1: x*e[1] + y*e[2]
  2: 2*x^2*e[1] + 3*y^2*e[2]

julia> ambient_free_module(M) === F
true

```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> F = graded_free_module(Rg, [8,8])
Graded free module Rg^2([-8]) of rank 2 over Rg

julia> A = Rg[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]
 
julia> M = cokernel(F, A)
Graded subquotient of graded submodule of F with 2 generators
  1: e[1]
  2: e[2]
by graded submodule of F with 2 generators
  1: x*e[1] + y*e[2]
  2: 2*x^2*e[1] + 3*y^2*e[2]

julia> ambient_free_module(M) === F
true

julia> degrees_of_generators(M)
2-element Vector{FinGenAbGroupElem}:
 [8]
 [8]
```
"""
function cokernel(F::FreeMod{R}, A::MatElem{R}) where R
  return is_graded(F) ? cokernel(graded_map(F, A)) : cokernel(map(F, A))
end

@doc raw"""
    cokernel(A::MatElem)

Return the cokernel of `A` as an object of type `SubquoModule`.

# Examples
```jldoctest
julia> R, (x,y,z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> A = R[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]
 
julia> M = cokernel(A)
Subquotient of submodule with 2 generators
  1: e[1]
  2: e[2]
by submodule with 2 generators
  1: x*e[1] + y*e[2]
  2: 2*x^2*e[1] + 3*y^2*e[2]

```
"""
function cokernel(A::MatElem)
  return cokernel(map(A))
end

@doc raw"""
    image(F::FreeMod{R}, A::MatElem{R}) where R

Return the image of `A` as an object of type `SubquoModule` with ambient free module `F`.

# Examples
```jldoctest
julia> R, (x,y,z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> F = free_module(R, 2)
Free module of rank 2 over R

julia> A = R[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]
 
julia> M = image(F, A)
Submodule with 2 generators
  1: x*e[1] + y*e[2]
  2: 2*x^2*e[1] + 3*y^2*e[2]
represented as subquotient with no relations

julia> ambient_free_module(M) === F
true
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> F = graded_free_module(Rg, [8,8])
Graded free module Rg^2([-8]) of rank 2 over Rg

julia> A = Rg[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]
 
julia> M = image(F, A)
Graded submodule of F with 2 generators
  1: x*e[1] + y*e[2]
  2: 2*x^2*e[1] + 3*y^2*e[2]
represented as subquotient with no relations

julia> ambient_free_module(M) === F
true

julia> degrees_of_generators(M)
2-element Vector{FinGenAbGroupElem}:
 [9]
 [10]
```
"""
function image(F::FreeMod{R}, A::MatElem{R}) where R
  return is_graded(F) ? image(graded_map(F, A))[1] : image(map(F, A))[1]
end

@doc raw"""
    image(A::MatElem)

Return the image of `A` as an object of type `SubquoModule`.

# Examples
```jldoctest
julia> R, (x,y,z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> A = R[x y; 2*x^2 3*y^2]
[    x       y]
[2*x^2   3*y^2]
 
julia> M = image(A)
Submodule with 2 generators
  1: x*e[1] + y*e[2]
  2: 2*x^2*e[1] + 3*y^2*e[2]
represented as subquotient with no relations
```
"""
function image(A::MatElem)
  return image(map(A))[1]
end

@doc raw"""
    default_ordering(M::SubquoModule)    

Return the default ordering of `M`.
"""
function default_ordering(M::SubquoModule)
  if !isdefined(M.sub, :default_ordering)
    ord = default_ordering(ambient_free_module(M))
    set_default_ordering!(M, ord)
    return default_ordering(M.sub)
  end
  return default_ordering(M.sub)
end

@doc raw"""
    set_default_ordering!(M::SubquoModule, ord::ModuleOrdering)

Set the default ordering in `M` to `ord`.
"""
function set_default_ordering!(M::SubquoModule, ord::ModuleOrdering)
  set_default_ordering!(M.sub, ord)
  if isdefined(M, :quo)
    set_default_ordering!(M.quo, ord)
  end
  set_default_ordering!(M.sum, ord)
end

function standard_basis(M::SubquoModule; ordering::Union{ModuleOrdering, Nothing} = nothing)
  error("standard basis computation is not supported for modules over rings of type $(typeof(base_ring(M)))")
end

function standard_basis(M::SubquoModule{<:MPolyRingElem{T}}; ordering::ModuleOrdering = default_ordering(M)) where {T<:Union{<:FieldElem, ZZRingElem}}
  @req is_exact_type(elem_type(base_ring(M))) "This functionality is only supported over exact fields."
  if !haskey(M.groebner_basis, ordering)
    if isdefined(M, :quo)
      quo_gb = standard_basis(M.quo, ordering=ordering)
      sub_union_gb_of_quo = SubModuleOfFreeModule(M.F, ModuleGens(vcat(oscar_generators(M.sub.gens), oscar_generators(quo_gb)), M.F))
      gb = compute_standard_basis(sub_union_gb_of_quo, ordering)
      rel_gb_list = Vector{elem_type(ambient_free_module(M))}()

      SG = singular_generators(gb)
      for (i, vo) in enumerate(oscar_generators(gb))
        if !iszero(_reduce(SG[i], singular_generators(quo_gb)))
          push!(rel_gb_list, vo)
        end
      end

      rel_gb_ModuleGens = ModuleGens(rel_gb_list, M.F)
      rel_gb_ModuleGens.isGB = true
      rel_gb_ModuleGens.ordering = ordering
      rel_gb_ModuleGens.quo_GB = quo_gb
      M.groebner_basis[ordering] = rel_gb_ModuleGens
    else
      M.groebner_basis[ordering] = standard_basis(M.sub, ordering=ordering)
    end
  end
  return M.groebner_basis[ordering]
end

function groebner_basis(M::SubquoModule; ordering::ModuleOrdering = default_ordering(M))
  @assert is_global(ordering)
  return standard_basis(M, ordering=ordering)
end

function reduced_groebner_basis(M::SubquoModule, ord::ModuleOrdering = default_ordering(M))
  if !haskey(M.groebner_basis, ord) || !(M.groebner_basis[ord].is_reduced)
    if !isdefined(M, :quo)
      M.groebner_basis[ord] = reduced_groebner_basis(M.sub, ord)
    else
      quo_gb = reduced_groebner_basis(M.quo, ord)
      sub_union_gb_of_quo = SubModuleOfFreeModule(M.F, ModuleGens(vcat(oscar_generators(M.sub.gens), oscar_generators(quo_gb)), M.F))
      gb = reduced_groebner_basis(sub_union_gb_of_quo, ord)
      rel_gb_list = Vector{elem_type(ambient_free_module(M))}()

      SG = singular_generators(gb)
      for (i, vo) in enumerate(oscar_generators(gb))
        if !iszero(_reduce(SG[i], singular_generators(quo_gb)))
          push!(rel_gb_list, vo)
        end
      end

      rel_gb_ModuleGens = ModuleGens(rel_gb_list, M.F)
      rel_gb_ModuleGens.isGB = true
      rel_gb_ModuleGens.is_reduced = true
      rel_gb_ModuleGens.quo_GB = quo_gb
      if !haskey(M.groebner_basis, ord)
        M.groebner_basis[ord] = rel_geb_ModuleGens
      else
        set_attribute!(M.groebner_basis[ord], :reduced_groebner_basis => rel_gb_ModuleGens)
        return rel_geb_ModuleGens
      end
    end
  end
  return M.groebner_basis[ord]
end

function leading_module(M::SubquoModule, ord::ModuleOrdering = default_ordering(M))
  @assert (!isdefined(M, :quo) || length(relations(M)) == 0)
  return SubquoModule(leading_module(M.sub, ord))
end

@doc raw"""
    is_subset(M::SubquoModule{T}, N::SubquoModule{T}) where T

Given subquotients `M` and `N` such that `ambient_module(M) == ambient_module(N)`,
return `true` if `M` is contained in `N`, where `M` and `N` are regarded as submodules 
of the common ambient module.

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> F = free_module(R, 1)
Free module of rank 1 over R

julia> AM = R[x;]
[x]

julia> BM = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> M = subquotient(F, AM, BM)
Subquotient of submodule with 1 generator
  1: x*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> AN = R[x; y]
[x]
[y]

julia> BN = R[x^2+y^4; y^3; z^4]
[x^2 + y^4]
[      y^3]
[      z^4]

julia> N = subquotient(F, AN, BN)
Subquotient of submodule with 2 generators
  1: x*e[1]
  2: y*e[1]
by submodule with 3 generators
  1: (x^2 + y^4)*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> is_subset(M, N)
true
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> F = graded_free_module(Rg, 2);

julia> O1 = [x*F[1]+y*F[2],y*F[2]];

julia> O1a = [x*F[1],y*F[2]];

julia> O2 = [x^2*F[1]+y^2*F[2],y^2*F[2]];

julia> M1 = subquotient(F, O1, O2)
Graded subquotient of graded submodule of F with 2 generators
  1: x*e[1] + y*e[2]
  2: y*e[2]
by graded submodule of F with 2 generators
  1: x^2*e[1] + y^2*e[2]
  2: y^2*e[2]

julia> M2 = subquotient(F, O1a, O2)
Graded subquotient of graded submodule of F with 2 generators
  1: x*e[1]
  2: y*e[2]
by graded submodule of F with 2 generators
  1: x^2*e[1] + y^2*e[2]
  2: y^2*e[2]

julia> is_subset(M1,M2)
true

julia> is_subset(M2,M1)
true

julia> M1 == M2
true
```
"""
function is_subset(M::SubquoModule{T}, N::SubquoModule{T}) where T
  if !isdefined(M, :quo) 
    if !isdefined(N, :quo)
      return issubset(M.sub, N.sub)
    else
      return iszero(N.quo) && issubset(M.sub, N.sub)
    end
  else
    if !isdefined(N, :quo)
      return iszero(M.quo) && issubset(M.sub, N.sub)
    else
      return M.quo == N.quo && issubset(M.sum, N.sum)
    end
  end
end

function compare_helper(M::SubquoModule{T}, N::SubquoModule{T}, comparer::Function) where {T}
  if !isdefined(M, :quo) 
    if !isdefined(N, :quo)
      return comparer(M.sub, N.sub)
    else
      return iszero(N.quo) && comparer(M.sub, N.sub)
    end
  else
    if !isdefined(N, :quo)
      return iszero(M.quo) && comparer(M.sub, N.sub)
    else
      return comparer(M.quo, N.quo) && comparer(M.sum, N.sum)
    end
  end
end

@doc raw"""
    ==(M::SubquoModule{T}, N::SubquoModule{T}) where {T}

Given subquotients `M` and `N` such that `ambient_module(M) == ambient_module(N)`,
return `true` if `M` equals `N`, where `M` and `N` are regarded as submodules 
of the common ambient module.

Here, `ambient_module(M) == ambient_module(N)` if

- `ambient_free_module(M) === ambient_free_module(N)`, and
- the submodules of the common ambient free module generated by the relations of `M` and `N`, respectively, are equal.

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> F = free_module(R, 1)
Free module of rank 1 over R

julia> AM = R[x;]
[x]

julia> BM = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> M = subquotient(F, AM, BM)
Subquotient of submodule with 1 generator
  1: x*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> AN = R[x; y]
[x]
[y]

julia> BN = R[x^2+y^4; y^3; z^4]
[x^2 + y^4]
[      y^3]
[      z^4]

julia> N = subquotient(F, AN, BN)
Subquotient of submodule with 2 generators
  1: x*e[1]
  2: y*e[1]
by submodule with 3 generators
  1: (x^2 + y^4)*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> M == N
false
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> F = graded_free_module(Rg, 2);

julia> O1 = [x*F[1]+y*F[2],y*F[2]];

julia> O1a = [x*F[1],y*F[2]];

julia> O2 = [x^2*F[1]+y^2*F[2],y^2*F[2]];

julia> M1 = subquotient(F, O1, O2)
Graded subquotient of graded submodule of F with 2 generators
  1: x*e[1] + y*e[2]
  2: y*e[2]
by graded submodule of F with 2 generators
  1: x^2*e[1] + y^2*e[2]
  2: y^2*e[2]

julia> M2 = subquotient(F, O1a, O2)
Graded subquotient of graded submodule of F with 2 generators
  1: x*e[1]
  2: y*e[2]
by graded submodule of F with 2 generators
  1: x^2*e[1] + y^2*e[2]
  2: y^2*e[2]

julia> M1 == M2
true
```
"""
function (==)(M::SubquoModule{T}, N::SubquoModule{T}) where {T} # TODO replace implementation by two inclusion checks?
  return compare_helper(M, N, (==))
end

@doc raw"""
    is_canonically_isomorphic(M::SubquoModule{T}, N::SubquoModule{T}) where {T}

Check if `M` and `N` are isomorphic under `canonical_isomorphism(F, G)` where
`F` and `G` are the ambient free modules of `M` and `N` respectively.
Return `false` if the ambient free modules are not isomorphic.

```jldoctest
julia> Rg, (x, y) = graded_polynomial_ring(QQ, [:x, :y]);

julia> F1 = graded_free_module(Rg,[2,3, 4])
Graded free module Rg^1([-2]) + Rg^1([-3]) + Rg^1([-4]) of rank 3 over Rg

julia> A1 = Rg[x^3 x^2 x; (2*x^2+x*y)*x^2 (2*y^2+x^2)*x x^2]
[          x^3             x^2     x]
[2*x^4 + x^3*y   x^3 + 2*x*y^2   x^2]

julia> M1 = image(F1, A1)
Graded submodule of F1 with 2 generators
  1: x^3*e[1] + x^2*e[2] + x*e[3]
  2: (2*x^4 + x^3*y)*e[1] + (x^3 + 2*x*y^2)*e[2] + x^2*e[3]
represented as subquotient with no relations

julia> F2 = graded_free_module(Rg,[2,4, 3])
Graded free module Rg^1([-2]) + Rg^1([-4]) + Rg^1([-3]) of rank 3 over Rg

julia> A2 = Rg[x^3 x x^2; (2*x^2+x*y)*x^2 x^2 (2*y^2+x^2)*x]
[          x^3     x             x^2]
[2*x^4 + x^3*y   x^2   x^3 + 2*x*y^2]

julia> M2 = image(F2, A2)
Graded submodule of F2 with 2 generators
  1: x^3*e[1] + x*e[2] + x^2*e[3]
  2: (2*x^4 + x^3*y)*e[1] + x^2*e[2] + (x^3 + 2*x*y^2)*e[3]
represented as subquotient with no relations

julia> is_canonically_isomorphic(M1, M2)
true

```
"""
function is_canonically_isomorphic(M::SubquoModule{T}, N::SubquoModule{T}) where {T}
  F = ambient_free_module(M)
  G = ambient_free_module(N)
  if !is_isomorphic(F, G)
    return false
  end
  return compare_helper(M, N, is_canonically_isomorphic)
end

@doc raw"""
    is_canonically_isomorphic_with_map(M::SubquoModule{T}, N::SubquoModule{T}) where {T}

Check if `M` and `N` are isomorphic under `canonical_isomorphism(F, G)` where
`F` and `G` are the ambient free modules of `M` and `N` respectively.
Moreover, if `M` and `N` are canonically isomorphic then return also the isomorphism, 
otherwise return the zero map.

```jldoctest
julia> Rg, (x, y) = graded_polynomial_ring(QQ, [:x, :y]);

julia> F1 = graded_free_module(Rg,[2,3, 4])
Graded free module Rg^1([-2]) + Rg^1([-3]) + Rg^1([-4]) of rank 3 over Rg

julia> A1 = Rg[x^3 x^2 x; (2*x^2+x*y)*x^2 (2*y^2+x^2)*x x^2]
[          x^3             x^2     x]
[2*x^4 + x^3*y   x^3 + 2*x*y^2   x^2]

julia> M1 = image(F1, A1)
Graded submodule of F1 with 2 generators
  1: x^3*e[1] + x^2*e[2] + x*e[3]
  2: (2*x^4 + x^3*y)*e[1] + (x^3 + 2*x*y^2)*e[2] + x^2*e[3]
represented as subquotient with no relations

julia> F2 = graded_free_module(Rg,[2,4, 3])
Graded free module Rg^1([-2]) + Rg^1([-4]) + Rg^1([-3]) of rank 3 over Rg

julia> A2 = Rg[x^3 x x^2; (2*x^2+x*y)*x^2 x^2 (2*y^2+x^2)*x]
[          x^3     x             x^2]
[2*x^4 + x^3*y   x^2   x^3 + 2*x*y^2]

julia> M2 = image(F2, A2)
Graded submodule of F2 with 2 generators
  1: x^3*e[1] + x*e[2] + x^2*e[3]
  2: (2*x^4 + x^3*y)*e[1] + x^2*e[2] + (x^3 + 2*x*y^2)*e[3]
represented as subquotient with no relations

julia> is_canonically_isomorphic_with_map(M1, M2)
(true, Hom: M1 -> M2)

```
"""
function is_canonically_isomorphic_with_map(M::SubquoModule{T}, N::SubquoModule{T}) where {T}
  is_canonically_iso = is_canonically_isomorphic(M, N)
  if is_canonically_iso
    F = ambient_free_module(M)
    G = ambient_free_module(N)
    f = canonical_isomorphism(F, G)
    f = induced_map(f, M, false) # is certainly well-defined
    f = restrict_codomain(f, N)
    return true, f
  else
    return false, hom(M, N, [zero(N) for _ in 1:gens(M)])
  end
end

@doc raw"""
    sum(M::SubquoModule{T},N::SubquoModule{T}) where T

Given subquotients `M` and `N` such that `ambient_module(M) == ambient_module(N)`,
return the sum of `M` and `N` regarded as submodules of the common ambient module.

Additionally, return the inclusion maps `M` $\to$ `M + N` and `N` $\to$ `M + N`.

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> F = free_module(R, 1)
Free module of rank 1 over R

julia> AM = R[x;]
[x]

julia> BM = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> M = subquotient(F, AM, BM)
Subquotient of submodule with 1 generator
  1: x*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> AN = R[y;]
[y]

julia> BN = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> N = subquotient(F, AN, BN)
Subquotient of submodule with 1 generator
  1: y*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> O = sum(M, N);

julia> O[1]
Subquotient of submodule with 2 generators
  1: x*e[1]
  2: y*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> O[2]
Module homomorphism
  from M
  to subquotient of submodule with 2 generators
    1: x*e[1]
    2: y*e[1]
  by submodule with 3 generators
    1: x^2*e[1]
    2: y^3*e[1]
    3: z^4*e[1]

julia> O[3]
Module homomorphism
  from N
  to subquotient of submodule with 2 generators
    1: x*e[1]
    2: y*e[1]
  by submodule with 3 generators
    1: x^2*e[1]
    2: y^3*e[1]
    3: z^4*e[1]
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> F = graded_free_module(Rg, 1);

julia> AM = Rg[x;];

julia> BM = Rg[x^2; y^3; z^4];

julia> M = subquotient(F, AM, BM)
Graded subquotient of graded submodule of F with 1 generator
  1: x*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> AN = Rg[y;];

julia> BN = Rg[x^2; y^3; z^4];

julia> N = subquotient(F, AN, BN)
Graded subquotient of graded submodule of F with 1 generator
  1: y*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> sum(M, N)
(Graded subquotient of graded submodule of F with 2 generators
  1: x*e[1]
  2: y*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1], Hom: M -> graded subquotient of graded submodule of F with 2 generators
  1: x*e[1]
  2: y*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1], Hom: N -> graded subquotient of graded submodule of F with 2 generators
  1: x*e[1]
  2: y*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1])

```
"""
function sum(M::SubquoModule{T},N::SubquoModule{T}) where T
  @assert ambient_free_module(M) === ambient_free_module(N)

  if !isdefined(M, :quo) && !isdefined(N, :quo)
    SQ = SubquoModule(sum(M.sub,N.sub))
  else

    M_quo = isdefined(M, :quo) ? M.quo : SubModuleOfFreeModule(ambient_free_module(M), Vector{elem_type(ambient_free_module(M))}())
    N_quo = isdefined(N, :quo) ? N.quo : SubModuleOfFreeModule(ambient_free_module(N), Vector{elem_type(ambient_free_module(N))}())
  
    if M_quo == N_quo
      SQ = SubquoModule(sum(M.sub,N.sub),M_quo)
    else
      error("Relations are not equal")
    end
  end

  iM = SubQuoHom(M,SQ,[SQ[i] for i=1:ngens(M)]; check=false)
  iN = SubQuoHom(N,SQ,[SQ[i] for i=ngens(M)+1:ngens(SQ)]; check=false)

  register_morphism!(iM)
  register_morphism!(iN)

  SQ_simplified, _, s_proj = simplify_light(SQ)
  return SQ_simplified, iM*s_proj, iN*s_proj
end

@doc raw"""
    +(M::SubquoModule{T},N::SubquoModule{T}) where T

Given subquotients `M` and `N` such that `ambient_module(M) == ambient_module(N)`,
return the sum of `M` and `N` regarded as submodules of the common ambient module. 

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> F = free_module(R, 1)
Free module of rank 1 over R

julia> AM = R[x;]
[x]

julia> BM = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> M = subquotient(F, AM, BM)
Subquotient of submodule with 1 generator
  1: x*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> AN = R[y;]
[y]

julia> BN = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> N = subquotient(F, AN, BN)
Subquotient of submodule with 1 generator
  1: y*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> O = M + N
Subquotient of submodule with 2 generators
  1: x*e[1]
  2: y*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> F = graded_free_module(Rg, 1);

julia> AM = Rg[x;];

julia> BM = Rg[x^2; y^3; z^4];

julia> M = subquotient(F, AM, BM)
Graded subquotient of graded submodule of F with 1 generator
  1: x*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> AN = Rg[y;];

julia> BN = Rg[x^2; y^3; z^4];

julia> N = subquotient(F, AN, BN)
Graded subquotient of graded submodule of F with 1 generator
  1: y*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> M + N
Graded subquotient of graded submodule of F with 2 generators
  1: x*e[1]
  2: y*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

```
"""
function +(M::SubquoModule{T},N::SubquoModule{T}) where T
  return sum(M,N)[1]
end

@doc raw"""
    intersect(M::SubquoModule{T}, N::SubquoModule{T}) where T

Given subquotients `M` and `N` such that `ambient_module(M) == ambient_module(N)`,
return the intersection of `M` and `N` regarded as submodules of the common ambient module.

Additionally, return the inclusion maps `M` $\cap$ `N` $\to$ `M` and `M` $\cap$ `N` $\to$ `N`.

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> F = free_module(R, 1)
Free module of rank 1 over R

julia> AM = R[x;]
[x]

julia> BM = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> M = subquotient(F, AM, BM)
Subquotient of submodule with 1 generator
  1: x*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> AN = R[y;]
[y]

julia> BN = R[x^2; y^3; z^4]
[x^2]
[y^3]
[z^4]

julia> N = subquotient(F, AN, BN)
Subquotient of submodule with 1 generator
  1: y*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> intersect(M, N)
(Subquotient of submodule with 2 generators
  1: -x*y*e[1]
  2: x*z^4*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1], Hom: subquotient of submodule with 2 generators
  1: -x*y*e[1]
  2: x*z^4*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1] -> M, Hom: subquotient of submodule with 2 generators
  1: -x*y*e[1]
  2: x*z^4*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1] -> N)
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> F = graded_free_module(Rg, 1);

julia> AM = Rg[x;];

julia> BM = Rg[x^2; y^3; z^4];

julia> M = subquotient(F, AM, BM)
Graded subquotient of graded submodule of F with 1 generator
  1: x*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> AN = Rg[y;];

julia> BN = Rg[x^2; y^3; z^4];

julia> N = subquotient(F, AN, BN)
Graded subquotient of graded submodule of F with 1 generator
  1: y*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> intersect(M, N)
(Graded subquotient of graded submodule of F with 2 generators
  1: -x*y*e[1]
  2: x*z^4*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1], Hom: graded subquotient of graded submodule of F with 2 generators
  1: -x*y*e[1]
  2: x*z^4*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1] -> M, Hom: graded subquotient of graded submodule of F with 2 generators
  1: -x*y*e[1]
  2: x*z^4*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1] -> N)

```
"""
function intersect(M::SubquoModule{T}, N::SubquoModule{T}) where T
  #TODO allow task as argument?
  @assert ambient_free_module(M) === ambient_free_module(N)
  M_quo = isdefined(M, :quo) ? M.quo : SubModuleOfFreeModule(ambient_free_module(M), Vector{elem_type(ambient_free_module(M))}())
  N_quo = isdefined(N, :quo) ? N.quo : SubModuleOfFreeModule(ambient_free_module(N), Vector{elem_type(ambient_free_module(N))}())
  R = base_ring(M)

  if M_quo == N_quo

    F1 = FreeMod(R, ngens(M.sub) + ngens(N.sub) + ngens(M_quo))
    F2 = ambient_free_module(M)
    phi = FreeModuleHom(F1,F2,vcat(gens(M.sub),gens(N.sub),gens(M_quo)); check=false)
    K,i = kernel(phi)

    intersection_gens_array_with_zeros = [sum([repres(k)[i]*M.sub[i] for i=1:ngens(M.sub)]; init=zero(ambient_free_module(M))) for k in gens(K)]
    iszero_array = map(!iszero, intersection_gens_array_with_zeros)

    intersection_gens = SubModuleOfFreeModule(ambient_free_module(M), intersection_gens_array_with_zeros[iszero_array] )
    SQ = SubquoModule(intersection_gens,M_quo)

    m = ngens(M)
    M_hom = SubQuoHom(SQ,M,[sum([repres(k)[i]*M[i] for i=1:m]; init=zero(M)) for k in gens(K)][iszero_array]; check=false)
    N_hom = SubQuoHom(SQ,N,[sum([repres(k)[i]*N[i-m] for i=m+1:m+ngens(N)]; init=zero(N)) for k in gens(K)][iszero_array]; check=false)

    register_morphism!(M_hom)
    register_morphism!(N_hom)

    SQ_simplified, s_inj, _ = simplify_light(SQ)
    return SQ_simplified, s_inj*M_hom, s_inj*N_hom
  end
  throw(ArgumentError("Relations of M and N are not equal."))
end

########################################
# module quotients
########################################

@doc raw"""
     annihilator(N::SubquoModule{T}) where T

Return the annihilator of `N`.

!!! note
    By definition, the annihilator of $N$ is the ideal $0:N = \{a \in R \mid aN = 0\}$. 
    Here, `R = base_ring(N)`.

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> F = free_module(R, 1);

julia> AN = R[y;];

julia> BN = R[x^2; y^3; z^4];

julia> N = subquotient(F, AN, BN)
Subquotient of submodule with 1 generator
  1: y*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> J = annihilator(N)
Ideal generated by
  y^2
  x^2
  z^4

```

```jldoctest
julia> S, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> I = ideal(S, [x*y*z])
Ideal generated by
  x*y*z

julia> R, _ = quo(S, I)
(Quotient of multivariate polynomial ring by ideal (x*y*z), Map: S -> R)

julia> F = free_module(R, 1);

julia> AN = R[y;];

julia> BN = R[x^2; y^3; z^4];

julia> N = subquotient(F, AN, BN)
Subquotient of submodule with 1 generator
  1: y*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> J = annihilator(N)
Ideal generated by
  x*z
  y^2
  x^2
  z^4
```
"""
function annihilator(M::SubquoModule{T}) where T
  R = base_ring(M)
  F = FreeMod(R, 1)
  I = ideal(R, [one(R)])
  for v in gens(M)
    h = hom(F, M, [v])
    K, _ = kernel(h)
    # this is a hack, because getindex is broken for K
    g = Oscar.as_matrix(F, ambient_representatives_generators(K))
    I = intersect(I, ideal(R, minors(g, 1)))
  end
  return I
end

function annihilator(N::SubquoModule{T}) where T <: Union{MPolyRingElem, MPolyQuoRingElem}
  R = base_ring(N)
  N_quo = isdefined(N, :quo) ? N.quo : SubModuleOfFreeModule(ambient_free_module(N), Vector{elem_type(ambient_free_module(N))}())
  A = N.sub
  SA = singular_generators(A.gens) 
  B = N_quo
  SB = singular_generators(B.gens)
  return R isa MPolyQuoRing ? MPolyQuoIdeal(R, Singular.quotient(SB, SA)) : MPolyIdeal(R, Singular.quotient(SB, SA))
end

@doc raw"""
    quotient(M::SubquoModule{T}, N::SubquoModule{T}) where T

Given subquotients `M` and `N` such that `ambient_module(M) == ambient_module(N)`,
return the module quotient of `M` by `N` regarded as submodules of the common ambient module.

Alternatively, use `M:N`.

!!! note
    By definition, $M:N = \{a \in R \mid aN \subset M\}$. Here, `R = base_ring(M) = base_ring(N)`.

# Examples

```jldoctest
julia> R, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> F = graded_free_module(R, 1);

julia> B = R[x^2; y^3; z^4];

julia> AM = R[x;];

julia> M = subquotient(F, AM, B)
Graded subquotient of graded submodule of F with 1 generator
  1: x*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> AN = R[y;];

julia> N = subquotient(F, AN, B)
Graded subquotient of graded submodule of F with 1 generator
  1: y*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> L = quotient(M, N)
Ideal generated by
  x
  y^2
  z^4

```
"""
function quotient(M::SubquoModule{T}, N::SubquoModule{T}) where T
  @assert base_ring(M) == base_ring(N)
  @assert ambient_module(M) == ambient_module(N)
  MplusN, iM, _ = sum(M, N)
  Q, _ = quo(MplusN, [iM(x) for x in gens(M)])
  return annihilator(Q)
end

(::Colon)(M::SubquoModule{T}, N::SubquoModule{T}) where T = quotient(M, N)

@doc raw"""
     quotient(M::SubquoModule, J::Ideal)

Return the quotient of `M` by `J`.

Alternatively, use `M:J`.

!!! note
    By definition, $M:J = \{a \in A \mid Ja \subset M\}$. Here, $A$ is the
    ambient module of $M$.

# Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> F = free_module(R, 1);

julia> AM = R[x;];

julia> BM = R[x^2; y^3; z^4];

julia> M = subquotient(F, AM, BM)
Subquotient of submodule with 1 generator
  1: x*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> J = ideal(R, [x, y, z])^2
Ideal generated by
  x^2
  x*y
  x*z
  y^2
  y*z
  z^2

julia> L = quotient(M, J)
Subquotient of submodule with 3 generators
  1: x*e[1]
  2: y*z^3*e[1]
  3: y^2*z^2*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> ambient_free_module(L) == ambient_free_module(M)
true

```

```jldoctest
julia> S, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> R, _ = quo(S, ideal(S, [x+y+z]));

julia> F = free_module(R, 1);

julia> AM = R[x;];

julia> BM = R[x^2; y^3; z^4];

julia> M = subquotient(F, AM, BM)
Subquotient of submodule with 1 generator
  1: (-y - z)*e[1]
by submodule with 3 generators
  1: (y^2 + 2*y*z + z^2)*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> J = ideal(R, [x, y, z])^2
Ideal generated by
  x^2
  x*y
  x*z
  y^2
  y*z
  z^2

julia> quotient(M, J)
Subquotient of submodule with 2 generators
  1: z*e[1]
  2: y*e[1]
by submodule with 3 generators
  1: (y^2 + 2*y*z + z^2)*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

```
"""
function quotient(M::SubquoModule, J::Ideal)
  @assert base_ring(M) == base_ring(J)
  M_quo = isdefined(M, :quo) ? M.quo : SubModuleOfFreeModule(ambient_free_module(M), Vector{elem_type(ambient_free_module(M))}())
  U = M.sub+M.quo
  UF = _quotient(U, J)
  res = SubquoModule(UF)
  res.quo = M.quo
  return simplify_light(res)[1]
end

(::Colon)(M::SubquoModule, J::Ideal) = quotient(M, N)

function _quotient(U::SubModuleOfFreeModule, J::Ideal) ### TODO Replace by generic method
  error("not implemented for the given types of modules.")
end

function _quotient(U::SubModuleOfFreeModule, J::Ideal{T}) where T <: Union{MPolyRingElem, MPolyQuoRingElem}
  F = ambient_free_module(U)
  SgU = singular_generators(U.gens)
  SgJ = singular_generators(J.gens)
  SQ = Singular.quotient(SgU, SgJ)
  MG = ModuleGens(F, SQ)
  return SubModuleOfFreeModule(F, MG)
end

########################################
### saturation for modules
########################################

@doc raw"""
     saturation(M::SubquoModule,
               J::Ideal = ideal(base_ring(M), gens(base_ring(M)));
               iteration::Bool = false)

Return the saturation $M:J^{\infty}$ of `M` with respect to `J`.

If the ideal `J` is not given, the ideal generated by the generators (variables) of `base_ring(M)` is used.

Setting `iteration` to `true` only has an effect over rings of type `MPolyRing` or `MPolyQuoRing`. Over such rings,
if `iteration` is set to `true`, the saturation is done by carrying out successive ideal quotient computations as
suggested by the definition of saturation. Otherwise, a more sophisticated Gröbner basis approach is used which is typically
faster. Applying the two approaches may lead to different generating sets of the saturation.

!!! note
    By definition,
    $M:J^{\infty} = \{ a \in A \mid J^ka \subset M \text{ for some } k\geq 1 \} = \bigcup\limits_{k=1}^{\infty} (M:J^k).$
    Here, $A$ is the ambient module of $M$.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> F = free_module(R, 1);

julia> AM = R[x;];

julia> BM = R[x^2; y^3; z^4];

julia> M = subquotient(F, AM, BM)
Subquotient of submodule with 1 generator
  1: x*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> J = ideal(R, [x, y, z])^2
Ideal generated by
  x^2
  x*y
  x*z
  y^2
  y*z
  z^2

julia> saturation(M, J)
Subquotient of submodule with 1 generator
  1: e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

```
"""
function saturation(M::SubquoModule, J::Ideal = ideal(base_ring(M), gens(base_ring(M))); iteration::Bool = false)
  @assert base_ring(M) == base_ring(J)
  M_quo = isdefined(M, :quo) ? M.quo : SubModuleOfFreeModule(ambient_free_module(M), Vector{elem_type(ambient_free_module(M))}())
  U = M.sub+M.quo
  UF = _saturation(U, J; iteration = iteration)
  res = SubquoModule(UF)
  res.quo = M.quo
  return simplify_light(res)[1]
end

function _saturation(U::SubModuleOfFreeModule, J::Ideal) ### TODO Replace by generic method
  error("not implemented for the given types of modules.")
end

function _saturation(U::SubModuleOfFreeModule, J::Ideal{T}; iteration::Bool = false) where T <: Union{MPolyRingElem, MPolyQuoRingElem}
  F = ambient_free_module(U)
  SgU = singular_generators(U.gens)
  SgJ = singular_generators(J.gens)
  SQ, _ = Singular.saturation(SgU, SgJ)
  MG = ModuleGens(F, SQ)
  return SubModuleOfFreeModule(F, MG)
end

@doc raw"""
     saturation_with_index(M::SubquoModule,
               J::MPolyIdeal = ideal(base_ring(M), gens(base_ring(M)));
               iteration::Bool = false)


Return the saturation $M:J^{\infty}$ of $M$ with respect to $J$ and the smallest integer $k$ such that $I:J^k = I:J^{\infty}$ (saturation index).

If the ideal `J` is not given, the ideal generated by the generators (variables) of `base_ring(M)` is used.

Setting `iteration` to `true` only has an effect over rings of type `MPolyRing` or `MPolyQuoRing`. Over such rings,
if `iteration` is set to `true`, the saturation is done by carrying out successive module quotient computations as
suggested by the definition of saturation. Otherwise, a more sophisticated Gröbner basis approach is used which is typically
faster. Applying the two approaches may lead to different generating sets of the saturation.

!!! note
    By definition,
    $M:J^{\infty} = \{ a \in A \mid J^ka \subset M \text{ for some } k\geq 1 \} = \bigcup\limits_{k=1}^{\infty} (M:J^k).$
    Here, $A$ is the ambient module of $M$.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> F = free_module(R, 1);

julia> AM = R[x;];

julia> BM = R[x^2; y^3; z^4];

julia> M = subquotient(F, AM, BM)
Subquotient of submodule with 1 generator
  1: x*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> J = ideal(R, [x, y, z])^2
Ideal generated by
  x^2
  x*y
  x*z
  y^2
  y*z
  z^2

julia> L = saturation_with_index(M, J);

julia> L[1]
Subquotient of submodule with 1 generator
  1: e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> L[2]
3

```

```jldoctest
julia> S, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> R, _ = quo(S, ideal(S, [x+y+z]));

julia> F = free_module(R, 1);

julia> AM = R[x;];

julia> BM = R[x^2; y^3; z^4];

julia> M = subquotient(F, AM, BM)
Subquotient of submodule with 1 generator
  1: (-y - z)*e[1]
by submodule with 3 generators
  1: (y^2 + 2*y*z + z^2)*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> J = ideal(R, [x, y, z])^2
Ideal generated by
  x^2
  x*y
  x*z
  y^2
  y*z
  z^2

julia> L = saturation_with_index(M, J);

julia> L[1]
Subquotient of submodule with 1 generator
  1: e[1]
by submodule with 3 generators
  1: (y^2 + 2*y*z + z^2)*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> L[2]
2

```
"""
function saturation_with_index(M::SubquoModule, J::Ideal = ideal(base_ring(M), gens(base_ring(M))); iteration::Bool = false)
@assert base_ring(M) == base_ring(J)
  M_quo = isdefined(M, :quo) ? M.quo : SubModuleOfFreeModule(ambient_free_module(M), Vector{elem_type(ambient_free_module(M))}())
  U = M.sub+M.quo
  UF, k = _saturation_with_index(U, J; iteration = iteration)
  res = SubquoModule(UF)
  res.quo = M.quo
  return simplify_light(res)[1], k
end

function _saturation_with_index(U::SubModuleOfFreeModule, J::Ideal) ### TODO Replace by generic method
  error("not implemented for the given types of modules.")
end

function _saturation_with_index(U::SubModuleOfFreeModule, J::Ideal{T}; iteration::Bool = false) where T <: Union{MPolyRingElem, MPolyQuoRingElem}
  F = ambient_free_module(U)
  SgU = singular_generators(U.gens)
  SgJ = singular_generators(J.gens)
  SQ, k = Singular.saturation(SgU, SgJ)
  MG = ModuleGens(F, SQ)
  return SubModuleOfFreeModule(F, MG), k
end

########################################


@doc raw"""
    represents_element(a::FreeModElem, SQ::SubquoModule)

Check if `a` represents an element `SQ`.
"""
function represents_element(a::FreeModElem, SQ::SubquoModule)
  return in(a, SQ.sum)
end



@doc raw"""
    reduce(v::FreeModElem, N::SubquoModule)

Let `N` be a submodule of a free module (that is, `N` has no quotient).
Reduce the element `v` with respect to a Gröbner basis of `N`.
"""
function reduce(v::AbstractFreeModElem, N::SubquoModule)
  @assert !(isdefined(N, :quo))
  return reduce(v, groebner_basis(N))
end

@doc raw"""
    ambient_free_module(M::SubquoModule)

Return the ambient free module of `M`.
"""
function ambient_free_module(M::SubquoModule)
  return M.F
end

@doc raw"""
    ambient_module(M::SubquoModule, task = :none)

If $M = (P + Q) / Q$ then return $F / Q$ where `F == ambient_free_module(M)`.
If $M$ is a submodule of a free module, then the (ambient) free module is returned.

If `task == :with_morphism`, return also the canonical inclusion.

# Examples

```jldoctest
julia> mat = matrix(QQ, [0 -1; 0 0]);

julia> U = image(mat)
Submodule with 1 generator
  1: -e[2]
represented as subquotient with no relations

julia> ambient_module(U)
Free module of rank 2 over rational field
```
"""
function ambient_module(M::SubquoModule, task = :none)
  F = ambient_free_module(M)
  if !isdefined(M, :quo)
    if task == :none
      return F
    else
      return F, hom(M,F,[repres(v) for v in gens(M)])
    end
  end
  g = SubModuleOfFreeModule(F,basis(F))
  SQ = SubquoModule(g, M.quo)
  if task == :none
    return SQ
  else
    return SQ, hom(M,SQ,[SubquoModuleElem(coordinates(repres(v)), SQ) for v in gens(M)])
  end
end

@doc raw"""
    ambient_representatives_generators(M::SubquoModule)

Return elements of the ambient free module of `M` which represent the generators of `M`.
"""
function ambient_representatives_generators(M::SubquoModule)
  G = ambient_free_module(M)
  return [FreeModElem(coordinates(repres(x)), G) for x in gens(M)]
end


@doc raw"""
    rels(M::SubquoModule)

Return the relations of `M`.
"""
rels(M::SubquoModule) = isdefined(M, :quo) ? collect(M.quo.gens) : elem_type(M.F)[]

@doc raw"""
    relations(M::SubquoModule)

Return the relations of `M`.
"""
relations(M::SubquoModule) = rels(M)

# the two methods below are needed for the implementation of is_surjective
function (==)(G::SubquoModule, F::FreeMod)
  return F == G
end

function (==)(F::FreeMod, G::SubquoModule)
  base_ring(F) === base_ring(G) || return false
  ambient_free_module(G) === F || return false
  if isdefined(G, :quo) 
    iszero(G.quo) || return false
  end
  all(in(G), gens(F)) || return false
  return true
end
