####################

@doc raw"""
    presentation(M::SubquoModule)

Return a free presentation of `M`. 
"""
function presentation(SQ::SubquoModule)
  #A+B/B is generated by A and B
  #the relations are A meet B? written wrt to A
  R = base_ring(SQ)
  if is_graded(SQ)
    h_F_SQ = graded_map(SQ, gens(SQ))
    F = domain(h_F_SQ)
  else
    F = FreeMod(R, ngens(SQ.sub))
    h_F_SQ = hom(F, SQ, gens(SQ)) # DO NOT CHANGE THIS LINE, see present_as_cokernel and preimage
  end
  br_name = AbstractAlgebra.find_name(R)
  if br_name === nothing
    br_name = "br"
  end
  set_attribute!(F,  :name => "$br_name^$(ngens(SQ.sub))")
  q = elem_type(F)[]
  if is_generated_by_standard_unit_vectors(SQ.sub)
    if isdefined(SQ, :quo)
      q = [FreeModElem(coordinates(g), F) for g in gens(SQ.quo)]
    end
  else
    if is_graded(SQ)
      s, _ = kernel(graded_map(ambient_free_module(SQ), gens(SQ.sum)))
    else
      s, _ = kernel(hom(FreeMod(R,ngens(SQ.sum)), ambient_free_module(SQ), gens(SQ.sum)))
    end
    #s = syzygy_module(SQ.sum.gens)
    #TODO: wait for Hans to release Modulo(A, B) that does exactly this
    c = collect(s.sub.gens)
    #q = elem_type(F)[]

    for x = c
      b = sparse_row(R)
      e = zero(SQ.F)
      for (i,v) = x.coords
        if i>ngens(SQ)
          break
        end
        e += v*repres(gen(SQ, i))
        push!(b.pos, i)
        push!(b.values, v)
      end
      if length(b) == 0
        continue
      end
      push!(q, FreeModElem(b, F))
    end
  end
  #want R^a -> R^b -> SQ -> 0
  #from Hans:
  # as a complex R^b has index 0
  #              R^a           1
  # so 0 has index -2, hence seed has to be -2
  #TODO sort decoration and fix maps, same decoration should be bundled (to match pretty printing)
  if is_graded(SQ)
    h_G_F = graded_map(F, q)
    G = domain(h_G_F)
  else
    G = FreeMod(R, length(q))
    h_G_F = hom(G, F, q)
  end
  br_name = AbstractAlgebra.find_name(F.R)
  if br_name === nothing
    br_name = "br"
  end
  set_attribute!(G, :name => "$br_name^$(length(q))")
  if is_graded(SQ)
    Z = graded_free_module(F.R, 0)
  else
    Z = FreeMod(F.R, 0)
  end
  set_attribute!(Z, :name => "0")
  h_SQ_Z = hom(SQ, Z, Vector{elem_type(Z)}([zero(Z) for i=1:ngens(SQ)]))
  M = Hecke.ComplexOfMorphisms(ModuleFP, ModuleFPHom[h_G_F, h_F_SQ, h_SQ_Z], check = false, seed = -2)
  set_attribute!(M, :show => Hecke.pres_show)
  return M
end

@doc raw"""
    presentation(F::FreeMod)

Return a free presentation of `F`.
"""
function presentation(F::FreeMod)
  if is_graded(F)
    Z = graded_free_module(F.R, 0)
  else
    Z = FreeMod(F.R, 0)
  end
  set_attribute!(Z, :name => "0")
  M = Hecke.ComplexOfMorphisms(ModuleFP, ModuleFPHom[hom(Z, F, Vector{elem_type(F)}()), hom(F, F, gens(F)), hom(F, Z, Vector{elem_type(Z)}([zero(Z) for i=1:ngens(F)]))], check = false, seed = -2)
  set_attribute!(M, :show => Hecke.pres_show)
  return M
end

@doc raw"""
    presentation(M::ModuleFP)

Return a free presentation of `M`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> A = R[x; y];

julia> B = R[x^2; y^3; z^4];

julia> M = SubquoModule(A, B);

julia> P = presentation(M)
0 <---- M <---- R^2 <---- R^5
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = graded_free_module(Rg, [1,2,2]);

julia> p = presentation(F)
0 <---- F <---- F <---- 0

julia> p[-2]
Graded free module Rg^0 of rank 0 over Rg

julia> p[-1]
Graded free module Rg^1([-1]) + Rg^2([-2]) of rank 3 over Rg

julia> p[0]
Graded free module Rg^1([-1]) + Rg^2([-2]) of rank 3 over Rg

julia> p[1]
Graded free module Rg^0 of rank 0 over Rg

julia> map(p,-1)
F -> 0
e[1] -> 0
e[2] -> 0
e[3] -> 0
Homogeneous module homomorphism

julia> map(p,0)
F -> F
e[1] -> e[1]
e[2] -> e[2]
e[3] -> e[3]
Homogeneous module homomorphism

julia> map(p,1)
0 -> F
Homogeneous module homomorphism

julia> F = graded_free_module(Rg, 1);

julia> A = Rg[x; y];

julia> B = Rg[x^2; y^3; z^4];

julia> M = SubquoModule(F, A, B);

julia> P = presentation(M)
0 <---- M <---- Rg^2 <---- Rg^5

julia> P[-2]
Graded free module Rg^0 of rank 0 over Rg

julia> P[-1]
Graded subquotient of submodule of F generated by
1 -> x*e[1]
2 -> y*e[1]
by submodule of F generated by
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> P[0]
Graded free module Rg^2([-1]) of rank 2 over Rg

julia> P[1]
Graded free module Rg^2([-2]) + Rg^1([-3]) + Rg^2([-5]) of rank 5 over Rg

julia> map(P,-1)
M -> 0
x*e[1] -> 0
y*e[1] -> 0
Homogeneous module homomorphism

julia> map(P,0)
Rg^2 -> M
e[1] -> x*e[1]
e[2] -> y*e[1]
Homogeneous module homomorphism

julia> map(P,1)
Rg^5 -> Rg^2
e[1] -> x*e[1]
e[2] -> -y*e[1] + x*e[2]
e[3] -> y^2*e[2]
e[4] -> z^4*e[1]
e[5] -> z^4*e[2]
Homogeneous module homomorphism
```
"""
function presentation(M::ModuleFP)
 error("presentation is not implemented for the given types.")
end

@doc raw"""
    present_as_cokernel(M::SubquoModule, task::Symbol = :none)

Return a subquotient `C` which is isomorphic to `M`, and whose generators are the standard unit vectors of its ambient free module.

Additionally,

- return an isomorphism `M` $\to$ `C` if `task = :with_morphism`,
- return and cache an isomorphism `M` $\to$ `C` if `task = :cache_morphism`,
- do none of the above if `task = :none` (default).

If `task = :only_morphism`, return only an isomorphism.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> A = R[x; y];

julia> B = R[x^2; y^3; z^4];

julia> M = SubquoModule(A, B)
Subquotient of Submodule with 2 generators
1 -> x*e[1]
2 -> y*e[1]
by Submodule with 3 generators
1 -> x^2*e[1]
2 -> y^3*e[1]
3 -> z^4*e[1]

julia> C = present_as_cokernel(M)
Subquotient of Submodule with 2 generators
1 -> e[1]
2 -> e[2]
by Submodule with 5 generators
1 -> x*e[1]
2 -> -y*e[1] + x*e[2]
3 -> y^2*e[2]
4 -> z^4*e[1]
5 -> z^4*e[2]
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = graded_free_module(Rg, 1);

julia> A = Rg[x; y];

julia> B = Rg[x^2; y^3; z^4];

julia> M = SubquoModule(F, A, B);

julia> present_as_cokernel(M, :with_morphism)
(Graded subquotient of submodule of Rg^2 generated by
1 -> e[1]
2 -> e[2]
by submodule of Rg^2 generated by
1 -> x*e[1]
2 -> -y*e[1] + x*e[2]
3 -> y^2*e[2]
4 -> z^4*e[1]
5 -> z^4*e[2], Graded subquotient of submodule of Rg^2 generated by
1 -> e[1]
2 -> e[2]
by submodule of Rg^2 generated by
1 -> x*e[1]
2 -> -y*e[1] + x*e[2]
3 -> y^2*e[2]
4 -> z^4*e[1]
5 -> z^4*e[2] -> M
e[1] -> x*e[1]
e[2] -> y*e[1]
Homogeneous module homomorphism)
```
"""
function present_as_cokernel(SQ::SubquoModule, task::Symbol = :none)
  chainComplex = presentation(SQ)
  R_b = obj(chainComplex, 0)
  f = map(chainComplex, 1)
  g = map(chainComplex, 0)
  presentation_module = quo(R_b, image(f)[1], :module)

  if task == :none
    return presentation_module
  end
  
  # The isomorphism is just the identity matrix
  isomorphism = hom(presentation_module, SQ, Vector{elem_type(SQ)}([g(x) for x in gens(R_b)]))
  inverse_isomorphism = hom(SQ, presentation_module, Vector{elem_type(presentation_module)}([presentation_module[i] for i=1:ngens(SQ)]))
  isomorphism.inverse_isomorphism = inverse_isomorphism

  if task == :cache_morphism
    register_morphism!(isomorphism)
    register_morphism!(inverse_isomorphism)
  end
  task == :only_morphism && return isomorphism
  
  return presentation_module, isomorphism
end

@doc raw"""
    present_as_cokernel(F::FreeMod, task::Symbol = :none)

Represent `F` as the quotient `C` of itself with no relations. This method exists for compatibility reasons with `present_as_cokernel(M::SubQuoModule, task::Symbol = :none)`. 

Additionally,

- return an isomorphism `F` $\to$ `C` if `task = :with_morphism`,
- return and cache an isomorphism `F` $\to$ `C` if `task = :cache_morphism`,
- do none of the above if `task = :none` (default).

If `task = :only_morphism`, return only an isomorphism.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> F = free_module(R, 2)
Free module of rank 2 over Multivariate polynomial ring in 3 variables over QQ

julia> present_as_cokernel(F)
Submodule with 2 generators
1 -> e[1]
2 -> e[2]
represented as subquotient with no relations.

julia> present_as_cokernel(F, :only_morphism)
Map with following data
Domain:
=======
Free module of rank 2 over Multivariate polynomial ring in 3 variables over QQ
Codomain:
=========
Submodule with 2 generators
1 -> e[1]
2 -> e[2]
represented as subquotient with no relations.
```
"""
function present_as_cokernel(F::FreeMod, task::Symbol = :none)
  presentation_module, isomorphism = quo(F, [zero(F)])
  inverse_isomorphism = hom(presentation_module, F, gens(F))

  if task == :none
    return presentation_module
  end

  if task == :cache_morphism
    register_morphism!(isomorphism)
    register_morphism!(inverse_isomorphism)
  end
  task == :only_morphism && return isomorphism
  
  return presentation_module, isomorphism
end
