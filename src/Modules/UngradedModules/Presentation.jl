####################

@doc raw"""
    presentation(M::SubquoModule; minimal = false)

Return a (free) presentation of `M`.  

!!! note
    If `minimal` is `true`, and `M` is positively graded, a minimal presentation is returned.
    If `minimal` is `true`, and `M` is not (positively) graded, the function still aims at returning an ''improved'' presentation.
"""
function presentation(SQ::SubquoModule;
                      minimal=false)
  if minimal
    return _presentation_minimal(SQ)
  elseif is_graded(SQ)
    return _presentation_graded(SQ)
  else
    return _presentation_simple(SQ)
  end

  # Old code left for debugging
  #=
  #A+B/B is generated by A and B
  #the relations are A meet B? written wrt to A
  R = base_ring(SQ)
  if is_graded(SQ)
    h_F_SQ = graded_map(SQ, gens(SQ); check=false)
    F = domain(h_F_SQ)
  else
    F = FreeMod(R, ngens(SQ.sub))
    h_F_SQ = hom(F, SQ, gens(SQ)) # DO NOT CHANGE THIS LINE, see present_as_cokernel and preimage
  end
  q = elem_type(F)[]
  if is_generated_by_standard_unit_vectors(SQ.sub)
    if isdefined(SQ, :quo)
      q = [FreeModElem(coordinates(g), F) for g in gens(SQ.quo)]
    end
  else
    if is_graded(SQ)
      s, _ = kernel(graded_map(ambient_free_module(SQ), filter(!iszero, gens(SQ.sum)); check=false))
    else
      s, _ = kernel(hom(FreeMod(R,ngens(SQ.sum)), ambient_free_module(SQ), gens(SQ.sum)))
    end
    #s = syzygy_module(SQ.sum.gens)
    #TODO: wait for Hans to release Modulo(A, B) that does exactly this
    c = collect(s.sub.gens)
    #q = elem_type(F)[]

    for x = c
      b = sparse_row(R)
      for (i,v) in coordinates(x)
        if i>ngens(SQ)
          break
        end
        push!(b.pos, i)
        push!(b.values, v)
      end
      if length(b) == 0
        continue
      end
      push!(q, FreeModElem(b, F))
    end
  end
  for i in 1:length(q)
    if !is_homogeneous(q[i])
      for m in terms(q[i])
      end
    end
  end
  #want R^a -> R^b -> SQ -> 0
  #from Hans:
  # as a complex R^b has index 0
  #              R^a           1
  # so 0 has index -2, hence seed has to be -2
  #TODO sort decoration and fix maps, same decoration should be bundled (to match pretty printing)
  q = elem_type(F)[g for g in q if !is_zero(g)]
  if is_graded(SQ)
    h_G_F = graded_map(F, q; check=false)
    G = domain(h_G_F)
  else
    G = FreeMod(R, length(q))
    h_G_F = hom(G, F, q)
  end
  if is_graded(SQ)
    Z = graded_free_module(F.R, 0)
  else
    Z = FreeMod(F.R, 0)
  end
  h_SQ_Z = hom(SQ, Z, Vector{elem_type(Z)}([zero(Z) for i=1:ngens(SQ)]))
  M = Hecke.ComplexOfMorphisms(ModuleFP, ModuleFPHom[h_G_F, h_F_SQ, h_SQ_Z], check = false, seed = -2)
  set_attribute!(M, :show => Hecke.pres_show)
  return M
  =#
end

function _presentation_graded(SQ::SubquoModule)
  #any(iszero(a) for a in gens(SQ)) && error("generators must not be zero for presentations in the graded case")
  R = base_ring(SQ)

  # Create the free module for the presentation
  #
  # We have to take representatives of the simplified 
  # generators, because otherwise the degrees are not correctly
  # inferred. 
  #
  # At the same time, we can not just throw away zero 
  # generators, because other code relies on the 1:1-correspondence
  # of the generators in a presentation.
  F0_to_SQ = graded_map(SQ, gens(SQ); check=false)
  F0_to_SQ.generators_map_to_generators = true
  F0 = domain(F0_to_SQ)

  K, inc_K = kernel(F0_to_SQ)
  F1_to_F0 = graded_map(F0, images_of_generators(inc_K))
  F1 = domain(F1_to_F0)
  #F1 = graded_free_module(R, [degree(x; check=false) for x in images_of_generators(inc_K)])
  #F1_to_F0 = hom(F1, F0, images_of_generators(inc_K), check=false)

  # When there is no kernel, clean things up
  if is_zero(F1)
    F1 = graded_free_module(R, elem_type(grading_group(R))[])
    F1_to_F0 = hom(F1, F0, elem_type(F0)[]; check=false)
  end

  # prepare the end of the presentation
  Z = graded_free_module(R, elem_type(grading_group(R))[])
  SQ_to_Z = hom(SQ, Z, elem_type(Z)[zero(Z) for i in 1:ngens(SQ)]; check=false)

  # compile the presentation complex
  M = Hecke.ComplexOfMorphisms(ModuleFP, ModuleFPHom[F1_to_F0, F0_to_SQ, SQ_to_Z], check=false, seed = -2)
  @assert M[0] === F0::FreeMod
  @assert M[1] === F1::FreeMod
  set_attribute!(M, :show => Hecke.pres_show)
  return M
end

function _presentation_simple(SQ::SubquoModule)
  R = base_ring(SQ)

  # Create the free module for the presentation
  F0 = FreeMod(R, length(gens(SQ)))
  F0_to_SQ = hom(F0, SQ, gens(SQ); check=false)
  F0_to_SQ.generators_map_to_generators = true

  K, inc_K = kernel(F0_to_SQ)
  @assert codomain(inc_K) === F0
  @assert all(x->parent(x) === F0, images_of_generators(inc_K))
  F1 = FreeMod(R, ngens(K))
  F1_to_F0 = hom(F1, F0, images_of_generators(inc_K), check=false)

  # When there is no kernel, clean things up
  if is_zero(F1)
    F1 = FreeMod(R, 0)
    F1_to_F0 = hom(F1, F0, elem_type(F0)[]; check=false)
  end

  # prepare the end of the presentation
  Z = FreeMod(R, 0)
  SQ_to_Z = hom(SQ, Z, elem_type(Z)[zero(Z) for i in 1:ngens(SQ)]; check=false)

  # compile the presentation complex
  M = Hecke.ComplexOfMorphisms(ModuleFP, ModuleFPHom[F1_to_F0, F0_to_SQ, SQ_to_Z], check=false, seed = -2)
  set_attribute!(M, :show => Hecke.pres_show)
  return M
end

@doc raw"""
    presentation(F::FreeMod)

Return a (free) presentation of `F`.
"""
function presentation(F::FreeMod; minimal = false)
  if is_graded(F)
    Z = graded_free_module(F.R, 0)
  else
    Z = FreeMod(F.R, 0)
  end
  M = Hecke.ComplexOfMorphisms(ModuleFP, ModuleFPHom[hom(Z, F, Vector{elem_type(F)}()), hom(F, F, gens(F)), hom(F, Z, Vector{elem_type(Z)}([zero(Z) for i=1:ngens(F)]))], check = false, seed = -2)
  set_attribute!(M, :show => Hecke.pres_show)
  return M
end

@doc raw"""
    presentation(M::ModuleFP; minimal = false)

Return a (free) presentation of `M`.  

!!! note
    If `minimal` is `true`, and `M` is positively graded, a minimal presentation is returned.
    If `minimal` is `true`, and `M` is not (positively) graded, the function still aims at returning an ''improved'' presentation.

# Examples
```jldoctest
julia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);

julia> Z = R(0)
0

julia> O = R(1)
1

julia> B = [Z Z Z O; w*y w*z-x*y x*z-y^2 Z];

julia> A = transpose(matrix(B))
[0         w*y]
[0   w*z - x*y]
[0   x*z - y^2]
[1           0]

julia> M = graded_cokernel(A)
Graded subquotient of graded submodule of R^2 with 2 generators
  1: e[1]
  2: e[2]
by graded submodule of R^2 with 4 generators
  1: w*y*e[2]
  2: (w*z - x*y)*e[2]
  3: (x*z - y^2)*e[2]
  4: e[1]

julia> PM1 = presentation(M)
0 <---- M <---- R^2 <---- R^4

julia> PM2 = presentation(M, minimal = true)
0 <---- M <---- R^1 <---- R^3

```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> F = graded_free_module(Rg, [1,2,2]);

julia> p = presentation(F)
0 <---- F <---- F <---- 0

julia> p[-2]
Graded free module Rg^0 of rank 0 over Rg

julia> p[-1]
Graded free module Rg^1([-1]) + Rg^2([-2]) of rank 3 over Rg

julia> p[0]
Graded free module Rg^1([-1]) + Rg^2([-2]) of rank 3 over Rg

julia> p[1]
Graded free module Rg^0 of rank 0 over Rg

julia> map(p,-1)
Homogeneous module homomorphism
  from F
  to 0
defined by
  e[1] -> 0
  e[2] -> 0
  e[3] -> 0

julia> map(p,0)
Homogeneous module homomorphism
  from F
  to F
defined by
  e[1] -> e[1]
  e[2] -> e[2]
  e[3] -> e[3]

julia> map(p,1)
Homogeneous module homomorphism
  from 0
  to F
defined by

julia> F = graded_free_module(Rg, 1);

julia> A = Rg[x; y];

julia> B = Rg[x^2; y^3; z^4];

julia> M = SubquoModule(F, A, B);

julia> P = presentation(M)
0 <---- M <---- Rg^2 <---- Rg^5

julia> P[-2]
Graded free module Rg^0 of rank 0 over Rg

julia> P[-1]
Graded subquotient of graded submodule of F with 2 generators
  1: x*e[1]
  2: y*e[1]
by graded submodule of F with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> P[0]
Graded free module Rg^2([-1]) of rank 2 over Rg

julia> P[1]
Graded free module Rg^2([-2]) + Rg^1([-3]) + Rg^2([-5]) of rank 5 over Rg

julia> map(P,-1)
Homogeneous module homomorphism
  from M
  to 0
defined by
  x*e[1] -> 0
  y*e[1] -> 0

julia> map(P,0)
Homogeneous module homomorphism
  from Rg^2
  to M
defined by
  e[1] -> x*e[1]
  e[2] -> y*e[1]

julia> map(P,1)
Homogeneous module homomorphism
  from Rg^5
  to Rg^2
defined by
  e[1] -> x*e[1]
  e[2] -> -y*e[1] + x*e[2]
  e[3] -> y^2*e[2]
  e[4] -> z^4*e[1]
  e[5] -> z^4*e[2]
```
"""
function presentation(M::ModuleFP; minimal=false)
 error("presentation is not implemented for the given types.")
end

@doc raw"""
    present_as_cokernel(M::SubquoModule, task::Symbol = :none)

Return a subquotient `C` which is isomorphic to `M`, and whose generators are the standard unit vectors of its ambient free module.

Additionally,

- return an isomorphism `M` $\to$ `C` if `task = :with_morphism`,
- return and cache an isomorphism `M` $\to$ `C` if `task = :cache_morphism`,
- do none of the above if `task = :none` (default).

If `task = :only_morphism`, return only an isomorphism.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> A = R[x; y];

julia> B = R[x^2; y^3; z^4];

julia> M = SubquoModule(A, B)
Subquotient of submodule with 2 generators
  1: x*e[1]
  2: y*e[1]
by submodule with 3 generators
  1: x^2*e[1]
  2: y^3*e[1]
  3: z^4*e[1]

julia> C = present_as_cokernel(M)
Subquotient of submodule with 2 generators
  1: e[1]
  2: e[2]
by submodule with 5 generators
  1: x*e[1]
  2: -y*e[1] + x*e[2]
  3: y^2*e[2]
  4: z^4*e[1]
  5: z^4*e[2]
```

```jldoctest
julia> Rg, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> F = graded_free_module(Rg, 1);

julia> A = Rg[x; y];

julia> B = Rg[x^2; y^3; z^4];

julia> M = SubquoModule(F, A, B);

julia> present_as_cokernel(M, :with_morphism)
(Graded subquotient of graded submodule of Rg^2 with 2 generators
  1: e[1]
  2: e[2]
by graded submodule of Rg^2 with 5 generators
  1: x*e[1]
  2: -y*e[1] + x*e[2]
  3: y^2*e[2]
  4: z^4*e[1]
  5: z^4*e[2], Hom: graded subquotient of graded submodule of Rg^2 with 2 generators
  1: e[1]
  2: e[2]
by graded submodule of Rg^2 with 5 generators
  1: x*e[1]
  2: -y*e[1] + x*e[2]
  3: y^2*e[2]
  4: z^4*e[1]
  5: z^4*e[2] -> M)
```
"""
function present_as_cokernel(SQ::SubquoModule, task::Symbol = :none)
  chainComplex = presentation(SQ)
  R_b = obj(chainComplex, 0)
  f = map(chainComplex, 1)
  g = map(chainComplex, 0)
  presentation_module = quo_object(R_b, image(f)[1])

  if task == :none
    return presentation_module
  end
  
  # The isomorphism is just the identity matrix
  isomorphism = hom(presentation_module, SQ, Vector{elem_type(SQ)}([g(x) for x in gens(R_b)]))
  inverse_isomorphism = hom(SQ, presentation_module, Vector{elem_type(presentation_module)}([presentation_module[i] for i=1:ngens(SQ)]))
  isomorphism.inverse_isomorphism = inverse_isomorphism

  if task == :cache_morphism
    register_morphism!(isomorphism)
    register_morphism!(inverse_isomorphism)
  end
  task == :only_morphism && return isomorphism
  
  return presentation_module, isomorphism
end

@doc raw"""
    present_as_cokernel(F::FreeMod, task::Symbol = :none)

Represent `F` as the quotient `C` of itself with no relations. This method exists for compatibility reasons with `present_as_cokernel(M::SubQuoModule, task::Symbol = :none)`. 

Additionally,

- return an isomorphism `F` $\to$ `C` if `task = :with_morphism`,
- return and cache an isomorphism `F` $\to$ `C` if `task = :cache_morphism`,
- do none of the above if `task = :none` (default).

If `task = :only_morphism`, return only an isomorphism.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> F = free_module(R, 2)
Free module of rank 2 over R

julia> present_as_cokernel(F)
Submodule with 2 generators
  1: e[1]
  2: e[2]
represented as subquotient with no relations

julia> present_as_cokernel(F, :only_morphism)
Module homomorphism
  from F
  to submodule with 2 generators
    1: e[1]
    2: e[2]
  represented as subquotient with no relations
```
"""
function present_as_cokernel(F::FreeMod, task::Symbol = :none)
  presentation_module, isomorphism = quo(F, [zero(F)])
  inverse_isomorphism = hom(presentation_module, F, gens(F))

  if task == :none
    return presentation_module
  end

  if task == :cache_morphism
    register_morphism!(isomorphism)
    register_morphism!(inverse_isomorphism)
  end
  task == :only_morphism && return isomorphism
  
  return presentation_module, isomorphism
end

@doc raw"""
    prune_with_map(M::ModuleFP)

If `M` is positively graded, return a module `N` and an isomorphism from `N` to `M` such
that `N` is generated by a minimal number of elements.

If `M` is not (positively) graded, the function still aims at reducing the number of generators.

# Examples
```jldoctest
julia> R, (w, x, y, z) = graded_polynomial_ring(QQ, [:w, :x, :y, :z]);

julia> Z = R(0)
0

julia> O = R(1)
1

julia> B = [Z Z Z O; w*y w*z-x*y x*z-y^2 Z];

julia> A = transpose(matrix(B))
[0         w*y]
[0   w*z - x*y]
[0   x*z - y^2]
[1           0]

julia> M = graded_cokernel(A)
Graded subquotient of graded submodule of R^2 with 2 generators
  1: e[1]
  2: e[2]
by graded submodule of R^2 with 4 generators
  1: w*y*e[2]
  2: (w*z - x*y)*e[2]
  3: (x*z - y^2)*e[2]
  4: e[1]

julia> N, phi = prune_with_map(M);

julia> N
Graded subquotient of graded submodule of R^1 with 1 generator
  1: e[1]
by graded submodule of R^1 with 3 generators
  1: (-x*z + y^2)*e[1]
  2: (-w*z + x*y)*e[1]
  3: w*y*e[1]

julia> phi(first(gens(N)))
e[2]
```
"""
function prune_with_map(M::ModuleFP)
  return prune_with_map_atomic(M)
end

# generic fallback
function prune_with_map_atomic(M::ModuleFP)
  # TODO: take special care of graded modules 
  # by stripping off the grading and rewrapping it afterwards.
  N, b = simplify(M)
  return N, b
end

# MpolyRing and MPolyQuoRing case
function prune_with_map_atomic(M::ModuleFP{T}) where {T<:Union{MPolyRingElem, MPolyQuoRingElem}} # The case that can be handled by Singular

  # Singular presentation
  pm = presentation(M)
  pres_map = map(pm, 1)
  krnel = SubquoModule(pm[0], pres_map.(gens(pm[1]))) # Create the image of pres_map without the inclusion map

  # work around if we're passing the zero module to singular, see
  # https://github.com/oscar-system/Singular.jl/issues/796
  if iszero(krnel)
    return M, identity_map(M)
  end
  
  s_fmod  = Oscar.singular_module(ambient_free_module(krnel))
  s_mod = Singular.Module(base_ring(s_fmod),
                          [s_fmod(repres(g)) for g in gens(krnel)]...)

  # compute minimal presentation
  s_mod_new, mat, p = Singular.prune_with_map_projection(s_mod)
  new_rk = Singular.rank(s_mod_new)

  # find which generators were scratched
  img_inds = [findlast(==(i), p) for i in 1:new_rk]
  @assert all(!isnothing, img_inds) "something went wrong when trying to construct the map"
  phi2 = map(pm, 0)
  F2 = domain(phi2)

  # convert s_mod_new to Oscar
  R = base_ring(M)
  if is_graded(M)
    F = graded_free_module(R, degrees_of_generators(F2)[img_inds])
  else
    F = free_module(base_ring(M), new_rk)
  end
  new_krnel_gens = (F).([s_mod_new[i] for i in 1:ngens(s_mod_new)])
  M_new, _ = quo(F, new_krnel_gens)

  # build map
  phi3 = hom(M_new, F2, gens(F2)[img_inds]) 
  phi = compose(phi3, phi2)
  
  return M_new, phi
end

@attr Any function presentation_ctx(M::SubquoModule{ZZRingElem})
  R = base_ring(M)
  F = ambient_free_module(M)
  m = ngens(F)
  rels = relations(M)
  n = length(rels)
  A = zero_matrix(R, m, n)
  for (j, rel) in enumerate(rels)
    for (i, v) in coordinates(rel)
      A[i, j] = v
    end
  end
  D, U, V = snf_with_transform(A)
  return (D=D, U=U, V=V)
end

@attr Any function presentation_ctx(M::SubquoModule{T}) where {T<:FieldElem}
  R = base_ring(M)
  F = ambient_free_module(M)
  m = ngens(F)
  rels = relations(M)
  n = length(rels)

  A = zero_matrix(R, m, n)
  for (j, rel) in enumerate(rels)
    for (i, v) in coordinates(rel)
      A[i, j] = v
    end
  end

  D, U, V = snf_with_transform(A)
  return (D=D, U=U, V=V)
end

function prune_with_map_atomic(M::SubquoModule{T}) where {T<:Union{ZZRingElem, FieldElem}}
  ctx = presentation_ctx(M)
  R = base_ring(M)
  F = ambient_free_module(M)
  m = ngens(F)
  D = ctx.D
  U = ctx.U
  diag_length = min(size(D)...)
  unit_diag_indices = [i for i in 1:diag_length if is_unit(D[i,i])]
  row_indices = setdiff(1:size(D, 1), unit_diag_indices)
  col_indices = setdiff(1:size(D, 2), unit_diag_indices)
  D_prime_matrix = sub(D, row_indices, col_indices)
  F_prime = FreeMod(R, length(row_indices))
  rels_prime = [F_prime(sparse_row(transpose(D_prime_matrix[:, j:j]))) for j in 1:size(D_prime_matrix, 2)]
  N_prime, _ = sub(F_prime, rels_prime)
  M_prime, _ = quo(F_prime, N_prime)
  U_inv = inv(U)
  iso_basis_ambient = [sum(U_inv[j, row_indices[i]] * gens(F)[j] for j in 1:m) for i in 1:length(row_indices)]
  proj_to_M = hom(F, M, gens(M))
  iso_basis = [proj_to_M(b) for b in iso_basis_ambient]
  iso_map = hom(M_prime, M, iso_basis)
  return M_prime, iso_map
end

function _presentation_minimal(SQ::ModuleFP{T};
                               minimal_kernel::Bool=true) where {T <: Union{MPolyRingElem, MPolyQuoRingElem}}
  R = base_ring(SQ)

  R = base_ring(SQ)
 
  SQ_new, phi = prune_with_map(SQ)
  F0 = ambient_free_module(SQ_new)

  # M_new is a quotient of a free module
  proj_map = hom(F0, SQ_new, gens(SQ_new), check=false)
  F0_to_SQ = compose(proj_map, phi)
  F0_to_SQ.generators_map_to_generators = false

  is_sq_graded = is_graded(SQ)

  # if we want a minimal kernel too, we go to prune_with_map
  K, inc = sub(F0, relations(SQ_new))
  if minimal_kernel
    K, inc2 = prune_with_map(K)
    inc = compose(inc2, inc)
  end
  F1 = if is_sq_graded
    graded_free_module(R, degrees_of_generators(K))
  else
    free_module(R, ngens(K))
  end
  F1_to_F0 = compose(hom(F1, K, gens(K), check=false), inc)

  # When there is no kernel, clean things up
  if is_zero(F1)
    if is_sq_graded
        F1 = graded_free_module(R, 0)
    else
        F1 = FreeMod(R, 0)
    end
    F1_to_F0 = hom(F1, F0, elem_type(F0)[]; check=false)
  end
  
  # prepare the end of the presentation
  if is_sq_graded
      Z = graded_free_module(R, 0)
  else
      Z = FreeMod(R, 0)
  end
  SQ_to_Z = hom(SQ, Z, elem_type(Z)[zero(Z) for i in 1:ngens(SQ)]; check=false)

  # compile the presentation complex
  CC = Hecke.ComplexOfMorphisms(ModuleFP, ModuleFPHom[F1_to_F0, F0_to_SQ, SQ_to_Z], check=false, seed = -2)
  set_attribute!(CC, :show => Hecke.pres_show)
  return CC
end

function prune_with_map(F::FreeMod)
  return F, hom(F, F, gens(F))
end

@doc raw"""
    is_finite(M::SubquoModule{T}) where {T<:Union{ZZRingElem, FieldElem}}

Determine whether the finitely presented module `M` over `ZZRing` or a `Field` is finite as a set.

This is done by computing a minimal presentation.

# Examples
```jldoctest
julia> R = ZZ;

julia> F = free_module(FreeMod, R, 2);

julia> A = matrix(ZZ, [2 0; 0 3]);

julia> M = cokernel(hom(F, F, A));

julia> is_finite(M)
true

julia> B = matrix(ZZ, [0 0; 0 0]);

julia> N = cokernel(hom(F, F, B));

julia> is_finite(N)
false

julia> B = matrix(ZZ, [0 0; 0 0]);

julia> N = cokernel(hom(F, F, B));

julia> is_finite(N)
false

julia> K, a = finite_field(7, "a");

julia> G = free_module(FreeMod, K, 3);

julia> C = matrix(K, [1 0 0; 0 1 0; 0 0 1]);

julia> L = cokernel(hom(G, G, C));

julia> is_finite(L)
true

julia> H = free_module(FreeMod, QQ, 1);

julia> P = cokernel(hom(H, H, matrix(QQ, 1, 1, [QQ(0)])));

julia> is_finite(P)
false

julia> Z = cokernel(hom(H, H, matrix(QQ, 1, 1, [QQ(1)])));

julia> is_finite(Z)
true
```
"""
function is_finite(M::SubquoModule{T}) where {T<:Union{ZZRingElem, FieldElem}}
  M_prime, _ = prune_with_map_atomic(M)
  R = base_ring(M_prime)
  pres = presentation(M_prime)
  rel_map = map(pres, 1)
  rel_matrix = matrix(rel_map)
  nc = size(rel_matrix, 2)
  nr = size(rel_matrix, 1)
  has_free_generator = any(j -> all(i -> iszero(rel_matrix[i, j]), 1:nr), 1:nc)
  if isa(R, ZZRing)
    return !has_free_generator && nc > 0
  elseif isa(R, Field)
    if is_finite(R)
      return true
    else
      return nc == 0
    end
  else
    error("The base ring $(typeof(R)) is not supported.")
  end
end

@doc raw"""
    size(M::SubquoModule{T}) where {T<:Union{ZZRingElem, FieldElem}}

Compute the cardinality of the finitely presented module `M` over `ZZRing` or a `Field` as a set.
Returns `PosInf` if the module is infinite.

This is done by computing a minimal presentation.

# Examples
```jldoctest
julia> R = ZZ;

julia> F = free_module(FreeMod, R, 2);

julia> M = cokernel(hom(F, F, matrix(ZZ, [2 0; 0 3])));

julia> size(M)
6

julia> N = cokernel(hom(F, F, matrix(ZZ, [1 0; 0 0])));

julia> size(N)
infinity

julia> K, a = finite_field(7, "a");

julia> G = free_module(FreeMod, K, 3);

julia> H = free_module(FreeMod, K, 1);

julia> L = cokernel(hom(H, G, matrix(K, [1 0 0])));

julia> size(L)
49
```
"""
function size(M::SubquoModule{T}) where {T<:Union{ZZRingElem, FieldElem}}
  M_prime, _ = prune_with_map_atomic(M)
  R = base_ring(M_prime)
  pres = presentation(M_prime)
  rel_matrix = matrix(map(pres, 1))
  nc, nr = size(rel_matrix, 2), size(rel_matrix, 1)
  has_free_generator = any(j -> all(i -> iszero(rel_matrix[i, j]), 1:nr), 1:nc)
  if isa(R, ZZRing)
    if has_free_generator
      return PosInf()
    end
    return prod(abs(rel_matrix[i,i]) for i in 1:min(nr,nc))
  elseif isa(R, Field)
    if is_finite(R)
      q = order(R)
      dim = ngens(M_prime)
      return q^dim
    else
      return nc == 0 ? 1 : PosInf()
    end
  else
    error("Unhandled base ring: $(typeof(R))")
  end
end
