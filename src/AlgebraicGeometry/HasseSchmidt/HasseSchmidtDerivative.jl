

# HASSE-SCHMIDT Derivative for MPolyRingElem
function hasse_derivatives(f::MPolyRingElem)
  R = parent(f)
  n = ngens(R)
  # degreef = maximum(degrees(f))
  # define new ring with more variables: R[x1, ..., xn] -> R[x1, ..., xn, t1, ..., tn]
  Rtemp, _ = polynomial_ring(R, "y" => 1:n, "t" => 1:n)
  # replace f(x_i) -> f(y_i + t_i)
  F = evaluate(f, gens(Rtemp)[1:n] + gens(Rtemp)[n+1:2n])
  # i = 1 # counter to iterate though degrees of monomials
  HasseDerivativesList = empty([f])
  varR = vcat(gens(R), ones(typeof(base_ring(R)(1)), n))
  # varR = vcat(gens(R), ones(ZZRingElem, n))

  # getting hasse derivs without extra attention on ordering
  for term in terms(F)
    # hasse derivatives are the factors in front of the monomial in t
    push!(HasseDerivativesList, evaluate(term, varR))
  end

  return HasseDerivativesList
end

function hasse_deriv(IX::MPolyIdeal)

  R = base_ring(IX)
  n = ngens(R) # number of variables of R
  r = ngens(IX) # number of generators of IX

  # Variables of Rtemp don't have names. This way there are less problems with the names of variables of R. 
  Rtemp, _ = polynomial_ring(base_ring(R), "y" => 1:n, "t" => 1:n)
  F = gens(IX)
  # replace f_j(x_i) -> f(y_i + t_i)
  for j in 1:r
    F[j] = evaluate(F[j], gens(Rtemp)[1:n] + gens(Rtemp)[n+1:2n]) # F(x) -> F(y+t)
  end
  # F = [evaluate(F[j], gens(Rtemp)[1:n] + gens(Rtemp)[n+1:2n]) for j in 1:r]
  # Initializing Variables
  i=1   # counter to iterate through degrees of monomials
  tempid = gens(IX) # list to collect generators of IX and their Hasse Schmidt derivatives
  RetList = [IX]  # list to collect ideals generated by tempid
  # RetList = empty([IX])
  varR = vcat(gens(R), ones(ZZRingElem, n)) # TODO: fmpz gibts nicht mehr wenn der dev-tree genutzt wird # fmpz -> ZZRingElem, fmpq -> QQFieldElem

  while i == 1 || tempid != gens(RetList[i-1])  # Comparing ideals was a bad idea # A little loophole: 2nd condition would throw an error at the first iteration but because i==1 is true the 2nd conditions check is skipped.
    for polynome in F
      for term in terms(polynome)
        if sum(degrees(term)[n+1:2n]) == i
          tempid = vcat(tempid, [evaluate(term, varR)]) # maybe use vector operations for shorter code?
        end
      end
    end
    i = i + 1
    RetList = vcat(RetList, ideal(R, tempid))
  end
  return (RetList[1:i-1])
end