
export adjugate
export pseudo_diff
export integer_generator
export hasse_deriv


####################################################################################
#####################   ADJUGATE MATRIX   ########################################## 
# Name:		adjugate
#
# INPUT:	square matrix M 
# OUTPUT:	adjugate matrix of M

# function provided by Max Horn. Thx
function adjugate(M)
  c = charpoly(M)
  f = divexact(c - c(0), gen(parent(c)))
  a = f(M)
  iseven(nrows(M)) ? -a : a
end

####################################################################################
##################   DERIVATE WITH RESPECT TO PARAMETERSYSTEM   ####################
# Name:		pseudo_diff
#
# INPUT:	
# OUTPUT:	

function pseudo_diff(f, j, A, q, I::Ideal, systemOfParameters::Vector{Int})
  R = base_ring(I)

  # Check for correct input? No, it'll be checked in main functions.
  gensR = gens(R)
  RetPoly = q * derivative(f, systemOfParameters[j])

  # Generating a list of Variables which aren't in parametersystem y
  OtherVars = empty(gensR)
  n = ngens(R)
  for k in 1:n
    gensR[k] in systemOfParameters || push!(OtherVars, gensR[k])
  end

  # See formular in remark 4.2
  for k in 1:ncols(A)
    for l in 1:nrows(A)
      SubPoly = derivative(gens(I)[l], systemOfParameters[j]) * A[l,k] * derivative(f, OtherVars[k])
      RetPoly = RetPoly - SubPoly
    end
  end
  Istd = standard_basis(I)
  RetPoly = reduce(RetPoly, gens(Istd)) # mod IZ
  return (RetPoly)
end

####################################################################################
#####################   INTEGER GENERATOR   ######################################## 
# Name:		integer_generator
#
# INPUT:	Ideal I
# OUTPUT:	Ideal J, was den Schnitt von I mit dem Ring repr채sentiert, 체ber den der Polynomring definiert ist

function integer_generator(I)
  vars = gens(base_ring(I))
  J = eliminate(I, vars)  # eliminiere die Variablen des Polynomrings aus dem Ideal I
  return (J)
end

####################################################################################
#####################   HASSE-SCHMIDT DERIVATIVE  (IZ == <0>)  ##################### 
# Name:		hasse_deriv
# 			
# INPUT:	Ideals <f_1, ..., f_r> = IX   (IZ = <0>)
# OUTPUT:	List of ideals generated by hasse derivatives until but without <1>

function hasse_deriv(IX::MPolyQuoIdeal)
  # println("Funktion hasse_deriv f체r Ideale aus Faktor- bzw. Quotientenringen")
  RQ = base_ring(IX)
  R = base_ring(RQ) # could cause problems if this isn't a MPolyRing
  # embedding the generators of IX into the base_ring of RQ
  IX_R = ideal(R, [R(gen) for gen in gens(IX)])

  list_IX_derivs = hasse_deriv(IX_R) # calling hasse_deriv for MPolyIdeals

  # projecting the hasse derivs onto the original Quotient Ring
  return_list = empty([]) 
  for i in 1:length(list_IX_derivs)
    push!(return_list, ideal(RQ, [RQ(gen) for gen in gens(list_IX_derivs[i])]))
  end
  return return_list
end

function hasse_deriv(IX::Oscar.MPolyLocalizedIdeal)
  # Rloc.(I.gens)
  Rloc = base_ring(IX)
  R = base_ring(Rloc) # could cause problems if this isn't a MPolyRing
  # projecting the generators of IX onto the base_ring of Rloc by taking the numerators
  IX_R = ideal(R, [numerator(gen) for gen in gens(IX)])

  list_IX_derivs = hasse_deriv(IX_R) # calling hasse_deriv for MPolyIdeals

  # embedding the hasse derivs into original localized ring
  return_list = empty([]) 
  for i in 1:length(list_IX_derivs)
    push!(return_list, ideal(Rloc, [Rloc(gen) for gen in gens(list_IX_derivs[i])]))
  end
  # println("Type of IX: ",typeof(IX))
  # println("Type of IX_R: ",typeof(IX_R))
  # println("Type of list_IX_derivs: ",typeof(list_IX_derivs))
  # println("Type of return_list: ",typeof(return_list))
  return return_list
end

function hasse_deriv(IX::MPolyIdeal)

  R = base_ring(IX)
  n = ngens(R) # number of variables of R
  r = ngens(IX) # number of generators of IX

  # Variables of Rtemp don't have names. This way there are less problems with the names of variables of R. 
  Rtemp, _ = polynomial_ring(base_ring(R), "y" => 1:n, "t" => 1:n)
  F = gens(IX)
  # replace f_j(x_i) -> f(y_i + t_i)
  for j in 1:r
    F[j] = evaluate(F[j], gens(Rtemp)[1:n] + gens(Rtemp)[n+1:2n]) # F(x) -> F(y+t)
  end
  # F = [evaluate(F[j], gens(Rtemp)[1:n] + gens(Rtemp)[n+1:2n]) for j in 1:r]
  # Initializing Variables
  i=1   # counter to iterate through degrees of monomials
  tempid = gens(IX) # list to collect generators of IX and their Hasse Schmidt derivatives
  RetList = [IX]  # list to collect ideals generated by tempid
  # RetList = empty([IX])
  varR = vcat(gens(R), ones(ZZRingElem, n)) # TODO: fmpz gibts nicht mehr wenn der dev-tree genutzt wird # fmpz -> ZZRingElem, fmpq -> QQFieldElem

  while i == 1 || tempid != gens(RetList[i-1])  # Comparing ideals was a bad idea # A little loophole: 2nd condition would throw an error at the first iteration but because i==1 is true the 2nd conditions check is skipped.
    for polynome in F
      for term in terms(polynome)
        if sum(degrees(term)[n+1:2n]) == i
          tempid = vcat(tempid, [evaluate(term, varR)]) # maybe use vector operations for shorter code?
        end
      end
    end
    i = i + 1
    RetList = vcat(RetList, ideal(R, tempid))
  end
  return (RetList[1:i-1])
end

####################################################################################
#####################   HASSE-SCHMIDT DERIVATIVE  (IZ != <0>)   #################### 
# Name:		hasse_deriv
# 
# INPUT:	Ideals IZ,IX, system of parameters y, matrix M
# OUTPUT:	List of ideals generated by hasse derivatives until but without <1>

function hasse_deriv(IZ::MPolyQuoIdeal, IX::MPolyQuoIdeal, systemOfParameters::Vector{Int}, M)
  RQ = base_ring(IX)
  R = base_ring(RQ) # could cause problems if this isn't a MPolyRing
  # embedding the generators of IX and IZ into the base_ring of RQ
  IX_R = ideal(R, [R(gen) for gen in gens(IX)])
  IZ_R = ideal(R, [R(gen) for gen in gens(IZ)])

  # systemOfParameters needs no change because it beeing Vector{Int} ist just fine
  nRows = n_rows(M)
  nCols = n_columns(M)
  M_R = matrix(R, nRows, nCols, [R(M[i,j]) for i in 1:nRows for j in 1:nCols])

  list_IX_derivs = hasse_deriv(IZ_R, IX_R, systemOfParameters, M_R) # calling hasse_deriv for MPolyIdeals

  # projecting the hasse derivs onto original localized ring
  return_list = empty([]) 
  for i in 1:length(list_IX_derivs)
    push!(return_list, ideal(Rloc, [Rloc(gen) for gen in gens(list_IX_derivs[i])]))
  end
  return return_list
end

function hasse_deriv(IZ::Oscar.MPolyLocalizedIdeal, IX::Oscar.MPolyLocalizedIdeal, systemOfParameters::Vector{Int}, M)
  Rloc = base_ring(IX)
  R = base_ring(Rloc) # could cause problems if this isn't a MPolyRing
  # projecting the generators of IX and IZ onto the base_ring of Rloc by taking the numerators
  IX_R = ideal(R, [numerator(gen) for gen in gens(IX)])
  IZ_R = ideal(R, [numerator(gen) for gen in gens(IZ)])

  # systemOfParameters needs no change because it beeing Vector{Int} ist just fine

  # M_R = M, aber alle Eintr채ge sind aus R (MPolyRing)
  nRows = n_rows(M)
  nCols = n_columns(M)
  M_R = matrix(R, nRows, nCols, [numerator(M[i,j]) for i in 1:nRows for j in 1:nCols])

  list_IX_derivs = hasse_deriv(IZ_R, IX_R, systemOfParameters, M_R) # calling hasse_deriv for MPolyIdeals

  # embedding the hasse derivs into original localized ring
  return_list = empty([]) 
  for i in 1:length(list_IX_derivs)
    push!(return_list, ideal(Rloc, [Rloc(gen) for gen in gens(list_IX_derivs[i])]))
  end
  # println("Type of IX: ",typeof(IX))
  # println("Type of IX_R: ",typeof(IX_R))
  # println("Type of list_IX_derivs: ",typeof(list_IX_derivs))
  # println("Type of return_list: ",typeof(return_list))
  return return_list
end

function hasse_deriv(IZ::MPolyIdeal, IX::MPolyIdeal, systemOfParameters::Vector{Int}, M)
  R = base_ring(IZ)
  if IZ == ideal(R, [zero(R)])
    return hasse_deriv(IX)
  end

  # Checking for correct input. 
  IZ !== IX || error("IZ and IX cannot be equal.")
  issubset(IZ,IX) || error("IZ needs to be a subset of IX.")

  # IZstd = standard_basis(ideal(R, reduce(IX, standard_basis(IZ)))) # why is this returning gens(IZ)
  n = ngens(R) # number of variables of R
  t = ngens(IZ)
  r = ngens(IX) - t # number of generators of IX without number of generators of IZ
  f = empty([R(0)])        
  for poly in gens(IX)
    println("# ", poly)
    poly in IZ || push!(f, poly)
  end # f = [Generators of IX but not of IZ]
  detM = det(M)
  A = adjugate(M)

  Itemp = IX
  RetList = [IX] # List of ideals to return.
  # RetList = empty([IX]) # Maybe we don't need IX as first entry?
  Null = zeros(ZZ, length(systemOfParameters)) 

  L = [[f[i],Null] for i in 1:r]
  old = 0
  cur = r 

  while integer_generator(Itemp) == ideal(R, [zero(R)]) # intersect(Itemp, ZZ) == <0> 
    println("# Intersection(Itemp, ZZ) == <0>")
    println("# old = ", old)
    println("# cur = ", cur)
    for i in old+1:cur # for every f in Itemp without gens(IZ)
      # println("# i = ", i)
      for j in 1:length(systemOfParameters) # for every varialbe of system of parameters y
        # println("# yj = ", y[j], " ")
        ftemp = L[i][1]
        note = copy(L[i][2]) # "copy" is important, otherwise "note" would only be a pointer to L[i][2] and NOT a copy
        note[j] = note[j] + 1
        # normal pseudo_diff divided by faktor a
        ftemp = div(pseudo_diff(ftemp, j, A, detM, IZ, systemOfParameters), R(note[j]))
        if ftemp != zero(R)
          L = push!(L, [ftemp, copy(note)]) # "copy" is important, (see above)
          Itemp = Itemp + ideal(R, ftemp)
        end
        sleep(0.001) # hasse_deriv did not work without letting it sleep (julia-stuff)
        println("# ftemp = ", ftemp, " # note = ", note)
        # println("# L = ", L)
      end
      sleep(0.001) # hasse_deriv did not work without letting it sleep (julia-stuff)
    end
    println("# Itemp before saturation: ", Itemp)
    Itemp = saturation(Itemp, ideal(R, detM)) # saturate with <det(M)> to get rid of the factor q = det(M) we got using pseudo_diff
    println("# Itemp saturated with ", detM, ": ", Itemp)
    RetList = push!(RetList, Itemp)
    old = cur
    cur = length(L)
    sleep(0.001) # hasse_deriv did not work without letting it sleep (julia-stuff)
    # println("# RetList = ", RetList)
  end
  return (RetList)
end