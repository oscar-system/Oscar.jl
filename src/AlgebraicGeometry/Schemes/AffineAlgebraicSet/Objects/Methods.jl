########################################################
# (1) Display
########################################################

# As a set, corresponding the fat ideal or the radical does not change anything.
# If one already knows the reduced scheme structure on this algebraic set, we
# print it (more convenient to see the ideal)
function Base.show(io::IO, ::MIME"text/plain", X::AffineAlgebraicSet{<:Field,<:MPolyQuoRing})
  io = pretty(io)
  println(io, "Affine algebraic set")
  println(io, Indent(), "in ", Lowercase(), ambient_space(X))
  if isdefined(X, :Xred)
    I = saturated_ideal(defining_ideal(X))
  else
    I = fat_ideal(X)
  end
  print(io, Dedent(), "defined by ", Lowercase(), I)
end

# As a set, corresponding the fat ideal or the radical does not change anything.
# If one already knows the reduced scheme structure on this algebraic set, we
# print it (more convenient to see the ideal)
#
# For compact printing, we value the notation V(bla) since it tells everything
# we need to know, in a given contextual printing
function Base.show(io::IO, X::AffineAlgebraicSet{<:Field,<:MPolyQuoRing})
  if is_terse(io)
    print(io, "Affine algebraic set")
  elseif get_attribute(X, :is_empty, false)
    io = pretty(io)
    print(io, "Empty affine algebraic set over ")
    K = base_ring(X)
    print(terse(io), Lowercase(), K)
  else
    io = pretty(io)
    if isdefined(X, :Xred)
      I = saturated_ideal(defining_ideal(X))
    else
      I = fat_ideal(X)
    end
    print(io, LowercaseOff(), "V(")
    join(io, gens(I), ", ")
    print(io,")")
  end
end

# special case for Zariski opens
function Base.show(io::IO, ::MIME"text/plain", X::AffineAlgebraicSet)
  io = pretty(io)
  println(io, "Reduced subscheme")
  print(io, Indent(),"of ", Lowercase(), fat_scheme(X))
  print(io, Dedent())
end

function Base.show(io::IO, X::AffineAlgebraicSet)
  if is_terse(io)
    print(io, "Affine algebraic set")
  elseif get_attribute(X, :is_empty, false)
    io = pretty(io)
    print(io, "Empty affine algebraic set over ")
    K = base_ring(X)
    print(terse(io), Lowercase(), K)
  else
    io = pretty(io)
    print(io, "Reduced subscheme of ", Lowercase(), fat_scheme(X))
  end
end

########################################################
# (2) give back k-points (if finitely many)
########################################################
@doc raw"""
    rational_point_coordinates(I::MPolyIdeal)

Returns the $k$-coordinates of the point corresponding to a 
maximal ideal $I \in k[x_1,\dots,x_n]$. 
If $I$ is not maximal or does not describe a point with coordinates in the 
field $k$, an assertion error is raised.

# Examples
```jldoctest
julia> R, (x, y) = QQ[:x, :y]
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x-1,y-3])
Ideal generated by
  x - 1
  y - 3

julia> rational_point_coordinates(I)
2-element Vector{QQFieldElem}:
 1
 3

```
"""
function rational_point_coordinates(I::MPolyIdeal)
  R = base_ring(I)
  o = degrevlex(gens(R))
  LG = leading_ideal(I;ordering=o)
  @req dim(LG) == 0 "Ideal does not describe finite set of points"
  vd = vector_space_dim(quo(base_ring(LG),LG)[1])
  @req vd == 1 "Ideal does not describe a single K-point"
  nf_vec = [normal_form(v,I) for v in gens(R)]
  return [iszero(a) ? zero(coefficient_ring(a)) : leading_coefficient(a) for a in nf_vec]
end

@doc raw"""
    rational_points(::Type{S}, X::AffineAlgebraicSet)

If $X$ is defined by a zero-dimensional ideal in a multivariate
polynomial ring over a field, say, $k$, return the $k$-rational
points of $X$ as an instance of `S`. Here, `S` must be one of [`Vector`](@ref)
and [`AbsRationalPointSet`](@ref).

!!! note
The zero-dimensional condition is checked by the function.

# Examples
```jldoctest
julia> R, (x, y) = QQ[:x, :y]
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x^2-1,y-3])
Ideal generated by
  x^2 - 1
  y - 3

julia> X = algebraic_set(I)
Affine algebraic set
  in affine 2-space over QQ with coordinates [x, y]
defined by ideal (x^2 - 1, y - 3)

julia> rational_points(Vector,X)
2-element Vector{Vector{<:FieldElem}}:
 QQFieldElem[1, 3]
 QQFieldElem[-1, 3]

```
"""
function rational_points(::Type{S}, X::AffineAlgebraicSet{T}) where {T <: Field, S <:Vector}
  I = fat_ideal(X)
  @req dim(I) == 0 "Currently only available for zero-dimensional case"
  PL = minimal_primes(I)
  return Vector{<:FieldElem}[rational_point_coordinates(J)
                       for J in PL
                           if vector_space_dim(quo(base_ring(J),J)[1]) == 1]
end

function rational_points(::Type{S}, X::AffineAlgebraicSet{T}) where {T <: Field, S <:AbsRationalPointSet}
  v = rational_points(Vector,X)
  return finite_point_set(X,v)
end

rational_points(X::AffineAlgebraicSet) = rational_points(FiniteRationalPointSet,X)
