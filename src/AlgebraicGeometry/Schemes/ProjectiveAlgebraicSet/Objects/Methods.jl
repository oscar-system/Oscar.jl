########################################################
# (1) Display
########################################################

function Base.show(io::IO, ::MIME"text/plain",
                   X::AbsProjectiveAlgebraicSet{<:Field,<:MPolyQuoRing})
  io = pretty(io)
  println(io, "Projective algebraic set")
  println(io, Indent(), "in ", Lowercase(), ambient_space(X))
  if isdefined(X, :Xred)
    I = vanishing_ideal(X)
  else
    I = fat_ideal(X)
  end
  print(io, Dedent(), "defined by ", Lowercase(), I)
end

# If we know a radical ideal describing our algebraic set, we preferably print
# that one (it is easier to read...)
function Base.show(io::IO, X::AbsProjectiveAlgebraicSet{<:Field, <:MPolyQuoRing})
  if is_terse(io)
    print(io, "Projective algebraic set")
  elseif get_attribute(X, :is_empty, false)
    print(io, "Empty projective algebraic set")
  else
    io = pretty(io)
    print(io, LowercaseOff(), "V(")
    if isdefined(X, :Xred)
      I = vanishing_ideal(X)
    else
      I = fat_ideal(X)
    end
    join(io, gens(I), ",")
    print(io, ")")
  end
end

@doc raw"""
    rational_points(::Type{S}, X::ProjectiveAlgebraicSet)

If $X$ is defined by a zero-dimensional homogeneous ideal in a multivariate
graded polynomial ring over a field, say, $k$, return the $k$-rational
points of $X$ as an instance of $S$. Here, S must be one of Vector
and AbsRationalPointSet.

!!! note
The zero-dimensional condition is checked by the function.

# Examples
```jldoctest
julia> R,(x,y,z) = graded_polynomial_ring(QQ,3)
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x1, x2, x3])

julia> I = ideal(R,[(x+y+z)*(x-y-z),x-y+2*z])
Ideal generated by
  x1^2 - x2^2 - 2*x2*x3 - x3^2
  x1 - x2 + 2*x3

julia> X = algebraic_set(I)
Projective algebraic set
  in projective 2-space over QQ with coordinates [x1, x2, x3]
defined by ideal (x1^2 - x2^2 - 2*x2*x3 - x3^2, x1 - x2 + 2*x3)

julia> rational_points(X)
2-element Vector{Vector{QQFieldElem}}:
 [1, 1, 0]
 [-3//2, 1//2, 1]

```
"""
function rational_points(::Type{S}, X::ProjectiveAlgebraicSet{T}) where {T <: Field, S<:Vector}
  @req dim(X) == 0 "Not a zero-dimensional projective algebraic set"
  I = fat_ideal(X)
  @req is_standard_graded(ambient_coordinate_ring(X)) "only available for standard grading"
  PL = minimal_primes(I)
  result = Vector{elem_type(T)}[]
  for J in PL
    all(b -> degree(b)[1] == 1, gens(J)) || continue
    Jf = forget_grading(J)
    Rf = base_ring(Jf)
    V = matrix(coefficient_ring(Rf),ngens(Jf),ngens(Rf),
        [coeff(gen(Jf,erz),gen(Rf,rvar))
               for erz in 1:ngens(Jf), rvar in 1:ngens(Rf)])
    KV = kernel(transpose(V))
    size(KV)[1] == 1 || error("not a single point")
    push!(result,[KV[1,b] for b in 1:size(KV)[2]])
  end
  return result
end

function rational_points(::Type{S}, X::ProjectiveAlgebraicSet{T}) where {T <: Field, S <:AbsRationalPointSet}
  v = rational_points(Vector,X)
  return finite_pointset(X,v)
end