### Forwarding the presheaf functionality
underlying_presheaf(I::IdealSheaf) = I.I
underlying_presheaf(I::PrimeIdealSheafFromChart) = I.F
underlying_presheaf(I::SumIdealSheaf) = I.underlying_presheaf
underlying_presheaf(I::ProductIdealSheaf) = I.underlying_presheaf
underlying_presheaf(I::SimplifiedIdealSheaf) = I.underlying_presheaf

# an alias for the user's convenience
scheme(I::AbsIdealSheaf) = space(I)

@doc raw"""
    IdealSheaf(X::AbsProjectiveScheme, g::Vector{<:RingElem})

Create the ideal sheaf on the covered scheme of ``X`` which is
generated by the dehomogenization of the homogeneous elements in `g`
in every chart.

**Note:** When taking the pullback of an `IdealSheaf` ``â„`` along a morphism
``f : X â†’ Y``, what is actually computed, is ``fâ»Â¹ â„ â‹… ð’ª_{X}``.
To obtain the pullback of ``â„`` as a sheaf of modules (i.e. ``f* â„``),
convert ``â„`` into a `CoherentSheaf` on ``Y``, first.

# Examples
```jldoctest
julia> P, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]);

julia> I = ideal([x^3-y^2*z]);

julia> Y = proj(P)
Projective space of dimension 2
  over rational field
with homogeneous coordinates [x, y, z]

julia> IdealSheaf(Y, I)
Sheaf of ideals
  on scheme over QQ covered with 3 patches
    1: [(y//x), (z//x)]   affine 2-space
    2: [(x//y), (z//y)]   affine 2-space
    3: [(x//z), (y//z)]   affine 2-space
with restrictions
  1: Ideal (-(y//x)^2*(z//x) + 1)
  2: Ideal ((x//y)^3 - (z//y))
  3: Ideal ((x//z)^3 - (y//z)^2)
```
"""
function IdealSheaf(X::AbsProjectiveScheme, I::MPolyIdeal)
  S = base_ring(I)
  S === homogeneous_coordinate_ring(X) || error("ideal does not live in the graded coordinate ring of the scheme")
  g = gens(I)
  X_covered = covered_scheme(X)
  C = default_covering(X_covered)
  r = relative_ambient_dimension(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(C)
    I[U] = ideal(OO(U), dehomogenization_map(X, U).(g))
  end
  return IdealSheaf(X_covered, I, check=false)
end

function IdealSheaf(X::AbsProjectiveScheme, I::MPolyQuoIdeal)
  S = base_ring(I)
  S === homogeneous_coordinate_ring(X) || error("ideal does not live in the graded coordinate ring of the scheme")
  g = gens(I)
  X_covered = covered_scheme(X)
  C = default_covering(X_covered)
  r = relative_ambient_dimension(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(C)
    I[U] = ideal(OO(U), dehomogenization_map(X, U).(g))
  end
  return IdealSheaf(X_covered, I, check=false)
end

ideal_sheaf(X::AbsProjectiveScheme, I::MPolyIdeal) = IdealSheaf(X, I)
ideal_sheaf(X::AbsProjectiveScheme, I::MPolyQuoIdeal) = IdealSheaf(X, I)

function IdealSheaf(
    X::AbsProjectiveScheme,
    g::MPolyDecRingElem
  )
  return IdealSheaf(X, [g])
end

function IdealSheaf(
    X::AbsProjectiveScheme,
    g::MPolyQuoRingElem
  )
  return IdealSheaf(X, [g])
end

ideal_sheaf(X::AbsProjectiveScheme, g::MPolyDecRingElem) = IdealSheaf(X, g)
ideal_sheaf(X::AbsProjectiveScheme, g::MPolyQuoRingElem) = IdealSheaf(X, g)

function IdealSheaf(
    X::AbsProjectiveScheme,
    g::Vector{RingElemType}
  ) where {RingElemType<:MPolyDecRingElem}
  X_covered = covered_scheme(X)
  r = relative_ambient_dimension(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(default_covering(X_covered))
    I[U] = ideal(OO(U), dehomogenization_map(X, U).(g))
  end
  return IdealSheaf(X_covered, I, check=false)
end

function IdealSheaf(
    X::AbsProjectiveScheme,
    g::Vector{RingElemType}
  ) where {RingElemType<:MPolyQuoRingElem}
  X_covered = covered_scheme(X)
  r = relative_ambient_dimension(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(default_covering(X_covered))
    I[U] = ideal(OO(U), dehomogenization_map(X, U).(g))
  end
  return IdealSheaf(X_covered, I, check=false)
end

ideal_sheaf(X::AbsProjectiveScheme, g::Vector{RingElemType}) where {RingElemType<:MPolyDecRingElem} = IdealSheaf(X, g)
ideal_sheaf(X::AbsProjectiveScheme, g::Vector{RingElemType}) where {RingElemType<:MPolyQuoRingElem} = IdealSheaf(X, g)



# this constructs the zero ideal sheaf
function IdealSheaf(X::AbsCoveredScheme)
  C = default_covering(X)
  I = IdDict{AbsAffineScheme, Ideal}()
  for U in basic_patches(C)
    I[U] = ideal(OO(U), elem_type(OO(U))[])
  end
  return IdealSheaf(X, I, check=false)
end

@doc raw"""
    ideal_sheaf(X::AbsCoveredScheme)

See the documentation for `IdealSheaf`.
"""
ideal_sheaf(X::AbsCoveredScheme) = IdealSheaf(X)

# set up an ideal sheaf by automatic extension
# from one prescribed set of generators on one affine patch
@doc raw"""
    IdealSheaf(X::AbsCoveredScheme, U::AbsAffineScheme, I::Ideal)

Set up an ideal sheaf on ``X`` by specifying an ideal ``I``
on one affine open subset ``U`` among the `basic_patches` of the
`default_covering` of ``X``.

**Note:** The ideal ``I`` has to be prime so that its extension 
to the other charts of ``X`` is well defined. 
"""
function IdealSheaf(
    X::AbsCoveredScheme, U::AbsAffineScheme, 
    I::Ideal; check::Bool=true
  )
  @assert base_ring(I) === OO(U) || error("ideal not defined in the correct ring")
  @check is_prime(I) "ideal must be prime"
  return PrimeIdealSheafFromChart(X, U, I)
end

function IdealSheaf(
    X::AbsCoveredScheme, U::AbsAffineScheme, 
    g::Vector{RET}; check::Bool=true
  ) where {RET<:RingElem}
  return IdealSheaf(X, U, ideal(OO(U), g); check)
end

@doc raw"""
    IdealSheaf(X::AbsAffineScheme, I::Ideal; Xcoverd=covered_scheme(X)) -> IdealSheaf

Return `I` as an ideal sheaf on the covered scheme with 1 affine patch `X`.
"""
function IdealSheaf(X::AbsAffineScheme, I::Ideal; covered_scheme::AbsCoveredScheme=covered_scheme(X), check::Bool=true)
  @req base_ring(I) === OO(X) "ideal must lie in the coordinate ring of X"
  @req length(affine_charts(covered_scheme)) == 1 && X === first(affine_charts(covered_scheme)) "covered_scheme must be the covered scheme with a single patch X"
  return IdealSheaf(covered_scheme, IdDict{AbsAffineScheme, Ideal}([X=>I]); check=false)
end


ideal_sheaf(X::AbsCoveredScheme, U::AbsAffineScheme, g::Vector{RET}; check::Bool=true) where {RET<:RingElem} = IdealSheaf(X, U, g; check)
ideal_sheaf(X::AbsCoveredScheme, U::AbsAffineScheme, I::Ideal; check::Bool=true) = IdealSheaf(X, U, I; check)

@doc raw"""
    IdealSheaf(Y::AbsCoveredScheme,
        phi::CoveringMorphism{<:Any, <:Any, <:ClosedEmbedding}
    )

Internal method to create an ideal sheaf from a `CoveringMorphism`
of `ClosedEmbedding`s; return the ideal sheaf describing the images
of the local morphisms.
"""
function IdealSheaf(Y::AbsCoveredScheme,
    phi::CoveringMorphism{<:Any, <:Any, <:ClosedEmbedding};
    check::Bool=true
  )
  maps = morphisms(phi)
  V = [codomain(ff) for ff in values(maps)]
  dict = IdDict{AbsAffineScheme, Ideal}()
  V = unique!(V)
  for W in V
    i = findall(x->(codomain(x) == W), maps)
    dict[W] = image_ideal(maps[first(i)])
  end
#  for U in affine_charts(Y)
#    if U in V
#      i = findall(x->(codomain(x) == U), maps)
#      dict[U] = image_ideal(maps[first(i)])
#    else
#      dict[U] = ideal(OO(U), one(OO(U)))
#    end
#  end
  return IdealSheaf(Y, dict, check=check)
end


# pullback of an ideal sheaf for internal use between coverings of the same scheme
#function (F::CoveringMorphism)(I::IdealSheaf)
#  X = scheme(I)
#  D = codomain(F)
#  D == covering(I) || error("ideal sheaf is not defined on the correct covering")
#  C = domain(F)
#  new_dict = Dict{AbsAffineScheme, Ideal}()
#
#  # go through the patches of C and pull back the generators
#  # whenever they are defined on the target patch
#  for U in patches(C)
#    f = F[U]
#    V = codomain(f)
#    # for the basic patches here
#    if haskey(ideal_dict(I), V)
#      new_dict[U] = ideal(OO(U), pullback(f).(I[V]))
#    end
#    # check for affine refinements
#    if haskey(affine_refinements(D), V)
#      Vrefs = affine_refinements(D)[V]
#      # pull back the refinement
#      for W in Vrefs
#        h = pullback(f).(gens(W))
#        # take care to discard possibly empty preimages of patches
#        j = [i for i in 1:length(h) if !iszero(h)]
#        Wpre = AffineSchemeOpenSubscheme(U, h[j])
#        add_affine_refinement!(C, Wpre)
#        for i in 1:length(j)
#          if haskey(ideal_dict(I), Wpre[i])
#            new_dict[Wpre[i]] = lifted_numerator.(pullback(f).(I[V[j[i]]]))
#          end
#        end
#      end
#    end
#  end
#  return IdealSheaf(X, C, new_dict)
#end

function +(I::AbsIdealSheaf, J::AbsIdealSheaf)
  return SumIdealSheaf([I, J])
end

function +(I::SumIdealSheaf, J::AbsIdealSheaf)
  return SumIdealSheaf(vcat(summands(I), [J]))
end

function +(I::AbsIdealSheaf, J::SumIdealSheaf)
  return SumIdealSheaf(vcat([I], summands(J)))
end

function +(I::SumIdealSheaf, J::SumIdealSheaf)
  return SumIdealSheaf(vcat(summands(I), summands(J)))
end

function *(I::AbsIdealSheaf, J::AbsIdealSheaf)
  return ProductIdealSheaf([I, J])
end

function *(I::ProductIdealSheaf, J::AbsIdealSheaf)
  return ProductIdealSheaf(vcat(factors(I), [J]))
end

function *(I::AbsIdealSheaf, J::ProductIdealSheaf)
  return ProductIdealSheaf(vcat([I], factors(J)))
end

function *(I::ProductIdealSheaf, J::ProductIdealSheaf)
  return ProductIdealSheaf(vcat(factors(I), factors(J)))
end

function simplify(I::AbsIdealSheaf)
  return SimplifiedIdealSheaf(I)
end

@doc raw"""
    simplify!(I::AbsIdealSheaf)

Replaces the set of generators of the ideal sheaf on each cached chart by a small generating set.
"""
function simplify!(I::IdealSheaf, cov::Covering=default_covering(space(I)))
  object_cache = I.I.obj_cache

  for U in basic_patches(cov)
    if !any(U===i for i in keys(object_cache))
      continue
    end
    object_cache[U] = ideal(OO(U), small_generating_set(I(U)))
  end
  return I
end

@doc """
    subscheme(I::AbsIdealSheaf)

For an ideal sheaf ``â„`` on an `AbsCoveredScheme` ``X`` return
the subscheme ``Y âŠ‚ X`` given by the zero locus of ``â„``.
"""
function subscheme(I::AbsIdealSheaf; covering::Covering=default_covering(scheme(I)))
  X = space(I)
  C = covering
  new_patches = IdDict{AbsAffineScheme, AbsAffineScheme}([U=>subscheme(U, I(U)) for U in basic_patches(C) if !isone(I(U))])
  new_gluings = IdDict{Tuple{AbsAffineScheme, AbsAffineScheme}, AbsGluing}()
  decomp_dict = IdDict{AbsAffineScheme, Vector{RingElem}}()
  for (U, Unew) in new_patches
    for (V, Vnew) in new_patches
      (U, V) in keys(gluings(C)) || continue # No gluing before, no gluing after.
      old_glue = C[U, V]
      new_gluings[(Unew, Vnew)] = LazyGluing(Unew, Vnew,
                                             RestrictionDataClosedEmbedding(C[U, V], Unew, Vnew)
                                            )
    end
  end
  Cnew = Covering(collect(values(new_patches)), new_gluings, check=false)

  # Inherit decomposition information if applicable
  if has_decomposition_info(C)
    for (U, V) in new_patches
      set_decomposition_info!(Cnew, V, elem_type(OO(V))[OO(V)(a, check=false) for a in decomposition_info(C)[U]])
    end
  end
  return CoveredScheme(Cnew)
end


@attr Union{Int, NegInf} function dim(I::AbsIdealSheaf)
  dims = [dim(I(U)) for U in affine_charts(scheme(I))]
  return maximum(dims)
end
  
@attr Bool function has_dimension_leq_zero(I::Ideal)
  is_one(I) && return true
  return dim(I) <= 0
end

@attr Bool function has_dimension_leq_zero(I::MPolyLocalizedIdeal)
  R = base_ring(I)
  P = base_ring(R)::MPolyRing
  J = ideal(P, numerator.(gens(I)))
  has_dimension_leq_zero(J) && return true
  is_one(I) && return true
  return dim(I) <= 0
end

@attr Bool function has_dimension_leq_zero(I::MPolyQuoLocalizedIdeal)
  R = base_ring(I)
  P = base_ring(R)::MPolyRing
  J = pre_saturated_ideal(pre_image_ideal(I))
  has_dimension_leq_zero(J) && return true
  is_one(I) && return true
  return dim(I) <= 0
end


function has_dimension_leq_zero(I::AbsIdealSheaf; covering::Covering=default_covering(scheme(I)))
  for U in keys(object_cache(I))
    has_dimension_leq_zero(I(U)) || return false
  end

  all_patches = patches(covering)
  for U in all_patches
    if !has_dimension_leq_zero(cheap_sub_ideal(I, U))
      has_dimension_leq_zero(I(U)) || return false
    end
  end
  return true
end

function has_dimension_leq_zero(I::SumIdealSheaf; 
    covering::Covering=default_covering(scheme(I)),
    use_decomposition_info::Bool=true
  )
  J = summands(I)

  common_patches = keys(object_cache(first(J)))
  for JJ in J[2:end]
    common_patches = [U for U in common_patches if U in keys(object_cache(JJ))]
  end

  for U in common_patches
    has_dimension_leq_zero(I(U)) || return false
  end

  all_patches = patches(covering)
  for U in all_patches
    patch_ok = false
    # go through the object cache of the summands
    if U in keys(object_cache(I))
      i = I(U)
      if has_decomposition_info(covering) && use_decomposition_info
        K = ideal(OO(U), OO(U).(decomposition_info(covering)[U]))
        has_dimension_leq_zero(K + i) && (patch_ok = true)
      else
        has_dimension_leq_zero(i) && (patch_ok = true)
      end
      patch_ok && continue
    end

    # Do the same for the summands
    for j in summands(I)
      if U in keys(object_cache(j))
        j_loc = j(U)
        if has_decomposition_info(covering) && use_decomposition_info
          K = ideal(OO(U), OO(U).(decomposition_info(covering)[U]))
          has_dimension_leq_zero(K + j_loc) && (patch_ok = true)
        else
          has_dimension_leq_zero(j_loc) && (patch_ok = true)
        end
        patch_ok && break
      end
    end
    patch_ok && continue

    # repeat with cheap sub-ideals
    for j in summands(I)
      j_cheap = cheap_sub_ideal(j, U)
      if has_decomposition_info(covering) && use_decomposition_info
        K = ideal(OO(U), OO(U).(decomposition_info(covering)[U]))
        has_dimension_leq_zero(K + j_cheap) && (patch_ok = true)
      else
        has_dimension_leq_zero(j_cheap) && (patch_ok = true)
      end
      patch_ok && break
    end
    patch_ok && continue

    if has_decomposition_info(covering) && use_decomposition_info
      K = ideal(OO(U), OO(U).(decomposition_info(covering)[U]))
      if !has_dimension_leq_zero(cheap_sub_ideal(I, U) + K)
        has_dimension_leq_zero(I(U) + K) || return false
      end
    else
      if !has_dimension_leq_zero(cheap_sub_ideal(I, U))
        has_dimension_leq_zero(I(U)) || return false
      end
    end
  end
  return true
end
  
@doc raw"""
    extend!(C::Covering, D::Dict{AffineSchemeType, IdealType}) where {AffineSchemeType<:AffineScheme, IdealType<:Ideal}

For ``C`` a covering and ``D`` a dictionary holding vectors of
polynomials on affine patches of ``C`` this function extends the
collection of polynomials over all patches in a compatible way;
meaning that on the overlaps the restrictions of either two sets
of polynomials coincides.

This proceeds by crawling through the gluing graph and taking
closures in the patches ``Uâ±¼`` of the subschemes
``Záµ¢â±¼ = V(I) âˆ© Uáµ¢ âˆ© Uâ±¼`` in the intersection with a patch ``Uáµ¢``
on which ``I`` had already been described.

Note that the covering `C` is not modified.
"""
function extend!(
    C::Covering, D::IdDict{AbsAffineScheme, Ideal};
    all_dense::Bool=false
  )
  all(x->any(y->x===y, patches(C)), keys(D)) || error("ideals must be given on the `patches` of the covering")
  # push all nodes on which I is known in a heap
  visited = collect(keys(D))
  # The nodes which can be used for extension
  fat = AbsAffineScheme[U for U in visited if !isone(D[U])]
  # Nodes which are leafs
  flat = AbsAffineScheme[U for U in visited if isone(D[U])]
  # Nodes to which we might need to extend
  leftover = AbsAffineScheme[U for U in patches(C) if !(U in keys(D))]
  # Nodes to which we can extend in one step
  neighbors = AbsAffineScheme[U for U in leftover if any(V->haskey(gluings(C), (U, V)), fat)]
  # All other nodes
  leftover = AbsAffineScheme[U for U in leftover if !any(W->W===U, neighbors)]
  while length(neighbors) > 0
    good_pairs = Vector{Tuple{AbsAffineScheme, AbsAffineScheme}}()
    for V in neighbors
      for U in fat
        G = C[U, V]
        if (G isa SimpleGluing || (G isa LazyGluing && is_computed(G)))
          push!(good_pairs, (U, V))
        end
      end
    end

    # Initialize some variables
    U = first(visited) # The visited node
    V = first(visited) # The neighboring node for which we do the extension
    if !isempty(good_pairs)
      # In case we find a good neighboring pair, use that
      (U, V) = first(good_pairs)
    else
      # If there is no good neighboring pair, compute a new gluing
      V = first(neighbors)
      k = findfirst(U->haskey(gluings(C), (U, V)), fat)
      U = fat[k]
    end
    f, _ = gluing_morphisms(C[V, U])
    if C[V, U] isa SimpleGluing || (C[V, U] isa LazyGluing && first(gluing_domains(C[V, U])) isa PrincipalOpenSubset)

      # Take a shortcut if possible
      _, UV = gluing_domains(C[V, U])
      if isone(ideal(OO(UV), OO(UV).(gens(D[U]), check=false)))
        D[V] = ideal(OO(V), one(OO(V)))
        # Register this patch as a leaf
        push!(flat, V)
        # Update the neighbors
        neighbors = [W for W in neighbors if !(W===V)]
        continue
      end

      # if not, extend D to this patch
      f, _ = gluing_morphisms(C[V, U])
      pbI_gens = pullback(f).([OO(codomain(f))(x, check=false) for x in gens(D[U])])
      J = ideal(OO(V), lifted_numerator.(pbI_gens))
      #J_sat = saturation(J, ideal(OO(V), complement_equation(domain(f))))
      J_sat = _iterative_saturation(J, lifted_numerator(complement_equation(domain(f))))
      D[V] = J_sat
    else
      Z = subscheme(U, D[U])
      pZ = preimage(f, Z, check=false)
      ZV = closure(pZ, V, check=false)
      D[V] = ideal(OO(V), [g for g in OO(V).(small_generating_set(saturated_ideal(modulus(OO(ZV))))) if !iszero(g)])
    end

    # Update the neighbors
    neighbors = [W for W in neighbors if !(W===V)]
    # Put that new node in the correct list
    if isone(D[V])
      push!(flat, V)
    else
      push!(fat, V)
      for W in leftover
        if haskey(gluings(C), (V, W))
          push!(neighbors, W)
        end
      end
      leftover = [W for W in leftover if !any(x->x===W, neighbors)]
    end
  end
  for U in basic_patches(C)
    if !haskey(D, U)
      D[U] = ideal(OO(U), one(OO(U)))
    end
  end
  return D
end

function _iterative_saturation(I::Ideal, f::RingElem)
  return _iterative_saturation(I, typeof(f)[u for (u, _) in factor(f)])
end

function _iterative_saturation(I::Ideal, f::Vector{T}) where{T<:RingElem}
  R = base_ring(I)
  for u in f
    I = saturation(I, ideal(R, u))
  end
  return I
end

function ==(I::AbsIdealSheaf, J::AbsIdealSheaf)
  I === J && return true
  X = space(I)
  if X isa NormalToricVariety
    X === space(J) || return false
  else
    X == space(J) || return false
  end
  for U in basic_patches(default_covering(X))
    is_subset(I(U), J(U)) && is_subset(J(U), I(U)) || return false
  end
  return true
end

function Base.hash(I::AbsIdealSheaf, h::UInt)
  h = hash(scheme(I), h)
  return h
end

function is_subset(I::AbsIdealSheaf, J::AbsIdealSheaf)
  X = space(I)
  X === space(J) || return false
  for U in basic_patches(default_covering(X))
    is_subset(I(U), J(U)) || return false
  end
  return true
end

# prepares a refinement C' of the covering for the ideal sheaf I
# such that I can be generated by a regular sequence defining a smooth
# local complete intersection subscheme in every patch U of C' and
# returns the ideal sheaf with those generators on C'.
#function as_smooth_lci(
#    I::IdealSheaf;
#    verbose::Bool=false,
#    check::Bool=true,
#    codimension::Int=dim(scheme(I))-dim(subscheme(I)) #assumes both scheme(I) and its subscheme to be equidimensional
#  )
#  X = scheme(I)
#  C = covering(I)
#  AffineSchemeType = affine_patch_type(C)
#  PolyType = poly_type(AffineSchemeType)
#  new_gens_dict = Dict{AffineSchemeType, Vector{PolyType}}()
#  for U in patches(C)
#    V, spec_dict = as_smooth_lci(U, I[U],
#                                 verbose=verbose,
#                                 check=check,
#                                 codimension=codimension)
#    add_affine_refinement!(C, V)
#    merge!(new_gens_dict, spec_dict)
#  end
#  Iprep = IdealSheaf(X, C, new_gens_dict)
#  set_attribute!(Iprep, :is_regular_sequence, true)
#  return Iprep
#end
#
#function as_smooth_lci(
#    U::AffineScheme, g::Vector{T};
#    verbose::Bool=false,
#    check::Bool=true,
#    codimension::Int=dim(U)-dim(subscheme(U, g)) # this assumes both U and its subscheme to be equidimensional
#  ) where {T<:MPolyRingElem}
#  verbose && println("preparing $g as a local complete intersection on $U")
#  f = numerator.(gens(localized_modulus(OO(U))))
#  f = [a for a in f if !iszero(a)]
#  verbose && println("found $(length(f)) generators for the ideal defining U")
#  h = vcat(f, g)
#  r = length(f)
#  s = length(g)
#  Dh = jacobian_matrix(h)
#  (ll, ql, rl, cl) = _non_degeneration_cover(subscheme(U, g), Dh, codimension + codim(U),
#                          verbose=verbose, check=check,
#                          restricted_columns=[collect(1:r), [r + k for k in 1:s]])
#
#  n = length(ll)
#  # first process the necessary refinements of U
#  # The restricted columns in the call to _non_degenerate_cover
#  # assure that the first codim(U) entries of every cl[i] are
#  # indices of some element of f. However, we can discard these,
#  # as they are trivial generators of the ideal sheaf on U.
#  minor_list = [det(Dh[rl[i], cl[i]]) for i in 1:n]
#  V = Vector{open_subset_type(U)}()
#  AffineSchemeType = typeof(U)
#  PolyType = poly_type(U)
#  spec_dict = Dict{AffineSchemeType, Vector{PolyType}}()
#  g = Vector{PolyType}()
#  W = AffineSchemeOpenSubscheme(U, minor_list)
#  for i in 1:n
#    spec_dict[W[i]] = h[cl[i][codim(U)+1:end]]
#  end
#  return W, spec_dict
#end
#

@attr Bool function is_one(I::AbsIdealSheaf; covering::Covering=default_covering(scheme(I)))
  for U in keys(object_cache(I))
    !is_one(cheap_sub_ideal(I, U)) && !is_one(I(U)) && return false
  end
  return all(x->isone(I(x)), covering)
end

function is_one(I::PrimeIdealSheafFromChart; covering::Covering=default_covering(scheme(I)))
  return false
end

function dim(I::PrimeIdealSheafFromChart)
  return dim(I(original_chart(I)))
end

@attr Bool function is_one(I::SumIdealSheaf; covering::Covering=default_covering(scheme(I)))
  for U in keys(object_cache(I))
    !is_one(I(U)) && return false
  end

  J = summands(I)
  k = findfirst(x->x isa PrimeIdealSheafFromChart, J)
  if k !== nothing
    P = J[k]
    U = original_chart(P)
    if !is_one(cheap_sub_ideal(I, U))
      is_one(I(U)) || return false
    end
  end
  
  if has_decomposition_info(covering)
    dec = decomposition_info(covering)
    for U in covering 
      D = ideal(OO(U), dec[U])
      K = D
      for J in summands(I) # shortcut for trivial patches
        if U in keys(object_cache(J))
          K = K + J(U)
        end 
      end
      isone(K) && continue
      
      isone(D + cheap_sub_ideal(I, U)) || isone(I(U)+D) || return false
    end 
    return true
  end
  return all(x->(isone(cheap_sub_ideal(I, x)) || isone(I(x))), covering)
end

function is_one(I::ProductIdealSheaf; covering::Covering=default_covering(scheme(I)))
  return all(is_one, factors(I))
end

@doc raw"""
    is_prime(I::AbsIdealSheaf) -> Bool

Return whether ``I`` is prime.

We say that a sheaf of ideals is prime if its support is irreducible and
``I`` is locally prime. (Note that the empty set is not irreducible.)
"""
@attr Bool function is_prime(I::AbsIdealSheaf)
  is_locally_prime(I) || return false
  # TODO: this can be made more efficient
  PD = maximal_associated_points(I)
  return length(PD)==1
end

function is_prime(I::PrimeIdealSheafFromChart)
  return true
end

has_is_prime(I::PrimeIdealSheafFromChart) = true
has_is_prime(I::AbsIdealSheaf) = has_attribute(I, :is_prime)

@doc raw"""
    is_locally_prime(I::AbsIdealSheaf) -> Bool

Return whether ``I`` is locally prime.

A sheaf of ideals $\mathcal{I}$ is locally prime if its stalk $\mathcal{I}_p$
at every point $p$ is one or prime.
"""
@attr Bool function is_locally_prime(I::AbsIdealSheaf)
  return all(U->is_prime(I(U)) || is_one(I(U)), basic_patches(default_covering(space(I))))
end

is_locally_prime(I::PrimeIdealSheafFromChart) = true

function is_equidimensional(I::AbsIdealSheaf; covering=default_covering(scheme(I)))
  has_attribute(I, :is_equidimensional) && return get_attribute(I, :is_equidimensional)::Bool
  has_attribute(I, :is_prime) && get_attribute(I, :is_prime)::Bool && return true
  local_dims = [dim(I(U)) for U in patches(covering) if !isone(I(U))]
  length(local_dims) == 0 && return true # This only happens if I == OO(X)
  d = first(local_dims)
  if !all(==(d), local_dims) ||
     !all(U->(isone(I(U)) || is_equidimensional(I(U))), patches(covering))
    set_attribute!(I, :is_equidimensional=>false)
    return false
  else
    set_attribute!(I, :is_equidimensional=>true)
    return true
  end
end

is_equidimensional(I::PrimeIdealSheafFromChart) = true

@attr Bool function is_equidimensional(I::MPolyIdeal)
  decomp = equidimensional_decomposition_weak(I)
  return isone(length(decomp))
end

@attr Bool function is_equidimensional(I::MPolyQuoIdeal)
  is_equidimensional(saturated_ideal(I))
end

@attr Bool function is_equidimensional(I::MPolyLocalizedIdeal)
  return is_equidimensional(saturated_ideal(I))
end

@attr Bool function is_equidimensional(I::MPolyQuoLocalizedIdeal)
  return is_equidimensional(pre_image_ideal(I))
end

@doc raw"""
    _minimal_power_such_that(
        I::Ideal, P::PropertyType;
        boundary_for_incremental_strategy::Union{Int, PosInf}=inf
      ) where {PropertyType}

Find a minimal exponent `k` such that `P(I^k) == true` where `P` is 
some property which can be evaluated on an ideal; return the pair 
`(k, I^k)`.

By default, this is done by bisection, i.e. first we try with powers 
`I^0, I^1, I^2, I^4, I^8, I^16, ...` until we obtain `P(I^k) == true` 
for the first time and then downwards bisection to find the minimal 
exponent with this property. 

As this is prone to quickly trigger Groebner basis computations of ideals 
with generators of rather high degree, we provide the keyword argument 
`boundary_for_incremental_strategy`. If set to some integer value `k_lim`, 
the build up phase for finding powers `J = I^(2^r)` with `P(J) == true` 
is aborted, once `2^r >= k_lim` and an incremental search for the lowest 
exponent is done instead. 
"""
function _minimal_power_such_that(
    I::Ideal, P::PropertyType;
    boundary_for_incremental_strategy::Union{Int, PosInf}=inf
  ) where {PropertyType}
  whole_ring = ideal(base_ring(I), [one(base_ring(I))])
  P(whole_ring) && return (0, whole_ring)
  P(I) && return (1, I)
  I_powers = [(1,I)]

  # building up a cache by iterated squaring of the exponent
  while 2*last(I_powers)[1] < boundary_for_incremental_strategy && !P(last(I_powers)[2])
    push!(I_powers, (last(I_powers)[1]*2, last(I_powers)[2]^2))
  end

  # if we crossed the boundary for the build up, switch to dumb iteration
  if 2*last(I_powers)[1] >= boundary_for_incremental_strategy && !P(last(I_powers)[2])
    while true
      push!(I_powers, (last(I_powers)[1]+1, last(I_powers)[2]*I))
      k, J = last(I_powers)
      P(J) && return k, J
    end
  end

  upper = pop!(I_powers)
  lower = pop!(I_powers)
  while upper[1]!=lower[1]+1
    middle = pop!(I_powers)
    middle = (lower[1]+middle[1], lower[2]*middle[2])
    if P(middle[2])
      upper = middle
    else
      lower = middle
    end
  end
  return upper
end

@doc raw"""
    order_of_vanishing(f::VarietyFunctionFieldElem, D::WeilDivisor; check::Bool=true) -> Int

Return the order of the rational function `f` on the prime divisor `D`.
"""
function order_of_vanishing(f::VarietyFunctionFieldElem, D::WeilDivisor; check::Bool=true)
  @check is_prime(D) "divisor must be prime for the order of vanishing to be defined"
  P = components(D)[1]
  return order_of_vanishing(f, P; check=false)
end 

@doc raw"""
    order_of_vanishing(f::VarietyFunctionFieldElem, I::AbsIdealSheaf; check::Bool=true) -> Int

Return the order of the rational function `f` on the prime divisor given by the ideal sheaf `I`.
"""
function order_of_vanishing(
    f::VarietyFunctionFieldElem,
    I::AbsIdealSheaf;
    check::Bool=true
  )
  @check is_prime(I) "ideal sheaf must be a sheaf of prime ideals"

  X = space(I)::AbsCoveredScheme
  X == variety(parent(f)) || error("schemes not compatible")

  # Since X is integral and I is a sheaf of prime ideals,
  # it suffices to find one chart in which I is non-trivial.

  # We look for the chart with the least complexity
  V = first(affine_charts(X))
  complexity = inf
  for U in keys(Oscar.object_cache(underlying_presheaf(I))) # Those charts on which I is known.
    U in default_covering(X) || continue
    is_one(I(U)) && continue
    tmp = sum([total_degree(lifted_numerator(g)) for g in gens(I(U)) if !iszero(g)]) # /ngens(Oscar.pre_image_ideal(I(U)))
    if tmp < complexity
      complexity = tmp
      V = U
    end
  end
  flag = false
  if complexity == inf
    for U in X[1]
      is_one(I(U)) && continue
      # no chart has been computed, so we just take the first one
      flag = true
      V = U
      break
    end
    flag || error("divisor is empty")
  end
  R = ambient_coordinate_ring(V)
  J = saturated_ideal(I(V))
  K = saturated_ideal(defining_ideal(V))
  floc = f[V]
  aR = ideal(R, numerator(floc))
  bR = ideal(R, denominator(floc))

  # The following uses ArXiv:2103.15101, Lemma 2.18 (4):
  num_mult = _minimal_power_such_that(J, x->(issubset(quotient(x+K, aR), J)); boundary_for_incremental_strategy=4)[1]-1
  den_mult = _minimal_power_such_that(J, x->(issubset(quotient(x+K, bR), J)); boundary_for_incremental_strategy=4)[1]-1
  return num_mult - den_mult
end

@doc raw"""
    smooth_lci_covering(I::AbsIdealSheaf)

For an ideal sheaf ``â„`` on a *smooth* scheme ``X`` with a *smooth*
associated subscheme ``Y = V(â„)`` this produces a covering ``ð”˜ = {Uâ‚}, a âˆˆ A``
such that ``â„(Uâ‚) = âŸ¨fâ‚,â€¦,fâ‚–âŸ©`` is generated by a regular sequence on every
patch ``Uâ‚`` of that covering.
"""
function smooth_lci_covering(I::AbsIdealSheaf)
  error("not implemented")
end

### pushforward of ideal sheaves along closed embeddings
function pushforward(inc::CoveredClosedEmbedding, I::AbsIdealSheaf)
  return PushforwardIdealSheaf(inc, I)
end

function pushforward(inc::CoveredClosedEmbedding, I::PrimeIdealSheafFromChart)
  X = scheme(I)
  @assert X === domain(inc)
  U = original_chart(I)
  inc_cov = covering_morphism(inc)
  dom_cov = domain(inc_cov)
  def_cov = default_covering(X)
  V = __find_chart(U, def_cov)
  for UU in patches(dom_cov)
    if has_ancestor(x->x===V, UU)
      if !is_one(I(V))
        J = pushforward(inc_cov[UU], I(UU))
        return PrimeIdealSheafFromChart(codomain(inc), codomain(inc_cov[UU]), J)
      else
        continue
      end
    end
  end
  error("no patch found")
end

morphism(I::PushforwardIdealSheaf) = I.f
original_ideal_sheaf(I::PushforwardIdealSheaf) = I.orig
underlying_presheaf(I::PushforwardIdealSheaf) = I.Ipre

function produce_object_on_affine_chart(II::PushforwardIdealSheaf, U::AbsAffineScheme)
  f = morphism(II)
  def_cov = default_covering(codomain(f))
  phi = covering_morphism(f)
  g = [g for (V, g) in morphisms(phi) if has_ancestor(x->x===U, codomain(g))]
  is_empty(g) && return ideal(OO(U), one(OO(U))) # the domain scheme is not visible in this chart
  loc_id_dict = IdDict{AbsAffineScheme, Ideal}(codomain(inc)=>pushforward(inc, original_ideal_sheaf(II)(domain(inc))) for inc in g)
  # Assemble the ideal on U from those in the patches covering it
  loc_id = [pullback(inverse(_flatten_open_subscheme(V, def_cov)))(I) for (V, I) in loc_id_dict]
  return ideal(OO(U), gens(reduce(intersect, saturated_ideal.(loc_id))))
  return pushforward(inc, original_ideal_sheaf(II)(domain(inc)))
end

function pushforward(inc::ClosedEmbedding, I::Ideal)
  Y = domain(inc)
  base_ring(I) === OO(Y) || error("ideal is not defined in the coordinate ring of the domain")
  X = codomain(inc)
  return ideal(OO(X), vcat(gens(image_ideal(inc)),
                           OO(X).(lifted_numerator.(gens(I))))
              )
end

function radical_membership(x::RingElem, I::MPolyLocalizedIdeal)
  return radical_membership(lifted_numerator(x), saturated_ideal(I))
end

function radical_membership(x::RingElem, I::MPolyQuoLocalizedIdeal)
  return radical_membership(lifted_numerator(x), saturated_ideal(I))
end

########################################################################
# primary decomposition
########################################################################

@doc raw"""
    maximal_associated_points(I::AbsIdealSheaf)

Return a `Vector` of `AbsIdealSheaf`s corresponding to the non-embedded associated points of ``I`` on ``scheme(I)``.

Note:
For usability reasons these associated points are not encoded as a subscheme, but as the corresponding ideal sheaf defining the subscheme.

Background:
More generally, a point ``x`` on a scheme ``X`` associated to a quasi-coherent sheaf ``F`` is embedded, if it is the specialization of another associated point of ``F``.
Note that maximal associated points of an ideal sheaf on an affine scheme ``Spec(A)`` correspond to the minimal associated primes of the corresponding ideal in ``A``.
"""
function maximal_associated_points(
    I::AbsIdealSheaf; 
    covering=default_covering(scheme(I)), 
    use_decomposition_info::Bool=true,
    algorithm::Symbol=:GTZ,
    mode::Symbol=:save_gluings
  )
  X = scheme(I)
  comps = AbsIdealSheaf[]
  for U in patches(covering)
    loc_dec = elem_type(OO(U))[] # Initialize the variable
    if use_decomposition_info && has_decomposition_info(covering)
      # A list of equations which indicate the locus in this chart 
      # which is *not* visible in "previous" charts. 
      loc_dec = elem_type(OO(U))[OO(U)(a) for a in decomposition_info(covering)[U]]
      # If the following holds, everything is visible in other charts already.
      is_one(I(U) + ideal(OO(U), loc_dec)) && continue
    else
      # trivial charts can be skipped
      is_one(I(U)) && continue
    end
    #all(g->radical_membership(g, I(U)), loc_dec) && continue
    loc_primes = minimal_primes(I(U); algorithm)

    # Take only those not visible in other charts 
    use_decomposition_info && has_decomposition_info(covering) && filter!(p->all(in(p), loc_dec), loc_primes) 
    for p in loc_primes
      P = PrimeIdealSheafFromChart(X, U, p)
      P in comps && continue
      #any(q->q(U) == p, comps) && continue # p is just the local version of a component already collected
      # We found a new component! Keep it.
      push!(comps, P)
    end
  end

  if mode==:save_gluings && length(comps)==1
    R = radical(I)
    set_attribute!(R, :is_prime=>true)
    P = comps[1]
    U = original_chart(P)
    object_cache(R)[U] = P(U)
    comps = AbsIdealSheaf[R]
  end
  # Manually fill up the cache
  if use_decomposition_info 
    # we can at least remember some partial information 
    for U in patches(covering)
      if isone(I(U))
        I_one = ideal(OO(U), one(OO(U)))
        for P in comps
          object_cache(P)[U] = I_one
        end
      end
    end
  else 
    # We can only do this if all we treated all components on all charts.
    for U in patches(covering)
      I_one = ideal(OO(U), one(OO(U)))
      for P in comps
        haskey(object_cache(P), U) && continue
        object_cache(P)[U] = I_one
      end
    end
  end

  return comps
end

@doc raw"""
    minimal_primes(I::AbsIdealSheaf; kwargs...)

Return the minimal prime ideal sheaves of ``I``.

These are the ideal sheaves of the maximal associated points of ``I``.

See [`maximal_associated_points`](@ref) for possible keyword arguments.
"""
minimal_primes(I::AbsIdealSheaf; kwargs...) = maximal_associated_points(I; kwargs...)

@doc raw"""
    associated_primes(I::AbsIdealSheaf; kwargs...)

Return the prime ideal sheaves associated to``I``.

These are the ideal sheaves of the associated points of ``I``.

See [`associated_points`](@ref) for possible keyword arguments.
"""
associated_primes(I::AbsIdealSheaf; kwargs...) = associated_points(I; kwargs...)
  
  
@doc raw"""
    associated_points(I::AbsIdealSheaf)

Return a `Vector` of `AbsIdealSheaf`s corresponding to the associated points of ``I`` on ``scheme(I)``.

Note:
For usability reasons an associated point is not encoded as subscheme, but as the corresponding ideal sheaf defining the subscheme.

Background:
More generally, a point ``x`` on a scheme ``X`` is associated to a quasi-coherent sheaf ``F``, if the maximal ideal ``m_x`` is associated to the ``O_{X,x}``-module ``F_x``.
If ``U = Spec(A)`` is an affine open on a locally noetherian scheme ``X``, ``x \in U`` and ``p \in A`` the corresponding prime ideal, then ``p \in Ass(\Gamma(U,F))`` iff ``x \in Ass(F)``.

"""
function associated_points(I::AbsIdealSheaf)
  !isone(I) || return typeof(I)[]
  X = scheme(I)
  OOX = OO(X)
  charts_todo = copy(affine_charts(X))            ## todo-list of charts

  associated_primes_temp = Vector{IdDict{AbsAffineScheme, Ideal}}()  ## already identified components
                                                  ## may not yet contain all relevant charts. but
                                                  ## at least one for each identified component

# run through all charts and try to match the components
  while !iszero(length(charts_todo))
    U = pop!(charts_todo)
    !is_one(I(U)) || continue                        ## supp(I) might not meet all components
    components_here = [ a for (_,a) in primary_decomposition(I(U))]

## run through all primes in Ass(I(U)) and try to match them with previously found ones
    for comp in components_here
      matches = match_on_intersections(X,U,comp,associated_primes_temp,false)
      nmatches = length(matches)

      if nmatches == 0                             ## not found
        add_dict = IdDict{AbsAffineScheme,Ideal}()         ## create new dict
        add_dict[U] = comp                         ## and fill it
        push!(associated_primes_temp, add_dict)
      elseif nmatches == 1                         ## unique match, update it
        component_index = matches[1]
        associated_primes_temp[component_index][U] = comp
      else                                                ## more than one match, form union
        target_comp = pop!(matches)
        merge!(associated_primes_temp[target_comp], associated_primes_temp[x] for x in matches)
        deleteat!(associated_primes_temp,matches)
        associated_primes_temp[target_comp][U] = comp
      end
    end
  end

# fill the gaps arising from a support not meeting a patch
  for U in affine_charts(X)
    I_one = ideal(OOX(U),one(OOX(U)))
    for i in 1:length(associated_primes_temp)
      !haskey(associated_primes_temp[i],U) || continue
      associated_primes_temp[i][U] = I_one
    end
  end

# make sure to return ideal sheaves, not dicts
  associated_primes_result = [IdealSheaf(X,associated_primes_temp[i],check=false) for i in 1:length(associated_primes_temp)]
  for Itemp in associated_primes_result
    set_attribute!(Itemp, :is_prime=>true)
  end
  return associated_primes_result
end

# Given a prime ideal I on an `affine_chart` U of X and a list 
# of dictionaries { V=>(some prime ideal) } representing prime 
# ideal sheaves on X, this function tries to match I with the 
# entries of the list. 
function match_on_intersections(
      X::AbsCoveredScheme,
      U::AbsAffineScheme,
      I::Union{<:MPolyIdeal, <:MPolyQuoIdeal, <:MPolyQuoLocalizedIdeal, <:MPolyLocalizedIdeal},
      associated_list::Vector{<:IdDict{<:AbsAffineScheme, <:Ideal}},
      check::Bool=true)
  @vprint :MaximalAssociatedPoints 2 "matching $(I) \n to $(length(associated_list))\n on $(U)\n"
  matches = Int[] # the indices of entries in the list matching I on U
  OOX = OO(X)
# run through all components in associated_list and try to match up I
  for i in 1:length(associated_list)
    match_found = false
    match_contradicted = false

## run through all known patches of the component
    for (V,IV) in associated_list[i]
      G = default_covering(X)[V,U]
      VU, UV = gluing_domains(G)
      if UV isa AffineSchemeOpenSubscheme && VU isa AffineSchemeOpenSubscheme
        # This first case is probably never triggered, because the type is hardly used anymore
        I_res = [OOX(U, UV[i])(I) for i in 1:ngens(UV)]
        IV_res = [OOX(V, UV[i])(IV) for i in 1:ngens(UV)]
        if all(i->(I_res[i] == IV_res[i]), 1:ngens(UV))
          match_found = !all(is_one, I_res)                               ## count only non-trivial matches
          check || break
        else
          match_contradicted = true
          check || break
        end
      elseif UV isa AbsAffineScheme && VU isa AbsAffineScheme
        # Restrict I to the gluing domain
        I_res = OOX(U,UV)(I)
        # Pull the other ideal to the gluing domain
        IV_res = OOX(V,UV)(IV)
        if (I_res == IV_res)
          match_found = !is_one(I_res)                               ## count only non-trivial matches
          check || break
        else
          match_contradicted = true
          check || break
        end
      else
        error("case not implemented")
      end
    end

## make sure we are working on consistent data
   @check begin
      if match_found && match_contradicted
        error("contradictory matching result!!")                     ## this should not be reached for ass. points
      end
    end

## update list of matches
    if match_found
      push!(matches, i)
    end
  end

  return matches
end

function (phi::Map{D, C})(I::Ideal) where {D<:Ring, C<:Ring}
  base_ring(I) === domain(phi) || error("ideal not defined over the domain of the map")
  R = domain(phi)
  S = codomain(phi)
  return ideal(S, phi.(gens(I)))
end

# Workaround for ambiguity
function (id::AbstractAlgebra.Generic.IdentityMap{D})(I::Ideal) where {D<:Ring}
  return I
end

# Necessary for removing ambiguities
function (phi::AbstractAlgebra.Generic.CompositeMap{D, C})(I::Ideal) where {D<:Ring, C<:Ring}
  base_ring(I) === domain(phi) || error("ideal not defined over the domain of the map")
  R = domain(phi)
  S = codomain(phi)
  return ideal(S, phi.(gens(I)))
end

function (phi::MPolyAnyMap{D, C})(I::MPolyIdeal) where {D<:MPolyRing, C<:Ring}
  base_ring(I) === domain(phi) || error("ideal not defined over the domain of the map")
  R = domain(phi)
  S = codomain(phi)
  return ideal(S, phi.(gens(I)))
end

function (phi::MPolyAnyMap{D, C})(I::MPolyQuoIdeal) where {D<:MPolyQuoRing, C<:Ring}
  base_ring(I) === domain(phi) || error("ideal not defined over the domain of the map")
  R = domain(phi)
  S = codomain(phi)
  return ideal(S, phi.(gens(I)))
end

function complement_of_prime_ideal(P::MPolyQuoIdeal)
  return complement_of_prime_ideal(saturated_ideal(P))
end

function complement_of_prime_ideal(P::MPolyQuoLocalizedIdeal)
  return complement_of_prime_ideal(saturated_ideal(P))
end

function complement_of_prime_ideal(P::MPolyLocalizedIdeal)
  return complement_of_prime_ideal(saturated_ideal(P))
end

radical(I::PrimeIdealSheafFromChart) = I

# TODO: This function should be removed for ideal sheaves! 
# Reason: There is no "generating set" for ideal sheaves and even if there was, 
# this is not what the function returns. Whatever it is doing should probably 
# be subsumed under `simplify` and `simlpify!`.
# Why not remove it straight away? @afkafkafk13 is using it in the resolutions of singularities. 
# We will talk about the removal on Monday, March 11, 2024.
function small_generating_set(II::AbsIdealSheaf)
  X = scheme(II)
  # If there is a simplified covering, do the calculations there.
  covering = (has_attribute(X, :simplified_covering) ? simplified_covering(X) : default_covering(X))
  ID = IdDict{AbsAffineScheme, Ideal}()
  for U in patches(covering)
    ID[U] = ideal(OO(U), filter!(!iszero, OO(U).(small_generating_set(saturated_ideal(II(U))))))
  end
  return(IdealSheaf(X, ID, check = false))
end

###########################################################################
## show functions for Ideal sheaves
###########################################################################

# If we know things about the ideal sheaf, we print them
function Base.show(io::IO, I::AbsIdealSheaf)
  io = pretty(io)
  X = scheme(I)
  if get(io, :show_semi_compact, false)
    cov = Oscar._covering_for_printing(io, X)
    n = get(io, :label, "")
    _show_semi_compact(io, I, cov, n)
  else
    show_scheme = get(io, :show_scheme, true)
    if has_attribute(I, :dim) && has_attribute(X, :dim)
      z = dim(X) - dim(I) == 0 ? true : false
    else
      z = false
    end
    prim = get_attribute(I, :is_prime, false)::Bool
    if has_attribute(I, :name)
      print(io, get_attribute(I, :name))
    elseif is_terse(io)
      print(io, "Sheaf of ideals")
    else
      if get_attribute(I, :is_one, false)::Bool
        print(io, "Sheaf of unit ideals")
      elseif z
        print(io, "Sheaf of zero ideals")
      elseif prim
        print(io, "Sheaf of prime ideals")
      else
        print(io, "Sheaf of ideals")
      end
      if show_scheme
        print(io," on ", Lowercase(), X)
      end
    end
  end
end

function Base.show(io::IO, ::MIME"text/plain", I::PrimeIdealSheafFromChart)
  io = pretty(io)
  if has_attribute(I, :name)
    print(io, get_attribute(I, :name))
    return
  end
  print(io, "Prime ideal sheaf on ", scheme(I), " extended from ", I.P, " on ", I.U)
end

function Base.show(io::IO, ::MIME"text/plain", I::SumIdealSheaf)
  io = pretty(io)
  print(io, "Sum of \n")
  print(io, Indent())
  join(io, summands(I), "\n")
  print(io, Dedent())
end

function Base.show(io::IO, ::MIME"text/plain", I::ProductIdealSheaf)
  io = pretty(io)
  print(io, "Product of \n")
  print(io, Indent())
  join(io, factors(I), "\n")
  print(io, Dedent())
end

function Base.show(io::IO, I::SumIdealSheaf)
  io = pretty(io)
  print(io, "Sum of $(length(summands(I))) ideal sheaves")
end

function Base.show(io::IO, I::ProductIdealSheaf)
  io = pretty(io)
  print(io, "Product of $(length(factors(I))) ideal sheaves")
end

function Base.show(io::IO, I::PrimeIdealSheafFromChart)
  io = pretty(io)
  if has_attribute(I, :name)
    print(io, get_attribute(I, :name))
    return
  end
  print(io, "Prime ideal sheaf on ", 
        Lowercase(), scheme(I), " extended from ", 
        Lowercase(), I.P, " on ", 
        Lowercase(), I.U)
end

# This semi compact printing is used for nested printings, like in blow-up or
# for the description of Cartier divisors and algebraic cycles.
#
# We want to keep track of a given covering `voc`, for everything to be consistent. In
# case we may have several charts in the nest, we want to make sure to follow-up
# with the labels. Hence the string `n` allows one to do this.
# Usually, in morphisms printing, one would take "a" for the domain's charts
# and "b" for the codomain's ones.
#
# We take also care of left offsets when printing the labels - if there are more
# than 10 charts, this is necessary to have all the labels aligned on the right
function _show_semi_compact(io::IO, I::AbsIdealSheaf, cov::Covering, n::String)
  io = pretty(io)
  X = scheme(I)
  if has_attribute(I, :dim) && has_attribute(X, :dim)
    z = dim(X) - dim(I) == 0 ? true : false
  else
    z = false
  end
  prim = get_attribute(I, :is_prime, false)::Bool

  if get_attribute(I, :is_one, false)::Bool
    print(io, "Sheaf of unit ideals")
  elseif z
    print(io, "Sheaf of zero ideals")
  else
    # If there is a simplified covering, use it!
    if prim
      print(io, "Sheaf of prime ideals")
    else
      print(io, "Sheaf of ideals")
    end
    if length(cov) > 0
      l = ndigits(length(cov))
      print(io, " with restriction")
      length(cov) > 1 && print(io, "s")
      print(io, Indent())
      for (i, U) in enumerate(patches(cov))
        li = ndigits(i)
        println(io)
        print(io, " "^(l-li)*"$i"*n*": $(I(U))")
      end
      print(io, Dedent())
    end
  end
end

function Base.show(io::IO, ::MIME"text/plain", I::AbsIdealSheaf)
  io = pretty(io)
  X = scheme(I)
  cov = Oscar._covering_for_printing(io, X)
  # If there is a simplified covering, use it!
  println(io, "Sheaf of ideals")
  print(io, Indent(), "on ", Lowercase())
  show(IOContext(io, :show_semi_compact => true, :covering => cov), X)
  if length(cov) > 0
    l = ndigits(length(cov))
    println(io)
    print(io, Dedent(), "with restriction")
    length(cov) > 1 && print(io, "s")
    print(io, Indent())
    for (i, U) in enumerate(patches(cov))
      li = ndigits(i)
      println(io)
      print(io, " "^(l-li)*"$i: $(I(U))")
    end
    print(io, Dedent())
  end
end

function _separate_disjoint_components(comp::Vector{<:AbsIdealSheaf}; covering::Covering=default_covering(scheme(first(comp))))
  isempty(comp) && error("list of components must not be empty")
  X = scheme(first(comp))
  all(x->scheme(x) === X, comp) || error("components must be defined over the same scheme")
  isone(length(comp)) && return covering
  new_patches = Vector{AbsAffineScheme}()
  for U in patches(covering)
    isempty(U) && continue
    loc_comp = [I(U) for I in comp]
    loc_comp = [a for a in loc_comp if !isone(a)]
    if isempty(loc_comp) || isone(length(loc_comp))
      push!(new_patches, U)
      continue
    end
    cof = _cofactors(loc_comp)
    if isempty(cof)
      push!(new_patches, U)
    else
      new_patches = vcat(new_patches, [PrincipalOpenSubset(U, a) for a in cof])
    end
  end
  new_cov = Covering(new_patches)
  inherit_gluings!(new_cov, covering)
  return new_cov
end

function _cofactors(comp::Vector{<:Ideal})
  R = base_ring(first(comp))
  all(x->base_ring(x)===R, comp) || error("ideals must be defined over the same ring")
  n = length(comp)
  pairwise_cof = identity_matrix(R, n)
  for i in 1:n-1
    for j in i+1:n
      I = ideal(R, vcat(gens(comp[i]), gens(comp[j])))
      r = ngens(comp[i])
      s = ngens(comp[j])
      z = coordinates(one(R), I)
      x = z isa MatElem ? [z[1, k] for k in 1:r] : z[1:r]
      y = z isa MatElem ? [z[1, r+k] for k in 1:s] : z[r+1:r+s]
      pairwise_cof[i, j] = sum(x[k]*gen(comp[i], k) for k in 1:r; init=zero(R))
      pairwise_cof[j, i] = sum(y[k]*gen(comp[j], k) for k in 1:s; init=zero(R))
    end
  end
  result = [prod(pairwise_cof[1:n, i]) for i in 1:n]
  return result
end

function _one_patch_per_component(covering::Covering, comp::Vector{<:AbsIdealSheaf})
  new_patches2 = Vector{AbsAffineScheme}()
  patches_todo = copy(patches(covering))
  for P in comp
    # Find one patch in which this component is supported
    i = findfirst(U->!isone(P(U)), patches_todo)
    U = patches_todo[i]
    # Take this patch out of the list
    deleteat!(patches_todo, i)
    # Add it to the list of patches for the new covering
    push!(new_patches2, U)
    # For every other patch V in which P appears we do the following:
    # Replace V by the complement of the support of P.
    # This will not be affine in general, but can be covered by hypersurface
    # complements. Even though this may lead to many charts, they will be harmless
    # in the mext blowup.
    done = Int[]
    for (j, V) in enumerate(patches_todo)
      # Check whether P is visible in this patch; if not leave it
      isone(P(V)) && continue
      # Remember this patch to be done
      push!(done, j)
      sg = small_generating_set(P(V))
      new_patches2 = append!(new_patches2, [PrincipalOpenSubset(V,a) for a in sg])
      # TODO: Cache that P = 1 on all these new patches?
    end
    deleteat!(patches_todo, done)
  end
  new_patches2 = append!(new_patches2, patches_todo)
  new_cov = Covering(new_patches2)
  inherit_gluings!(new_cov, covering)
  return new_cov
end

@attr Vector{elem_type(base_ring(I))} function small_generating_set(I::MPolyLocalizedIdeal; algorithm::Symbol=:simple)
  L = base_ring(I)
  poly_ideal = pre_saturated_ideal(I)
  if algorithm == :simple
    # do nothing more
  elseif algorithm == :with_saturation
    poly_ideal = saturated_ideal(I)
  else
    error("algorithm keyword not recognized")
  end
  g = small_generating_set(poly_ideal)
  unique!(elem_type(L)[gg for gg in L.(g) if !iszero(gg)])
end

function saturation(I::AbsIdealSheaf, J::AbsIdealSheaf)
  X = scheme(I)
  K = IdDict{AbsAffineScheme, Ideal}()
  for U in affine_charts(X)
    K[U] = saturation(I(U), J(U))
  end
  return IdealSheaf(X, K, check=false)
end

function pushforward(f::AbsCoveredSchemeMorphism, II::AbsIdealSheaf)
  @req domain(f)===space(II) "ideal sheaf not defined on domain of morphism"
  f_cov = covering_morphism(f)
  dom_cov = domain(f_cov)
  cod_cov = codomain(f_cov)
  ideal_dict = IdDict{AbsAffineScheme, Ideal}()
  for V in cod_cov
    f_loc = maps_with_given_codomain(f_cov, V)
    I_loc = [preimage(pullback(f), II(domain(f))) for f in f_loc]
    ideal_dict[V] = intersect(I_loc...)
  end
  return IdealSheaf(codomain(f), ideal_dict, check=true) #TODO: Set to false
end
  

function Base.:^(II::AbsIdealSheaf, k::IntegerUnion)
  k < 0 && error("negative powers of ideal sheaves are not allowed")
  if iszero(k)
    X = scheme(II)
    return IdealSheaf(X, IdDict{AbsAffineScheme, Ideal}([U => ideal(OO(U), one(OO(U))) for U in affine_charts(X)]), check=false)
  end
  isone(k) && return II
  b = div(k, 2)
  r = k - b
  return II^b * II^r
end

original_chart(P::PrimeIdealSheafFromChart) = P.U

########################################################################
# production of the ideals for the various types
########################################################################

### generic override for the restriction map
produce_restriction_map(I::AbsIdealSheaf, U::AbsAffineScheme, V::AbsAffineScheme) = OO(scheme(I))(U, V)

### IdealSheaf
function produce_object(F::IdealSheaf, U::AbsAffineScheme)
  X = scheme(F)
  OOX = F.OOX
  ID = F.ID
  # If U is an affine chart on which the ideal has already been described, take that.
  haskey(ID, U) && return ID[U]
  # Transferring from another chart did not work. That means 
  # I(U) is already prescribed on some refinement of U. We 
  # need to gather that information from all the patches involved
  # and assemble the ideal from there.
  V = [W for W in keys(ID) if has_ancestor(x->(x===U), W)] # gather all patches under U

  # Check for some SimplifiedAffineScheme lurking around
  if any(x->(x isa SimplifiedAffineScheme), V)
    i = findfirst(x->(x isa SimplifiedAffineScheme), V)
    W = V[i]
    _, g = identification_maps(W)
    return ideal(OO(U), pullback(g).(gens(ID[W])))
  end

  length(V) == 0 && return ideal(OO(U), one(OO(U))) # In this case really nothing is defined here.
  # Just return the unit ideal so that the 
  # associated subscheme is empty.
  result = ideal(OO(U), one(OO(U)))
  V = filter!(x->(x isa PrincipalOpenSubset && ambient_scheme(x) === U), V)
  for VV in V
    result = intersect(result, ideal(OO(U), gens(saturated_ideal(produce_object(F, VV)))))
  end
  return result
end

function produce_object(F::IdealSheaf, U::PrincipalOpenSubset)
  X = scheme(F)
  OOX = F.OOX
  ID = F.ID
  haskey(ID, U) && return ID[U]
  V = ambient_scheme(U)
  # In case the ambient_scheme is leading out of the admissible domain, 
  # this is a top-chart and we have to reconstruct from below.
  if !is_open_func(F)(V, space(F)) 
    V = [W for W in keys(ID) if has_ancestor(x->(x===U), W)] # gather all patches under U

    # Check for some SimplifiedAffineScheme lurking around
    if any(x->(x isa SimplifiedAffineScheme), V)
      i = findfirst(x->(x isa SimplifiedAffineScheme), V)
      W = V[i]
      _, g = identification_maps(W)
      return ideal(OO(U), pullback(g).(gens(ID[W])))
    end

    length(V) == 0 && return ideal(OO(U), one(OO(U))) # In this case really nothing is defined here.
    # Just return the unit ideal so that the 
    # associated subscheme is empty.
    result = ideal(OO(U), one(OO(U)))
    V = filter!(x->(x isa PrincipalOpenSubset && ambient_scheme(x) === U), V)
    for VV in V
      result = intersect(result, ideal(OO(U), gens(saturated_ideal(produce_object(F, VV)))))
    end
    return result
  end

  IV = F(V)::Ideal
  rho = OOX(V, U)
  IU = ideal(OO(U), rho.(gens(IV)))
  return IU
end

function produce_object(F::IdealSheaf, U::SimplifiedAffineScheme)
  X = scheme(F)
  OOX = F.OOX
  ID = F.ID
  haskey(ID, U) && return ID[U]
  V = original(U)
  # In case the original is leading out of the admissible domain, 
  # this is a top-chart and we have to reconstruct from below.
  if !is_open_func(F)(V, space(F)) 
    V = [W for W in keys(ID) if has_ancestor(x->(x===U), W)] # gather all patches under U

    # Check for some SimplifiedAffineScheme lurking around
    if any(x->(x isa SimplifiedAffineScheme), V)
      i = findfirst(x->(x isa SimplifiedAffineScheme), V)
      W = V[i]
      _, g = identification_maps(W)
      return ideal(OO(U), pullback(g).(gens(ID[W])))
    end

    length(V) == 0 && return ideal(OO(U), one(OO(U))) # In this case really nothing is defined here.
    # Just return the unit ideal so that the 
    # associated subscheme is empty.
    result = ideal(OO(U), one(OO(U)))
    V = filter!(x->(x isa PrincipalOpenSubset && ambient_scheme(x) === U), V)
    for VV in V
      result = intersect(result, ideal(OO(U), gens(saturated_ideal(produce_object(F, VV)))))
    end
    return result
  end
  IV = F(V)::Ideal
  rho = OOX(V, U)
  IU = ideal(OO(U), rho.(gens(IV)))
  return IU
end

### Some generic functionality to allow for the production of objects 
# to happen only on the `affine_charts` of a given scheme.
function produce_object(F::AbsIdealSheaf, U::AbsAffineScheme)
  X = scheme(F)

  # If this is an affine chart, delegate to a specialized production method
  if any(V->V===U, affine_charts(X))
    return produce_object_on_affine_chart(F, U)
  end

  # Otherwise, construct the object generically from the affine charts.
  V = __find_chart(U, default_covering(X))
  return OO(X)(V, U)(F(V))
end

### PrimeIdealSheafFromChart
@doc raw"""
produce_object(F::PrimeIdealSheafFromChart, U2::AbsAffineScheme; 
               algorithm::Symbol=:pullback)
        
Return the ideal ``F(U_2)``. 

# Input
The optional argument `algorithm` must be either `:pushforward` or `:pullback`.
This determines how to extend through the gluings.
- `:pullback` -- works via a saturation and turned out to be faster for complicated ideals 
  (and relatively simple gluings.)
- `:pushforward` -- works via a preimage computation 

"""
function produce_object(
    F::PrimeIdealSheafFromChart, U2::AbsAffineScheme; 
    algorithm::Symbol=:pullback # Either :pushforward or :pullback
                                   # This determines how to extend through the gluings.
  )
  U2 === original_chart(F) && return F.P
  # Initialize some local variables
  X = scheme(F)
  OOX = OO(X)
  P = F.P
  U = F.U

  # we are in the same ancestor tree, but on top of the defining chart
  if has_ancestor(x->(x===U2), U)
    iso = _flatten_open_subscheme(U, U2)
    iso_inv = inverse(iso)
    pb_P = pullback(iso_inv)(P)
    result = ideal(OO(U2), [g for g in OO(U2).(gens(saturated_ideal(pb_P))) if !iszero(g)])
    @hassert :IdealSheaves 1 is_one(result) || is_prime(result)
    return result
  end

  V = __find_chart(U, default_covering(X))
  # we are in the same ancestor tree, but somewhere else;
  # reconstruct from the root
  if has_ancestor(x->(x===V), U2)
    result = OOX(V, U2)(F(V))
    @hassert :IdealSheaves 1 is_one(result) || is_prime(result)
    return result
  end

  # we are in a different tree;
  # reconstruct from that root
  V2 = __find_chart(U2, default_covering(X))
  if haskey(object_cache(F), V2) && V2 !== U2
    result = OOX(V2, U2)(F(V2))
    @hassert :IdealSheaves 1 is_one(result) || is_prime(result)
    return result
  end

  F(V) # Fill the cache with at least one element

  fat = [W for W in keys(object_cache(F)) if any(x->x===W, affine_charts(X)) && !isone(F(W))]

  function complexity(X1::AbsAffineScheme)
    init = maximum(total_degree.(lifted_numerator.(gens(F(X1)))); init=0)
    glue = default_covering(X)[X1, V2]
    init += _gluing_complexity(glue)
    return init
  end
      
  function _gluing_complexity(glue::SimpleGluing)
    f, g = gluing_morphisms(glue)
    img_gens = pullback(f).(gens(OO(codomain(f))))
    init = sum(total_degree.(lifted_numerator(i)) for i in img_gens)
    init += sum(total_degree.(lifted_denominator(i)) for i in img_gens)
    return init
  end
      
  function _gluing_complexity(glue::LazyGluing)
    is_computed(glue) && return _gluing_complexity(underlying_gluing(glue))
    return 5000
  end
  
  function _gluing_complexity(glue::AbsGluing)
    return 10000
  end 
    
  sort!(fat, by=complexity)
  @vprintln :Divisors 2 "complexities in production function of $(F) on $(U2) $(complexity.(fat))"
  for W in fat
    @vprintln :Divisors 3 "moving primve divisor from $(W)"
    # In case there is no gluing there is no extension.
    !haskey(gluings(default_covering(X)), (W, V2)) && continue

    glue = default_covering(X)[W, V2]
    f, g = gluing_morphisms(glue)
    if glue isa SimpleGluing || (glue isa LazyGluing && first(gluing_domains(glue)) isa PrincipalOpenSubset)
      if algorithm == :pushforward
        complement_equation(codomain(g)) in F(W) && return ideal(OO(U2), one(OO(U2))) # We know the ideal is prime. No need to saturate!
        @vprintln :Divisors 3 "complement equation $(complement_equation(codomain(f)))"
        pb_f = pullback(f)::AbsLocalizedRingHom
        pb_f_res = restricted_map(pb_f)
        @vprintln :Divisors 4 pb_f_res.(gens(domain(pb_f_res)))
        @assert domain(pb_f_res) === ambient_coordinate_ring(V2)
        Q = preimage(pb_f_res, F(domain(f)))
        rest = OOX(V2, U2)
        result = ideal(OO(U2), rest.(gens(Q)))
        @hassert :IdealSheaves 1 !isone(Q)
        @hassert :IdealSheaves 1 is_prime(result)
        set_attribute!(result, :is_prime=>true)
        return result
      elseif algorithm == :pullback
        I2 = F(codomain(g))
        I = pullback(g)(I2)
        I = ideal(OO(V2), lifted_numerator.(gens(I)))
        I = _iterative_saturation(I, lifted_numerator(complement_equation(domain(g))))
        result = OOX(V2, U2)(ideal(OO(V2), lifted_numerator.(gens(I))))
        @hassert :IdealSheaves 1 is_one(result) || is_prime(result)
        return result
      else
        error("algorithm not recognized")
      end
    else
      Z = subscheme(W, F(W))
      pZ = preimage(g, Z, check=false)
      is_empty(pZ) && continue
      ZV = closure(pZ, V2, check=false)
      result = OOX(V2, U2)(ideal(OO(V2), [g for g in OO(V2).(small_generating_set(saturated_ideal(modulus(OO(ZV))))) if !iszero(g)]))
      @hassert :IdealSheaves 1 is_one(result) || is_prime(result)
      return result
    end
  end
  # If nothing pulls back to this chart, the ideal sheaf is trivial here.
  result = ideal(OO(U2), one(OO(U2)))
  return result
end


### SumIdealSheaf
summands(I::SumIdealSheaf) = I.summands

function produce_object(I::SumIdealSheaf, U::AbsAffineScheme)
  result = sum([a(U) for a in summands(I)]; init=ideal(OO(U), elem_type(OO(U))[]))
  # We need to eliminate zeroes manually
  return ideal(OO(U), filter!(!is_zero, gens(result)))
end

### ProductIdealSheaf
factors(I::ProductIdealSheaf) = I.factors

function produce_object(I::ProductIdealSheaf, U::AbsAffineScheme)
  return prod([a(U) for a in factors(I)]; init=ideal(OO(U), one(OO(U))))
end

### SimplifiedIdealSheaf
original_ideal_sheaf(I::SimplifiedIdealSheaf) = I.orig

function produce_object(I::SimplifiedIdealSheaf, U::AbsAffineScheme)
  g = OO(U).(small_generating_set(saturated_ideal(original_ideal_sheaf(I)(U))))
  return ideal(OO(U), filter!(!is_zero, g))
end

### PullbackIdealSheaf
morphism(I::PullbackIdealSheaf) = I.f
original_ideal_sheaf(I::PullbackIdealSheaf) = I.orig
underlying_presheaf(I::PullbackIdealSheaf) = I.Ipre

function produce_object(I::PullbackIdealSheaf, U::AbsAffineScheme)
  f = morphism(I)
  J = original_ideal_sheaf(I)
  f_cov = covering_morphism(f)
  dom = domain(f_cov)
  X = scheme(I)

  # The easy case: We can just pull back
  if any(x->x===U, patches(dom))
    f_loc = f_cov[U]
    V = codomain(f_loc)
    KK = original_ideal_sheaf(I)(V)
    @assert base_ring(KK) === OO(V)
    return pullback(f_loc)(KK)
  end

  # We are in a chart below a patch in the domain covering
  if has_ancestor(x->any(y->y===x, patches(dom)), U)
    V = __find_chart(U, dom)
    return OO(X)(V, U)(I(V))
  end

  # We are in some other branch.
  V = __find_chart(U, default_covering(X))

  if V === U
    # Construct the ideal directly on the root
    subs = AbsAffineScheme[V for V in patches(dom) if has_ancestor(x->x===U, V)]
    length(subs) == 0 && return ideal(OO(U), one(OO(U))) # In this case really nothing is defined here.
    # Just return the unit ideal so that the 
    # associated subscheme is empty.
    result = ideal(OO(U), one(OO(U)))
    sub_surface = AbsAffineScheme[]
    for V in subs
      cut = false
      while !cut
        if V isa SimplifiedAffineScheme && original(V) !== U
          V = original(V)
          continue
        end
        if V isa PrincipalOpenSubset && ambient_scheme(V) !== U
          V = ambient_scheme(V)
          continue
        end
        cut = true
      end
      any(x->x===V, sub_surface) && continue
      push!(sub_surface, V)
    end

    if any(x->(x isa SimplifiedAffineScheme), sub_surface)
      i = findfirst(x->(x isa SimplifiedAffineScheme), sub_surface)
      W = sub_surface[i]
      _, g = identification_maps(W)
      return ideal(OO(U), pullback(g).(gens(I(W))))
    end

    for VV in sub_surface
      result = intersect(result, ideal(OO(U), gens(saturated_ideal(I(VV)))))
    end
    return result
  end

  # Infer the ideal from the root
  return OO(X)(V, U)(I(V))
end

########################################################################
# Cheap previews of an ideal sheaf
#
# In some applications it is already sufficient to get one's hands on 
# some subideal J âŠ‚ I on an open patch U. For instance, if one wants to 
# know whether I + K is the unit ideal on U: If this already holds for J + K, 
# then we do not need to go through the hustle of computing I.
########################################################################

# The default knows nothing about the ideal sheaf, so we do nothing special
function cheap_sub_ideal(II::AbsIdealSheaf, U::AbsAffineScheme)
  return II(U)
end


function cheap_sub_ideal(II::SumIdealSheaf, U::AbsAffineScheme)
  for J in summands(II) # shortcut for trivial patches
    if U in keys(object_cache(J))
      if has_attribute(J(U),:is_one) && is_one(J(U))
        return J(U)
      else
        # sometimes the ideal is obviously one but the attribute not set
        ngens(J(U))==1 && isone(J(U))
        return J(U)
      end      
    end 
  end
  return sum(cheap_sub_ideal(J, U) for J in summands(II); init = ideal(OO(U), elem_type(OO(U))[]))
end

function cheap_sub_ideal(II::PrimeIdealSheafFromChart, U2::AbsAffineScheme)
  U2 === original_chart(II) && return II(U2)
  haskey(object_cache(II), U2) && return II(U2)

  haskey(II.cheap_sub_ideals, U2) && return II.cheap_sub_ideals[U2]

  # A modification of the code in produce_object

  # Initialize some local variables
  X = scheme(II)
  OOX = OO(X)
  U = original_chart(II)

  # we are in the same ancestor tree, but on top of the defining chart
  if has_ancestor(x->(x===U2), U)
    iso = _flatten_open_subscheme(U, U2)  # an embedding U -> V \subseteq U2
    iso_inv = inverse(iso)
    P = II(U)
    pb_P = pullback(iso_inv)(P)
    # avoids a saturation by discarding denominators but only produces a subideal
    result = ideal(OO(U2), [g for g in OO(U2).(lifted_numerator.(gens(pb_P))) if !iszero(g)])
    II.cheap_sub_ideals[U2] = result
    return result
  end

  V = __find_chart(U, default_covering(X))
  # we are in the same ancestor tree, but somewhere else;
  # reconstruct from the root
  if has_ancestor(x->(x===V), U2)
    result = OOX(V, U2)(cheap_sub_ideal(II, V))
    II.cheap_sub_ideals[U2] = result
    return result
  end

  # we are in a different tree;
  # reconstruct from that root
  V2 = __find_chart(U2, default_covering(X))
  if haskey(object_cache(II), V2) && V2 !== U2
    result = OOX(V2, U2)(II(V2))
    II.cheap_sub_ideals[U2] = result
    return result
  end

  II(V) # Fill the cache with at least one element

  fat = [W for W in keys(object_cache(II)) if any(x->x===W, affine_charts(X)) && !isone(II(W))]

  function complexity(X1::AbsAffineScheme)
    init = maximum(total_degree.(lifted_numerator.(gens(II(X1)))); init=0)
    glue = default_covering(X)[V, X1]
    if glue isa SimpleGluing || (glue isa LazyGluing && is_computed(glue))
      return init
    end
    return init + 1000
  end

  sort!(fat; by=complexity)
  count = 0
  for W in fat
    glue = default_covering(X)[W, V2]
    if glue isa SimpleGluing || (glue isa LazyGluing && first(gluing_domains(glue)) isa PrincipalOpenSubset)
      f, g = gluing_morphisms(glue)
      I2 = II(codomain(g))
      complement_equation(codomain(g)) in I2 && continue
      I = pullback(g)(I2)
    # isone(I) && continue
      result = OOX(V2, U2)(ideal(OO(V2), lifted_numerator.(gens(I))))
      II.cheap_sub_ideals[U2] = result
      return result
    else
      f, g = gluing_morphisms(glue)
      I2 = II(codomain(g))
      Z = subscheme(W, II(W))
      pZ = preimage(g, Z, check=false)
      is_empty(pZ) && continue
      ZV = closure(pZ, V2, check=false)
      result = OOX(V2, U2)(ideal(OO(V2), [g for g in OO(V2).(lifted_numerator.(gens(modulus(OO(ZV))))) if !iszero(g)]))
      II.cheap_sub_ideals[U2] = result
      return result
    end
  end
  # If nothing pulls back to this chart, the ideal sheaf is trivial here.
  result = ideal(OO(U2), one(OO(U2)))
  II.cheap_sub_ideals[U2] = result
  return result
end

function cheap_sub_ideal(I::PullbackIdealSheaf, U::AbsAffineScheme)
  f = morphism(I)
  J = original_ideal_sheaf(I)
  f_cov = covering_morphism(f)
  dom = domain(f_cov)
  X = scheme(I)

  # The easy case: We can just pull back
  if any(x->x===U, patches(dom))
    f_loc = f_cov[U]
    V = codomain(f_loc)
    return pullback(f_loc)(cheap_sub_ideal(original_ideal_sheaf(I), V))
  end

  # We are in a chart below a patch in the domain covering
  if has_ancestor(x->any(y->y===x, patches(dom)), U)
    V = __find_chart(U, dom)
    return OO(X)(V, U)(cheap_sub_ideal(I, V))
  end

  # We are in some other branch.
  V = __find_chart(U, default_covering(X))

  if V === U
    # Construct the ideal directly on the root
    subs = AbsAffineScheme[V for V in patches(dom) if has_ancestor(x->x===U, V)]
    length(subs) == 0 && return ideal(OO(U), one(OO(U))) # In this case really nothing is defined here.
    # Just return the unit ideal so that the 
    # associated subscheme is empty.
    result = ideal(OO(U), one(OO(U)))
    sub_surface = AbsAffineScheme[]
    for V in subs
      cut = false
      while !cut
        if V isa SimplifiedAffineScheme && original(V) !== U
          V = original(V)
          continue
        end
        if V isa PrincipalOpenSubset && ambient_scheme(V) !== U
          V = ambient_scheme(V)
          continue
        end
        cut = true
      end
      any(x->x===V, sub_surface) && continue
      push!(sub_surface, V)
    end

    if any(x->(x isa SimplifiedAffineScheme), sub_surface)
      i = findfirst(x->(x isa SimplifiedAffineScheme), sub_surface)
      W = sub_surface[i]
      _, g = identification_maps(W)
      return ideal(OO(U), pullback(g).(gens(cheap_sub_ideal(I, W))))
    end

    for VV in sub_surface
      result = intersect(result, ideal(OO(U), gens(saturated_ideal(cheap_sub_ideal(I, VV)))))
    end
    return result
  end

  # Infer the ideal from the root
  return OO(X)(V, U)(cheap_sub_ideal(I, V))
end

function sub(I::AbsIdealSheaf)
  X = scheme(I)
  inc = CoveredClosedEmbedding(X, I)
  return domain(inc), inc
end

########################################################################
# Radicals of ideal sheaves                                            #
########################################################################

underlying_presheaf(rad::RadicalOfIdealSheaf) = rad.Ipre
original_ideal_sheaf(rad::RadicalOfIdealSheaf) = rad.orig

function produce_object(rad::RadicalOfIdealSheaf, U::AbsAffineScheme)
  result = radical(original_ideal_sheaf(rad)(U))
  set_attribute!(result, :is_radical=>true) # Necessary? Or should the radical computation take care of this?
  return result
end

function is_subset(I::AbsIdealSheaf, rad::RadicalOfIdealSheaf)
  X = scheme(rad)
  @assert X === scheme(I) "ideal sheaves do not live on the same scheme"
  for U in affine_charts(X)
    all(radical_membership(g, rad(U)) for g in gens(I(U))) || return false
  end
  return true
end

function is_subset(I::PrimeIdealSheafFromChart, rad::RadicalOfIdealSheaf)
  X = scheme(rad)
  @assert X === scheme(I) "ideal sheaves do not live on the same scheme"
  U = original_chart(I)
  return all(g->radical_membership(g, rad(U)), gens(I(U)))
end
 
function radical(I::AbsIdealSheaf)
  result = RadicalOfIdealSheaf(I)
  return result
end

is_radical(rad::RadicalOfIdealSheaf) = true

########################################################################
# custom functionality for prime ideal sheaves from chart
########################################################################
function is_subset(I::AbsIdealSheaf, P::PrimeIdealSheafFromChart)
  X = scheme(I)
  @assert X === scheme(P)
  U = original_chart(P)
  return is_subset(I(U), P(U))
end


function is_subset(P::PrimeIdealSheafFromChart, I::AbsIdealSheaf)
  X = scheme(P)
  @assert X === scheme(I)
  U = original_chart(P)
  is_subset(P(U), I(U)) || return false
  # I might have support outside the support of P. Hence, we can not 
  # avoid the full check, as it seems.
  return all(is_subset(P(U), I(U)) for U in affine_charts(X) if !is_one(I(U)))
end

function ==(P::PrimeIdealSheafFromChart, Q::PrimeIdealSheafFromChart)
  X = scheme(P)
  @assert X === scheme(Q)
  U = original_chart(P)
  V = original_chart(Q)

  U === V && return P(U) == Q(U)
  haskey(object_cache(Q), U) && return Q(U) == P(U)
  haskey(object_cache(P), V) && return Q(V) == P(V)
  for (W1, PP) in object_cache(P)
    W1 in keys(object_cache(Q)) || continue
    is_one(PP) && continue
    return PP == Q(W1)
  end

  for (W2, Q2) in object_cache(Q)
    W2 in keys(object_cache(P)) || continue
    is_one(Q2) && continue
    return Q2 == P(W2)
  end

  if any(x->x===U, affine_charts(X)) && any(x->x===V, affine_charts(X))
    gg = default_covering(X)[U, V]
    UV, VU = gluing_domains(gg)
    if UV isa PrincipalOpenSubset
      h_V = complement_equation(UV)
      h_U = complement_equation(VU)
      h_V in P(U) && return false # P and Q will have different support, then.
    end

    if UV isa AffineSchemeOpenSubscheme && VU isa AffineSchemeOpenSubscheme
      # We have to handle this special case differently as there 
      # is no type for ideals in the associated rings.
      if all(P(UV[i]) == Q(UV[i]) for i in 1:ngens(UV)) 
        object_cache(P)[V] = Q(V)
        object_cache(Q)[U] = P(U)
        return true
      end
    elseif UV isa AbsAffineScheme && VU isa AbsAffineScheme
      # This should be the default case
      if P(UV) == Q(UV)
        object_cache(P)[V] = Q(V)
        object_cache(Q)[U] = P(U)
        return true
      end
    else
      error("case of this type is not handled")
    end
  end

  return !is_one(Q(U)) && P(U) == Q(U)
end

function _pullback_along_base_change(f::AbsCoveredSchemeMorphism, D::AbsWeilDivisor)
  scheme(D) === codomain(f) || error("divisor must live on the codomain of the map")
  comp_dict = IdDict{AbsIdealSheaf, elem_type(coefficient_ring(D))}()
  for I in components(D)
    comp_dict[pullback(f, I)] = D[I]
  end
  return WeilDivisor(AlgebraicCycle(domain(f), coefficient_ring(D), comp_dict; check=false); check=false)
end

########################################################################
# Singular locus ideal sheaf
########################################################################

function produce_object_on_affine_chart(II::SingularLocusIdealSheaf, U::AbsAffineScheme)
  return radical(produce_non_radical_ideal_of_singular_locus(II, U))
end

function produce_non_radical_ideal_of_singular_locus(II::SingularLocusIdealSheaf, U::AbsAffineScheme)
  if !haskey(II.non_radical_ideals, U)
    if is_one(focus(II)(U))
      II.non_radical_ideals[U] = focus(II)(U)
      return focus(II)(U)
    end
    X = scheme(II)
    @assert any(V===U for V in affine_charts(X))
    UU = simplify(U)
    id, id_inv = identification_maps(UU)

    # Prepare for shortcuts in the computation
    has_attribute(X, :is_equidimensional) && get_attribute(X, :is_equidimensional)===true && set_attribute!(UU, :is_equidimensional=>true)
    has_attribute(X, :is_irreducible) && get_attribute(X, :is_irreducible)===true && set_attribute!(UU, :is_irreducible=>true)
    has_attribute(X, :is_reduced) && get_attribute(X, :is_reduced)===true && set_attribute!(UU, :is_reduced=>true)
    S, inc_S = singular_locus(UU; compute_radical=false)
    res = ideal(OO(U), pullback(id_inv).(gens(image_ideal(inc_S)))) + focus(II)(U)
    II.non_radical_ideals[U] = res
  end
  return II.non_radical_ideals[U]::Ideal
end

is_one(II::SingularLocusIdealSheaf) = all(is_one(produce_non_radical_ideal_of_singular_locus(II, U)) for U in affine_charts(scheme(II)))

in_radical(J::AbsIdealSheaf, II::SingularLocusIdealSheaf) = all(all(radical_membership(g, produce_non_radical_ideal_of_singular_locus(II, U)) for g in gens(J(U))) for U in affine_charts(scheme(J)))

@doc raw"""
    colength(I::AbsIdealSheaf; covering::Covering=default_covering(scheme(I)))
    
Return the colength of `I`.


"""
function colength(I::AbsIdealSheaf; covering::Covering=default_covering(scheme(I)))
  X = scheme(I)
  all_patches = copy(patches(covering))
  patches_done = AbsAffineScheme[]
  patches_todo = AbsAffineScheme[]
  @vprintln :Divisors 2 "checking colength of $(I)"
  for U in all_patches
    dec_inf = (has_decomposition_info(covering) ? elem_type(OO(U))[OO(U)(g) for g in decomposition_info(covering)[U]] : elem_type(OO(U))[])
    if is_known(is_one, I, U; dec_inf)
      push!(patches_done, U)
    else
      push!(patches_todo, U)
    end
  end

  result = 0
  while length(patches_todo) != 0
    U = pop!(patches_todo)

    # First do a cheaper test whether this chart needs to be looked at
    J_cheap = cheap_sub_ideal(I, U)
    if has_decomposition_info(covering)
      h = decomposition_info(covering)[U]
      if isone(J_cheap + ideal(OO(U), elem_type(OO(U))[OO(U)(a) for a in h])) # R(a) is not type stable for R::MPolyQuoRing
        # push!(patches_done, U)
        continue
      end
    end

    J = I(U)
    if has_decomposition_info(covering)
      h = decomposition_info(covering)[U]
      # The elements in h indicate where components must 
      # be located so that they can not be spotted in other charts.
      # We iteratively single out these components by adding a sufficiently high 
      # power of the equation to the ideal.
      for f in h
        g = f
        while !(g in ideal(OO(U), g*f) + J)
          g = g * g
        end
        J = J + ideal(OO(U), g)
        if isone(J)
          push!(patches_done, U)
          continue
        end
      end
    else
      # To avoid overcounting, throw away all components that 
      # were already visible in other charts.
      for V in patches_done
        if !haskey(gluings(covering), (U, V))
          continue
        end
        G = covering[U, V]
        (UV, VU) = gluing_domains(G)
        UV isa PrincipalOpenSubset || error("method is only implemented for simple gluings")
        f = complement_equation(UV)
        # Find a sufficiently high power of f such that it throws
        # away all components away from the horizon, but does not affect
        # those on the horizon itself.
        g = f
        while !(g in ideal(OO(U), g*f) + J)
          g = g * g
        end
        J = J + ideal(OO(U), g)
        isone(J) && break
      end
    end
    if !isone(J)
      JJ = leading_ideal(saturated_ideal(J))
      A, _ = quo(base_ring(JJ), JJ)
      result = result + ngens(vector_space(coefficient_ring(base_ring(A)), A)[1])
    end
    push!(patches_done, U)
  end
  return result
end

function is_zero(II::AbsIdealSheaf)
  return all(iszero(II(U)) for U in affine_charts(scheme(II)))
end

function is_zero(II::PrimeIdealSheafFromChart)
  return is_zero(II(original_chart(II)))
end

