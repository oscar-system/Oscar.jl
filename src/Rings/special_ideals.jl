export katsura

function _get_katsura_exponent(n::Int64, m::Int64, l::Int64)
    e = zeros(Int64, n + 1)
    if abs(l) == abs(m - l)
        e[abs(l) + 1] = 2
    else
        e[abs(l) + 1] = 1
        e[abs(m - l) + 1] = 1
    end

    return e
end

@doc Markdown.doc"""
    katsura(n::Int64)

Given a natural number `n` returns the Katsura ideal generated by\
$u_m - \sum_{l=n}^n u_{l-m} u_l $, $ 1 - \sum_{l = -n}^n u_l $
where $u_{-i} = u_i$, and $u_i = 0$ for $i > n$ and $m \in \{-n, \ldots, n\}$. \
Also note that indices have been shifted to start from 1.

# Example
```jldoctest
julia> katsura(3)
ideal(x1 + 2*x2 + 2*x3 + 2*x4 - 1, x1^2 - x1 + 2*x2^2 + 2*x3^2 + 2*x4^2, 2*x1*x2 + 2*x2*x3 - x2 + 2*x3*x4, 2*x1*x3 + x2^2 + 2*x2*x4 - x3)
```
"""
function katsura(R::Ring, n::Int64)
    PR, x = PolynomialRing(R, n + 1)
    polys = Vector{elem_type(PR)}()
    coeffs_vec = 2 * ones(elem_type(R), n + 1)
    coeffs_vec[1] = R(1)
    mono_exps = Matrix{Int64}(identity_matrix(ZZ, n + 1))
    linear_poly = PR(coeffs_vec, [mono_exps[:, i] for i in 1:ncols(mono_exps)])
    linear_poly -= R(1)
    push!(polys, linear_poly)
    
    for m in 0:n - 1
        polynomial = MPolyBuildCtx(PR)
        for l in -n:n
            if abs(l) > n || abs(m - l) > n 
                continue
            end
            e = _get_katsura_exponent(n, m, l)
            push_term!(polynomial, R(1), e)
        end

        e = zeros(Int64, n + 1)
        e[abs(m) + 1] = 1
        push_term!(polynomial, R(-1), e)
        poly = finish(polynomial)
        push!(polys, poly)
    end

    return ideal(PR, polys)
end
