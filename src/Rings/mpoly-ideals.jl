
# constructors #######################################################

@doc raw"""
    ideal(R::MPolyRing, V::Vector)

Given a vector `V` of polynomials in `R`, return the ideal of `R` generated by these polynomials.

!!! note
    In the graded case, the entries of `V` must be homogeneous.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x*y-3*x,y^3-2*x^2*y])
ideal(x*y - 3*x, -2*x^2*y + y^3)

julia> typeof(I)
MPolyIdeal{QQMPolyRingElem}

julia> S, (x, y) = graded_polynomial_ring(QQ, ["x", "y"],  [1, 2])
(Multivariate Polynomial Ring in x, y over Rational Field graded by
  x -> [1]
  y -> [2], MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y])

julia> J = ideal(S, [(x^2+y)^2])
ideal(x^4 + 2*x^2*y + y^2)

julia> typeof(J)
MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}
```
"""
function ideal(R::MPolyRing, g::Vector)
  h = elem_type(R)[R(f) for f = g]
  #if isempty(g)
  #  push!(h, R())
  #end
  return MPolyIdeal(R, h)
end

function ideal(I::IdealGens{T}) where {T <: MPolyRingElem}
  return MPolyIdeal(I)
end

# TODO: Can we make this the default?
# (Or maybe remove ideal(...) without a ring completely?)

function ideal(Qxy::MPolyRing{T}, x::MPolyRingElem{T}) where T <: RingElem
  return ideal(Qxy, [x])
end

function ideal(g::Vector{T}) where {T <: MPolyRingElem}
  @req length(g) > 0 "List of elements must be non-empty"
  return ideal(parent(g[1]), g)
end

function is_graded(I::MPolyIdeal)
  return is_graded(Hecke.ring(I))
end

# elementary operations #######################################################
@doc raw"""
    check_base_rings(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T

Throws an error if the base rings of the ideals `I` and `J` do not coincide.
"""
function check_base_rings(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T
  if !isequal(base_ring(I), base_ring(J))
    error("Base rings must coincide.")
  end
end

@doc raw"""
    ^(I::MPolyIdeal, m::Int)

Return the `m`-th power of `I`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate Polynomial Ring in x, y, z over Rational Field, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [x, y])
ideal(x, y)

julia> I^3
ideal(x^3, x^2*y, x*y^2, y^3)
```
"""
function Base.:^(I::MPolyIdeal, m::Int)
  singular_assure(I)
  return MPolyIdeal(base_ring(I), I.gens.S^m)
end

@doc raw"""
    +(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T

Return the sum of `I` and `J`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate Polynomial Ring in x, y, z over Rational Field, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [x, y])
ideal(x, y)

julia> J = ideal(R, [z^2])
ideal(z^2)

julia> I+J
ideal(x, y, z^2)
```
"""
function Base.:+(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T
  oscar_assure(I)
  oscar_assure(J)
  check_base_rings(I, J)
  newgens = filter!(!iszero, unique!(vcat(I.gens.O,J.gens.O)))
  return ideal(base_ring(I), newgens)
end
Base.:-(I::MPolyIdeal, J::MPolyIdeal) = I+J

@doc raw"""
    *(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T

Return the product of `I` and `J`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate Polynomial Ring in x, y, z over Rational Field, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [x, y])
ideal(x, y)

julia> J = ideal(R, [z^2])
ideal(z^2)

julia> I*J
ideal(x*z^2, y*z^2)
```
"""
function Base.:*(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T
  oscar_assure(I)
  oscar_assure(J)
  check_base_rings(I, J)
  newgens = elem_type(base_ring(I))[]
  for g in I.gens.O
    for h in J.gens.O
      gh = g * h
      if !iszero(gh)
        push!(newgens, gh)
      end
    end
  end
  return ideal(base_ring(I), unique!(newgens))
end

#######################################################

# ideal intersection #######################################################
@doc raw"""
    intersect(I::MPolyIdeal{T}, Js::MPolyIdeal{T}...) where T
    intersect(V::Vector{MPolyIdeal{T}}) where T

Return the intersection of two or more ideals.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2;

julia> J = ideal(R, [y^2-x^3+x]);

julia> intersect(I, J)
ideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)

julia> intersect([I, J])
ideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)
```
"""
function Base.intersect(I::MPolyIdeal{T}, Js::MPolyIdeal{T}...) where T
  singular_assure(I)
  si = I.gens.S
  for J in Js
    singular_assure(J)
  end
  si = Singular.intersection(si, [J.gens.S for J in Js]...)
  return MPolyIdeal(base_ring(I), si)
end

function Base.intersect(V::Vector{MPolyIdeal{T}}) where T
  @assert length(V) != 0
  length(V) == 1 && return V[1]

  return Base.intersect(V[1], V[2:end]...)
end


#######################################################

@doc raw"""
    quotient(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T

Return the ideal quotient of `I` by `J`. Alternatively, use `I:J`.

    quotient(I::MPolyIdeal{T}, f::MPolyRingElem{T}) where T

Return the ideal quotient of `I` by the ideal generated by `f`. Alternatively, use `I:f`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate Polynomial Ring in x, y, z over Rational Field, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [x^4+x^2*y*z+y^3*z, y^4+x^3*z+x*y^2*z, x^3*y+x*y^3])
ideal(x^4 + x^2*y*z + y^3*z, x^3*z + x*y^2*z + y^4, x^3*y + x*y^3)

julia> J = ideal(R, [x, y, z])^2
ideal(x^2, x*y, x*z, y^2, y*z, z^2)

julia> L = quotient(I, J)
ideal(x^3*z + x*y^2*z + y^4, x^3*y + x*y^3, x^4 + x^2*y*z + y^3*z, x^3*z^2 - x^2*y*z^2 + x*y^2*z^2 - y^3*z^2, x^2*y^2*z - x^2*y*z^2 - y^3*z^2, x^3*z^2 + x^2*y^3 - x^2*y^2*z + x*y^2*z^2)

julia> I:J
ideal(x^3*z + x*y^2*z + y^4, x^3*y + x*y^3, x^4 + x^2*y*z + y^3*z, x^3*z^2 - x^2*y*z^2 + x*y^2*z^2 - y^3*z^2, x^2*y^2*z - x^2*y*z^2 - y^3*z^2, x^3*z^2 + x^2*y^3 - x^2*y^2*z + x*y^2*z^2)

julia> I:x
ideal(x^2*y + y^3, x^3*z + x*y^2*z + y^4, x^2*z^2 + x*y^3 - x*y^2*z + y^2*z^2, x^4, x^3*z^2 - x^2*z^3 + 2*x*y^2*z^2 - y^2*z^3, -x^2*z^4 + x*y^2*z^3 - y^2*z^4)
```
"""
function quotient(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T
  @assert base_ring(I) == base_ring(J)
  singular_assure(I)
  singular_assure(J)
  return MPolyIdeal(base_ring(I), Singular.quotient(I.gens.S, J.gens.S))
end

function quotient(I::MPolyIdeal{T}, f::T) where T
  R = base_ring(I)
  @assert R == parent(f)
  return quotient(I, ideal(R, [f]))
end
(::Colon)(I::MPolyIdeal, J::MPolyIdeal) = quotient(I, J)
(::Colon)(I::MPolyIdeal, f::MPolyRingElem) = quotient(I, f)

#######################################################

# saturation #######################################################
@doc raw"""
    saturation(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T

Return the saturation of `I` with respect to `J`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate Polynomial Ring in x, y, z over Rational Field, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y])
ideal(z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y)

julia> J = ideal(R, [x, y, z])
ideal(x, y, z)

julia> K = saturation(I, J)
ideal(z, x*y)
```
"""
function saturation(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T
  singular_assure(I)
  singular_assure(J)
  K, _ = Singular.saturation(I.gens.S, J.gens.S)
  return MPolyIdeal(base_ring(I), K)
end
#######################################################
@doc raw"""
    saturation_with_index(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T

Return $I:J^{\infty}$ together with the smallest integer $m$ such that $I:J^m = I:J^{\infty}$.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate Polynomial Ring in x, y, z over Rational Field, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y])
ideal(z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y)

julia> J = ideal(R, [x, y, z])
ideal(x, y, z)

julia> K, m = saturation_with_index(I, J)
(ideal(z, x*y), 2)
```
"""
function saturation_with_index(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T
  singular_assure(I)
  singular_assure(J)
  K, k = Singular.saturation(I.gens.S, J.gens.S)
  return (MPolyIdeal(base_ring(I), K), k)
 end

# elimination #######################################################
@doc raw"""
    eliminate(I::MPolyIdeal{T}, V::Vector{T}) where T <: MPolyRingElem

Given a vector `V` of polynomials which are variables, these variables are eliminated from `I`.
That is, return the ideal generated by all polynomials in `I` which only involve the remaining variables.

    eliminate(I::MPolyIdeal, V::AbstractVector{Int})

Given a vector `V` of indices which specify variables, these variables are eliminated from `I`.
That is, return the ideal generated by all polynomials in `I` which only involve the remaining variables.

!!! note
    The return value is an ideal of the original ring.

# Examples
```jldoctest
julia> R, (t, x, y, z) = polynomial_ring(QQ, ["t", "x", "y", "z"])
(Multivariate Polynomial Ring in t, x, y, z over Rational Field, QQMPolyRingElem[t, x, y, z])

julia> I = ideal(R, [t-x, t^2-y, t^3-z])
ideal(t - x, t^2 - y, t^3 - z)

julia> A = [t]
1-element Vector{QQMPolyRingElem}:
 t

julia> TC = eliminate(I, A)
ideal(-x*z + y^2, x*y - z, x^2 - y)

julia> A = [1]
1-element Vector{Int64}:
 1

julia> TC = eliminate(I, A)
ideal(-x*z + y^2, x*y - z, x^2 - y)

julia> base_ring(TC)
Multivariate Polynomial Ring in t, x, y, z over Rational Field
```
"""
function eliminate(I::MPolyIdeal{T}, l::Vector{T}) where T <: MPolyRingElem
  singular_assure(I)
  S = base_ring(I.gens.S)
  s = Singular.eliminate(I.gens.S, [S(x) for x = l]...)
  return MPolyIdeal(base_ring(I), s)
end
function eliminate(I::MPolyIdeal, l::AbstractVector{Int})
  R = base_ring(I)
  return eliminate(I, [gen(R, i) for i=l])
end

### todo: wenn schon GB bzgl. richtiger eliminationsordnung bekannt ...
### Frage: return MPolyIdeal(base_ring(I), s) ???

###################################################

# primary decomposition #######################################################

#######################################################
@doc raw"""
    radical(I::MPolyIdeal)

Return the radical of `I`.

# Implemented Algorithms

If the base ring of `I` is a polynomial
ring over a field, a combination of the algorithms of Krick and Logar
(with modifications by Laplagne) and Kemper is used. For polynomial
rings over the integers, the algorithm proceeds as suggested by
Pfister, Sadiq, and Steidel. See [KL91](@cite),
[Kem02](@cite), and [PSS11](@cite).

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
ideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)

julia> I = intersect(I, ideal(R, [x-y-1])^2)
ideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)

julia> RI = radical(I)
ideal(x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2)
```
```jldoctest
julia> R, (a, b, c, d) = polynomial_ring(ZZ, ["a", "b", "c", "d"])
(Multivariate Polynomial Ring in a, b, c, d over Integer Ring, ZZMPolyRingElem[a, b, c, d])

julia> I = intersect(ideal(R, [9,a,b]), ideal(R, [3,c]))
ideal(9, 3*b, 3*a, b*c, a*c)

julia> I = intersect(I, ideal(R, [11,2a,7b]))
ideal(99, 3*b, 3*a, b*c, a*c)

julia> I = intersect(I, ideal(R, [13a^2,17b^4]))
ideal(39*a^2, 13*a^2*c, 51*b^4, 17*b^4*c, 3*a^2*b^4, a^2*b^4*c)

julia> I = intersect(I, ideal(R, [9c^5,6d^5]))
ideal(78*a^2*d^5, 117*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5, 6*a^2*b^4*d^5, 9*a^2*b^4*c^5, 39*a^2*c^5*d^5, 51*b^4*c^5*d^5, 3*a^2*b^4*c^5*d^5)

julia> I = intersect(I, ideal(R, [17,a^15,b^15,c^15,d^15]))
ideal(1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5, 663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15, 78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15, 39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5, 6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15, 3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5)

julia> RI = radical(I)
ideal(102*b*d, 78*a*d, 51*b*c, 39*a*c, 6*a*b*d, 3*a*b*c)
```
"""
@attr T function radical(I::T) where {T <: MPolyIdeal}
  singular_assure(I)
  R = base_ring(I)
  if elem_type(base_ring(R)) <: FieldElement
    J = Singular.LibPrimdec.radical(I.gens.Sx, I.gens.S)
  elseif base_ring(I.gens.Sx) isa Singular.Integers
    J = Singular.LibPrimdecint.radicalZ(I.gens.Sx, I.gens.S)
  else
    error("not implemented for base ring")
  end
  Irad = ideal(R, J)
  set_attribute!(Irad, :is_radical => true)
  return Irad
end

@doc raw"""
    is_radical(I::MPolyIdeal)

Return whether `I` is a radical ideal.

Computes the radical.
"""
@attr Bool function is_radical(I::MPolyIdeal)
  return I == radical(I)
end
#######################################################
@doc raw"""
    primary_decomposition(I::MPolyIdeal; algorithm = :GTZ, cache=true)

Return a minimal primary decomposition of `I`. If `I` is the unit ideal, return `[ideal(1)]`.

The decomposition is returned as a vector of tuples $(Q_1, P_1), \dots, (Q_t, P_t)$, say,
where each $Q_i$ is a primary ideal with associated prime $P_i$, and where the intersection of
the $Q_i$ is `I`.

# Implemented Algorithms

If the base ring of `I` is a polynomial ring over a field, the algorithm of Gianni, Trager, and Zacharias
is used by default (`algorithm = :GTZ`). Alternatively, the algorithm by Shimoyama and Yokoyama can be used
by specifying `algorithm = :SY`.  For polynomial rings over the integers, the algorithm proceeds as suggested by
Pfister, Sadiq, and Steidel. See [GTZ88](@cite), [SY96](@cite), and [PSS11](@cite).

!!! warning
    The algorithm of Gianni, Trager, and Zacharias may not terminate over a small finite field. If it terminates, the result is correct.

If `cache=false` is set, the primary decomposition is recomputed and not cached.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
ideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)

julia> I = intersect(I, ideal(R, [x-y-1])^2)
ideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)

julia> L = primary_decomposition(I)
3-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}}}:
 (ideal(x^3 - x - y^2), ideal(x^3 - x - y^2))
 (ideal(x^2 - 2*x*y - 2*x + y^2 + 2*y + 1), ideal(x - y - 1))
 (ideal(y, x^2), ideal(x, y))

julia> L = primary_decomposition(I, algorithm = :SY, cache=false)
3-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}}}:
 (ideal(x^3 - x - y^2), ideal(x^3 - x - y^2))
 (ideal(x^2 - 2*x*y - 2*x + y^2 + 2*y + 1), ideal(x - y - 1))
 (ideal(y, x^2), ideal(y, x))
```
```jldoctest
julia> R, (a, b, c, d) = polynomial_ring(ZZ, ["a", "b", "c", "d"])
(Multivariate Polynomial Ring in a, b, c, d over Integer Ring, ZZMPolyRingElem[a, b, c, d])

julia> I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,
       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,
       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,
       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,
       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,
       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])
ideal(1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5, 663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15, 78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15, 39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5, 6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15, 3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5)

julia> L = primary_decomposition(I)
8-element Vector{Tuple{MPolyIdeal{ZZMPolyRingElem}, MPolyIdeal{ZZMPolyRingElem}}}:
 (ideal(d^5, c^5), ideal(d, c))
 (ideal(a^2, b^4), ideal(b, a))
 (ideal(2, c^5), ideal(2, c))
 (ideal(3), ideal(3))
 (ideal(13, b^4), ideal(13, b))
 (ideal(17, a^2), ideal(17, a))
 (ideal(17, d^15, c^15, b^15, a^15), ideal(17, d, c, b, a))
 (ideal(9, 3*d^5, d^10), ideal(3, d))
```
"""
function primary_decomposition(I::T; algorithm::Symbol=:GTZ, cache::Bool=true) where {T<:MPolyIdeal}
  !cache && return _compute_primary_decomposition(I, algorithm=algorithm)
  return get_attribute!(I, :primary_decomposition) do
    return _compute_primary_decomposition(I, algorithm=algorithm)
  end::Vector{Tuple{T,T}}
end

function _compute_primary_decomposition(I::MPolyIdeal; algorithm::Symbol=:GTZ)
  R = base_ring(I)
  singular_assure(I)
  if elem_type(base_ring(R)) <: FieldElement
    if algorithm == :GTZ
      L = Singular.LibPrimdec.primdecGTZ(I.gens.Sx, I.gens.S)
    elseif algorithm == :SY
      L = Singular.LibPrimdec.primdecSY(I.gens.Sx, I.gens.S)
    else
      error("algorithm invalid")
    end
  elseif base_ring(I.gens.Sx) isa Singular.Integers
    L = Singular.LibPrimdecint.primdecZ(I.gens.Sx, I.gens.S)
  else
    error("base ring not implemented")
  end
  return [(ideal(R, q[1]), ideal(R, q[2])) for q in L]
end

########################################################
@doc raw"""
    absolute_primary_decomposition(I::MPolyIdeal{<:MPolyRingElem{QQFieldElem}})

If `I` is an ideal in a multivariate polynomial ring over the rationals, return an absolute minimal primary decomposition of `I`.

Return the decomposition as a vector of tuples $(Q_i, P_i, P_{ij}, d_{ij})$, say,
where $(Q_i, P_i)$ is a (primary, prime) tuple as returned by `primary_decomposition(I)`,
and $P_{ij}$ represents a corresponding class of conjugated absolute associated primes
defined over a number field of degree $d_{ij}$ whose generator prints as `_a`.

# Implemented Algorithms

The implementation combines the algorithm of Gianni, Trager, and Zacharias for primary
decomposition with absolute polynomial factorization.

# Examples
```jldoctest
julia> R, (y, z) = polynomial_ring(QQ, ["y", "z"])
(Multivariate Polynomial Ring in y, z over Rational Field, QQMPolyRingElem[y, z])

julia> p = z^2+1
z^2 + 1

julia> q = z^3+2
z^3 + 2

julia> I = ideal(R, [p*q^2, y-z^2])
ideal(z^8 + z^6 + 4*z^5 + 4*z^3 + 4*z^2 + 4, y - z^2)

julia> L = primary_decomposition(I)
2-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}}}:
 (ideal(z^2 + 1, y - z^2), ideal(z^2 + 1, y - z^2))
 (ideal(z^6 + 4*z^3 + 4, y - z^2), ideal(z^3 + 2, y - z^2))

julia> AL = absolute_primary_decomposition(I)
2-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{AbstractAlgebra.Generic.MPoly{nf_elem}}, Int64}}:
 (ideal(z^2 + 1, y + 1), ideal(z^2 + 1, y + 1), ideal(z - _a, y + 1), 2)
 (ideal(z^6 + 4*z^3 + 4, y - z^2), ideal(z^3 + 2, y - z^2), ideal(z - _a, y - _a*z), 3)

julia> AP = AL[1][3]
ideal(z - _a, y + 1)

julia> RAP = base_ring(AP)
Multivariate Polynomial Ring in y, z over Number field over Rational Field with defining polynomial x^2 + 1

julia> NF = coefficient_ring(RAP)
Number field over Rational Field with defining polynomial x^2 + 1

julia> a = gen(NF)
_a

julia> minpoly(a)
x^2 + 1
```
"""
@attr function absolute_primary_decomposition(I::MPolyIdeal{<:MPolyRingElem{QQFieldElem}})
  R = base_ring(I)
  if is_zero(I)
     return [(ideal(R, zero(R)), ideal(R, zero(R)), ideal(R, zero(R)), 1)]
  end
  singular_assure(I)
  (S, d) = Singular.LibPrimdec.absPrimdecGTZ(I.gens.Sx, I.gens.S)
  decomp = d[:primary_decomp]
  absprimes = d[:absolute_primes]
  @assert length(decomp) == length(absprimes)
  return [(_map_last_var(R, decomp[i][1], 1, one(QQ)),
           _map_last_var(R, decomp[i][2], 1, one(QQ)),
           _map_to_ext(R, absprimes[i][1]),
           absprimes[i][2]::Int)
          for i in 1:length(decomp)]
end

# the ideals in QQbar[x] come back in QQ[x,a] with an extra variable a added
# and the minpoly of a prepended to the ideal generator list
function _map_to_ext(Qx::MPolyRing, I::Oscar.Singular.sideal)
  Qxa = base_ring(I)
  @assert nvars(Qxa) == nvars(Qx) + 1
  p = I[1]
  minpoly = zero(Hecke.Globals.Qx)
  for (c, e) in zip(AbstractAlgebra.coefficients(p), AbstractAlgebra.exponent_vectors(p))
    setcoeff!(minpoly, e[nvars(Qxa)], QQ(c))
  end
  R, a = number_field(minpoly)
  Rx, _ = polynomial_ring(R, symbols(Qx))
  return _map_last_var(Rx, I, 2, a)
end

# the ideals in QQ[x] also come back in QQ[x,a]
function _map_last_var(Qx::MPolyRing, I::Singular.sideal, start, a)
  newgens = elem_type(Qx)[]
  for i in start:ngens(I)
    p = I[i]
    g = MPolyBuildCtx(Qx)
    for (c, e) in zip(AbstractAlgebra.coefficients(p), AbstractAlgebra.exponent_vectors(p))
      ca = QQ(c)*a^pop!(e)
      push_term!(g, ca, e)
    end
    push!(newgens, finish(g))
  end
  return ideal(Qx, newgens)
end

#######################################################
@doc raw"""
    minimal_primes(I::MPolyIdeal; algorithm::Symbol = :GTZ)

Return a vector containing the minimal associated prime ideals of `I`.
If `I` is the unit ideal, return `[ideal(1)]`.

# Implemented Algorithms

If the base ring of `I` is a polynomial ring over a field, the algorithm of
Gianni, Trager, and Zacharias is used by default (`algorithm = :GTZ`). Alternatively, characteristic sets can be
used by specifying `algorithm = :charSets`. For polynomial rings over the integers,
the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel.
See [GTZ88](@cite) and [PSS11](@cite).

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
ideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)

julia> I = intersect(I, ideal(R, [x-y-1])^2)
ideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)

julia> L = minimal_primes(I)
2-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 ideal(x - y - 1)
 ideal(x^3 - x - y^2)

julia> L = minimal_primes(I, algorithm = :charSets)
2-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 ideal(x - y - 1)
 ideal(x^3 - x - y^2)
```
```jldoctest
julia> R, (a, b, c, d) = polynomial_ring(ZZ, ["a", "b", "c", "d"])
(Multivariate Polynomial Ring in a, b, c, d over Integer Ring, ZZMPolyRingElem[a, b, c, d])

julia> I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,
       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,
       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,
       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,
       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,
       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])
ideal(1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5, 663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15, 78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15, 39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5, 6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15, 3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5)

julia> L = minimal_primes(I)
6-element Vector{MPolyIdeal{ZZMPolyRingElem}}:
 ideal(d, c)
 ideal(b, a)
 ideal(2, c)
 ideal(3)
 ideal(13, b)
 ideal(17, a)
```
"""
function minimal_primes(I::MPolyIdeal; algorithm::Symbol = :GTZ)
  R = base_ring(I)
  singular_assure(I)
  if elem_type(base_ring(R)) <: FieldElement
    if algorithm == :GTZ
      l = Singular.LibPrimdec.minAssGTZ(I.gens.Sx, I.gens.S)
    elseif algorithm == :charSets
      l = Singular.LibPrimdec.minAssChar(I.gens.Sx, I.gens.S)
    else
      error("algorithm invalid")
    end
  elseif base_ring(I.gens.Sx) isa Singular.Integers
    l = Singular.LibPrimdecint.minAssZ(I.gens.Sx, I.gens.S)
  else
    error("base ring not implemented")
  end
  return [ideal(R, i) for i in l]
end
#######################################################
@doc raw"""
    equidimensional_decomposition_weak(I::MPolyIdeal)

Return a vector of equidimensional ideals where the last entry is the
equidimensional hull of `I`, that is, the intersection of the primary
components of `I` of maximal dimension. Each of the previous entries
is an ideal of lower dimension whose associated primes are exactly the associated
primes of `I` of that dimension. If `I` is the unit ideal, return `[ideal(1)]`.

# Implemented Algorithms

The implementation relies on ideas of Eisenbud, Huneke, and Vasconcelos. See [EHV92](@cite).

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
ideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)

julia> I = intersect(I, ideal(R, [x-y-1])^2)
ideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)

julia> L = equidimensional_decomposition_weak(I)
2-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 ideal(y, x)
 ideal(x^5 - 2*x^4*y - 2*x^4 + x^3*y^2 + 2*x^3*y - x^2*y^2 + 2*x^2*y + 2*x^2 + 2*x*y^3 + x*y^2 - 2*x*y - x - y^4 - 2*y^3 - y^2)
```
"""
@attr function equidimensional_decomposition_weak(I::MPolyIdeal)
  R = base_ring(I)
  @req coefficient_ring(R) isa AbstractAlgebra.Field "The coefficient ring must be a field"
  singular_assure(I)
  l = Singular.LibPrimdec.equidim(I.gens.Sx, I.gens.S)
  return [ideal(R, i) for i in l]
end

@doc raw"""
    equidimensional_decomposition_radical(I::MPolyIdeal)

Return a vector of equidimensional radical ideals increasingly ordered by dimension.
For each dimension, the returned radical ideal is the intersection of the associated primes
of `I` of that dimension. If `I` is the unit ideal, return `[ideal(1)]`.

# Implemented Algorithms

The implementation combines the algorithms of Krick and Logar (with modifications by Laplagne) and Kemper. See [KL91](@cite) and [Kem02](@cite).

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
ideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)

julia> I = intersect(I, ideal(R, [x-y-1])^2)
ideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)

julia> L = equidimensional_decomposition_radical(I)
2-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 ideal(y, x)
 ideal(x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2)
```
"""
@attr function equidimensional_decomposition_radical(I::MPolyIdeal)
  R = base_ring(I)
  @req coefficient_ring(R) isa AbstractAlgebra.Field "The coefficient ring must be a field"
  singular_assure(I)
  l = Singular.LibPrimdec.prepareAss(I.gens.Sx, I.gens.S)
  return [ideal(R, i) for i in l]
end
#######################################################
@doc raw"""
    equidimensional_hull(I::MPolyIdeal)

If the base ring of `I` is a polynomial ring over a field, return the intersection
of the primary components of `I` of maximal dimension. In the case of polynomials
over the integers, return the intersection of the primary components of I of
minimal height.  If `I` is the unit ideal, return `[ideal(1)]`.

# Implemented Algorithms

For polynomial rings over a field, the implementation relies on ideas as used by
Gianni, Trager, and Zacharias or Krick and Logar. For polynomial rings over the integers,
the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel. See [GTZ88](@cite),
[KL91](@cite),  and [PSS11](@cite).

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
ideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)

julia> I = intersect(I, ideal(R, [x-y-1])^2)
ideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)

julia> L = equidimensional_hull(I)
ideal(x^5 - 2*x^4*y - 2*x^4 + x^3*y^2 + 2*x^3*y - x^2*y^2 + 2*x^2*y + 2*x^2 + 2*x*y^3 + x*y^2 - 2*x*y - x - y^4 - 2*y^3 - y^2)
```
```jldoctest
julia> R, (a, b, c, d) = polynomial_ring(ZZ, ["a", "b", "c", "d"])
(Multivariate Polynomial Ring in a, b, c, d over Integer Ring, ZZMPolyRingElem[a, b, c, d])

julia> I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,
       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,
       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,
       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,
       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,
       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])
ideal(1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5, 663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15, 78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15, 39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5, 6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15, 3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5)

julia> L = equidimensional_hull(I)
ideal(3)
```
"""
function equidimensional_hull(I::MPolyIdeal)
  R = base_ring(I)
  singular_assure(I)
  if elem_type(base_ring(R)) <: FieldElement
    i = Singular.LibPrimdec.equidimMax(I.gens.Sx, I.gens.S)
  elseif base_ring(I.gens.Sx) isa Singular.Integers
    i = Singular.LibPrimdecint.equidimZ(I.gens.Sx, I.gens.S)
  else
    error("base ring not implemented")
  end
  return ideal(R, i)
end
#######################################################
@doc raw"""
    equidimensional_hull_radical(I::MPolyIdeal)

Return the intersection of the associated primes of `I` of maximal dimension.
If `I` is the unit ideal, return `[ideal(1)]`.

# Implemented Algorithms

The implementation relies on a combination of the algorithms of Krick and Logar
(with modifications by Laplagne) and Kemper. See [KL91](@cite) and [Kem02](@cite).

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
ideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)

julia> I = intersect(I, ideal(R, [x-y-1])^2)
ideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)

julia> L = equidimensional_hull_radical(I)
ideal(x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2)
```
"""
function equidimensional_hull_radical(I::MPolyIdeal)
  R = base_ring(I)
  @req coefficient_ring(R) isa AbstractAlgebra.Field "The coefficient ring must be a field"
  singular_assure(I)
  i = Singular.LibPrimdec.equiRadical(I.gens.Sx, I.gens.S)
  return ideal(R, i)
end

#######################################################
@doc raw"""
    ==(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T

Return `true` if `I` is equal to `J`, `false` otherwise.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x^2])
ideal(x^2)

julia> J = ideal(R, [x, y])^2
ideal(x^2, x*y, y^2)

julia> I == J
false
```
"""
function ==(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T
  I === J && return true
  gens(I) == gens(J) && return true
  return issubset(I, J) && issubset(J, I)
end

### todo: wenn schon GB's  bekannt ...

#######################################################
@doc raw"""
    is_subset(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T

Return `true` if `I` is contained in `J`, `false` otherwise.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x^2])
ideal(x^2)

julia> J = ideal(R, [x, y])^2
ideal(x^2, x*y, y^2)

julia> is_subset(I, J)
true
```
"""
function is_subset(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T
  singular_assure(I)
  G = groebner_assure(J)
  singular_assure(G)
  return Singular.iszero(Singular.reduce(I.gens.S, G.S))
end

### todo: wenn schon GB's  bekannt ...

#######################################################

@doc raw"""
    ideal_membership(f::T, I::MPolyIdeal{T}) where T

Return `true` if `f` is contained in `I`, `false` otherwise. Alternatively, use `f in I`.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> f = x^2
x^2

julia> I = ideal(R, [x, y])^2
ideal(x^2, x*y, y^2)

julia> ideal_membership(f, I)
true

julia> g = x
x

julia> g in I
false
```
"""
function ideal_membership(f::T, I::MPolyIdeal{T}; ordering::MonomialOrdering = default_ordering(base_ring(I))) where T
  GI = standard_basis(I, ordering=ordering, complete_reduction=false)
  singular_assure(GI)
  Sx = base_ring(GI.S)
  return Singular.iszero(Singular.reduce(Sx(f), GI.S))
end
Base.:in(f::MPolyRingElem, I::MPolyIdeal) = ideal_membership(f,I)
#######################################################
@doc raw"""
    radical_membership(f::T, I::MPolyIdeal{T}) where T

Return `true` if `f` is contained in the radical of `I`, `false` otherwise.
Alternatively, use `inradical(f, I)`.

# Examples
```jldoctest
julia> R, (x,) = polynomial_ring(QQ, ["x"])
(Multivariate Polynomial Ring in x over Rational Field, QQMPolyRingElem[x])

julia> f = x
x

julia> I = ideal(R,  [x^2])
ideal(x^2)

julia> radical_membership(f, I)
true

julia> g = x+1
x + 1

julia> inradical(g, I)
false
```
"""
function radical_membership(f::T, I::MPolyIdeal{T}) where T
  singular_assure(I)
  Sx = base_ring(I.gens.S)
  return Singular.LibPolylib.rad_con(Sx(f), I.gens.S) == 1
end
inradical(f::MPolyRingElem, I::MPolyIdeal) = radical_membership(f,I)
################################################################################
@doc raw"""
    is_prime(I::MPolyIdeal)

Return `true` if `I` is prime, `false` otherwise.

!!! warning
    The function computes the minimal associated primes of `I`. This may take some time.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2
ideal(x^2, x*y, y^2)

julia> is_prime(I)
false
```
"""
@attr Bool function is_prime(I::MPolyIdeal)
  D = minimal_primes(I)
  return length(D) == 1 && issubset(D[1], I)
end

################################################################################
@doc raw"""
    is_primary(I::MPolyIdeal)

Return `true` if `I` is primary, `false` otherwise.

!!! warning
    The function computes a primary decomposition of `I`. This may take some time.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2
ideal(x^2, x*y, y^2)

julia> is_primary(I)
true
```
"""
@attr Bool function is_primary(I::MPolyIdeal)
  D = primary_decomposition(I)
  return length(D) == 1
end

#######################################################
@doc raw"""
    base_ring(I::MPolyIdeal)

Return the ambient ring of `I`.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2
ideal(x^2, x*y, y^2)

julia> base_ring(I)
Multivariate Polynomial Ring in x, y over Rational Field
```
"""
function base_ring(I::MPolyIdeal{S}) where {S}
  return I.gens.Ox::parent_type(S)
end

#######################################################
@doc raw"""
    coefficient_ring(I::MPolyIdeal)

Return the coefficient ring of `I`, which is the coefficient ring of the
polynomial ring containing the ideal.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2
ideal(x^2, x*y, y^2)

julia> coefficient_ring(I)
Rational Field
```
"""
coefficient_ring(I::MPolyIdeal) = coefficient_ring(base_ring(I))


#######################################################
@doc raw"""
    ngens(I::MPolyIdeal)

Return the number of generators of `I`.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2
ideal(x^2, x*y, y^2)

julia> ngens(I)
3
```
"""
function ngens(I::MPolyIdeal)
  return length(I.gens)
end

#######################################################
@doc raw"""
    gens(I::MPolyIdeal)

Return the generators of `I`.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2
ideal(x^2, x*y, y^2)

julia> gens(I)
3-element Vector{QQMPolyRingElem}:
 x^2
 x*y
 y^2
```
"""
function gens(I::MPolyIdeal)
  return [I.gens[Val(:O), i] for i=1:ngens(I)]
end

gen(I::MPolyIdeal, i::Int) = I.gens[Val(:O), i]
getindex(I::MPolyIdeal, i::Int) = gen(I, i)

#######################################################
@doc raw"""
    dim(I::MPolyIdeal)

Return the Krull dimension of `I`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate Polynomial Ring in x, y, z over Rational Field, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [y-x^2, x-z^3])
ideal(-x^2 + y, x - z^3)

julia> dim(I)
1
```
"""
@attr Int function dim(I::MPolyIdeal)
  if I.dim > -1
    return I.dim
  end
  G = groebner_assure(I, false, true)
  singular_assure(G)
  I.dim = Singular.dimension(G.S)
  return I.dim
end

#######################################################
#######################################################
@doc raw"""
    codim(I::MPolyIdeal)

Return the codimension of `I`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"])
(Multivariate Polynomial Ring in x, y, z over Rational Field, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [y-x^2, x-z^3])
ideal(-x^2 + y, x - z^3)

julia> codim(I)
2
```
"""
codim(I::MPolyIdeal) = nvars(base_ring(I)) - dim(I)

################################################################################
#
#  iszero and isone functions
#
################################################################################

@doc raw"""
    is_zero(I::MPolyIdeal)

Return `true` if `I` is the zero ideal, `false` otherwise.
# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = ideal(R, y-x^2)
ideal(-x^2 + y)

julia> is_zero(I)
false
```
"""
@attr Bool function is_zero(I::MPolyIdeal)
  lg = gens(I)
  return isempty(lg) || all(iszero, lg)
end

@doc raw"""
    is_one(I::MPolyIdeal)

Return `true` if `I` is generated by `1`, `false` otherwise.
# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, x + y, y - 1])
ideal(x, x + y, y - 1)

julia> is_one(I)
true
```
"""
@attr Bool function is_one(I::MPolyIdeal)
  R = base_ring(I)
  if iszero(I)
      return false
  end
  if any(x -> (!is_zero(x) && is_constant(x) && is_unit(first(AbstractAlgebra.coefficients(x)))), gens(I))
    return true
  end
  gb = groebner_basis(I, complete_reduction = true)
  return is_constant(gb[1]) && is_unit(first(AbstractAlgebra.coefficients(gb[1])))
end

################################################################################
#
#  is_monomial functions
#
################################################################################

@doc raw"""
    is_monomial(f::MPolyRingElem)

Return `true` if `f` is a monomial, `false` otherwise.

    is_monomial(I::MPolyIdeal)

Return `true` if `I` can be generated by monomials, `false` otherwise.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate Polynomial Ring in x, y over Rational Field, QQMPolyRingElem[x, y])

julia> f = 2*x+y
2*x + y

julia> g = y
y

julia> is_monomial(f)
false

julia> is_monomial(g)
true

julia> is_monomial(ideal(R, [f, g]))
true
```
"""
function is_monomial(f::MPolyRingElem)
   if (length(f) == 1 && coeff(f, 1) == 1)
      return true
   else
      return false
   end
end

function _ismonomial(V::Vector{<: MPolyRingElem})
  return all(is_monomial, V)
end

@attr Bool function is_monomial(I::MPolyIdeal)
  if _ismonomial(gens(I))
    return true
  end
  GB = gens(groebner_basis(I, complete_reduction = true))
  if _ismonomial(GB)
    return true
  end
  return false
end

################################################################################
#
# Minimal generating set
#
################################################################################

@doc raw"""
    minimal_generating_set(I::MPolyIdeal{<:MPolyDecRingElem})

Given a homogeneous ideal `I` in a graded multivariate polynomial ring
over a field, return an array containing a minimal set of generators
of `I`. If `I` is the zero ideal an empty list is returned.

# Examples
```jldoctest
julia> R, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> V = [x, z^2, x^3+y^3, y^4, y*z^5];

julia> I = ideal(R, V)
ideal(x, z^2, x^3 + y^3, y^4, y*z^5)

julia> minimal_generating_set(I)
3-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x
 z^2
 y^3

julia> I = ideal(R, zero(R))
ideal(0)

julia> minimal_generating_set(I)
MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[]
```
"""
function minimal_generating_set(I::MPolyIdeal{<:MPolyDecRingElem})
  # This only works / makes sense for homogeneous ideals. So far ideals in an
  # MPolyDecRing are forced to be homogeneous though.

  R = base_ring(I)

  @assert is_graded(R)

  @req coefficient_ring(R) isa AbstractAlgebra.Field "The coefficient ring must be a field"

  if !isempty(I.gb)
    # make sure to not recompute a GB from scratch on the singular
    # side if we have one
    G = first(values(I.gb))
    singular_assure(G, G.ord)
    G.gens.S.isGB = true
    _, sing_min = Singular.mstd(G.gens.S)
    return filter(!iszero, (R).(gens(sing_min)))
  else
    singular_assure(I)
    sing_gb, sing_min = Singular.mstd(I.gens.gens.S)
    ring = I.gens.Ox
    computed_gb = IdealGens(ring, sing_gb, true)
    I.gb[computed_gb.ord] = computed_gb
    return filter(!iszero, (R).(gens(sing_min)))
  end
end

################################################################################
#
# Grassmann Pluecker Ideal
#
################################################################################
function grassmann_pluecker_ideal(subspace_dimension::Int, ambient_dimension::Int)
    return convert(MPolyIdeal{QQMPolyRingElem}, Polymake.ideal.pluecker_ideal(subspace_dimension, ambient_dimension))
end

@doc raw"""
    grassmann_pluecker_ideal([ring::MPolyRing,] subspace_dimension::Int, ambient_dimension::Int)

Given a ring, an ambient dimension and a subspace dimension return the ideal in the given ring
generated by the Plücker relations. If the ring is not specified return the ideal 
in a multivariate polynomial ring over the rationals.

The Grassmann-Plücker ideal is the homogeneous ideal generated by the relations defined by 
the Plücker Embedding of the Grassmannian. That is given Gr$(k, n)$ the Moduli 
space of all $k$-dimensional subspaces of an $n$-dimensional vector space, the relations
are given by all $d \times d$ minors of a $d \times n$ matrix. For the algorithm see
[Stu93](@cite).

# Examples
```jldoctest
julia> grassmann_pluecker_ideal(2, 4)
ideal(x[1]*x[6] - x[2]*x[5] + x[3]*x[4])

julia> R, x = polynomial_ring(residue_ring(ZZ, 7), "x" => (1:2, 1:3), ordering=:degrevlex)
(Multivariate Polynomial Ring in 6 variables x[1, 1], x[2, 1], x[1, 2], x[2, 2], ..., x[2, 3] over Integers modulo 7, zzModMPolyRingElem[x[1, 1] x[1, 2] x[1, 3]; x[2, 1] x[2, 2] x[2, 3]])

julia> grassmann_pluecker_ideal(R, 2, 4)
ideal(x[1, 2]*x[2, 2] + 6*x[2, 1]*x[1, 3] + x[1, 1]*x[2, 3])
```

"""
function grassmann_pluecker_ideal(ring::MPolyRing,
                                 subspace_dimension::Int,
                                 ambient_dimension::Int) 
    pluecker_ideal = grassmann_pluecker_ideal(subspace_dimension, ambient_dimension)
    converted_generators = elem_type(ring)[]
    coeff_ring = base_ring(ring)
    for g in gens(pluecker_ideal)
        converted_coeffs = [coeff_ring(numerator(c)) for c in AbstractAlgebra.coefficients(g)]
        polynomial = MPolyBuildCtx(ring)

        for (i, exponent) in enumerate(AbstractAlgebra.exponent_vectors(g))
            c = converted_coeffs[i]
            push_term!(polynomial, c, exponent)
        end
        converted_g = finish(polynomial)
        push!(converted_generators, converted_g)
    end
    return ideal(ring, converted_generators)
end
