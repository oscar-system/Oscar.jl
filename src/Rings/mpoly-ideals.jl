
# constructors #######################################################

@doc raw"""
    ideal(R::MPolyRing, V::Vector)

Given a vector `V` of polynomials in `R`, return the ideal of `R` generated by these polynomials.

!!! note
    In the graded case, the entries of `V` must be homogeneous.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x*y-3*x,y^3-2*x^2*y])
Ideal generated by
  x*y - 3*x
  -2*x^2*y + y^3

julia> typeof(I)
MPolyIdeal{QQMPolyRingElem}

julia> S, (x, y) = graded_polynomial_ring(QQ, [:x, :y],  [1, 2])
(Graded multivariate polynomial ring in 2 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y])

julia> J = ideal(S, [(x^2+y)^2])
Ideal generated by
  x^4 + 2*x^2*y + y^2

julia> typeof(J)
MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}
```
"""
function ideal(R::MPolyRing, g::Vector)
  h = elem_type(R)[R(f) for f = g]
  #if isempty(g)
  #  push!(h, R())
  #end
  return MPolyIdeal(R, h)
end

function ideal(I::IdealGens{T}) where {T <: MPolyRingElem}
  return MPolyIdeal(I)
end

function ideal(x::MPolyRingElem{T}) where T <: RingElem
  return ideal([x])
end

function ideal(Qxy::MPolyRing{T}, x::MPolyRingElem{T}) where T <: RingElem
  return ideal(Qxy, [x])
end

function ideal(g::Vector{T}) where {T <: MPolyRingElem}
  @req length(g) > 0 "List of elements must be non-empty"
  return ideal(parent(g[1]), g)
end

# Coerce an ungraded ideal in a graded ring
function ideal(S::MPolyDecRing, I::MPolyIdeal)
  @req base_ring(I) === forget_grading(S) "Rings do not coincide"
  return ideal(S, [ S(f) for f in gens(I) ])
end

function is_graded(I::MPolyIdeal)
  return is_graded(Hecke.ring(I))
end

# elementary operations #######################################################
@doc raw"""
    check_base_rings(I::MPolyIdeal, J::MPolyIdeal)

Throws an error if the base rings of the ideals `I` and `J` do not coincide.
"""
function check_base_rings(I::MPolyIdeal, J::MPolyIdeal)
  if !isequal(base_ring(I), base_ring(J))
    error("Base rings must coincide.")
  end
end

@doc raw"""
    ^(I::MPolyIdeal, m::Int)

Return the `m`-th power of `I`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [x, y])
Ideal generated by
  x
  y

julia> I^3
Ideal generated by
  x^3
  x^2*y
  x*y^2
  y^3
```
"""
function Base.:^(I::MPolyIdeal, m::Int)
  return MPolyIdeal(base_ring(I), (singular_generators(I))^m)
end

@doc raw"""
    +(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T

Return the sum of `I` and `J`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [x, y])
Ideal generated by
  x
  y

julia> J = ideal(R, [z^2])
Ideal generated by
  z^2

julia> I+J
Ideal generated by
  x
  y
  z^2
```
"""
function Base.:+(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T
  oscar_assure(I)
  oscar_assure(J)
  check_base_rings(I, J)
  newgens = filter!(!iszero, unique!(vcat(I.gens.O,J.gens.O)))
  return ideal(base_ring(I), newgens)
end
Base.:-(I::MPolyIdeal, J::MPolyIdeal) = I+J

@doc raw"""
    *(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T

Return the product of `I` and `J`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [x, y])
Ideal generated by
  x
  y

julia> J = ideal(R, [z^2])
Ideal generated by
  z^2

julia> I*J
Ideal generated by
  x*z^2
  y*z^2
```
"""
function Base.:*(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T
  oscar_assure(I)
  oscar_assure(J)
  check_base_rings(I, J)
  newgens = elem_type(base_ring(I))[]
  for g in I.gens.O
    for h in J.gens.O
      gh = g * h
      if !iszero(gh)
        push!(newgens, gh)
      end
    end
  end
  result = ideal(base_ring(I), unique!(newgens))
  # carry over eventual information about the dimension
  if is_known(dim, I) && is_known(dim, J)
    result.dim = max(dim(I), dim(J))
  end
  return result
end

#######################################################

# ideal intersection #######################################################
@doc raw"""
    intersect(I::MPolyIdeal{T}, Js::MPolyIdeal{T}...) where T
    intersect(V::Vector{MPolyIdeal{T}}) where T

Return the intersection of two or more ideals.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2;

julia> J = ideal(R, [y^2-x^3+x]);

julia> intersect(I, J)
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia> intersect([I, J])
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2
```
"""
function Base.intersect(I::MPolyIdeal{T}, Js::MPolyIdeal{T}...) where T
  si = singular_generators(I)
  si = Singular.intersection(si, [singular_generators(J) for J in Js]...)
  return MPolyIdeal(base_ring(I), si)
end

function Base.intersect(V::Vector{MPolyIdeal{T}}) where T
  @assert length(V) != 0
  length(V) == 1 && return V[1]

  return Base.intersect(V[1], V[2:end]...)
end


#######################################################

@doc raw"""
    quotient(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T

Return the ideal quotient of `I` by `J`. Alternatively, use `I:J`.

    quotient(I::MPolyIdeal{T}, f::MPolyRingElem{T}) where T

Return the ideal quotient of `I` by the ideal generated by `f`. Alternatively, use `I:f`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [x^4+x^2*y*z+y^3*z, y^4+x^3*z+x*y^2*z, x^3*y+x*y^3])
Ideal generated by
  x^4 + x^2*y*z + y^3*z
  x^3*z + x*y^2*z + y^4
  x^3*y + x*y^3

julia> J = ideal(R, [x, y, z])^2
Ideal generated by
  x^2
  x*y
  x*z
  y^2
  y*z
  z^2

julia> L = quotient(I, J)
Ideal generated by
  x^3*z + x*y^2*z + y^4
  x^3*y + x*y^3
  x^4 + x^2*y*z + y^3*z
  x^3*z^2 - x^2*y*z^2 + x*y^2*z^2 - y^3*z^2
  x^2*y^2*z - x^2*y*z^2 - y^3*z^2
  x^3*z^2 + x^2*y^3 - x^2*y^2*z + x*y^2*z^2

julia> I:J
Ideal generated by
  x^3*z + x*y^2*z + y^4
  x^3*y + x*y^3
  x^4 + x^2*y*z + y^3*z
  x^3*z^2 - x^2*y*z^2 + x*y^2*z^2 - y^3*z^2
  x^2*y^2*z - x^2*y*z^2 - y^3*z^2
  x^3*z^2 + x^2*y^3 - x^2*y^2*z + x*y^2*z^2

julia> I:x
Ideal generated by
  x^2*y + y^3
  x^3*z + x*y^2*z + y^4
  x^2*z^2 + x*y^3 - x*y^2*z + y^2*z^2
  x^4
  x^3*z^2 - x^2*z^3 + 2*x*y^2*z^2 - y^2*z^3
  -x^2*z^4 + x*y^2*z^3 - y^2*z^4
```
"""
function quotient(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T
  @assert base_ring(I) == base_ring(J)
  return MPolyIdeal(base_ring(I), Singular.quotient(singular_generators(I), singular_generators(J)))
end

function quotient(I::MPolyIdeal{T}, f::T) where T
  R = base_ring(I)
  @assert R == parent(f)
  return quotient(I, ideal(R, [f]))
end
(::Colon)(I::MPolyIdeal, J::MPolyIdeal) = quotient(I, J)
(::Colon)(I::MPolyIdeal, f::MPolyRingElem) = quotient(I, f)

#######################################################

# saturation #######################################################
@doc raw"""
    saturation(I::MPolyIdeal{T},
               J::MPolyIdeal{T} = ideal(base_ring(I), gens(base_ring(I)));
               iteration::Bool=false) where T

Return the saturation of `I` with respect to `J`.

If the second ideal `J` is not given, the ideal generated by the generators (variables) of `base_ring(I)` is used.

If `iteration` is set to `true`, the saturation is done by carrying out successive ideal quotient computations as in the definition of saturation. Otherwise, a more sophisticated GrÃ¶bner basis approach is used which is typically faster. Applying the two approaches may lead to different generating sets of the saturation.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y])
Ideal generated by
  z^3
  y*z^2
  x*z^2
  y^2*z
  x*y*z
  x^2*z
  x*y^2
  x^2*y

julia> J = ideal(R, [x, y, z])
Ideal generated by
  x
  y
  z

julia> K = saturation(I, J)
Ideal generated by
  z
  x*y

julia> K = saturation(I)
Ideal generated by
  z
  x*y

```
"""
function saturation(I::MPolyIdeal{T}, J::MPolyIdeal{T} = ideal(base_ring(I), gens(base_ring(I))); iteration::Bool=false) where T
  # `ppio` is faster than `Singular.saturation` when saturating with
  # respect to principal ideals
  if is_known(is_principal, I) && is_principal(I) && is_known(is_principal, J) && is_principal(J)
    is_unit(principal_generator(I)) && return I
    is_gen(principal_generator(I)) && ideal(remove(principal_generator(I), principal_generator(J))[2]) # catches a special case in strict transforms of toric blowups 
    return ideal(ppio(principal_generator(I), principal_generator(J))[2])
  end

  if iteration
    K, _ = Singular.saturation(singular_generators(I), singular_generators(J))
  else
    K, _ = Singular.saturation2(singular_generators(I), singular_generators(J))
  end
  return MPolyIdeal(base_ring(I), K)
end

_saturation2(I::MPolyIdeal{T}, J::MPolyIdeal{T} = ideal(base_ring(I), gens(base_ring(I)))) where T = saturation(I, J)
# kept for backwards compatibility

#######################################################
@doc raw"""
    saturation_with_index(I::MPolyIdeal{T},
                          J::MPolyIdeal{T} = ideal(base_ring(I), gens(base_ring(I)))) where T

Return $I:J^{\infty}$ together with the smallest integer $m$ such that $I:J^m = I:J^{\infty}$ (saturation index).

If the second ideal `J` is not given, the ideal generated by the generators (variables) of `base_ring(I)` is used.

!!! note
    If the saturation index is not needed, we recommend to use `saturation(I, J)` which is typically faster.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y])
Ideal generated by
  z^3
  y*z^2
  x*z^2
  y^2*z
  x*y*z
  x^2*z
  x*y^2
  x^2*y

julia> J = ideal(R, [x, y, z])
Ideal generated by
  x
  y
  z

julia> K, m = saturation_with_index(I, J)
(Ideal (z, x*y), 2)

julia> K, m = saturation_with_index(I)
(Ideal (z, x*y), 2)

```
"""
function saturation_with_index(I::MPolyIdeal{T}, J::MPolyIdeal{T} = ideal(base_ring(I), gens(base_ring(I)))) where T
  K, k = Singular.saturation(singular_generators(I), singular_generators(J))
  return (MPolyIdeal(base_ring(I), K), k)
 end

# elimination #######################################################
@doc raw"""
    eliminate(I::MPolyIdeal{T}, V::Vector{T}) where T <: MPolyRingElem

Given a vector `V` of polynomials which are variables, these variables are eliminated from `I`.
That is, return the ideal generated by all polynomials in `I` which only involve the remaining variables.

    eliminate(I::MPolyIdeal, V::AbstractVector{Int})

Given a vector `V` of indices which specify variables, these variables are eliminated from `I`.
That is, return the ideal generated by all polynomials in `I` which only involve the remaining variables.

    eliminate(I::MPolyIdeal, o::MonomialOrdering, l::Int)

Given an ordering `o` and an integer `l` return the `l`th elimination ideal for the given ordering.
This method will not compute a Groebner basis if one has already been computed for `o`.

!!! note
    The return value is an ideal of the original ring. To obtain the result in
    a proper subring, construct an appropriate morphism and compute the
    preimage of the ideal.

# Examples
```jldoctest
julia> R, (t, x, y, z) = polynomial_ring(QQ, [:t, :x, :y, :z]);

julia> I = ideal(R, [t-x, t^2-y, t^3-z])
Ideal generated by
  t - x
  t^2 - y
  t^3 - z

julia> A = [t];

julia> TC = eliminate(I, A)
Ideal generated by
  -x*z + y^2
  x*y - z
  x^2 - y

julia> A = [1];

julia> TC = eliminate(I, A)
Ideal generated by
  -x*z + y^2
  x*y - z
  x^2 - y

julia> eliminate(I, lex(R), 2)
Ideal generated by
  y^3 - z^2

julia> base_ring(TC)
Multivariate polynomial ring in 4 variables t, x, y, z
  over rational field

julia> S, (yy, zz) = QQ[:yy, :zz]; # Construct the elimination as an ideal of S

julia> f = hom(S, R, [y, z]);

julia> TCS = preimage(f, I)
Ideal generated by
  yy^3 - zz^2

julia> base_ring(TCS)
Multivariate polynomial ring in 2 variables yy, zz
  over rational field
```
"""
function eliminate(I::MPolyIdeal{T}, l::Vector{T}) where T <: MPolyRingElem
  S = singular_polynomial_ring(I)
  s = Singular.eliminate(singular_generators(I), [S(x) for x = l]...)
  return MPolyIdeal(base_ring(I), s)
end
function eliminate(I::MPolyIdeal, l::AbstractVector{Int})
  R = base_ring(I)
  return eliminate(I, [gen(R, i) for i=l])
end
function eliminate(I::MPolyIdeal, o::MonomialOrdering, l::Int)
  R = base_ring(I)
  R_gens = sort(gens(R); order=o, rev=true)[1:l]
  @req is_elimination_ordering(o, R_gens) "Given ordering is not an elimination ordering"
  gb = get(I.gb, o, nothing)
  isnothing(gb) && return eliminate(I, R_gens)

  elimination_ideal_gens_indices = findall(x -> cmp(o, R_gens[end], leading_monomial(x; ordering=o)) > 0, gens(gb))
  isempty(elimination_ideal_gens_indices) && return ideal(R, [])
  ideal(IdealGens(gens(gb)[elimination_ideal_gens_indices], o; isGB=true))
end

### todo: wenn schon GB bzgl. richtiger eliminationsordnung bekannt ...
### Frage: return MPolyIdeal(base_ring(I), s) ???

###################################################

# primary decomposition #######################################################

#######################################################
@doc raw"""
    radical(I::MPolyIdeal{T}; preprocessing::Bool = true) where {T <: MPolyRingElem}

Return the radical of `I`.

# Implemented Algorithms

  * If the base ring of `I` is a polynomial ring over a the field of rational numbers or a finite field, a combination of the algorithms of Krick and Logar (with modifications by Laplagne) and Kemper is used.
  * If the `base_ring` of `I` is a number field, then we first expand the minimal polynomials to reduce to a computation over the rationals.
  * For polynomial rings over the integers, the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel. See [KL91](@cite), [Kem02](@cite), and [PSS11](@cite).

When `preprocessing` is set to `true`, several preprocessing heuristics are applied. See the source code for more detailed information and options.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia> I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia> RI = radical(I)
Ideal generated by
  x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2
```
```jldoctest
julia> R, (a, b, c, d) = polynomial_ring(ZZ, [:a, :b, :c, :d])
(Multivariate polynomial ring in 4 variables over ZZ, ZZMPolyRingElem[a, b, c, d])

julia> I = intersect(ideal(R, [9,a,b]), ideal(R, [3,c]))
Ideal generated by
  9
  3*b
  3*a
  b*c
  a*c

julia> I = intersect(I, ideal(R, [11,2a,7b]))
Ideal generated by
  99
  3*b
  3*a
  b*c
  a*c

julia> I = intersect(I, ideal(R, [13a^2,17b^4]))
Ideal generated by
  39*a^2
  13*a^2*c
  51*b^4
  17*b^4*c
  3*a^2*b^4
  a^2*b^4*c

julia> I = intersect(I, ideal(R, [9c^5,6d^5]))
Ideal generated by
  78*a^2*d^5
  117*a^2*c^5
  102*b^4*d^5
  153*b^4*c^5
  6*a^2*b^4*d^5
  9*a^2*b^4*c^5
  39*a^2*c^5*d^5
  51*b^4*c^5*d^5
  3*a^2*b^4*c^5*d^5

julia> I = intersect(I, ideal(R, [17,a^15,b^15,c^15,d^15]))
Ideal generated by
  1326*a^2*d^5
  1989*a^2*c^5
  102*b^4*d^5
  153*b^4*c^5
  663*a^2*c^5*d^5
  51*b^4*c^5*d^5
  78*a^2*d^15
  117*a^2*c^15
  78*a^15*d^5
  117*a^15*c^5
  6*a^2*b^4*d^15
  9*a^2*b^4*c^15
  39*a^2*c^5*d^15
  39*a^2*c^15*d^5
  6*a^2*b^15*d^5
  9*a^2*b^15*c^5
  6*a^15*b^4*d^5
  9*a^15*b^4*c^5
  39*a^15*c^5*d^5
  3*a^2*b^4*c^5*d^15
  3*a^2*b^4*c^15*d^5
  3*a^2*b^15*c^5*d^5
  3*a^15*b^4*c^5*d^5

julia> RI = radical(I)
Ideal generated by
  1326*a*d
  663*a*c
  102*b*d
  51*b*c
  663*a*c*d
  51*b*c*d
  78*a*d
  39*a*c
  6*a*b*d
  3*a*b*c
  39*a*c*d
  3*a*b*c*d
```
"""
@attr MPolyIdeal{T} function radical(
    I::MPolyIdeal{T};
    preprocessing::Bool=true,
    eliminate_variables::Bool=true,
    factor_generators::Bool=true
  ) where {T <: MPolyRingElem}
  is_known(is_radical, I) && is_radical(I) && return I
  # We first check for the squarefree flag.
  # Elimination of variables will probably affect how the generators factor.
  if preprocessing && factor_generators
    # Replace every generator by its squarefree part to get closer to the actual radical
    # even before passing computations on to Singular.
    return radical(_squarefree_generator_ideal(I); preprocessing, eliminate_variables, factor_generators=false)
  end
  if preprocessing && eliminate_variables
    is_known(is_radical, I) && is_radical(I) && return I
    # Call `elimpart` (within `simplify`) in order to substitute variables.
    # This turns out to significantly speed things up in many cases.
    R = base_ring(I)
    Q, pr = quo(R, I)
    S, iso, iso_inv = simplify(Q)
    is_zero(ngens(S)) && return I # This only happens when all variables can be eliminated.
    # Then the ideal defines a reduced point.
    J = modulus(S)
    pre_res = radical(J; preprocessing, eliminate_variables=false, factor_generators)
    pre_res = ideal(R, elem_type(R)[lift(iso_inv(S(g))) for g in gens(pre_res)])
    res = ideal(R, small_generating_set(pre_res + I))
    set_attribute!(res, :is_radical=>true)
    if is_known(dim, I)
      res.dim = dim(I) # preserve information about the dimension
    end
    return res
  end
  res = _compute_radical(I)
  if is_known(dim, I)
    res.dim = dim(I) # preserve information about the dimension
  end
  return res
end

function is_known(::typeof(radical), I::MPolyIdeal)
  has_attribute(I, :radical) && return true
  is_known(is_radical, I) && is_radical(I) && return true
  return false
end

function _compute_radical(I::T) where {T <: MPolyIdeal}
  R = base_ring(I)
  if isa(base_ring(R), NumField) && !isa(base_ring(R), AbsSimpleNumField)
    A, mA = absolute_simple_field(base_ring(R))
    r = radical(map_coefficients(pseudo_inv(mA), I))
    Irad = map_coefficients(mA, r, parent = R)
    set_attribute!(Irad, :is_radical => true)
    return Irad
  elseif elem_type(base_ring(R)) <: FieldElement
    J = Singular.LibPrimdec.radical(singular_polynomial_ring(I), singular_generators(I))
  elseif base_ring(singular_polynomial_ring(I)) isa Singular.Integers
    J = Singular.LibPrimdecint.radicalZ(singular_polynomial_ring(I), singular_generators(I))
  else
    error("not implemented for base ring")
  end
  Irad = ideal(R, J)
  set_attribute!(Irad, :is_radical => true)
  return Irad
end

# Go through the generators of I and replace each generator by its squarefree part.
# This is a heuristic preprocessing method for radical computations.
function _squarefree_generator_ideal(I::MPolyIdeal)
  R = base_ring(I)
  res_gens = elem_type(R)[]
  for g in gens(I)
    is_zero(g) && continue
    fact = factor_squarefree(g)
    is_empty(fact) && return ideal(R, one(R))
    h = prod(x for (x, _) in fact; init=one(R))
    push!(res_gens, h)
  end
  return ideal(R, res_gens)
end

# Rerouting via expansion of the coefficient field
@attr MPolyIdeal{T} function radical(
    I::MPolyIdeal{T};
    preprocessing::Bool=true,
    factor_generators::Bool=true,
    eliminate_variables::Bool=true
  ) where {U<:Hecke.RelSimpleNumFieldElem, T<:MPolyRingElem{U}}
  is_known(is_radical, I) && is_radical(I) && return I
  R = base_ring(I)
  preprocessing && factor_generators && return radical(_squarefree_generator_ideal(I); preprocessing, eliminate_variables, factor_generators=false)
  R_flat, iso, iso_inv = _expand_coefficient_field_to_QQ(R)
  I_flat = ideal(R_flat, iso_inv.(gens(I)))
  I_flat_rad = radical(I_flat;
                       preprocessing,
                       eliminate_variables,
                       factor_generators=false) # Taking the squarefree part of generators only pays off on the top level.
  Irad = iso(I_flat_rad)
  set_attribute!(Irad, :is_radical => true)
  @hassert :IdealSheaves 2 !is_one(Irad)
  return Irad
end

function map_coefficients(mp, I::MPolyIdeal; parent = nothing)
  if parent === nothing
    parent = Oscar.parent(map_coefficients(mp, zero(base_ring(I))))
  end
  return ideal(parent, [map_coefficients(mp, g, parent = parent) for g = gens(I)])
end

@doc raw"""
    is_radical(I::MPolyIdeal)

Return whether `I` is a radical ideal.

Computes the radical.
"""
@attr Bool function is_radical(I::MPolyIdeal)
  is_known(is_prime, I) && is_prime(I) && return true
  return is_subset(radical(I), I)
end

function is_known(::typeof(is_radical), I::MPolyIdeal)
  is_known(is_prime, I) && is_prime(I) && return true
  return has_attribute(I, :is_radical)
end


#######################################################
@doc raw"""
    primary_decomposition(I::MPolyIdeal; algorithm = :GTZ, cache=true)

Return a minimal primary decomposition of `I`.

The decomposition is returned as a vector of tuples $(Q_1, P_1), \dots, (Q_t, P_t)$, say,
where each $Q_i$ is a primary ideal with associated prime $P_i$, and where the intersection of
the $Q_i$ is `I`.

# Implemented Algorithms

If the base ring of `I` is a polynomial ring over a field, the algorithm of Gianni, Trager, and Zacharias
is used by default (`algorithm = :GTZ`). Alternatively, the algorithm by Shimoyama and Yokoyama can be used
by specifying `algorithm = :SY`.  For polynomial rings over the integers, the algorithm proceeds as suggested by
Pfister, Sadiq, and Steidel. See [GTZ88](@cite), [SY96](@cite), and [PSS11](@cite).

!!! warning
    The algorithm of Gianni, Trager, and Zacharias may not terminate over a small finite field. If it terminates, the result is correct.

!!! warning
    If computations are done in a ring over a number field, then the output may contain redundant components.

If `cache=false` is set, the primary decomposition is recomputed and not cached.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia> I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia> L = primary_decomposition(I)
3-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}}}:
 (Ideal (x^3 - x - y^2), Ideal (x^3 - x - y^2))
 (Ideal (x^2 - 2*x*y - 2*x + y^2 + 2*y + 1), Ideal (x - y - 1))
 (Ideal (y, x^2), Ideal (x, y))

julia> L = primary_decomposition(I, algorithm = :SY, cache=false)
3-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}}}:
 (Ideal (x^3 - x - y^2), Ideal (x^3 - x - y^2))
 (Ideal (x^2 - 2*x*y - 2*x + y^2 + 2*y + 1), Ideal (x - y - 1))
 (Ideal (y, x^2), Ideal (y, x))
```
```jldoctest
julia> R, (a, b, c, d) = polynomial_ring(ZZ, [:a, :b, :c, :d])
(Multivariate polynomial ring in 4 variables over ZZ, ZZMPolyRingElem[a, b, c, d])

julia> I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,
       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,
       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,
       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,
       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,
       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])
Ideal generated by
  1326*a^2*d^5
  1989*a^2*c^5
  102*b^4*d^5
  153*b^4*c^5
  663*a^2*c^5*d^5
  51*b^4*c^5*d^5
  78*a^2*d^15
  117*a^2*c^15
  78*a^15*d^5
  117*a^15*c^5
  6*a^2*b^4*d^15
  9*a^2*b^4*c^15
  39*a^2*c^5*d^15
  39*a^2*c^15*d^5
  6*a^2*b^15*d^5
  9*a^2*b^15*c^5
  6*a^15*b^4*d^5
  9*a^15*b^4*c^5
  39*a^15*c^5*d^5
  3*a^2*b^4*c^5*d^15
  3*a^2*b^4*c^15*d^5
  3*a^2*b^15*c^5*d^5
  3*a^15*b^4*c^5*d^5

julia> L = primary_decomposition(I)
8-element Vector{Tuple{MPolyIdeal{ZZMPolyRingElem}, MPolyIdeal{ZZMPolyRingElem}}}:
 (Ideal (d^5, c^5), Ideal (d, c))
 (Ideal (a^2, b^4), Ideal (b, a))
 (Ideal (2, c^5), Ideal (2, c))
 (Ideal (3), Ideal (3))
 (Ideal (13, b^4), Ideal (13, b))
 (Ideal (17, a^2), Ideal (17, a))
 (Ideal (17, d^15, c^15, b^15, a^15), Ideal (17, d, c, b, a))
 (Ideal (9, 3*d^5, d^10), Ideal (3, d))
```
"""
function primary_decomposition(I::T; algorithm::Symbol=:GTZ, cache::Bool=true) where {T<:MPolyIdeal}
  !cache && return _compute_primary_decomposition(I, algorithm=algorithm)
  return get_attribute!(I, :primary_decomposition) do
    return _compute_primary_decomposition(I, algorithm=algorithm)
  end::Vector{Tuple{T,T}}
end

is_known(::typeof(primary_decomposition), I::MPolyIdeal) = has_attribute(I, :primary_decomposition)

function primary_decomposition(
    I::MPolyIdeal{T};
    algorithm::Symbol=:GTZ, cache::Bool=true
  ) where {U<:Hecke.RelSimpleNumFieldElem, T<:MPolyRingElem{U}}
  if has_attribute(I, :primary_decomposition)
    return get_attribute(I, :primary_decomposition)::Vector{Tuple{typeof(I), typeof(I)}}
  end
  R = base_ring(I)
  R_flat, iso, iso_inv = _expand_coefficient_field_to_QQ(R)
  I_flat = ideal(R_flat, iso_inv.(gens(I)))
  dec = primary_decomposition(I_flat; algorithm, cache)
  result = Vector{Tuple{typeof(I), typeof(I)}}()
  for (P, Q) in dec
    push!(result, (ideal(R, unique!([x for x in iso.(gens(P)) if !iszero(x)])),
                   ideal(R, unique!([x for x in iso.(gens(Q)) if !iszero(x)]))))
  end

  for (Q,P) in result
    set_attribute!(P, :is_prime=>true)
    set_attribute!(Q, :is_primary=>true)
  end

  cache && set_attribute!(I, :primary_decomposition=>result)
  return result
end

function _compute_primary_decomposition(I::MPolyIdeal; algorithm::Symbol=:GTZ)
  R = base_ring(I)
  if isa(base_ring(R), NumField) && !isa(base_ring(R), AbsSimpleNumField)
    A, mA = absolute_simple_field(base_ring(R))
    pd = primary_decomposition(map_coefficients(pseudo_inv(mA), I), algorithm = algorithm, cache = false)
    if isempty(pd)
      return Tuple{typeof(I), typeof(I)}[]
    end
    return Tuple{typeof(I), typeof(I)}[(map_coefficients(mA, x[1], parent = R), map_coefficients(mA, x[2], parent = R)) for x = pd]
  end
  if elem_type(base_ring(R)) <: FieldElement
    if algorithm == :GTZ
      L = Singular.LibPrimdec.primdecGTZ(singular_polynomial_ring(I), singular_generators(I))
    elseif algorithm == :SY
      L = Singular.LibPrimdec.primdecSY(singular_polynomial_ring(I), singular_generators(I))
    else
      error("algorithm invalid")
    end
  elseif base_ring(singular_polynomial_ring(I)) isa Singular.Integers
    L = Singular.LibPrimdecint.primdecZ(singular_polynomial_ring(I), singular_generators(I))
  else
    error("base ring not implemented")
  end
  V = [(ideal(R, q[1]), ideal(R, q[2])) for q in L]
  if length(V) == 1 && is_one(gen(V[1][1], 1))
    return Tuple{typeof(I), typeof(I)}[]
  end
  return V
end

########################################################
@doc raw"""
    absolute_primary_decomposition(I::MPolyIdeal{<:MPolyRingElem{QQFieldElem}})

Given an ideal `I` in a multivariate polynomial ring over the rationals, return an absolute minimal primary decomposition of `I`.

Return the decomposition as a vector of tuples $(Q_i, P_i, P_{ij}, d_{ij})$, say,
where $(Q_i, P_i)$ is a (primary, prime) tuple as returned by `primary_decomposition(I)`,
and $P_{ij}$ represents a corresponding class of conjugated absolute associated primes
defined over a number field of degree $d_{ij}$ whose generator prints as `_a`.

# Implemented Algorithms

The implementation combines the algorithm of Gianni, Trager, and Zacharias for primary
decomposition with absolute polynomial factorization.

# Examples
```jldoctest
julia> R, (y, z) = polynomial_ring(QQ, [:y, :z])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[y, z])

julia> p = z^2+1
z^2 + 1

julia> q = z^3+2
z^3 + 2

julia> I = ideal(R, [p*q^2, y-z^2])
Ideal generated by
  z^8 + z^6 + 4*z^5 + 4*z^3 + 4*z^2 + 4
  y - z^2

julia> L = primary_decomposition(I)
2-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}}}:
 (Ideal (z^2 + 1, y - z^2), Ideal (z^2 + 1, y - z^2))
 (Ideal (z^6 + 4*z^3 + 4, y - z^2), Ideal (z^3 + 2, y - z^2))

julia> AL = absolute_primary_decomposition(I)
2-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}, Int64}}:
 (Ideal (z^2 + 1, y + 1), Ideal (z^2 + 1, y + 1), Ideal (z - _a, y + 1), 2)
 (Ideal (z^6 + 4*z^3 + 4, y - z^2), Ideal (z^3 + 2, y - z^2), Ideal (z - _a, y - _a^2), 3)

julia> AP = AL[1][3]
Ideal generated by
  z - _a
  y + 1

julia> RAP = base_ring(AP)
Multivariate polynomial ring in 2 variables y, z
  over number field of degree 2 over QQ

julia> NF = coefficient_ring(RAP)
Number field with defining polynomial x^2 + 1
  over rational field

julia> a = gen(NF)
_a

julia> minpoly(a)
x^2 + 1
```


```jldoctest
julia> R, (x, y) = graded_polynomial_ring(QQ, [:x, :y])
(Graded multivariate polynomial ring in 2 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y])

julia> I = ideal(R, [x^2+y^2])
Ideal generated by
  x^2 + y^2

julia> AL = absolute_primary_decomposition(I)
1-element Vector{Tuple{MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}, MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}, MPolyIdeal{MPolyDecRingElem{AbsSimpleNumFieldElem, AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}}, Int64}}:
 (Ideal (x^2 + y^2), Ideal (x^2 + y^2), Ideal (x + _a*y), 2)

julia> AP = AL[1][3]
Ideal generated by
  x + _a*y

julia> RAP = base_ring(AP)
Multivariate polynomial ring in 2 variables over number field graded by
  x -> [1]
  y -> [1]
```
"""
@attr Vector{Tuple{typeof(I), typeof(I), ideal_type(change_base_ring(rationals_as_number_field()[1], base_ring(I))[1]), Int64}} function absolute_primary_decomposition(I::MPolyIdeal{<:MPolyRingElem{QQFieldElem}})
  R = base_ring(I)
  K, _ = rationals_as_number_field()
  RK, _ = change_base_ring(K, R)
  if is_zero(I)
    return [(ideal(R, zero(R)), ideal(R, zero(R)), ideal(RK, zero(RK)), 1)]
  end
  (S, d) = Singular.LibPrimdec.absPrimdecGTZ(singular_polynomial_ring(I), singular_generators(I))
  if isempty(d)
    return Vector{Tuple{typeof(I), typeof(I), ideal_type(RK), Int64}}()
  end
  decomp = d[:primary_decomp]
  absprimes = d[:absolute_primes]
  @assert length(decomp) == length(absprimes)
  V =  [(_map_last_var(R, decomp[i][1], 1, one(QQ))) for i in 1:length(decomp)]
  if length(V) == 1 && is_one(gen(V[1], 1))
    return Vector{Tuple{typeof(I), typeof(I), ideal_type(RK), Int64}}()
  end
  return [(V[i], _map_last_var(R, decomp[i][2], 1, one(QQ)),
         _map_to_ext(R, absprimes[i][1]),
         absprimes[i][2]::Int)
         for i in 1:length(decomp)]
end

@attr Any function absolute_primary_decomposition(
    I::MPolyIdeal{T}
  ) where {U<:Union{AbsSimpleNumFieldElem, <:Hecke.RelSimpleNumFieldElem}, T<:MPolyRingElem{U}}
  R = base_ring(I)
  kk = coefficient_ring(R)
  R_exp, iso, iso_inv = _expand_coefficient_field_to_QQ(R)
  iso_inv(one(R))
  I_exp = ideal(R_exp, iso_inv.(gens(I)))
  res = absolute_primary_decomposition(I_exp)
  full_res = []
  for (P_ext, Q_ext, P_prime, d) in res
    @assert base_ring(P_ext) === R_exp
    P = ideal(R, unique!(iso.(gens(P_ext))))
    Q = ideal(R, unique!(iso.(gens(Q_ext))))
    RR = base_ring(P_prime)
    L = coefficient_ring(RR)
    f = defining_polynomial(L)
    f_kk = map_coefficients(kk, f)
    h = first([h for (h, _) in factor(f_kk)])
    kk_ext, zeta = extension_field(h)
    inc_kk_ext = hom(L, kk_ext, zeta)
    LoR, to_LoR = change_base_ring(kk_ext, R)
    help_map = hom(RR, LoR, inc_kk_ext, to_LoR.(iso.(gens(R_exp))))
    P_prime_ext = ideal(LoR, help_map.(gens(P_prime)))
    push!(full_res, (P, Q, P_prime_ext, degree(h)))
  end
  return full_res
end

# the ideals in QQbar[x] come back in QQ[x,a] with an extra variable a added
# and the minpoly of a prepended to the ideal generator list
function _map_to_ext(Qx::MPolyRing, I::Oscar.Singular.sideal)
  Qxa = base_ring(I)
  @assert nvars(Qxa) == nvars(Qx) + 1
  p = I[1]
  minpoly = zero(Hecke.Globals.Qx)
  for (c, e) in zip(AbstractAlgebra.coefficients(p), AbstractAlgebra.exponent_vectors(p))
    setcoeff!(minpoly, e[nvars(Qxa)], QQ(c))
  end
  R, a = number_field(minpoly)
  if is_graded(Qx)
    Rx, _ = graded_polynomial_ring(R, symbols(Qx), [degree(x) for x = gens(Qx)]; cached = false)
  else
    Rx, _ = polynomial_ring(R, symbols(Qx); cached = false)
  end
  return _map_last_var(Rx, I, 2, a)
end

# the ideals in QQ[x] also come back in QQ[x,a]
function _map_last_var(Qx::MPolyRing, I::Singular.sideal, start, a)
  newgens = elem_type(Qx)[]
  for i in start:ngens(I)
    p = I[i]
    g = MPolyBuildCtx(Qx)
    for (c, e) in zip(AbstractAlgebra.coefficients(p), AbstractAlgebra.exponent_vectors(p))
      ca = QQ(c)*a^pop!(e)
      push_term!(g, ca, e)
    end
    push!(newgens, finish(g))
  end
  return ideal(Qx, newgens)
end

#######################################################
@doc raw"""
    minimal_primes(I::MPolyIdeal; algorithm::Symbol = :GTZ)

Return a vector containing the minimal associated prime ideals of `I`.

# Implemented Algorithms

If the base ring of `I` is a polynomial ring over a field, the algorithm of
Gianni, Trager, and Zacharias is used by default (`algorithm = :GTZ`). Alternatively, characteristic sets can be
used by specifying `algorithm = :charSets`. For polynomial rings over the integers,
the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel.
See [GTZ88](@cite) and [PSS11](@cite).

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia> I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia> L = minimal_primes(I)
2-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (x - y - 1)
 Ideal (x^3 - x - y^2)

julia> L = minimal_primes(I, algorithm = :charSets)
2-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (x - y - 1)
 Ideal (x^3 - x - y^2)
```
```jldoctest
julia> R, (a, b, c, d) = polynomial_ring(ZZ, [:a, :b, :c, :d])
(Multivariate polynomial ring in 4 variables over ZZ, ZZMPolyRingElem[a, b, c, d])

julia> I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,
       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,
       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,
       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,
       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,
       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])
Ideal generated by
  1326*a^2*d^5
  1989*a^2*c^5
  102*b^4*d^5
  153*b^4*c^5
  663*a^2*c^5*d^5
  51*b^4*c^5*d^5
  78*a^2*d^15
  117*a^2*c^15
  78*a^15*d^5
  117*a^15*c^5
  6*a^2*b^4*d^15
  9*a^2*b^4*c^15
  39*a^2*c^5*d^15
  39*a^2*c^15*d^5
  6*a^2*b^15*d^5
  9*a^2*b^15*c^5
  6*a^15*b^4*d^5
  9*a^15*b^4*c^5
  39*a^15*c^5*d^5
  3*a^2*b^4*c^5*d^15
  3*a^2*b^4*c^15*d^5
  3*a^2*b^15*c^5*d^5
  3*a^15*b^4*c^5*d^5

julia> L = minimal_primes(I)
6-element Vector{MPolyIdeal{ZZMPolyRingElem}}:
 Ideal (d, c)
 Ideal (b, a)
 Ideal (2, c)
 Ideal (3)
 Ideal (13, b)
 Ideal (17, a)
```
"""
function minimal_primes(I::MPolyIdeal; algorithm::Symbol = :GTZ, cache::Bool=true)
  has_attribute(I, :minimal_primes) && return get_attribute(I, :minimal_primes)::Vector{typeof(I)}
  R = base_ring(I)
  if isa(base_ring(R), NumField) && !isa(base_ring(R), AbsSimpleNumField)
    A, mA = absolute_simple_field(base_ring(R))
    mp = minimal_primes(map_coefficients(pseudo_inv(mA), I); algorithm = algorithm)
    result = typeof(I)[map_coefficients(mA, x) for x = mp]
    cache && set_attribute!(I, :minimal_primes=>result)
    return result
  end
  if elem_type(base_ring(R)) <: FieldElement
    if algorithm == :GTZ
      l = Singular.LibPrimdec.minAssGTZ(singular_polynomial_ring(I), singular_generators(I))
    elseif algorithm == :charSets
      l = Singular.LibPrimdec.minAssChar(singular_polynomial_ring(I), singular_generators(I))
    else
      error("algorithm invalid")
    end
  elseif base_ring(singular_polynomial_ring(I)) isa Singular.Integers
    l = Singular.LibPrimdecint.minAssZ(singular_polynomial_ring(I), singular_generators(I))
  else
    error("base ring not implemented")
  end
  V = [ideal(R, i) for i in l]
  if length(V) == 1 && is_one(gen(V[1], 1))
    result = typeof(I)[]
    cache && set_attribute!(I, :minimal_primes=>result)
    return result
  end

  for Ptemp in V
    set_attribute!(Ptemp, :is_prime=>true)
  end

  return V
end

is_known(::typeof(minimal_primes), I::MPolyIdeal) = has_attribute(I, :minimal_primes)

# rerouting the procedure for minimal primes this way leads to
# much longer computations compared to the flattening of the coefficient
# field implemented above.
function minimal_primes(
    I::MPolyIdeal{T};
    algorithm::Symbol=:GTZ,
    eliminate_variables::Bool=true,
    cache::Bool=true
  ) where {U<:Union{AbsSimpleNumFieldElem, <:Hecke.RelSimpleNumFieldElem}, T<:MPolyRingElem{U}}
  has_attribute(I, :minimal_primes) && return get_attribute(I, :minimal_primes)::Vector{typeof(I)}

  R = base_ring(I)
  is_one(I) && return typeof(I)[]

  # Try to eliminate variables first. This will often speed up computations significantly.
  if eliminate_variables
    Q, pr = quo(R, I)
    W, id, id_inv = simplify(Q)
    @assert domain(id) === codomain(id_inv) === Q
    @assert codomain(id) === domain(id_inv) === W
    res_simp = minimal_primes(modulus(W); algorithm, eliminate_variables=false)
    result = [I + ideal(R, lift.(id_inv.(W.(gens(j))))) for j in res_simp]
    for p in result
      set_attribute!(p, :is_prime=>true)
    end
    return result
  end

  R_flat, iso, iso_inv = _expand_coefficient_field_to_QQ(R)
  I_flat = ideal(R_flat, elem_type(R_flat)[g for g in iso_inv.(gens(I))])
  dec = minimal_primes(I_flat; algorithm)
  result = Vector{typeof(I)}()
  for Q in dec
    push!(result, ideal(R, iso.(gens(Q))))
  end

  cache && set_attribute!(I, :minimal_primes=>result)
  return result
end

#######################################################
@doc raw"""
    equidimensional_decomposition_weak(I::MPolyIdeal)

Return a vector of equidimensional ideals where the last entry is the
equidimensional hull of `I`, that is, the intersection of the primary
components of `I` of maximal dimension. Each of the previous entries
is an ideal of lower dimension whose associated primes are exactly the associated
primes of `I` of that dimension.

# Implemented Algorithms

The implementation relies on ideas of Eisenbud, Huneke, and Vasconcelos. See [EHV92](@cite).

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia> I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia> L = equidimensional_decomposition_weak(I)
2-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (y, x)
 Ideal with 1 generator
```
"""
@attr Vector{typeof(I)} function equidimensional_decomposition_weak(I::MPolyIdeal)
  R = base_ring(I)
  iszero(I) && return [I]
  @req coefficient_ring(R) isa AbstractAlgebra.Field "The coefficient ring must be a field"
  if isa(base_ring(R), NumField) && !isa(base_ring(R), AbsSimpleNumField)
    A, mA = absolute_simple_field(base_ring(R))
    eq = equidimensional_decomposition_weak(map_coefficients(pseudo_inv(mA), I))
    retval =  typeof(I)[map_coefficients(mA, x, parent = R) for x = eq]
    for Itemp in retval
      set_attribute!(Itemp, :is_equidimensional=>true)
    end
    return retval
  end
  l = Singular.LibPrimdec.equidim(singular_polynomial_ring(I), singular_generators(I))
  V = [ideal(R, i) for i in l]
  if length(V) == 1 && is_one(gen(V[1], 1))
    return typeof(I)[]
  end

  for Itemp in V
    set_attribute!(Itemp, :is_equidimensional=>true)
  end

  return V
end

@attr Vector{typeof(I)} function equidimensional_decomposition_weak(
    I::MPolyIdeal{T}
  ) where {U<:Union{AbsSimpleNumFieldElem, <:Hecke.RelSimpleNumFieldElem}, T<:MPolyRingElem{U}}
  R = base_ring(I)
  R_ext, iso, iso_inv = _expand_coefficient_field_to_QQ(R)
  I_ext = ideal(R_ext, iso_inv.(gens(I)))
  res = equidimensional_decomposition_weak(I_ext)
  retval =  typeof(I)[ideal(R, unique!([x for x in iso.(gens(I)) if !iszero(x)])) for I in res]
  for Itemp in retval
    set_attribute!(Itemp, :is_equidimensional=>true)
  end
  return retval
end



@doc raw"""
    equidimensional_decomposition_radical(I::MPolyIdeal)

Return a vector of equidimensional radical ideals increasingly ordered by dimension.
For each dimension, the returned radical ideal is the intersection of the associated primes
of `I` of that dimension.

# Implemented Algorithms

The implementation combines the algorithms of Krick and Logar (with modifications by Laplagne) and Kemper. See [KL91](@cite) and [Kem02](@cite).

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia> I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia> L = equidimensional_decomposition_radical(I)
2-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (y, x)
 Ideal (x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2)
```
"""
@attr Any function equidimensional_decomposition_radical(I::MPolyIdeal)
  R = base_ring(I)
  @req coefficient_ring(R) isa AbstractAlgebra.Field "The coefficient ring must be a field"
  if isa(base_ring(R), NumField) && !isa(base_ring(R), AbsSimpleNumField)
    A, mA = absolute_simple_field(base_ring(R))
    eq = equidimensional_decomposition_radical(map_coefficients(pseudo_inv(mA), I))
    retval = typeof(I)[map_coefficients(mA, x) for x = eq]
    for Itemp in retval
      set_attribute!(Itemp, :is_radical=>true)
      set_attribute!(Itemp, :is_equidimensional=>true)
    end
    return retval
  end
  l = Singular.LibPrimdec.prepareAss(singular_polynomial_ring(I), singular_generators(I))
  V = [ideal(R, i) for i in l]
  if length(V) == 1 && is_one(gen(V[1], 1))
    return typeof(I)[]
  end

  for Ptemp in V
    set_attribute!(Ptemp, :is_radical=>true)
    set_attribute!(Ptemp, :is_equidimensional=>true)
  end

  return V
end

@attr Any function equidimensional_decomposition_radical(
    I::MPolyIdeal{T}
  ) where {U<:Union{AbsSimpleNumFieldElem, <:Hecke.RelSimpleNumFieldElem}, T<:MPolyRingElem{U}}
  R = base_ring(I)
  R_ext, iso, iso_inv = _expand_coefficient_field_to_QQ(R)
  I_ext = ideal(R_ext, iso_inv.(gens(I)))
  res = equidimensional_decomposition_weak(I_ext)
  retval = [ideal(R, unique!(iso.(gens(I)))) for I in res]
  for Itemp in retval
    set_attribute!(Itemp, :is_equidimensional=>true)
    set_attribute!(Itemp, :is_radical=>true)
  end
  return retval
end

#######################################################
@doc raw"""
    equidimensional_hull(I::MPolyIdeal)

If the base ring of `I` is a polynomial ring over a field, return the intersection
of the primary components of `I` of maximal dimension. In the case of polynomials
over the integers, return the intersection of the primary components of I of
minimal height.  If `I` is the unit ideal, return `[ideal(1)]`.

# Implemented Algorithms

For polynomial rings over a field, the implementation relies on ideas as used by
Gianni, Trager, and Zacharias or Krick and Logar. For polynomial rings over the integers,
the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel. See [GTZ88](@cite),
[KL91](@cite),  and [PSS11](@cite).

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia> I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia> L = equidimensional_hull(I)
Ideal generated by
  x^5 - 2*x^4*y - 2*x^4 + x^3*y^2 + 2*x^3*y - x^2*y^2 + 2*x^2*y + 2*x^2 + 2*x*y^3 + x*y^2 - 2*x*y - x - y^4 - 2*y^3 - y^2
```
```jldoctest
julia> R, (a, b, c, d) = polynomial_ring(ZZ, [:a, :b, :c, :d])
(Multivariate polynomial ring in 4 variables over ZZ, ZZMPolyRingElem[a, b, c, d])

julia> I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,
       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,
       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,
       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,
       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,
       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])
Ideal generated by
  1326*a^2*d^5
  1989*a^2*c^5
  102*b^4*d^5
  153*b^4*c^5
  663*a^2*c^5*d^5
  51*b^4*c^5*d^5
  78*a^2*d^15
  117*a^2*c^15
  78*a^15*d^5
  117*a^15*c^5
  6*a^2*b^4*d^15
  9*a^2*b^4*c^15
  39*a^2*c^5*d^15
  39*a^2*c^15*d^5
  6*a^2*b^15*d^5
  9*a^2*b^15*c^5
  6*a^15*b^4*d^5
  9*a^15*b^4*c^5
  39*a^15*c^5*d^5
  3*a^2*b^4*c^5*d^15
  3*a^2*b^4*c^15*d^5
  3*a^2*b^15*c^5*d^5
  3*a^15*b^4*c^5*d^5

julia> L = equidimensional_hull(I)
Ideal generated by
  3
```
"""
function equidimensional_hull(I::MPolyIdeal)
  R = base_ring(I)
  if isa(base_ring(R), NumField) && !isa(base_ring(R), AbsSimpleNumField)
    A, mA = absolute_simple_field(base_ring(R))
    eq = equidimensional_hull(map_coefficients(pseudo_inv(mA), I))
    return map_coefficients(mA, eq)
  end
  if elem_type(base_ring(R)) <: FieldElement
    i = Singular.LibPrimdec.equidimMax(singular_polynomial_ring(I), singular_generators(I))
  elseif base_ring(singular_polynomial_ring(I)) isa Singular.Integers
    i = Singular.LibPrimdecint.equidimZ(singular_polynomial_ring(I), singular_generators(I))
  else
    error("base ring not implemented")
  end
  return ideal(R, i)
end

function equidimensional_hull(
    I::MPolyIdeal{T}
  ) where {U<:Union{AbsSimpleNumFieldElem, <:Hecke.RelSimpleNumFieldElem}, T<:MPolyRingElem{U}}
  R = base_ring(I)
  R_ext, iso, iso_inv = _expand_coefficient_field_to_QQ(R)
  I_ext = ideal(R_ext, iso_inv.(gens(I)))
  res = equidimensional_hull(I_ext)
  return ideal(R, unique!(iso.(gens(res))))
end

#######################################################
@doc raw"""
    equidimensional_hull_radical(I::MPolyIdeal)

Return the intersection of the associated primes of `I` of maximal dimension.
If `I` is the unit ideal, return `[ideal(1)]`.

# Implemented Algorithms

The implementation relies on a combination of the algorithms of Krick and Logar
(with modifications by Laplagne) and Kemper. See [KL91](@cite) and [Kem02](@cite).

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))
Ideal generated by
  x^3*y - x*y - y^3
  x^4 - x^2 - x*y^2

julia> I = intersect(I, ideal(R, [x-y-1])^2)
Ideal generated by
  x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3
  x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3

julia> L = equidimensional_hull_radical(I)
Ideal generated by
  x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2
```
"""
function equidimensional_hull_radical(I::MPolyIdeal)
  R = base_ring(I)
  @req coefficient_ring(R) isa AbstractAlgebra.Field "The coefficient ring must be a field"
  if isa(base_ring(R), NumField) && !isa(base_ring(R), AbsSimpleNumField)
    A, mA = absolute_simple_field(base_ring(R))
    eq = equidimensional_hull_radical(map_coefficients(pseudo_inv(mA), I))
    return map_coefficients(mA, eq)
  end
  i = Singular.LibPrimdec.equiRadical(singular_polynomial_ring(I), singular_generators(I))
  return ideal(R, i)
end

function equidimensional_hull_radical(
    I::MPolyIdeal{T}
  ) where {U<:Union{AbsSimpleNumFieldElem, <:Hecke.RelSimpleNumFieldElem}, T<:MPolyRingElem{U}}
  R = base_ring(I)
  R_ext, iso, iso_inv = _expand_coefficient_field_to_QQ(R)
  I_ext = ideal(R_ext, iso_inv.(gens(I)))
  res = equidimensional_hull_radical(I_ext)
  return ideal(R, unique!(iso.(gens(res))))
end

################################################################################
#
#  triangular decomposition
#
################################################################################

@doc raw"""
    triangular_decomposition(I::MPolyIdeal; algorithm::Symbol=:lazard, ord::Vector{<:MPolyRingElem}=reverse(gens(base_ring(I))))

Return a triangular decomposition of a zero-dimensional `I`.

By default the decomposition starts with a univariate polynomial in the last variable, then a
bivariate polynomial in the last two, etc similar to a lex Groebner basis..  If the optional argument 
`ord` is specified, it contains the list of variables fixing the ordering in which these are considered, that 
is the decomposition starts with a univariate polynomial in `ord[1]` and so on.

Possible algorithms are:
- `:lazard` (default) based on [Laz92](@cite).
- `:lazard_factorized` further factorizes each polynomial in the output of `:lazard`.
- `:moeller` based on [Moe93](@cite)
- `:moeller_hillebrand` based on [Hil99](@cite).

# Examples
```jldoctest
julia> R, (x1,x2,x3,x4,x5) = polynomial_ring(QQ, [:x1,:x2,:x3,:x4,:x5]);

julia> I = ideal([x1+x2+x3+x4+x5,
                  x1*x2+x2*x3+x3*x4+x1*x5+x4*x5,
                  x1*x2*x3+x2*x3*x4+x1*x2*x5+x1*x4*x5+x3*x4*x5,
                  x1*x2*x3*x4+x1*x2*x3*x5+x1*x2*x4*x5+x1*x3*x4*x5+x2*x3*x4*x5,
                  x1*x2*x3*x4*x5-1]);

julia> triangular_decomposition(I)
4-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (x5^5 - 1, x4 - x5, x3^2 + 3*x3*x5 + x5^2, x2 + x3 + 3*x5, x1 - x5)
 Ideal (x5^5 - 1, x4 - x5, x3 - x5, x2^2 + 3*x2*x5 + x5^2, x1 + x2 + 3*x5)
 Ideal with 5 generators
 Ideal with 5 generators

julia> triangular_decomposition(I,ord=[x1,x2,x3,x4,x5])
4-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (x1^5 - 1, -x1 + x2, x1^2 + 3*x1*x3 + x3^2, 3*x1 + x3 + x4, -x1 + x5)
 Ideal (x1^5 - 1, -x1 + x2, -x1 + x3, x1^2 + 3*x1*x4 + x4^2, 3*x1 + x4 + x5)
 Ideal with 5 generators
 Ideal with 5 generators

julia> triangular_decomposition(I; algorithm=:lazard_factorized)
13-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (x5 - 1, x4 - 1, x3 - 1, x2^2 + 3*x2 + 1, x1 + x2 + 3)
 Ideal (x5 - 1, x4 - 1, x3^2 + 3*x3 + 1, x2 + x3 + 3, x1 - 1)
 Ideal (x5 - 1, x4^2 + 3*x4 + 1, x3 + x4 + 3, x2 - 1, x1 - 1)
 Ideal (x5 - 1, x4^4 + x4^3 + x4^2 + x4 + 1, -x3 + x4^2, -x2 + x4^3, x1 + x4^3 + x4^2 + x4 + 1)
 Ideal (x5^2 + 3*x5 + 1, x4 - 1, x3 - 1, x2 - 1, x1 + x5 + 3)
 Ideal (x5^2 + 3*x5 + 1, x4 + x5 + 3, x3 - 1, x2 - 1, x1 - 1)
 Ideal with 5 generators
 Ideal (x5^4 + x5^3 + x5^2 + x5 + 1, x4 - 1, x3 + x5^3 + x5^2 + x5 + 1, -x2 + x5^3, -x1 + x5^2)
 Ideal (x5^4 + x5^3 + x5^2 + x5 + 1, x4 - x5, x3 - x5, x2^2 + 3*x2*x5 + x5^2, x1 + x2 + 3*x5)
 Ideal (x5^4 + x5^3 + x5^2 + x5 + 1, x4 - x5, x3^2 + 3*x3*x5 + x5^2, x2 + x3 + 3*x5, x1 - x5)
 Ideal with 5 generators
 Ideal (x5^4 + x5^3 + x5^2 + x5 + 1, x4^2 + 3*x4*x5 + x5^2, x3 + x4 + 3*x5, x2 - x5, x1 - x5)
 Ideal with 5 generators

julia> triangular_decomposition(I; algorithm=:moeller)
4-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (x5^5 - 1, x4 - x5, x3 - x5, x2^2 + 3*x2*x5 + x5^2, x1 + x2 + 3*x5)
 Ideal with 5 generators
 Ideal with 5 generators
 Ideal (x5^5 - 1, x4 - x5, x3^2 + 3*x3*x5 + x5^2, x2 + x3 + 3*x5, x1 - x5)

julia> triangular_decomposition(I; algorithm=:moeller_hillebrand)
4-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (x5^5 - 1, x4 - x5, x3 - x5, x2^2 + 3*x2*x5 + x5^2, x1 + x2 + 3*x5)
 Ideal with 5 generators
 Ideal with 5 generators
 Ideal (x5^5 - 1, x4 - x5, x3^2 + 3*x3*x5 + x5^2, x2 + x3 + 3*x5, x1 - x5)

```
"""
function triangular_decomposition(I::MPolyIdeal; algorithm::Symbol=:lazard, ord::Vector{<:MPolyRingElem}=reverse(gens(base_ring(I))))
  @req dim(I)==0 "The ideal must be zero-dimensional."
  R = base_ring(I)

  if ord==reverse(gens(R))
      G = ideal(groebner_basis(I; ordering=lex(R), complete_reduction=true))
      Gsing = singular_generators(G,lex(R)) # convert to Singular ideal
      if algorithm==:lazard
          Ts = Singular.LibTriang.triangL(Gsing)
      elseif algorithm==:lazard_factorized
          Ts = Singular.LibTriang.triangLfak(Gsing)
      elseif algorithm==:moeller
          Ts = Singular.LibTriang.triangM(Gsing)
      elseif algorithm==:moeller_hillebrand
          Ts = Singular.LibTriang.triangMH(Gsing)
      else
          error("algorithm allowed are :lazard, :lazard_factorized, :moeller, or :moeller_hillebrand")
      end
      Ts = ideal.(Ref(R),Ts) # convert to OSCAR ideals
  else
      n = ngens(R)
      perm = zeros(Int,n) # image notation permutation mapping
      #   - ord[1] to gens(R)[n]
      #   - ord[2] to gens(R)[n-1]
      #   - etc
      # so that triangular decomposition of permuted variables has form
      #   - univariate poly in ord[1]
      #   - bivariate poly in ord[1] and ord[2]
      #   - etc
      mrep = zeros(Int,n) # image notation permutation inverse to perm
      for (i,xi) in enumerate(gens(R))
          j = findfirst(isequal(xi),ord)
          perm[n-i+1] = j
          mrep[n-j+1] = i
      end

      Iperm = hom(R,R,gens(R)[perm])(I)
      Tperms = triangular_decomposition(Iperm,algorithm=algorithm)
      Ts = hom(R,R,gens(R)[mrep]).(Tperms)
  end
  return Ts
end

#######################################################
@doc raw"""
    ==(I::MPolyIdeal, J::MPolyIdeal)

Return `true` if `I` is equal to `J`, `false` otherwise.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x^2])
Ideal generated by
  x^2

julia> J = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia> I == J
false
```
"""
function ==(I::MPolyIdeal, J::MPolyIdeal)
  check_base_rings(I, J)
  I === J && return true
  gens(I) == gens(J) && return true
  return issubset(I, J) && issubset(J, I)
end

### todo: wenn schon GB's  bekannt ...

#######################################################
@doc raw"""
    is_subset(I::MPolyIdeal, J::MPolyIdeal)

Return `true` if `I` is contained in `J`, `false` otherwise.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x^2])
Ideal generated by
  x^2

julia> J = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia> is_subset(I, J)
true
```
"""
function is_subset(I::MPolyIdeal, J::MPolyIdeal)
  check_base_rings(I, J)
  return Singular.iszero(Singular.reduce(singular_generators(I), singular_groebner_generators(J)))
end

### todo: wenn schon GB's  bekannt ...

#######################################################

@doc raw"""
    ideal_membership(f::T, I::MPolyIdeal{T}) where T

Return `true` if `f` is contained in `I`, `false` otherwise. Alternatively, use `f in I`.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> f = x^2
x^2

julia> I = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia> ideal_membership(f, I)
true

julia> g = x
x

julia> g in I
false
```
"""
function ideal_membership(f::T, I::MPolyIdeal{T}; ordering::MonomialOrdering = default_ordering(base_ring(I))) where T
  Sx = singular_polynomial_ring(I, ordering)
  return Singular.iszero(Singular.reduce(Sx(f), singular_groebner_generators(I, ordering)))
end
Base.:in(f::MPolyRingElem, I::MPolyIdeal) = ideal_membership(f,I)
#######################################################
@doc raw"""
    radical_membership(f::T, I::MPolyIdeal{T}) where T

Return `true` if `f` is contained in the radical of `I`, `false` otherwise.
Alternatively, use `inradical(f, I)`.

# Examples
```jldoctest
julia> R, (x,) = polynomial_ring(QQ, [:x])
(Multivariate polynomial ring in 1 variable over QQ, QQMPolyRingElem[x])

julia> f = x
x

julia> I = ideal(R,  [x^2])
Ideal generated by
  x^2

julia> radical_membership(f, I)
true

julia> g = x+1
x + 1

julia> inradical(g, I)
false
```
"""
function radical_membership(f::T, I::MPolyIdeal{T}) where T
  iszero(I) && return iszero(f)
  Sx = singular_polynomial_ring(I)
  return Singular.LibPolylib.rad_con(Sx(f), singular_generators(I)) == 1
end
inradical(f::MPolyRingElem, I::MPolyIdeal) = radical_membership(f,I)
################################################################################
@doc raw"""
    is_prime(I::MPolyIdeal)

Return `true` if `I` is prime, `false` otherwise.

!!! warning
    The function computes the minimal associated primes of `I`. This may take some time.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia> is_prime(I)
false
```
"""
@attr Bool function is_prime(I::MPolyIdeal)
  is_known(primary_decomposition, I) && is_one(length(primary_decomposition(I))) && return is_subset(first(primary_decomposition(I))[2], I)
  D = minimal_primes(I)
  return length(D) == 1 && issubset(D[1], I)
end

function is_known(::typeof(is_prime), I::MPolyIdeal)
  has_attribute(I, :is_prime) && return true
  is_known(primary_decomposition, I) && return true
  is_known(minimal_primes, I) && return true
  if is_domain_type(base_ring_type(I))
    is_known(is_zero, I) && is_zero(I) && return true
    is_known(is_one, I) && is_one(I) && return true
  end
  return false
end


################################################################################
@doc raw"""
    is_primary(I::MPolyIdeal)

Return `true` if `I` is primary, `false` otherwise.

!!! warning
    The function computes a primary decomposition of `I`. This may take some time.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia> is_primary(I)
true
```
"""
@attr Bool function is_primary(I::MPolyIdeal)
  is_known(is_prime, I) && is_prime(I) && return true
  D = primary_decomposition(I)
  return length(D) == 1
end

#######################################################
@doc raw"""
    base_ring(I::MPolyIdeal)

Return the ambient ring of `I`.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia> base_ring(I)
Multivariate polynomial ring in 2 variables x, y
  over rational field
```
"""
function base_ring(I::MPolyIdeal{S}) where {S}
  return I.gens.Ox::parent_type(S)
end

base_ring_type(::Type{MPolyIdeal{S}}) where {S} = parent_type(S)

#######################################################
@doc raw"""
    coefficient_ring(I::MPolyIdeal)

Return the coefficient ring of `I`, which is the coefficient ring of the
polynomial ring containing the ideal.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia> coefficient_ring(I)
Rational field
```
"""
coefficient_ring(I::MPolyIdeal) = coefficient_ring(base_ring(I))


#######################################################
@doc raw"""
    number_of_generators(I::MPolyIdeal)

Return the number of generators of `I`.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia> number_of_generators(I)
3
```
"""
function number_of_generators(I::MPolyIdeal)
  return length(I.gens)
end

#######################################################
@doc raw"""
    gens(I::MPolyIdeal)

Return the generators of `I`.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia> gens(I)
3-element Vector{QQMPolyRingElem}:
 x^2
 x*y
 y^2
```
"""
function gens(I::MPolyIdeal)
  return [I.gens[Val(:O), i] for i=1:ngens(I)]
end

gen(I::MPolyIdeal, i::Int) = I.gens[Val(:O), i]

#######################################################
@doc raw"""
    dim(I::MPolyIdeal)

Return the Krull dimension of `I`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [y-x^2, x-z^3])
Ideal generated by
  -x^2 + y
  x - z^3

julia> dim(I)
1
```
"""
function dim(I::MPolyIdeal)
  if I.dim === nothing
    if is_zero(ngens(base_ring(I))) # Catch a boundary case
      I.dim = dim(coefficient_ring(base_ring(I)))
    else
      I.dim = Singular.dimension(singular_groebner_generators(I, false, true))
    end
    I.dim == -1 && (I.dim = -inf)
  end
  return I.dim::Union{Int, NegInf}
end

function is_known(::typeof(dim), I::MPolyIdeal)
  return I.dim !== nothing
end

#######################################################
#######################################################
@doc raw"""
    codim(I::MPolyIdeal)

Return the codimension of `I`.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [y-x^2, x-z^3])
Ideal generated by
  -x^2 + y
  x - z^3

julia> codim(I)
2
```
"""
codim(I::MPolyIdeal) = dim(base_ring(I)) - dim(I)
codim(I::MPolyIdeal{T}) where {T<:MPolyRingElem{<:FieldElem}}= nvars(base_ring(I)) - dim(I)

is_known(::typeof(codim), I::MPolyIdeal) = is_known(dim, I)


# Some fixes which were necessary for the above
dim(R::MPolyRing{<:FieldElem}) = nvars(R) # Needed, because `dim` for number fields implements something different from Krull dimension!
dim(R::MPolyRing) = dim(base_ring(R)) + nvars(R)
dim(R::ZZRing) = 1


################################################################################
#
#  iszero and isone functions
#
################################################################################

@doc raw"""
    is_zero(I::MPolyIdeal)

Return `true` if `I` is the zero ideal, `false` otherwise.
# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, y-x^2)
Ideal generated by
  -x^2 + y

julia> is_zero(I)
false
```
"""
@attr Bool function is_zero(I::MPolyIdeal)
  lg = gens(I)
  return all(iszero, lg)
end

# In general this depends on the ring, ...
is_known(::typeof(is_zero), I::MPolyIdeal) = true
# but for specific rings we can do more.
is_known(::typeof(is_zero), I::MPolyIdeal{QQMPolyRingElem}) = true

@doc raw"""
    is_one(I::MPolyIdeal)

Return `true` if `I` is generated by `1`, `false` otherwise.
# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, x + y, y - 1])
Ideal generated by
  x
  x + y
  y - 1

julia> is_one(I)
true
```
"""
@attr Bool function is_one(I::MPolyIdeal)
  R = base_ring(I)
  if iszero(I)
      return false
  end
  if any(x -> (!is_zero(x) && is_constant(x) && is_unit(first(AbstractAlgebra.coefficients(x)))), gens(I))
    return true
  end
  gb = groebner_basis(I, complete_reduction = true)
  return is_constant(gb[1]) && is_unit(first(AbstractAlgebra.coefficients(gb[1])))
end

function is_known(::typeof(is_one), I::MPolyIdeal)
  has_attribute(I, :is_one) && return true
  !is_empty(I.gb) && return true # a Groebner basis has already been computed
  if any(is_unit, gens(I))
    set_attribute!(I, :is_one=>true)
    return true
  end
  is_known(is_zero, I) && is_zero(I) && return true
  return false
end

################################################################################
#
#  is_monomial functions
#
################################################################################

@doc raw"""
    is_monomial(f::MPolyRingElem)

Return `true` if `f` is a monomial, `false` otherwise.

    is_monomial(I::MPolyIdeal)

Return `true` if `I` can be generated by monomials, `false` otherwise.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> f = 2*x+y
2*x + y

julia> g = y
y

julia> is_monomial(f)
false

julia> is_monomial(g)
true

julia> is_monomial(ideal(R, [f, g]))
true
```
"""
function is_monomial(f::MPolyRingElem)
   if (length(f) == 1 && coeff(f, 1) == 1)
      return true
   else
      return false
   end
end

function _ismonomial(V::Vector{<: MPolyRingElem})
  return all(is_monomial, V)
end

@attr Bool function is_monomial(I::MPolyIdeal)
  if _ismonomial(gens(I))
    return true
  end
  GB = gens(groebner_basis(I, complete_reduction = true))
  if _ismonomial(GB)
    return true
  end
  return false
end

################################################################################
#
# Small generating set
#
################################################################################

@doc raw"""
    small_generating_set(I::MPolyIdeal)

Given a ideal `I` in a multivariate polynomial ring over a field,
return an array containing a set of generators of `I`, which is usually
smaller than the original one.
If `I` is the zero ideal an empty list is returned.

!!! note
   Minimal generating sets exist only in the local and the homogeneous case. Beyond these cases, the best one can hope for is some small set of generators.

# Examples
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> V = [x, z^2, x^3+y^3, y^4, y*z^5];

julia> I = ideal(R, V)
Ideal generated by
  x
  z^2
  x^3 + y^3
  y^4
  y*z^5

julia> small_generating_set(I)
3-element Vector{QQMPolyRingElem}:
 x
 z^2
 y^3

julia> WW = [x-y^3,z-y^5,x^2-z^3, y^6-y^15]  # certainly not homogeneous
4-element Vector{QQMPolyRingElem}:
 x - y^3
 -y^5 + z
 x^2 - z^3
 -y^15 + y^6

julia> J = ideal(R,WW)
Ideal generated by
  x - y^3
  -y^5 + z
  x^2 - z^3
  -y^15 + y^6

julia> small_generating_set(J)
3-element Vector{QQMPolyRingElem}:
 -x^2 + z^3
 -x + y^3
 x*y^2 - z
```
"""
function small_generating_set(
    I::MPolyIdeal{T};
    algorithm::Symbol=:simple
  ) where {T<:MPolyRingElem{<:FieldElem}}
  return get_attribute!(I, :small_generating_set) do
    # For non-homogeneous ideals, we do not have a notion of minimal generating
    # set, but Singular.mstd still provides a good heuristic to find a small
    # generating set.

    R = base_ring(I)

    # in the ungraded case, mstd's heuristic returns smaller gens when recomputing gb
    sing_gb, sing_min = Singular.mstd(singular_generators(I))
    ring = I.gens.Ox
    computed_gb = IdealGens(ring, sing_gb, true)
    if !haskey(I.gb,computed_gb.ord)
      # if not yet present, store gb for later use
      I.gb[computed_gb.ord]      = computed_gb
      I.gb[computed_gb.ord].isGB = true
    end

    # we do not have a notion of minimal generating set in this context!
    # If we are unlucky, mstd can even produce a larger generating set
    # than the original one!!!
    return_value = filter(!iszero, (R).(gens(sing_min)))

    # The following is a common phenomenon which we can not fully explain yet. So far nothing but a
    # restart really seems to help, unfortunately.
    if is_zero(length(return_value))
      !is_zero(I) && error("singular crashed in the background; please restart your session!")
    end
    if length(return_value) <= ngens(I)
      return return_value
    else
      return gens(I)
    end
  end::Vector{T}
end

function is_known(::typeof(small_generating_set), I::MPolyIdeal)
  has_attribute(I, :small_generating_set) && return true
  is_known(is_one, I) && is_one(I) && return true
  is_known(is_zero, I) && is_zero(I) && return true
  return false
end

# in graded rings, reusing a cached gb makes sense, so use minimal_generating_set there
small_generating_set(I::MPolyIdeal{<:MPolyDecRingElem}; algorithm::Symbol=:simple) = minimal_generating_set(I)

################################################################################
#
# Grassmann Pluecker Ideal
#
################################################################################
#returns Pluecker ideal in ring with standard grading
function grassmann_pluecker_ideal(subspace_dimension::Int, ambient_dimension::Int)
  I = convert(MPolyIdeal{QQMPolyRingElem},
	      Polymake.ideal.pluecker_ideal(subspace_dimension, ambient_dimension))
  base = base_ring(I)
  base2, x = graded_polynomial_ring(coefficient_ring(base), :x=> sort(subsets(ambient_dimension, subspace_dimension)))
  h = hom(base, base2, x)
  o = degrevlex(base2)
  return ideal(IdealGens(base2, h.(gens(I)), o;
                keep_ordering=true,
                isReduced=true,
                isGB=true))
end

@doc raw"""
    grassmann_pluecker_ideal([ring::MPolyRing,] subspace_dimension::Int, ambient_dimension::Int)

Given a (possibly graded) ring, an ambient dimension $n$ and a subspace dimension $d$, return the ideal in the ring
generated by the PlÃ¼cker relations. If the input ring is not graded, return the ideal in the ring with the standard grading.
If the ring is not specified return the ideal in a multivariate polynomial ring over the rationals with variables indexed by
elements of ${[n]\choose d}$ with the standard grading.

The Grassmann-PlÃ¼cker ideal is the homogeneous ideal generated by the relations defined by
the PlÃ¼cker embedding of the Grassmannian. That is given Gr$(k, n)$ the moduli
space of all $k$-dimensional subspaces of an $n$-dimensional vector space, the relations
are given by all $d \times d$ minors of a $d \times n$ matrix. For the algorithm see
[Stu93](@cite).

# Examples
```jldoctest
julia> grassmann_pluecker_ideal(2, 4)
Ideal generated by
  x[[1, 2]]*x[[3, 4]] - x[[1, 3]]*x[[2, 4]] + x[[1, 4]]*x[[2, 3]]

julia> R, x = polynomial_ring(residue_ring(ZZ, 7)[1], :x => (1:2, 1:3))
(Multivariate polynomial ring in 6 variables over ZZ/(7), zzModMPolyRingElem[x[1, 1] x[1, 2] x[1, 3]; x[2, 1] x[2, 2] x[2, 3]])

julia> grassmann_pluecker_ideal(R, 2, 4)
Ideal generated by
  x[1, 1]*x[2, 3] + 6*x[2, 1]*x[1, 3] + x[1, 2]*x[2, 2]
```
"""
function grassmann_pluecker_ideal(ring::MPolyRing,
                                 subspace_dimension::Int,
                                 ambient_dimension::Int)
  I = grassmann_pluecker_ideal(subspace_dimension, ambient_dimension)
  coeff_ring = base_ring(ring)
  o = degrevlex(ring)
  coeffmap = c -> begin
    @assert is_integral(c)
    return coeff_ring(numerator(c))
  end
  if !is_graded(ring)
    ring, _ = grade(ring)
  end
  h = hom(base_ring(I), ring, coeffmap, gens(ring))
  converted_generators = elem_type(ring)[h(g) for g in groebner_basis(I; ordering = degrevlex(base_ring(I)))]
  ideal(IdealGens(ring, converted_generators, o;
                   keep_ordering=true,
                   isReduced=true,
                   isGB=true))
end

################################################################################
#
#  Printing
#
################################################################################

function AbstractAlgebra.expressify(a::MPolyIdeal; context = nothing)
  return Expr(:call, :ideal, [expressify(g, context = context) for g in a.gens]...)
end

# See Rings/mpolyquo-localizations.jl for show functions

################################################################################
#
#  Pluecker ideal
#
################################################################################

_pluecker_sgn(a::Vector{Int}, b::Vector{Int}, t::Int)::Int =
 iseven(count(>(t), a) + count(<(t), b)) ? 1 : -1
@doc raw"""
    flag_pluecker_ideal(F::Union{Field, MPolyRing}, dimensions::Vector{Int}, n::Int; minimal::Bool=true)

Return the generators of the defining ideal for the complete flag variety
$\text{Fl}(\mathbb{F}, (d_1,\dots,d_k), n)$, where $(d_1,\dots,d_k)
=$`dimensions`, with $d_j\leq n-1$,  denotes the rank.  That is, the vanishing
set of this ideal corresponds to the space of $k$-step flags of linear
subspaces $V_1\subset\dots\subset V_k$ in $\mathbb{F}^n$, where
$\text{dim}(V_j) = d_{j}$.  You can obtain the generators for the
*complete flag variety* of $\mathbb{F}^{n}$ by taking `dimensions`
$=(1,\dots,n-1)$ and `n`$=n$.  We remark that evaluating for `F = QQ` yields
the same set of generators as any field of characteristic $0$.

The first parameter can either be $\mathbb{F}$, or a polynomial ring over $\mathbb{F}$,
with $\sum^{k}_{j=1}{n\choose d_j}$ variables.
The parameter `dimensions` needs to be a vector of distinct increasing entries.
Evaluating this function with the parameter `minimal = true` returns the reduced GrÃ¶bner basis for
the flag PlÃ¼cker ideal with respect to the degree reverse lexicographical order. For more details, see Theorem 14.6 [MS05](@cite)
# Examples

Complete flag variety $\text{Fl}(\mathbb{Q}, (1,2,3), 4)$.
```jldoctest
julia> flag_pluecker_ideal(QQ,[1,2,3],4)
Ideal generated by
  x[[2, 4]]*x[[1, 2, 3]] - x[[2, 3]]*x[[1, 2, 4]] + x[[1, 2]]*x[[2, 3, 4]]
  x[[1, 4]]*x[[1, 2, 3]] - x[[1, 3]]*x[[1, 2, 4]] + x[[1, 2]]*x[[1, 3, 4]]
  -x[[3, 4]]*x[[1, 2, 3]] - x[[1, 3]]*x[[2, 3, 4]] + x[[2, 3]]*x[[1, 3, 4]]
  -x[[1, 4]]*x[[2, 3, 4]] + x[[2, 4]]*x[[1, 3, 4]] - x[[3, 4]]*x[[1, 2, 4]]
  -x[[1]]*x[[2, 3, 4]] + x[[2]]*x[[1, 3, 4]] - x[[3]]*x[[1, 2, 4]] + x[[4]]*x[[1, 2, 3]]
  -x[[1, 4]]*x[[2, 3]] + x[[2, 4]]*x[[1, 3]] - x[[3, 4]]*x[[1, 2]]
  -x[[1]]*x[[2, 3]] + x[[2]]*x[[1, 3]] - x[[3]]*x[[1, 2]]
  -x[[2]]*x[[3, 4]] + x[[3]]*x[[2, 4]] - x[[4]]*x[[2, 3]]
  -x[[1]]*x[[3, 4]] + x[[3]]*x[[1, 4]] - x[[4]]*x[[1, 3]]
  -x[[1]]*x[[2, 4]] + x[[2]]*x[[1, 4]] - x[[4]]*x[[1, 2]]

```
Flag variety $\text{Fl}(\mathbb{Q},(1,3),4)$.
```jldoctest
julia> flag_pluecker_ideal(QQ,[1,3],4)
Ideal generated by
  -x[[1]]*x[[2, 3, 4]] + x[[2]]*x[[1, 3, 4]] - x[[3]]*x[[1, 2, 4]] + x[[4]]*x[[1, 2, 3]]
```
An example with a custom ring as input.
```jldoctest
julia> R, _ = polynomial_ring(QQ, 8)
(Multivariate polynomial ring in 8 variables over QQ, QQMPolyRingElem[x1, x2, x3, x4, x5, x6, x7, x8])

julia> flag_pluecker_ideal(R, [1,3], 4; minimal=false)
Ideal generated by
  x1*x6 - x2*x5 + x3*x7 - x4*x8
```
"""
function flag_pluecker_ideal(F::Field, dimensions::Vector{Int}, n::Int; minimal::Bool=true)
  L = reduce(vcat, [subsets(n, d) for d in dimensions])
  ring, _ = polynomial_ring(F, :x => L; cached=false)

  return flag_pluecker_ideal(ring, dimensions, n; minimal=minimal)

end

flag_pluecker_ideal(dimensions::Vector{Int}, n::Int; minimal::Bool=true) = flag_pluecker_ideal(QQ,dimensions,n, minimal=minimal)

function flag_pluecker_ideal(ring::MPolyRing{<: FieldElem}, dimensions::Vector{Int}, n::Int; minimal::Bool=true)
  dimensions = unique(dimensions)

  @req maximum(dimensions) <= n-1 "The dimensions must be at most n-1"
  @req sum(binomial(n, d) for d in dimensions) == ngens(ring) "The ring doesn't have the right number of variables"
  @req issorted(dimensions) "The dimensions must be increasing"

  x = gens(ring)
  L = reduce(vcat, [subsets(n, d) for d in dimensions])

  xdict = Dict{Vector{Int},MPolyRingElem}([L[i] => x[i] for i in 1:length(L)])

  L1 = reduce(vcat, [subsets(n, d - 1) for d in dimensions])
  L2 = reduce(vcat, [subsets(n, d + 1) for d in dimensions])

  X = [(a, b) for a in L1, b in L2 if length(b) - length(a) >= 2]

  T = [
    [
      (_pluecker_sgn(a, b, t)) * xdict[sort(union(a, t))] * xdict[setdiff(b, t)] for
      t in setdiff(b, a)
    ] for (a, b) in X
  ]

  genz = [sum(t) for t in T]
  filter!(!iszero, genz)
  gg = unique(x ->  divexact(x, canonical_unit(x)), genz)
  I  = ideal(gg)

  !minimal && return I

  o = degrevlex(ring)
  converted_generators = collect(groebner_basis(I; ordering = o))
  return ideal(IdealGens(ring, converted_generators, o;
                   keep_ordering=true,
                   isReduced=true,
                   isGB=true))
end

# Since most ideals implement `==`, they have to implement the hash function.
# See issue #4143 for problems entailed. Interestingly, this does not yet fix
# the failure of unique! on lists of ideals.
function hash(I::Ideal, c::UInt)
  return hash(base_ring(I), c)
end

# Recognition of principal ideals
function is_known(::typeof(is_principal), I::MPolyIdeal)
  is_one(length(gens(I))) && return true
  has_attribute(I, :is_principal) && return true
  return false
end

@attr Bool function is_principal(I::MPolyIdeal)
  is_one(ngens(I)) && return true
  g = small_generating_set(I)
  !is_one(length(g)) && return false
  set_attribute!(I, :principal_generator=>only(g))
  return true
end

function principal_generator(I::MPolyIdeal{T}) where {T}
  is_one(length(gens(I))) && return only(gens(I))
  @req is_principal(I) "ideal is not principal" # sets the attribute in particular
  return get_attribute(I, :principal_generator)::T
end
 
 # This is a catchall method which should probably be moved elsewher
 function is_gen(a::MPolyRingElem)
   is_zero(a) && return false
   !is_one(length(a)) && return false
   e = only(AbstractAlgebra.exponent_vectors(a))
   i = findfirst(is_one, e)
   isnothing(i) && return false
   return all(k == i || is_zero(n) for (k, n) in enumerate(e))
 end
