###############################################################################
#
#  Ideals of a free associative algebra
#
###############################################################################

# Currently ideal membership relies entirely on Singular, where a degree bound
# is imposed and a inconclusive answer may be returned. We can later add the
# Groebner machinery operating purely on the Oscar types, and hence not
# necessarily be confined to a degree bound.

@doc raw"""
    mutable struct FreeAssociativeAlgebraIdeal{T}

Two-sided ideal of a free associative algebra with elements of type `T`.
"""
mutable struct FreeAssociativeAlgebraIdeal{T} <: Ideal{T}
  gens::IdealGens{T}
  gb::IdealGens{T}
  deg_bound::Int
  function FreeAssociativeAlgebraIdeal(g::IdealGens{T}) where T <: FreeAssociativeAlgebraElem
    r = new{T}()
    r.gens = g
    return r
  end
end

Base.show(io::IO, a::FreeAssociativeAlgebraIdeal) = print(io, "Ideal of ", base_ring(a), " with ", number_of_generators(a), " generators")

function Base.:(==)(I2::FreeAssociativeAlgebraIdeal, I1::FreeAssociativeAlgebraIdeal)
  return is_subset(I1,I2) && is_subset(I2,I1)
end

function Base.hash(a::FreeAssociativeAlgebraIdeal, h::UInt)
  return hash(base_ring(a), h)
end

@doc raw"""
    ideal(R::FreeAssociativeAlgebra, g::Vector{<:FreeAssociativeAlgebraElem})

Return the two-sided ideal of $R$ generated by $g$.
"""
function ideal(R::FreeAssociativeAlgebra, g::Vector{<:FreeAssociativeAlgebraElem})
  @req all(x -> parent(x) == R, g) "parent mismatch"
  return FreeAssociativeAlgebraIdeal(IdealGens(R, g))
end

function ideal(g::Vector{<:FreeAssociativeAlgebraElem})
  @req length(g) > 0 "cannot infer base ring"
  algebra = parent(g[1]) 
  return ideal(algebra, g)
end

function ideal(g::IdealGens{T}) where T <: FreeAssociativeAlgebraElem
  return FreeAssociativeAlgebraIdeal(g)
end


function base_ring(I::FreeAssociativeAlgebraIdeal{T}) where T
  return I.gens.Ox::parent_type(T)
end

function base_ring_type(::Type{<:FreeAssociativeAlgebraIdeal{T}}) where T
  return parent_type(T)
end

function number_of_generators(a::FreeAssociativeAlgebraIdeal)
  return length(a.gens)
end

function gen(a::FreeAssociativeAlgebraIdeal{T}, i::Int) where T
  return a.gens[Val(:O), i]
end

function gens(a::FreeAssociativeAlgebraIdeal{T}) where T
  return T[gen(a,i) for i in 1:ngens(a)]
end

function Base.:+(a::FreeAssociativeAlgebraIdeal{T}, b::FreeAssociativeAlgebraIdeal{T}) where T
  R = base_ring(a)
  @req R == base_ring(b) "parent mismatch"
  return ideal(R, vcat(gens(a), gens(b)))
end

function Base.:*(a::FreeAssociativeAlgebraIdeal{T}, b::FreeAssociativeAlgebraIdeal{T}) where T
  R = base_ring(a)
  @req R == base_ring(b) "parent mismatch"
  return ideal(R, [i*j for i in gens(a) for j in gens(b)])
end

AbstractAlgebra.normal_form(f::FreeAssociativeAlgebraElem, I::FreeAssociativeAlgebraIdeal) = normal_form(f, gens(I))
AbstractAlgebra.normal_form(f::FreeAssociativeAlgebraElem, I::IdealGens{<:FreeAssociativeAlgebraElem}) = normal_form(f, collect(I))

@doc raw"""
    ideal_membership(a::FreeAssociativeAlgebraElem, I::FreeAssociativeAlgebraIdeal, deg_bound::Int)

Returns `true` if intermediate degree calculations bounded by `deg_bound` prove that $a$ is in $I$.
Otherwise, returning `false` indicates an inconclusive answer, but larger `deg_bound`s give more confidence in a negative answer. 
If `deg_bound` is not specified, the default value is `-1`, which means that no degree bound is imposed,
resulting in a calculation using a much slower algorithm that may not terminate, but will return a full Groebner basis if it does.
```jldoctest
julia> free, (x,y,z) = free_associative_algebra(QQ, [:x, :y, :z]);

julia> f1 = x*y + y*z;

julia> I = ideal([f1]);

julia> ideal_membership(f1, I, 4)
true
```
"""
function ideal_membership(a::FreeAssociativeAlgebraElem, I::FreeAssociativeAlgebraIdeal, deg_bound::Int=-1)
  isdefined(I, :gb) && (I.deg_bound == -1 || I.deg_bound >= deg_bound) && return iszero(normal_form(a, I.gb))
  groebner_basis(I, deg_bound)
  return ideal_membership(a, I, deg_bound)
end
function ideal_membership(a::FreeAssociativeAlgebraElem, I::IdealGens{<:FreeAssociativeAlgebraElem}, deg_bound::Int=-1)
  return ideal_membership(a, collect(I), deg_bound)
end
function ideal_membership(a::FreeAssociativeAlgebraElem, I::Vector{<:FreeAssociativeAlgebraElem}, deg_bound::Int=-1)
  R = parent(a)
  @req all(x -> parent(x) == R, I) "parent mismatch"
  gb = groebner_basis(I, deg_bound)
  return iszero(normal_form(a, gb))
end

function Base.in(a::FreeAssociativeAlgebraElem, I::FreeAssociativeAlgebraIdeal)
  return ideal_membership(a, I)
end

function is_subset(I1::FreeAssociativeAlgebraIdeal, I2::FreeAssociativeAlgebraIdeal)
  @req base_ring(I1) === base_ring(I2) "parent mismatch"
  I1 === I2 && return true
  gens(I1) == gens(I2) && return true
  isdefined(I1, :gb) && isdefined(I2, :gb) && I1.gb == I2.gb && return true
  return all(in(I2), gens(I1))
end

function (R::Singular.LPRing)(a::FreeAssociativeAlgebraElem)
  B = MPolyBuildCtx(R)
  for (c, e) in zip(coefficients(a), exponent_words(a))
    push_term!(B, base_ring(R)(c), e)
  end
  return finish(B)
end

function (A::FreeAssociativeAlgebra)(a::Singular.slpalg)
  B = MPolyBuildCtx(A)
  for (c,e) in zip(Oscar.coefficients(a), Singular.exponent_words(a))
    push_term!(B, base_ring(A)(c), e)
  end 
  return finish(B)
end

_to_lpring(a::FreeAssociativeAlgebra, deg_bound::Int; ordering::Symbol=:deglex) = Singular.FreeAlgebra(base_ring(a), String.(symbols(a)), deg_bound; ordering=ordering)

@doc raw"""
    groebner_basis(I::FreeAssociativeAlgebraIdeal, deg_bound::Int=-1; protocol::Bool=false)

Return the Groebner basis of `I` with respect to the degree bound `deg_bound`.
If `protocol` is `true`, the protocol of the computation is also returned.
The default value of `deg_bound` is `-1`, which means that no degree bound is
imposed, resulting in a computation that is usually slower, but will return a
full Groebner basis if there exists a finite one.
```jldoctest
julia> free, (x,y,z) = free_associative_algebra(QQ, [:x, :y, :z]);

julia> f1 = x*y + y*z;

julia> f2 = x^2 + y^2;

julia> I = ideal([f1, f2]);

julia> gb = groebner_basis(I, 3; protocol=false)
Ideal generating system with elements
  1 -> x*y + y*z
  2 -> x^2 + y^2
  3 -> y^3 + y*z^2
  4 -> y^2*x + y*z*y
```
"""
function groebner_basis(I::FreeAssociativeAlgebraIdeal,
  deg_bound::Int=-1;
  protocol::Bool=false,
  interreduce::Bool=false)
  isdefined(I, :gb) && (I.deg_bound == -1 || I.deg_bound >= deg_bound) && return I.gb
  I.gb = groebner_basis(IdealGens(gens(I)), deg_bound; ordering=:deglex, protocol=protocol, interreduce=interreduce)
  I.deg_bound = deg_bound
  return I.gb
end
function groebner_basis(g::IdealGens{<:FreeAssociativeAlgebraElem},
  deg_bound::Int=-1;
  ordering::Symbol=:deglex,
  protocol::Bool=false,
  interreduce::Bool=false)
  gb = groebner_basis(collect(g), deg_bound; ordering=ordering, protocol=protocol, interreduce=interreduce)
  return IdealGens(gb)
end
function groebner_basis(g::Vector{<:FreeAssociativeAlgebraElem},
  deg_bound::Int=-1;
  ordering::Symbol=:deglex,
  protocol::Bool=false,
  interreduce::Bool=false)

  R = parent(g[1])
  @req all(x -> parent(x) == R, g) "parent mismatch"
  @req deg_bound >= 0 || !protocol "computing with a protocol requires a degree bound"
  @req ordering == :deglex || deg_bound > 0 "only :deglex ordering is supported for no degree bound"

  if deg_bound == -1
      gb = AbstractAlgebra.groebner_basis(g)
      interreduce && return interreduce!(gb)
      return gb
  end
    
  lpring, _ = _to_lpring(R, deg_bound; ordering=ordering)
  lp_I_gens = lpring.(g)

  I = Singular.Ideal(lpring, lp_I_gens)
  gb = nothing 

  Singular.with_prot(protocol) do; 
    gb = gens(Singular.std(I))
  end
  gb = R.(gb)
  interreduce && return interreduce!(gb)
  return gb
end

is_groebner_basis(g::IdealGens{<:FreeAssociativeAlgebraElem}) = is_groebner_basis(collect(g))

function is_groebner_basis(gb::Vector{<:FreeAssociativeAlgebraElem})
  obsructions =  AbstractAlgebra.Generic.get_obstructions(gb)
  while !isempty(obsructions)
    f = AbstractAlgebra.Generic.s_polynomial(popfirst!(obsructions)[1])
    iszero(normal_form(f, gb)) || return false  
  end
  return true
end


function interreduce!(I::FreeAssociativeAlgebraIdeal)
  I.gb = interreduce!(I.gb)
  return I
end
function interreduce!(gb::IdealGens{<:FreeAssociativeAlgebraElem})
  return IdealGens(interreduce!(collect(gb)))
end
