###############################################################################
#
#  Ideals of a free associative algebra
#
###############################################################################

# Currently ideal membership relies entirely on Singular, where a degree bound
# is imposed and a inconclusive answer may be returned. We can later add the
# Groebner machinery operating purely on the Oscar types, and hence not
# necessarily be confined to a degree bound.

@doc raw"""
    mutable struct FreeAssociativeAlgebraIdeal{T}

Two-sided ideal of a free associative algebra with elements of type `T`.
"""
mutable struct FreeAssociativeAlgebraIdeal{T} <: Ideal{T}
  gens::IdealGens{T}
  gb::IdealGens{T}
  deg_bound::Int
  function FreeAssociativeAlgebraIdeal(g::IdealGens{T}) where T <: FreeAssociativeAlgebraElem
    r = new{T}()
    r.gens = g
    return r
  end
end

function Base.show(io::IO, a::FreeAssociativeAlgebraIdeal)
  print(io, "Ideal of ", base_ring(a), " with ", ItemQuantity(ngens(a), "generator"))
end

function Base.:(==)(I2::FreeAssociativeAlgebraIdeal, I1::FreeAssociativeAlgebraIdeal)
  return is_subset(I1,I2) && is_subset(I2,I1)
end

function Base.hash(a::FreeAssociativeAlgebraIdeal, h::UInt)
  return hash(base_ring(a), h)
end

@doc raw"""
    ideal(R::FreeAssociativeAlgebra, g::Vector{<:FreeAssociativeAlgebraElem})

Return the two-sided ideal of $R$ generated by $g$.
"""
function ideal(R::FreeAssociativeAlgebra, g::Vector{<:FreeAssociativeAlgebraElem})
  @req all(x -> parent(x) == R, g) "parent mismatch"
  return FreeAssociativeAlgebraIdeal(IdealGens(R, g))
end

function ideal(g::Vector{<:FreeAssociativeAlgebraElem})
  @req length(g) > 0 "cannot infer base ring"
  algebra = parent(g[1]) 
  return ideal(algebra, g)
end

function ideal(g::IdealGens{T}) where T <: FreeAssociativeAlgebraElem
  return FreeAssociativeAlgebraIdeal(g)
end


function base_ring(I::FreeAssociativeAlgebraIdeal{T}) where T
  return base_ring(I.gens)::parent_type(T)
end

function base_ring_type(::Type{<:FreeAssociativeAlgebraIdeal{T}}) where T
  return parent_type(T)
end

function number_of_generators(a::FreeAssociativeAlgebraIdeal)
  return length(a.gens)
end

function gen(a::FreeAssociativeAlgebraIdeal{T}, i::Int) where T
  return oscar_generators(a.gens)[i]
end

function gens(a::FreeAssociativeAlgebraIdeal{T}) where T
  return T[gen(a,i) for i in 1:ngens(a)]
end

function Base.:+(a::FreeAssociativeAlgebraIdeal{T}, b::FreeAssociativeAlgebraIdeal{T}) where T
  R = base_ring(a)
  @req R == base_ring(b) "parent mismatch"
  return ideal(R, vcat(gens(a), gens(b)))
end

function Base.:*(a::FreeAssociativeAlgebraIdeal{T}, b::FreeAssociativeAlgebraIdeal{T}) where T
  R = base_ring(a)
  @req R == base_ring(b) "parent mismatch"
  return ideal(R, [i*j for i in gens(a) for j in gens(b)])
end

AbstractAlgebra.normal_form(f::FreeAssociativeAlgebraElem, I::FreeAssociativeAlgebraIdeal) = normal_form(f, gens(I))
AbstractAlgebra.normal_form(f::FreeAssociativeAlgebraElem, I::IdealGens{<:FreeAssociativeAlgebraElem}) = normal_form(f, collect(I))

@doc raw"""
    ideal_membership(a::FreeAssociativeAlgebraElem, I::FreeAssociativeAlgebraIdeal, deg_bound::Int)

Return `true` if intermediate degree calculations bounded by `deg_bound` prove that $a$ is in $I$.
Otherwise, returning `false` indicates an inconclusive answer, but larger `deg_bound`s give more confidence in a negative answer. 
If `deg_bound` is not specified, the default value is `-1`, which means that no degree bound is imposed,
resulting in a calculation using a much slower algorithm that may not terminate, but will return a full Groebner basis if it does.
```jldoctest
julia> free, (x,y,z) = free_associative_algebra(QQ, [:x, :y, :z]);

julia> f1 = x*y + y*z;

julia> I = ideal([f1]);

julia> ideal_membership(f1, I, 4)
true
```
"""
function ideal_membership(a::FreeAssociativeAlgebraElem, I::FreeAssociativeAlgebraIdeal, deg_bound::Int=-1)
  isdefined(I, :gb) && (I.deg_bound == -1 || I.deg_bound >= deg_bound) && return iszero(normal_form(a, I.gb))
  groebner_basis(I, deg_bound)
  return ideal_membership(a, I, deg_bound)
end
function ideal_membership(a::FreeAssociativeAlgebraElem, I::IdealGens{<:FreeAssociativeAlgebraElem}, deg_bound::Int=-1)
  return ideal_membership(a, collect(I), deg_bound)
end
function ideal_membership(a::FreeAssociativeAlgebraElem, I::Vector{<:FreeAssociativeAlgebraElem}, deg_bound::Int=-1)
  R = parent(a)
  @req all(x -> parent(x) == R, I) "parent mismatch"
  gb = groebner_basis(I, deg_bound)
  return iszero(normal_form(a, gb))
end

function Base.in(a::FreeAssociativeAlgebraElem, I::FreeAssociativeAlgebraIdeal)
  return ideal_membership(a, I)
end

function is_subset(I1::FreeAssociativeAlgebraIdeal, I2::FreeAssociativeAlgebraIdeal)
  @req base_ring(I1) === base_ring(I2) "parent mismatch"
  I1 === I2 && return true
  gens(I1) == gens(I2) && return true
  isdefined(I1, :gb) && isdefined(I2, :gb) && I1.gb == I2.gb && return true
  return all(in(I2), gens(I1))
end

function (R::Singular.LPRing)(a::FreeAssociativeAlgebraElem)
  B = MPolyBuildCtx(R)
  for (c, e) in zip(coefficients(a), exponent_words(a))
    push_term!(B, base_ring(R)(c), e)
  end
  return finish(B)
end

function (A::FreeAssociativeAlgebra)(a::Singular.slpalg)
  B = MPolyBuildCtx(A)
  for (c,e) in zip(Oscar.coefficients(a), Singular.exponent_words(a))
    push_term!(B, base_ring(A)(c), e)
  end 
  return finish(B)
end

_to_lpring(a::FreeAssociativeAlgebra, deg_bound::Int; ordering::Symbol=:deglex) = Singular.FreeAlgebra(base_ring(a), String.(symbols(a)), deg_bound; ordering=ordering)

@doc raw"""
    groebner_basis(I::FreeAssociativeAlgebraIdeal, deg_bound::Int=-1; ordering::Symbol=:deglex, protocol::Bool=false, interreduce::Bool=false, algorithm::Symbol=:f4, probabilistic::Bool=false)
    groebner_basis(g::Vector{<:FreeAssociativeAlgebraElem}, deg_bound::Int=-1; ordering::Symbol=:deglex, protocol::Bool=false, interreduce::Bool=false, algorithm::Symbol=:f4, probabilistic::Bool=false)

Compute the Groebner basis for a vector of generators `g` in a free associative algebra.
Supports several algorithms and options for degree bounds, ordering, protocol, and interreduction.

By default (`algorithm=:default`), the algorithm is chosen as follows:
- If `ordering == :deglex` and the base ring is `QQ`, use `:f4`.
- If `deg_bound == -1`, use `:buchberger`.
- Otherwise, use `:letterplace`.

# Arguments
- `g::Vector{<:FreeAssociativeAlgebraElem}`: Generators of the ideal.
- `deg_bound::Int`: Degree bound for the computation (default: -1).
- `ordering::Symbol`: Monomial ordering (default: :deglex).
- `protocol::Bool`: Whether to return the computation protocol (default: false).
- `interreduce::Bool`: Whether to interreduce the result (default: false).
- `algorithm::Symbol`: Algorithm to use (:f4, :buchberger, :letterplace, or :default). If set to `:default`, the algorithm is chosen automatically based on the input.
- `probabilistic::Bool`: Enable probabilistic behavior (default: false).

# Returns
- The Groebner basis as a vector of free associative algebra elements.

```jldoctest
julia> free, (x,y,z) = free_associative_algebra(QQ, [:x, :y, :z]);

julia> f1 = x*y + y*z;

julia> f2 = x^2 + y^2;

julia> I = ideal([f1, f2]);

julia> gb = groebner_basis(I, 3; protocol=false)
Ideal generating system with elements
  1: x*y + y*z
  2: x^2 + y^2
  3: y^3 + y*z^2
  4: y^2*x + y*z*y
```
"""
function groebner_basis(I::FreeAssociativeAlgebraIdeal,
  deg_bound::Int=-1;
  protocol::Bool=false,
  interreduce::Bool=false,
  algorithm::Symbol=:default,
  probabilistic::Bool = false
  )
  isdefined(I, :gb) && (I.deg_bound == -1 || I.deg_bound >= deg_bound) && return I.gb
  I.gb = groebner_basis(IdealGens(gens(I)), deg_bound; ordering=:deglex, protocol=protocol, interreduce=interreduce, algorithm=algorithm, probabilistic=probabilistic)
  I.deg_bound = deg_bound
  return I.gb
end
function groebner_basis(g::IdealGens{<:FreeAssociativeAlgebraElem},
  deg_bound::Int=-1;
  ordering::Symbol=:deglex,
  protocol::Bool=false,
  interreduce::Bool=false,
  algorithm::Symbol=:default,
  probabilistic::Bool = false
  )
  gb = groebner_basis(collect(g), deg_bound; ordering=ordering, protocol=protocol, interreduce=interreduce, algorithm=algorithm, probabilistic=probabilistic)
  gb = Generic.FreeAssociativeAlgebraElem{QQFieldElem}[x for x in gb]
  return IdealGens(gb)
end

function groebner_basis(g::Vector{<:FreeAssociativeAlgebraElem},
  deg_bound::Int=-1;
  ordering::Symbol=:deglex,
  protocol::Bool=false,
  interreduce::Bool=false,
  algorithm::Symbol=:default,
  probabilistic::Bool = false
  )

  @req length(g) > 0 "Vector must not be empty"
  R = parent(g[1])

  if algorithm == :default
    if (ordering == :deglex && base_ring(R) == QQ)
      algorithm = :f4
    elseif deg_bound == -1 
      algorithm = :buchberger
    else
      algorithm = :letterplace
    end
  end

  @req all(x -> parent(x) == R, g) "parent mismatch"
  @req ordering == :deglex || deg_bound > 0 "only :deglex ordering is supported for no degree bound"
  @req algorithm in (:f4, :buchberger, :letterplace) "Not a valid algorithm, use :f4, :buchberger or :letterplace"

  if algorithm == :f4
    @req ordering == :deglex "f4 only supports :deglex ordering"
    @req base_ring(R) == QQ "only rational coefficients are supported"
    f4ncgb_set_msg_printing(protocol)

    handle = f4ncgb_init()
    userdata = nothing
    try
      f4ncgb_set_nvars(handle, UInt32(ngens(R)))
      f4ncgb_set_blocks(handle, UInt32[ngens(R)])
      f4ncgb_set_threads(handle, UInt32(1))
      f4ncgb_set_tracer(handle, probabilistic)
      f4ncgb_set_maxiter(handle, UInt32(typemax(Int32)))

      deg_bound > 0 && f4ncgb_set_maxdeg(handle, UInt32(deg_bound))

      f4ncgb_add.(Ref(handle), g)
      userdata = f4ncgb_polys_helper(R)
      f4ncgb_solve(handle, userdata)
    finally
      f4ncgb_free(handle)
    end
    gb = userdata.gens
    interreduce && return interreduce!(gb)

    return userdata.gens

  end

  if algorithm == :buchberger
    @req deg_bound == -1 "The Buchberger algorithm cannot be used with a degree bound"
    gb = AbstractAlgebra.groebner_basis(g)
    interreduce && return interreduce!(gb)
    return gb
  end

  lpring, _ = _to_lpring(R, deg_bound; ordering=ordering)
  lp_I_gens = lpring.(g)

  I = Singular.Ideal(lpring, lp_I_gens)
  gb = nothing 

  Singular.with_prot(protocol) do; 
    gb = gens(Singular.std(I))
  end
  gb = R.(gb)
  interreduce && return interreduce!(gb)
  return gb
end

is_groebner_basis(g::IdealGens{<:FreeAssociativeAlgebraElem}) = is_groebner_basis(collect(g))

function is_groebner_basis(gb::Vector{<:FreeAssociativeAlgebraElem})
  obstructions = AbstractAlgebra.Generic.get_obstructions(gb)
  while !isempty(obstructions)
    g = popfirst!(obstructions)
    f = AbstractAlgebra.Generic.s_polynomial(g[1])
    iszero(normal_form(f, gb)) && continue
    return false
  end
  return true
end

function interreduce!(I::FreeAssociativeAlgebraIdeal)
  I.gb = interreduce!(I.gb)
  return I
end
function interreduce!(gb::IdealGens{<:FreeAssociativeAlgebraElem})
  return IdealGens(interreduce!(collect(gb)))
end
