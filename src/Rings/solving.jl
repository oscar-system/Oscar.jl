@doc raw"""
    real_solutions(I::MPolyIdeal, <keyword arguments>)

Given an ideal `I` with a finite solution set over the complex numbers, return a pair `r,p` where `p` is the rational parametrization of the solution set and `r` represents the real roots of `Ì`  with a given precision (default 32 bits).
See [BES21](@cite) for more information.

**Note**: At the moment only QQ is supported as ground field. If the dimension of `I`
is greater than zero an empty array is returned.

# Arguments
- `Ì::MPolyIdeal`: input ideal.
- `initial_hts::Int=17`: initial hash table size `log_2`.
- `nr_thrds::Int=1`: number of threads for parallel linear algebra.
- `max_nr_pairs::Int=0`: maximal number of pairs per matrix, only bounded by minimal degree if `0`.
- `la_option::Int=2`: linear algebra option: exact sparse-dense (`1`), exact sparse (`2`, default), probabilistic sparse-dense (`42`), probabilistic sparse(`44`).
- `info_level::Int=0`: info level printout: off (`0`, default), summary (`1`), detailed (`2`).
- `precision::Int=32`: bit precision for the computed solutions.

# Examples
```jldoctest
julia> R,(x,y) = polynomial_ring(QQ, [:x,:y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R,[x^2-y^2, x+1])
Ideal generated by
  x^2 - y^2
  x + 1

julia> real_solutions(I)
(Vector{QQFieldElem}[[-1, -1], [-1, 1]], AlgebraicSolving.RationalParametrization([:x, :y], ZZRingElem[], x^2 - 1, 2*x, QQPolyRingElem[-2*x]))
```
"""
function real_solutions(
        I::MPolyIdeal;                        # input generators
        initial_hts::Int=17,                  # hash table size, default 2^17
        nr_thrds::Int=1,                      # number of threads
        max_nr_pairs::Int=0,                  # number of pairs maximally chosen
                                              # in symbolic preprocessing
        la_option::Int=2,                     # linear algebra option
        info_level::Int=0,                    # info level for print outs
        precision::Int=32                     # precision of the solution set
        )
    AI = AlgebraicSolving.Ideal(oscar_generators(I))

    AlgebraicSolving.real_solutions(AI,
             initial_hts = initial_hts,
             nr_thrds = nr_thrds,
             max_nr_pairs = max_nr_pairs,
             la_option = la_option,
             info_level = info_level,
             precision = precision)

    return AI.real_sols, AI.rat_param
end

################################################################################
#
#  msolve interface for rational solutions
#
################################################################################

@doc raw"""
    _rational_solutions(I::Ideal{T} where T <: MPolyRingElem, <keyword arguments>)

Given an ideal `I` with a finite solution set over the complex numbers, return
the rational roots of the ideal.

**Note**: At the moment only QQ is supported as ground field. If the dimension of `I`
is greater than zero an empty array is returned.

# Arguments
- `Ì::MPolyIdeal`: input ideal.
- `initial_hts::Int=17`: initial hash table size `log_2`.
- `nr_thrds::Int=1`: number of threads for parallel linear algebra.
- `max_nr_pairs::Int=0`: maximal number of pairs per matrix, only bounded by minimal degree if `0`.
- `la_option::Int=2`: linear algebra option: exact sparse-dense (`1`), exact sparse (`2`, default), probabilistic sparse-dense (`42`), probabilistic sparse(`44`).
- `info_level::Int=0`: info level printout: off (`0`, default), summary (`1`), detailed (`2`).
- `precision::Int=32`: bit precision for the computed solutions.

# Examples
```jldoctest; filter = Main.Oscar.doctestfilter_hash_changes_in_1_13()
julia> R,(x1,x2,x3) = polynomial_ring(QQ, [:x1,:x2,:x3])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x1, x2, x3])

julia> I = ideal(R, [x1+2*x2+2*x3-1, x1^2+2*x2^2+2*x3^2-x1, 2*x1*x2+2*x2*x3-x2])
Ideal generated by
  x1 + 2*x2 + 2*x3 - 1
  x1^2 - x1 + 2*x2^2 + 2*x3^2
  2*x1*x2 + 2*x2*x3 - x2

julia> rat_sols = Oscar._rational_solutions(I)
2-element Vector{Vector{QQFieldElem}}:
 [1//3, 0, 1//3]
 [1, 0, 0]

julia> map(r->map(p->evaluate(p, r), I.gens), rat_sols)
2-element Vector{Vector{QQFieldElem}}:
 [0, 0, 0]
 [0, 0, 0]
```
"""
function _rational_solutions(
        I::MPolyIdeal;                        # input generators
        initial_hts::Int=17,                  # hash table size, default 2^17
        nr_thrds::Int=1,                      # number of threads
        max_nr_pairs::Int=0,                  # number of pairs maximally chosen
                                              # in symbolic preprocessing
        la_option::Int=2,                     # linear algebra option
        info_level::Int=0,                    # info level for print outs
        precision::Int=32                     # precision of the solution set
        )

    @assert coefficient_ring(I) == QQ
    AI = AlgebraicSolving.Ideal(gens(I))

    AlgebraicSolving.rational_solutions(AI,
             initial_hts = initial_hts,
             nr_thrds = nr_thrds,
             max_nr_pairs = max_nr_pairs,
             la_option = la_option,
             info_level = info_level,
             precision = precision)

    return AI.rat_sols
end

################################################################################
#
#  Rational solutions of zero-dimensional ideals
#
################################################################################

"""
    rational_solutions(I::MPolyIdeal) -> Vector{Vector}

Given a zero-dimensional ideal, return all rational elements of the vanishing
set.

```jldoctest; filter = Main.Oscar.doctestfilter_hash_changes_in_1_13()
julia> R, (x1,x2,x3) = polynomial_ring(QQ, [:x1,:x2,:x3]);

julia> I = ideal(R, [x1+2*x2+2*x3-1, x1^2+2*x2^2+2*x3^2-x1, 2*x1*x2+2*x2*x3-x2]);

julia> rat_sols = rational_solutions(I)
2-element Vector{Vector{QQFieldElem}}:
 [1//3, 0, 1//3]
 [1, 0, 0]

julia> map(r->map(p->evaluate(p, r), gens(I)), rat_sols)
2-element Vector{Vector{QQFieldElem}}:
 [0, 0, 0]
 [0, 0, 0]
```
"""
function rational_solutions(I::MPolyIdeal{<:MPolyRingElem})
  R = base_ring(I)
  K = base_ring(R)
  @req dim(I) == 0 "Dimension must be zero"
  # note that what follows does not assume shape position of the points
  G = groebner_basis(I; ordering = lex(R))
  if 1 in G
    return elem_type(K)[]
  end
  xs = gens(R)
  n  = length(xs)
  Qx, t = polynomial_ring(K; cached = false)
  occurs_only_from_i(f, i) = all(degree(f, xs[j]) == 0 for j in 1:(i-1))
  Gslices = [ [ f for f in G if occurs_only_from_i(f, i) ] for i in 1:n ]
  rts = [elem_type(Qx)[zero(Qx) for _ in 1:n]]
  for i in n:-1:1
    Gi = Gslices[i]
    isempty(Gi) && error("Elimination slice empty at step $i (unexpected for dim 0).")
    new_rts = Vector{Vector{elem_type(Qx)}}()
    for r in rts
      r[i] = t
      h = mapreduce(f -> evaluate(f, r), gcd, Gi)
      h == 0 && error("Unexpected zero polynomial")
      for a in roots(h)
        r[i] = Qx(a)
        push!(new_rts, copy(r))
      end
    end
    rts = new_rts
  end
  # now we have a bunch of constant polynomials, replace them by
  # their constant coefficient
  sols = [elem_type(K)[constant_coefficient(x) for x in r] for r in rts]
  return unique(sols)
end


@doc raw"""
    rational_solutions(K::Field, I::MPolyIdeal) -> Vector{Vector}

Given a zero-dimensional ideal or homogenous one-dimension ideal, return all
rational elements of the vanishing set over the field $K$.

```jldoctest; filter = Main.Oscar.doctestfilter_hash_changes_in_1_13()
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);

julia> K = algebraic_closure(QQ);

julia> rational_solutions(K, ideal(R, [x + 2, y^2 + 1]))
2-element Vector{Vector{QQBarFieldElem}}:
 [{a1: -2.00000}, {a2: 1.00000*im}]
 [{a1: -2.00000}, {a2: -1.00000*im}]
```
"""
function rational_solutions(K::Field, I::MPolyIdeal)
  R = base_ring(I)
  _, f = change_base_ring(K, R)
  return rational_solutions(f(I))
end

function rational_solutions(I::MPolyIdeal{QQMPolyRingElem})
  # Call msolve/AlgebraicSolving
  return _rational_solutions(I)
end

################################################################################
#
#  Rational solutions of one-dimensional homogeneous ideals
#
################################################################################

@doc raw"""
    rational_solutions(I::MPolyIdeal{<:MPolyDecRingElem}) -> Vector{Vector}

Given a one-dimensional homogeneous ideal, return all projective rational
elements of the vanishing set.
"""
function rational_solutions(I::MPolyIdeal{<:MPolyDecRingElem})
  @req dim(I) == 1 "Dimension must be 1"
  #TODO: make this work for non-standard gradings
  S = base_ring(I)
  R = S.R
  RS, _ = polynomial_ring(base_ring(R), ngens(S) - 1; cached = false)
  Q = base_ring(R)
  all_S = Vector{elem_type(Q)}[]
  for i=1:ngens(S)
    val = [zero(RS) for l = gens(S)]
    k = 1
    for j in 1:ngens(S)
      if i == j
        val[j] = RS(1)
      else
        val[j] = gen(RS, k)
        k += 1
      end
    end
    #J should be an affine patch where the j-th var is set to 1
    J = ideal(RS, [evaluate(f, val) for f = gens(I)])
    r = rational_solutions(J)
    for s = r
      k = 1
      so = elem_type(Q)[]
      for j in 1:ngens(S)
        if i == j
          push!(so, one(Q))
        else
          push!(so, Q(s[k]))
          k += 1
        end
      end
      push!(all_S, so)
    end
  end
  P = projective_space(Q, ngens(RS))
  #projective comparison!!!!
  return Vector{elem_type(Q)}[coordinates(p) for p in Set(P(x) for x = all_S)]
end
