export  groebner_assure, groebner_basis, groebner_basis_with_transform, leading_ideal, syzygy_generators

# groebner stuff #######################################################
@doc Markdown.doc"""
    groebner_assure(I::MPolyIdeal)

Given an ideal `I` in a multivariate polynomial ring this function assures that a
Groebner basis w.r.t. the given monomial ordering is attached to `I` in `I.gb`.
"""
function groebner_assure(I::MPolyIdeal)
  if !isdefined(I, :gb)
    singular_assure(I)
#    @show "std on", I.gens.S
    I.gb = BiPolyArray(I.gens.Ox, Singular.std(I.gens.S))
  end
end

@doc Markdown.doc"""
    groebner_basis(B::BiPolyArray; ord::Symbol = :degrevlex, complete_reduction::Bool = false)

Given an `BiPolyArray` `B` and optional parameters `ord` for a monomial ordering and `complete_reduction`
this function computes a Groebner basis (if `complete_reduction = true` the reduced Groebner basis) of the
ideal spanned by the elements in `B` w.r.t. the given monomial ordering `ord`. The Groebner basis is then
returned in `B.S`.
"""
function groebner_basis(B::BiPolyArray; ord::Symbol = :degrevlex, complete_reduction::Bool = false)
  # if ord != :degrevlex
    R = singular_ring(B.Ox, ord)
    i = Singular.Ideal(R, [R(x) for x = B])
#    @show "std on", i, B
    i = Singular.std(i, complete_reduction = complete_reduction)
    return BiPolyArray(B.Ox, i)
  # end
  if !isdefined(B, :S)
    B.S = Singular.Ideal(B.Sx, [B.Sx(x) for x = B.O])
  end
#  @show "dtd", B.S
  return BiPolyArray(B.Ox, Singular.std(B.S, complete_reduction = complete_reduction))
end

@doc Markdown.doc"""
    groebner_basis(I::MPolyIdeal)

Given an ideal `I` this function computes a Groebner basis
w.r.t. the given monomial ordering of the polynomial ring. The Groebner basis is then
returned as an array of multivariate polynomials.
"""
function groebner_basis(I::MPolyIdeal)
  groebner_assure(I)
  return collect(I.gb)
end


@doc Markdown.doc"""
    groebner_basis(I::MPolyIdeal, ord::Symbol = :degrevlex; complete_reduction::Bool=false)

Given an ideal `I`, a monomial ordering `ord` and an optional parameter `complete_reduction`
this function computes a Groebner basis (if `complete_reduction = true` the reduced Groebner basis) of `I`
w.r.t. the given monomial ordering `ord`. The Groebner basis is then
returned as an array of multivariate polynomials.
"""
function groebner_basis(I::MPolyIdeal, ord::Symbol; complete_reduction::Bool=false)
  R = singular_ring(base_ring(I), ord)
  !Oscar.Singular.has_global_ordering(R) && error("The ordering has to be a global ordering.")
  i = Singular.std(Singular.Ideal(R, [R(x) for x = gens(I)]), complete_reduction = complete_reduction)
  return collect(BiPolyArray(base_ring(I), i))
end

@doc Markdown.doc"""
    groebner_basis_with_transform(B::BiPolyArray; ord::Symbol = :degrevlex, complete_reduction::Bool = false)

Given an `BiPolyArray` `B` and optional parameters `ord` for a monomial ordering and `complete_reduction`
this function computes a Groebner basis (if `complete_reduction = true` the reduced Groebner basis) of the
ideal spanned by the elements in `B` w.r.t. the given monomial ordering `ord` and the transformation matrix from the ideal to the Groebner basis. Return value is a BiPolyArray together with a map.
"""
function groebner_basis_with_transform(B::BiPolyArray; ord::Symbol = :degrevlex, complete_reduction::Bool = false)
  if ord != :degrevlex
    R = singular_ring(B.Ox, ord)
    i = Singular.Ideal(R, [R(x) for x = B])
#    @show "std on", i, B
    i, m = Singular.lift_std(i, complete_reduction = complete_reduction)
    return BiPolyArray(B.Ox, i), map_entries(x->B.Ox(x), m)
  end
  if !isdefined(B, :S)
    B.S = Singular.Ideal(B.Sx, [B.Sx(x) for x = B.O])
  end
#  @show "dtd", B.S

  i, m = Singular.lift_std(B.S, complete_reduction = complete_reduction)
  return BiPolyArray(B.Ox, i), map_entries(x->B.Ox(x), m)
end

function lift_groebner_basis(I::MPolyIdeal, ord::Symbol; complete_reduction::Bool=false)
  R = singular_ring(base_ring(I), ord)
  !Oscar.Singular.has_global_ordering(R) && error("The ordering has to be a global ordering.")
  i, m = Singular.lift_std(Singular.Ideal(R, [R(x) for x = gens(I)]), complete_reduction = complete_reduction)
  return collect(BiPolyArray(base_ring(I), i)), m
end
# syzygies #######################################################
@doc Markdown.doc"""
    syzygy_generators(a::Array{<:MPolyElem, 1})

Given an array of multivariate polynomials this function returns the
generators of the syzygy module of the ideal generated by the given
array elements.
"""
function syzygy_generators(a::Array{<:MPolyElem, 1})
  I = ideal(a)
  singular_assure(I)
  s = Singular.syz(I.gens.S)
  F = free_module(parent(a[1]), length(a))
  @assert rank(s) == length(a)
  return [F(s[i]) for i=1:Singular.ngens(s)]
end

# leading ideal #######################################################
@doc Markdown.doc"""
    leading_ideal(g::Array{T, 1}, args...) where { T <: MPolyElem }

Given an array of multivariate polynomials this function returns the
ideal generated by the leading monomials of the given array elements.
If not otherwise given as a further argument this is done w.r.t. the
degree reverse lexicographical monomial ordering.
"""
function leading_ideal(g::Array{T, 1}, args...) where { T <: MPolyElem }
  return ideal([ leading_monomial(f, args...) for f in g ])
end

@doc Markdown.doc"""
    leading_ideal(g::Array{Any, 1}, args...)

Given an array of fitting type this function returns the ideal 
generated by the leading monomials of the given array elements.
If not otherwise given as a further argument this is done w.r.t.
the degree reverse lexicographical monomial ordering.

"""
function leading_ideal(g::Array{Any, 1}, args...)
  return leading_ideal(typeof(g[1])[ f for f in g ], args...)
end

@doc Markdown.doc"""
    leading_ideal(Rx::MPolyRing, g::Array{Any, 1}, args...)

Given a multivariate polynomial ring `Rx` and an array of elements
this function generates an array of multivariate polynomials in `Rx`
and returns the leading ideal for the ideal generated by the given
array elements w.r.t. the given monomial ordering of `Rx`.

"""
function leading_ideal(Rx::MPolyRing, g::Array{Any, 1}, args...)
  h = elem_type(Rx)[ Rx(f) for f in g ]
  return leading_ideal(h, args...)
end

@doc Markdown.doc"""
    leading_ideal(I::MPolyIdeal)

Given a multivariate polynomial ideal `Ì` this function returns the
leading ideal for `I`. This is done w.r.t. the given monomial ordering
in the polynomial ring of `I`.
"""
function leading_ideal(I::MPolyIdeal)
  return leading_ideal(groebner_basis(I))
end

@doc Markdown.doc"""
    leading_ideal(I::MPolyIdeal, ord::Symbol)

Given a multivariate polynomial ideal `Ì` and a monomial ordering `ord`
this function returns the leading ideal for `I` w.r.t. `ord`.
"""
function leading_ideal(I::MPolyIdeal, ord::Symbol)
  return leading_ideal(groebner_basis(I, ord), ord)
end

