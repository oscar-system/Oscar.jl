function is_f4_applicable(I::MPolyIdeal, ordering::MonomialOrdering)
  return (ordering == degrevlex(base_ring(I)) && !is_graded(base_ring(I))
            && ((coefficient_ring(I) isa FqField
                 && absolute_degree(coefficient_ring(I)) == 1
                 && characteristic(coefficient_ring(I)) < 2^31)
                || base_ring(I) isa QQMPolyRing))
end

@doc raw"""
    groebner_basis_f4(I::MPolyIdeal, <keyword arguments>)

Compute a Gröbner basis of `I` with respect to `degrevlex` using Faugère's F4 algorithm.
See [Fau99](@cite) for more information.

!!! note
    At current state only prime fields of characteristic `0 < p < 2^{31}` and the rationals are supported. For the rationals a multi-modular approach is used without final verification test over the rationals.

# Possible keyword arguments
- `initial_hts::Int=17`: initial hash table size `log_2`.
- `nr_thrds::Int=1`: number of threads for parallel linear algebra.
- `max_nr_pairs::Int=0`: maximal number of pairs per matrix, only bounded by minimal degree if `0`.
- `la_option::Int=2`: linear algebra option: exact sparse-dense (`1`), exact sparse (`2`, default), probabilistic sparse-dense (`42`), probabilistic sparse(`44`).
- `eliminate::Int=0`: size of first block of variables to be eliminated.
- `complete_reduction::Bool=true`: compute a reduced Gröbner basis for `I`
- `normalize::Bool=true`: normalizes elements in computed Gröbner basis for `I`
- `truncate_lifting::Int=0`: degree up to which the elements of the Gröbner basis are lifted to `QQ`, `0` for complete lifting
- `info_level::Int=0`: info level printout: off (`0`, default), summary (`1`), detailed (`2`).

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R,[x*y])
Ideal generated by
  x*y

julia> L = factoring_standard_basis(I)
2-element Vector{Oscar.IdealGens{QQMPolyRingElem}}:
 Gröbner basis with 1 element w.r.t. degrevlex([x, y])
 Gröbner basis with 1 element w.r.t. degrevlex([x, y])

julia> L[1]
Gröbner basis with elements
  1: y
with respect to the ordering
  degrevlex([x, y])

julia> L[2]
Gröbner basis with elements
  1: x
with respect to the ordering
  degrevlex([x, y])
```
"""
function groebner_basis_f4(
        I::MPolyIdeal;
        initial_hts::Int=17,
        nr_thrds::Int=1,
        max_nr_pairs::Int=0,
        la_option::Int=2,
        eliminate::Int=0,
        complete_reduction::Bool=true,
        normalize::Bool=true,
        truncate_lifting::Int=0,
        info_level::Int=0
        )

    AI   = AlgebraicSolving.Ideal(oscar_generators(I))
    if eliminate == 0
      AR = base_ring(I)
    else
      vars = symbols(base_ring(I))[eliminate+1:end]
      AR,  = polynomial_ring(coefficient_ring(I), vars; cached=false)
    end
    ord  = degrevlex(AR)
    if length(AI.gens) == 0
        GB = IdealGens(base_ring(I), singular_generators(I), complete_reduction)
        GB.ord    = ord
        GB..isGB  = true
        GB.S.isGB = true
    else
        AlgebraicSolving.groebner_basis(AI,
                    initial_hts = initial_hts,
                    nr_thrds = nr_thrds,
                    max_nr_pairs = max_nr_pairs,
                    la_option = la_option,
                    eliminate = eliminate,
                    complete_reduction = complete_reduction,
                    normalize = normalize,
                    truncate_lifting = truncate_lifting,
                    info_level = info_level)

        GB = IdealGens(AR, AI.gb[eliminate], ord, keep_ordering = false,
                       isGB = true, isReduced = complete_reduction)
    end
    if eliminate == 0
      I.gb[ord] = GB
    end

    return GB
end
