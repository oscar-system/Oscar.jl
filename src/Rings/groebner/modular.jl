# modular gröbner basis techniques using Singular
@doc raw"""
    groebner_basis_modular_qq(I::MPolyIdeal{QQMPolyRingElem}; ordering::MonomialOrdering = default_ordering(base_ring(I)), certify::Bool = false)

Compute the reduced Gröbner basis of `I` w.r.t. `ordering` using a
multi-modular strategy.

!!! note
    This function is probabilistic and returns a correct result
    only with high probability.
```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x,:y,:z]);

julia> I = ideal(R, [x^2+1209, x*y + 3279*y^2])
Ideal generated by
  x^2 + 1209
  x*y + 3279*y^2

julia> groebner_basis_modular_qq(I)
Gröbner basis with elements
  1: y^3 + 403//3583947*y
  2: x^2 + 1209
  3: x*y + 3279*y^2
with respect to the ordering
  degrevlex([x, y, z])
```
"""
function groebner_basis_modular_qq(I::MPolyIdeal{QQMPolyRingElem}; ordering::MonomialOrdering = default_ordering(base_ring(I)),
                                certify::Bool = false)

  # small function to get a canonically sorted reduced gb
  sorted_gb = idl -> begin
    R = base_ring(idl)
    gb = gens(groebner_basis(idl, ordering = ordering,
                             complete_reduction = true))
    sort!(gb; by = leading_monomial,
          lt = (m1, m2) -> cmp(MonomialOrdering(R, ordering.o), m1, m2) > 0)
  end
  
  if haskey(I.gb, ordering)
    return I.gb[ordering]
  end

  primes = Hecke.PrimesSet(rand(2^15:2^16), -1)

  p = iterate(primes)[1]
  Qt = base_ring(I)
  Zt = polynomial_ring(ZZ, [string(s) for s = symbols(Qt)]; cached = false)[1]

  Rt, t = polynomial_ring(GF(p), [string(s) for s = symbols(Qt)]; cached = false)
  std_basis_mod_p_lifted = map(sorted_gb(ideal(Rt, gens(I)))) do x
    map_coefficients(z -> lift(ZZ, z), x, parent = Zt)
  end
  std_basis_crt_previous = std_basis_mod_p_lifted

  n_stable_primes = 0
  d = ZZRingElem(p)
  unlucky_primes_in_a_row = 0
  done = false
  while !done
    while n_stable_primes < 2
      p = iterate(primes, p)[1]
      Rt, t = polynomial_ring(GF(p), [string(s) for s = symbols(Qt)]; cached = false)
      std_basis_mod_p_lifted = map(sorted_gb(ideal(Rt, gens(I)))) do x
        map_coefficients(z -> lift(ZZ, z), x, parent = Zt)
      end

      # test for unlucky prime
      if any(((i, p), ) -> leading_monomial(p) != leading_monomial(std_basis_crt_previous[i]),
             enumerate(std_basis_mod_p_lifted))
        unlucky_primes_in_a_row += 1
        # if we get unlucky twice in a row we assume that
        # we started with an unlucky prime
        if unlucky_primes_in_a_row == 2
          std_basis_crt_previous = std_basis_mod_p_lifted
        end
        continue
      end
      unlucky_primes_in_a_row = 0
      
      is_stable = true
      for (i, f) in enumerate(std_basis_mod_p_lifted)
        if !iszero(f - std_basis_crt_previous[i])
          std_basis_crt_previous[i], _ = induce_crt(std_basis_crt_previous[i], d, f, ZZRingElem(p), true)
          stable = false
        end
      end
      if is_stable
        n_stable_primes += 1
      end
      d *= ZZRingElem(p)
    end
    final_gb = QQMPolyRingElem[induce_rational_reconstruction(f, d, parent = base_ring(I)) for f in std_basis_crt_previous]

    I.gb[ordering] = IdealGens(final_gb, ordering)
    if certify
      done = _certify_modular_groebner_basis_qq(I, ordering)
    else
      done = true
    end
  end
  I.gb[ordering].isGB = true
  return I.gb[ordering]
end

function induce_crt(f::ZZMPolyRingElem, d::ZZRingElem, g::ZZMPolyRingElem, p::ZZRingElem, b::Bool)
  mu = MPolyBuildCtx(parent(f))
  for i=1:length(f)
    e = exponent_vector(f, i)
    @assert e == exponent_vector(g, i)
    push_term!(mu, crt(coeff(f, i), d, coeff(g, i), p, b), e)
  end
  return finish(mu), d*p
end

function induce_rational_reconstruction(f::ZZMPolyRingElem, d::ZZRingElem; parent = 1)
  g = MPolyBuildCtx(parent)
  for (c, v) in zip(AbstractAlgebra.coefficients(f), AbstractAlgebra.exponent_vectors(f))
    fl, r, s = Hecke.rational_reconstruction(c, d)
    fl ? push_term!(g, r//s, v) : push_term!(g, c, v)
  end
  return finish(g)
end

function _certify_modular_groebner_basis_qq(I::MPolyIdeal, ordering::MonomialOrdering)
  @req haskey(I.gb, ordering) "There exists no standard basis w.r.t. the given ordering."
  ctr = 0
  singular_generators(I.gb[ordering])
  SR = I.gb[ordering].gens.Sx
  SG = I.gb[ordering].gens.S

  #= test if I is included in <G> =#
  for f in I.gens
    if Singular.reduce(SR(f), SG) != 0
      break
    end
    ctr += 1
  end
  if ctr != ngens(I)
    return false
  end

  #= test if G is a standard basis of <G> w.r.t. ordering =#
  return is_standard_basis(I.gb[ordering], ordering=ordering)
end



#
#
#  Qt stuff
#
#

"""
  for evaluation of multivariate rational functions at
   [z*p[i]^j + s[i]] for 0<=j <= ?
"""
mutable struct MPolyPt{T}
  pt_z::Vector{T}
  pt_p::Vector{T}
  pt_s::Vector{T}
  j::Int

  function MPolyPt(n::Int)
    p = Vector{Int}()
    for q = PrimesSet(11, -1)
      push!(p, q)
      if length(p) == n
        break
      end
    end
    return new{Int}(Int[], p, Int[rand(-1000:1000) for i=1:n], 0)
  end
  function MPolyPt(lp::Vector{Int}, z::AbstractVector, s::Vector{Int}, j::Int)
    r = new{Int}()
    r.pt_z = collect(z)
    r.pt_p = lp
    r.pt_s = s
    r.j = j
    return r
  end
end

function push!(pt::MPolyPt, p::Int)
  if p in pt.pt_z
    error("point already there")
  end
  push!(pt.pt_z, p)
end

struct Vandermonde{T} <: MatElem{T}
  val::Vector{T}
end

size(V::Vandermonde) = (length(V.val), V.val)
getindex(V::Vandermonde, i::Int, j::Int) = V.val[i]^(j-1)
number_of_rows(V::Vandermonde) = size(V)[1]
number_of_columns(V::Vandermonde) = size(V)[1]
base_ring(V::Vandermonde) = parent(V.val[1])

struct VandermondeT{T} <: MatElem{T}
  V::Vandermonde{T}
end

size(V::VandermondeT) = size(V.V)
getindex(V::VandermondeT, i::Int, j::Int) = V.V[j,i]
number_of_rows(V::VandermondeT) = size(V)[1]
number_of_columns(V::VandermondeT) = size(V)[1]
base_ring(V::VandermondeT) = base_ring(V.V)

transpose(V::Vandermonde) = VandermondeT(V)
transpose(V::VandermondeT) = V.V

struct Hankel{T} <: MatElem{T}
  v::Vector{T}
end
size(V::Hankel) = (div(length(V.v)+1, 2), div(length(V.v)+1, 2))
number_of_rows(V::Hankel) = size(V)[1]
number_of_columns(V::Hankel) = size(V)[1]
base_ring(V::Hankel) = parent(V.v[1])
getindex(V::Hankel, i::Int, j::Int)  = V.v[j+i-1]

function solve_left(V::Vandermonde{T}, b::MatElem{T}) where {T <: Oscar.FieldElem}
  Qx = Oscar.Hecke.Globals.Qx
  x = gen(Qx)
  f = reduce(*, [x-i for i=V.val], init = one(Qx))
  z = zero(base_ring(V))
  H = Hankel(vcat([coeff(f, i) for i=1:nrows(V)], [z for i=nrows(V):2*nrows(V)-1]))
  Vt = transpose(V)
  D = diagonal_matrix([inv(derivative(f)(x)) for x = V.val])
  return ((b*H)*Vt)*D
end

mutable struct InterpolateCtx{T}
  C::Hecke.crt_env{T}
  function InterpolateCtx(a::Vector{S}, parent = polynomial_ring(parent(a[1]), cached = false)[1]) where {S}
    bt = parent
    t = gen(bt)
    r = new{elem_type(bt)}()
    r.C = Hecke.crt_env([t - i for i = a])
    return r
  end
end

function base_ring(I::InterpolateCtx)
  return base_ring(base_ring(I.C))
end

function rational_reconstruction(f::PolyRingElem, I::InterpolateCtx; error_tolerant::Bool = false)
  return rational_reconstruction(f, I.C.pr[end], error_tolerant = error_tolerant)
end

function interpolate(v::Vector, I::InterpolateCtx)
  bt = base_ring(I.C)
  return crt([bt(i) for i = v], I.C)
end

mutable struct MPolyInterpolateCtx{T}
  R#::parent_type(T)
  parent#::FracField{T}

  pt::MPolyPt
  I::InterpolateCtx#{T}
  status::Symbol

  function MPolyInterpolateCtx(F::FracField{<:MPolyRingElem{S}}, pt::MPolyPt) where {S}
    r = new{S}()
    r.parent = F
    r.R = base_ring(F)
    r.pt = pt
    r.I = InterpolateCtx(map(base_ring(r.R), pt.pt_z))
    return r
  end
  function MPolyInterpolateCtx(F::MPolyRing{S}, pt::MPolyPt) where {S}
    r = new{S}()
    r.parent = F
    r.R = F
    r.pt = pt
    r.I = InterpolateCtx(map(base_ring(r.R), pt.pt_z))
    return r
  end
end

is_integral(M::MPolyInterpolateCtx) = isa(M.parent, MPolyRing)

function set_status!(M::MPolyInterpolateCtx, s::Symbol)
  M.status = s
end

mutable struct Vals{T}
  v::Vector{Vector{T}}
  nd::Vector{Tuple{<:PolyRingElem{T}, <:PolyRingElem{T}}}
  G::RingElem # can be Generic.FracFieldElem{<:MPolyRingElem{T}} or PolyRingElem
  function Vals(v::Vector{Vector{S}}) where {S}
    r = new{S}()
    r.v = v
    return r
  end
end

function interpolate(Val::Vals{T}, M::MPolyInterpolateCtx) where {T}

  if isdefined(Val, :G)
    set_status!(M, :OK)
    return true, Val.G
  end

  set_status!(M, :univariate_failed)

  if !isdefined(Val, :nd) || length(Val.nd) < length(Val.v)
    nd = []
    val = Val.v
    i = 1
    for x = val
      f = interpolate(x, M.I)
      i += 1
      if is_integral(M)
        mu = (true, f, parent(f)(1))
      else
        mu = rational_reconstruction(f, M.I, error_tolerant = true)
      end
      if !mu[1]
        set_status!(M, :univariate_failed)
        return false, zero(M.R) # more z
      end
      t = inv(trailing_coefficient(mu[3]))
      push!(nd, (mu[2]*t, mu[3]*t))
    end
    Val.nd = nd
  else
    nd = Val.nd
  end
  Qx = parent(nd[1][1])
  @assert parent(nd[1][2]) == Qx

  R = [M.R(), M.R()]
  for ii = 1:2
    cor = elem_type(Qx)[zero(Qx) for i=1:length(nd)]
    for i=maximum(degree(x[ii]) for x = nd):-1:0
      bm = berlekamp_massey([coeff(nd[x][ii]-cor[x], i) for x = 1:length(nd)], error_tolerant = true)
      if !bm[1]
        set_status!(M, :BM_failed)
        return false, zero(M.R)
      end
      if is_constant(bm[2])
        continue
      end

      r = roots(bm[2])
      if length(r) != degree(bm[2]) 
        set_status!(M, :no_roots)
        return false, zero(M.R)
      end
      if !all(isinteger, r) || any(iszero, r)
        set_status!(M, :wrong_roots)
        return false, zero(M.R)
      end

      V = Vandermonde(r)
      s = solve_left(V, matrix(QQ, 1, length(r), [coeff(nd[x][ii]-cor[x], i) for x=1:length(r)]))
      G = MPolyBuildCtx(M.R)
      for i=1:length(r)
        push_term!(G, s[1,i], [valuation(r[i], p) for p = M.pt.pt_p])
      end
      g = finish(G)
      R[ii] += g
      for j=0:length(nd)-1
        t = evaluate(g, [T(M.pt.pt_p[l])^j*gen(Qx) + M.pt.pt_s[l] for l=1:length(M.pt.pt_p)])
        cor[j+1] += t
      end
    end
  end
  if iszero(R[2])
    set_status!(M, :bad)
    return false, zero(M.R)
  end
  set_status!(M, :OK)
  if is_integral(M)
    Val.G = R[1]
    @assert isone(R[2])
  else
    Val.G = R[1]//R[2]
  end

  return true, Val.G
end

function setindex!(v::Vals{T}, c::T, i::Int, j::Int) where {T}
  if i > length(v.v)
    push!(v.v, zeros(parent(v.v[1][1]), length(v.v[1])))
  end
  if j > length(v.v[i])
    while length(v.v[i]) < j-1
      push!(v.v[i], parent(v.v[1][1])(0))
    end
    @assert j == length(v.v[i])+1
    push!(v.v[i], c)
    return
  end
  v.v[i][j] = c
end

function groebner_basis_modular_qt(I::MPolyIdeal{AbstractAlgebra.Generic.MPoly{AbstractAlgebra.Generic.FracFieldElem{QQMPolyRingElem}}}; ordering::MonomialOrdering = default_ordering(base_ring(I)),
                                certify::Bool = false)
  T = QQFieldElem
  S = base_ring(I)
  R = base_ring(S)
  n = ngens(base_ring(R))
  P = MPolyPt(n)
  Q = base_ring(base_ring(R))
  Qy, _ = polynomial_ring(Q, S.S)
  frst = true
  lst = []
  do_z = true
  local lst
  while true
    if do_z 
      push!(P, length(P.pt_z)+1)
    else
      P.j += 1
    end

    idx = 1
    while true
      gens_J = elem_type(Qy)[]
      if do_z
        if idx > P.j+1
          break
        end
        pt = T[Q(P.pt_p[i])^(idx-1) * Q(P.pt_z[end]) + Q(P.pt_s[i]) for i=1:n]
      else
        if idx > length(P.pt_z)
          break
        end
        pt = T[Q(P.pt_p[i])^P.j * Q(P.pt_z[idx]) + Q(P.pt_s[i]) for i=1:n]
      end
      idx += 1
      for g = gens(I)
        G = MPolyBuildCtx(Qy)
        for (c, e) = zip(Generic.MPolyCoeffs(g), Generic.MPolyExponentVectors(g))
          push_term!(G, evaluate(c, pt, error_tolerant = true), e)
        end
        push!(gens_J, finish(G))
      end
      J = ideal(Qy, gens_J)
      gJ = groebner_basis(J, ordering = ordering, algorithm = :modular,  complete_reduction = true)
      # Tommy: There is not groebner_basis with Proof = false. But there is groebner_assure ...
      if frst
        lst = []
        for _g = gJ
          g = inv(AbstractAlgebra.leading_coefficient(_g))*_g
          f = []
          for (c, e) = zip(Generic.MPolyCoeffs(g), Generic.MPolyExponentVectors(g))
            push!(f, (e, Vals(Vector{T}[[c]])))
          end
          push!(lst, f)
        end
        frst = false
      else
        for ig = 1:length(gJ)
          g = gJ[ig]
          g *= inv(AbstractAlgebra.leading_coefficient(g))
          jg = 1
          for (c, e) = zip(Generic.MPolyCoeffs(g), Generic.MPolyExponentVectors(g))
            if lst[ig][jg][1] != e #TODO: sort and match
              @assert lst[ig][jg][1] == e
              if do_z
                lst[ig][jg][2][idx-1, length(P.pt_z)] = T(0)
              else
                lst[ig][jg][2][P.j+1, idx-1] = T(0)
              end
              jg += 1
              @assert lst[ig][jg][1] == e
            end
            if do_z
              lst[ig][jg][2][idx-1, length(P.pt_z)] = c
            else
              lst[ig][jg][2][P.j+1, idx-1] = c
            end
            jg += 1
          end
        end
      end
    end

    res = elem_type(S)[]
    M = MPolyInterpolateCtx(R, P)
    local fl = true
    for F = lst
      f = MPolyBuildCtx(S)
      for C = F
        fl, c = interpolate(C[2], M)
        if fl
          push_term!(f, c, C[1])
        else
          break
        end
      end
      fl || break
      push!(res, finish(f))
    end
    if fl
      I.gb[ordering] = Oscar.IdealGens(res, ordering, keep_ordering = false, isGB = true)
      return I.gb[ordering]
    end
    
    if M.status == :univariate_failed
      do_z = true
      continue
    end

    if M.status == :BM_failed && P.j > 10 
      do_z = !true
      continue
    end

    do_z = !do_z
  end
end
