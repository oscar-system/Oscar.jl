@doc raw"""
    factoring_standard_basis(I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(base_ring(I))) 

Return a factorization of the standard basis of `I` with respect to `ordering`,
i.e. a list of IdealGens.
The intersection of these ideals has the same zero set as the input ideal, i.e.
the radical of the intersection coincides with the radical of the input ideal.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R,[x*y])
Ideal generated by
  x*y

julia> L = factoring_standard_basis(I)
2-element Vector{Oscar.IdealGens{QQMPolyRingElem}}:
 Gröbner basis with 1 element w.r.t. degrevlex([x, y])
 Gröbner basis with 1 element w.r.t. degrevlex([x, y])

julia> L[1]
Gröbner basis with elements
  1: y
with respect to the ordering
  degrevlex([x, y])

julia> L[2]
Gröbner basis with elements
  1: x
with respect to the ordering
  degrevlex([x, y])
```
"""
function factoring_standard_basis(I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(base_ring(I)))

    #= apply highest corner standard basis variant in Singular =#
    sL = Singular.facstd(singular_generators(I, ordering))

    L = [Oscar.IdealGens(base_ring(I), r, false) for r in sL]

    return L
end
