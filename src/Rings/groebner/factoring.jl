@doc raw"""
    factoring_groebner_basis(I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(base_ring(I))) 

Return a list of Gröbner bases with respect to `ordering` which must be global.
The intersection of these ideals has the same zero set as the input ideal `I`, i.e.
the radical of the intersection coincides with the radical of `I`.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R,[x*y])
Ideal generated by
  x*y

julia> L = factoring_groebner_basis(I)
2-element Vector{Oscar.IdealGens{QQMPolyRingElem}}:
 Gröbner basis with 1 element w.r.t. degrevlex([x, y])
 Gröbner basis with 1 element w.r.t. degrevlex([x, y])

julia> L[1]
Gröbner basis with elements
  1: y
with respect to the ordering
  degrevlex([x, y])

julia> L[2]
Gröbner basis with elements
  1: x
with respect to the ordering
  degrevlex([x, y])
```
"""
function factoring_groebner_basis(I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(base_ring(I)))

    is_global(ordering) || error("Ordering must be global")
    return factoring_standard_basis(I, ordering=ordering)
end
@doc raw"""
    factoring_standard_basis(I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(base_ring(I))) 

Return a list of standard bases with respect to `ordering`.
The intersection of these ideals has the same zero set as the input ideal `I`, i.e.
the radical of the intersection coincides with the radical of `I`.

# Examples
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R,[x*y])
Ideal generated by
  x*y

julia> L = factoring_standard_basis(I)
2-element Vector{Oscar.IdealGens{QQMPolyRingElem}}:
 Gröbner basis with 1 element w.r.t. degrevlex([x, y])
 Gröbner basis with 1 element w.r.t. degrevlex([x, y])

julia> L[1]
Gröbner basis with elements
  1: y
with respect to the ordering
  degrevlex([x, y])

julia> L[2]
Gröbner basis with elements
  1: x
with respect to the ordering
  degrevlex([x, y])
```
"""
function factoring_standard_basis(I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(base_ring(I)))

    #= apply highest corner standard basis variant in Singular =#
    sL = Singular.facstd(singular_generators(I, ordering))

    L = [Oscar.IdealGens(base_ring(I), r, false) for r in sL]

    return L
end
