export fundamental_invariants

################################################################################
#
#  King's algorithm
#
################################################################################

# Computes a d-truncated GrÃ¶bner basis of I
# TODO: This should not be in this file and integrated in the general groebner_basis
# functionality
function _groebner_basis(I::MPolyIdeal, d::Int; ordering::MonomialOrdering = default_ordering(base_ring(I)))
  singular_assure(I, ordering)
  R = I.gens.Sx
  J = Singular.Ideal(R, gens(I.gens.S)...)
  G = Singular.with_degBound(d) do
        return Singular.std(J)
      end
  BA = BiPolyArray(base_ring(I), G)
  return BA
end

# [Kin13, p. 5] See also [DK15, Algorithm 3.8.2]
function fundamental_invariants_via_king(RG::InvRing, beta::Int = 0)
  @assert !is_modular(RG)

  Rgraded = polynomial_ring(RG)
  R = Rgraded.R
  # R needs to have the correct ordering for application of divrem
  @assert ordering(R) == :degrevlex
  ordR = degrevlex(gens(R))

  S = elem_type(R)[]
  G = BiPolyArray(R, elem_type(R)[])
  singular_assure(G, ordR)
  GO = elem_type(R)[]

  g = order(Int, group(RG))
  if is_cyclic(group(RG))
    dmax = g
  else
    # We get a somewhat better bound if the group is not cyclic, see [DK15, Theorem 3.2.8]
    if iseven(g)
      dmax = floor(Int, 3//4*g)
    else
      dmax = floor(Int, 5//8*g)
    end
  end
  if beta > 0 && beta < dmax
    dmax = beta
  end
  d = 1
  while d <= dmax
    if !isempty(S)
      I = ideal(R, GO)

      if total_degree(S[end]) == d - 2
        GO = groebner_basis(I, ordering = ordR)
        if is_zero(dim(I))
          mons = gens(ideal(R, Singular.kbase(I.gb[ordR].S)))
          dmax = maximum( total_degree(f) for f in mons )
          d > dmax ? break : nothing
        end
        G = I.gb[ordR]
      elseif total_degree(S[end]) == d - 1
        G = _groebner_basis(I, d, ordering = ordR)
        GO = collect(G)
      end
    end

    # TODO: Properly wrap kbase (or reimplement it; an iterator would be lovely)
    mons = gens(ideal(R, Singular.kbase(G.S, d)))
    if isempty(mons)
      break
    end

    for m in mons
      f = reynolds_operator(RG, Rgraded(m)).f
      if is_zero(f)
        continue
      end

      _, g = divrem(f, GO)
      if is_zero(g)
        continue
      end

      push!(S, inv(leading_coefficient(f))*f)
      push!(GO, g)
    end

    d += 1
  end

  invars_cache = FundamentalInvarsCache{elem_type(Rgraded), typeof(Rgraded)}()
  invars_cache.invars = [ Rgraded(f) for f in S ]
  invars_cache.via_primary_and_secondary = false
  invars_cache.S = GradedPolynomialRing(coefficient_ring(R), [ "y$i" for i = 1:length(S) ], [ total_degree(f) for f in S ])[1]
  return invars_cache
end

################################################################################
#
#  Via primary and secondary invariants
#
################################################################################

# By definition, an element of the irreducible secondary invariants cannot be
# written as a polynomial expression in the primary invariants and the other
# irreducible secondary invariants (note that this is also true in the modular
# case in OSCAR!).
# Hence if we take the primary and irreducible secondary invariants, we only have
# to make sure, that none of the *primary* invariants is in the algebra
# generated by the others.
function fundamental_invariants_via_primary_and_secondary(IR::InvRing)
  R = polynomial_ring(IR)
  K = coefficient_ring(R)

  invars_cache = FundamentalInvarsCache{elem_type(R), typeof(R)}()
  invars_cache.via_primary_and_secondary = true

  res = irreducible_secondary_invariants(IR)
  if isempty(res)

    # The easy case: there are no irreducible secondary invariants, so `IR` is
    # generated by the primary invariants

    invars_cache.invars = primary_invariants(IR)
    invars_cache.S = GradedPolynomialRing(K, [ "y$i" for i = 1:length(invars_cache.invars) ], [ total_degree(f.f) for f in invars_cache.invars ])[1]
    invars_cache.toS = Dict{elem_type(R), elem_type(invars_cache.S)}(invars_cache.invars[i] => gens(invars_cache.S)[i] for i = 1:length(invars_cache.invars))

    return invars_cache
  end

  # Use S to keep track of relations that might show up
  S, _ = PolynomialRing(K, [ "y$i" for i = 1:length(res) + length(primary_invariants(IR)) ])
  RtoS = Dict{elem_type(R), elem_type(S)}()
  for i = 1:length(res)
    RtoS[res[i]] = gen(S, i)
  end

  for p in primary_invariants(IR)
    fl, t = subalgebra_membership_homogeneous(p, res, check = false)
    if fl
      # p is in the span of the generators so far
      RtoS[p] = t(gens(S)[1:length(res)]...)
    else
      # p is a new generator
      RtoS[p] = gen(S, length(res) + 1)
      push!(res, p)
    end
  end

  # Sort the result by degree
  sp = sortperm(res, lt = (x, y) -> total_degree(x.f) < total_degree(y.f))

  res = res[sp]

  # Bookkeeping: we need to transform the relations in RtoS to the new ordering
  # (and potentially less variables)
  T, _ = GradedPolynomialRing(K, [ "y$i" for i = 1:length(res) ], [ total_degree(x.f) for x in res ])

  invars_cache.invars = res
  invars_cache.S = T

  t = append!(gens(T)[invperm(sp)], zeros(T, ngens(S) - ngens(T)))
  invars_cache.toS = Dict{elem_type(R), elem_type(T)}()
  for (f, g) in RtoS
    invars_cache.toS[f] = g(t...)
  end
  return invars_cache
end

################################################################################
#
#  User functions
#
################################################################################

@doc Markdown.doc"""
    fundamental_invariants(IR::InvRing, algo::Symbol = :default; beta::Int = 0)

Return a system of fundamental invariants for `IR`.

The result is cached, so calling this function again with argument `IR` 
will be fast and give the same result.

# Implemented Algorithms

In the non-modular case the function relies on King's algorithm [Kin13](@cite) which
finds a system of fundamental invariants directly, without computing primary and
secondary invariants.
If an upper bound for the degrees of fundamental invariants is known, this can be
supplied by the keyword argument `beta` and might result in an earlier termination
of the algorithm. By default, the algorithm uses the bounds from [DH00](@cite)
and [Sez02](@cite).

Alternatively, if specified by `algo = :primary_and_secondary`, the function computes
fundamental invariants from a collection of primary and irreducible secondary
invariants.
The optional keyword argument `beta` is ignored for this algorithm.

In the modular case, only the second method is available for theoretical reasons.

# Examples
```jldoctest
julia> K, a = CyclotomicField(3, "a")
(Cyclotomic field of order 3, a)

julia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0])
[0   0   1]
[1   0   0]
[0   1   0]

julia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1])
[1   0        0]
[0   a        0]
[0   0   -a - 1]

julia> G = MatrixGroup(3, K, [ M1, M2 ])
Matrix group of degree 3 over Cyclotomic field of order 3

julia> IR = invariant_ring(G)
Invariant ring of
Matrix group of degree 3 over Cyclotomic field of order 3
with generators
AbstractAlgebra.Generic.MatSpaceElem{nf_elem}[[0 0 1; 1 0 0; 0 1 0], [1 0 0; 0 a 0; 0 0 -a-1]]

julia> fundamental_invariants(IR)
4-element Vector{MPolyElem_dec{nf_elem, AbstractAlgebra.Generic.MPoly{nf_elem}}}:
 x[1]^3 + x[2]^3 + x[3]^3
 x[1]*x[2]*x[3]
 x[1]^6 + x[2]^6 + x[3]^6
 x[1]^3*x[2]^6 + x[1]^6*x[3]^3 + x[2]^3*x[3]^6
```
"""
function fundamental_invariants(IR::InvRing, algo::Symbol = :default; beta::Int = 0)
  if !isdefined(IR, :fundamental)
    if algo == :default
      algo = is_modular(IR) ? :primary_and_secondary : :king
    end

    if algo == :king
      IR.fundamental = fundamental_invariants_via_king(IR, beta)
    elseif algo == :primary_and_secondary
      IR.fundamental = fundamental_invariants_via_primary_and_secondary(IR)
    else
      error("Unsupported argument :$(algo) for algo")
    end
  end
  return copy(IR.fundamental.invars)
end
