mutable struct InvariantRing{T1 <: RingElem, T2 <: MatElem{T1}}
   field::Nemo.Field # coefficient field

   group::MatrixGroup{T1, T2}
   matrices::Vector{T2} # Needs to be set (so far)

   poly_ring::MPolyRing{T1}

   primary::Vector{<: MPolyElem{T1}}
   secondary::Vector{<: MPolyElem{T1}}
   irreducible_secondary::Vector{<: MPolyElem{T1}}

   function InvariantRing{T1, T2}(matrices::Vector{T2}) where { T1 <: RingElem, T2 <: MatrixElem{T1} }
      @assert !isempty(matrices)
      IR = new{T1, T2}()

      IR.field = base_ring(matrices[1])
      IR.matrices = matrices

      n = nrows(matrices[1])
      R, X = PolynomialRing(IR.field, [ "x$i" for i = 1:n ])
      IR.poly_ring = R

      return IR
   end

   function InvariantRing{T1, T2}(G::MatrixGroup{T1, T2}) where { T1 <: RingElem, T2 <: MatrixElem{T1} }
      IR = InvariantRing{T1, T2}([ g.elm for g in G.gens ])
      IR.group = G
      return IR
   end
end

function InvariantRing(matrices::Vector{T2}) where T2 <: MatrixElem{fmpq}
   @assert !isempty(matrices)

   return InvariantRing{elem_type(base_ring(matrices[1])), T2}(matrices)
end

function InvariantRing(G::MatrixGroup{T1, T2}) where { T1 <: fmpq, T2 <: MatrixElem{fmpq} }
   return InvariantRing{T1, T2}(G)
end

InvariantRing(matrices...) = InvariantRing(collect(matrices))

function Base.show(io::IO, IR::InvariantRing)
   if isdefined(IR, :group)
      print(io, "Invariant ring of group ")
      print(io, IR.group)
   else
     print(io, "Invariant ring of matrix group generated by ")
     print(io, IR.matrices)
   end
end

# Very first interface. We should split the different functions up.
function _compute_invariants(IR::InvariantRing)
   if isdefined(IR, :primary) && isdefined(IR, :secondary) && isdefined(IR, :irreducible_secondary)
      return nothing
   end

   R = IR.poly_ring
   RS = Oscar.singular_ring(R)
   singular_matrices = Vector{Singular.smatrix{elem_type(RS)}}(undef, length(IR.matrices))
   for i = 1:length(IR.matrices)
      singular_matrices[i] = map_entries(RS, IR.matrices[i])
   end

   P, S, IS = Singular.LibFinvar.invariant_ring(singular_matrices...)
   p = Vector{elem_type(R)}()
   for i = 1:ncols(P)
      push!(p, R(P[1, i]))
   end
   s = Vector{elem_type(R)}()
   for i = 1:ncols(S)
      push!(s, R(S[1, i]))
   end
   is = Vector{elem_type(R)}()
   for i = 1:ncols(IS)
      push!(is, R(IS[1, i]))
   end
   IR.primary = p
   IR.secondary = s
   IR.irreducible_secondary = is
   return nothing
end

function primary_invariants(IR::InvariantRing)
   if !isdefined(IR, :primary)
      _compute_invariants(IR)
   end
   return IR.primary
end

function secondary_invariants(IR::InvariantRing)
   if !isdefined(IR, :secondary)
      _compute_invariants(IR)
   end
   return IR.secondary
end

function irreducible_secondary_invariants(IR::InvariantRing)
   if !isdefined(IR, :irreducible_secondary)
      _compute_invariants(IR)
   end
   return IR.irreducible_secondary
end
