# TODO: Think about the types here.
# I think in Oscar, the user should only use Nemo types, so fmpq_mat + fmpq_mpoly etc.
# I don't think we should save the "converted to Singular"-stuff in here?
mutable struct InvariantRing{T}
   field::Nemo.Field # coefficient field

   # Either matrices or singular_matrices must be set
   matrices::Vector{AbstractAlgebra.MatElem{T}} # should be a group at some point
   singular_matrices::Vector{<: Singular.smatrix{<: Singular.spoly}}

   poly_ring::Singular.PolyRing # the "surrounding" polynomial ring

   primary::Vector{<: Singular.spoly}
   secondary::Vector{<: Singular.spoly}
   irreducible_secondary::Vector{<: Singular.spoly}

   function InvariantRing{T}(matrices::Vector{Singular.smatrix{Singular.spoly{T}}}) where T <: Union{ Singular.n_Q, Singular.n_algExt } # so far just for Singular QQ and Singular number fields
      @assert !isempty(matrices)
      IR = new{T}()
      IR.singular_matrices = matrices
      IR.poly_ring = base_ring(matrices[1])
      IR.field = base_ring(IR.poly_ring)
      return IR
   end

   function InvariantRing{T}(matrices::Vector{TT}) where { T <: fmpq, TT <: AbstractAlgebra.MatElem{T} }
      @assert !isempty(matrices)
      IR = new{T}()

      IR.matrices = matrices

      n = nrows(matrices[1])
      R, X = PolynomialRing(FlintQQ, [ "x$i" for i = 1:n ])
      IR.poly_ring = R
      IR.field = FlintQQ

      singular_matrices = Vector{Singular.smatrix{elem_type(R)}}(undef, length(matrices))
      for i = 1:length(matrices)
         singular_matrices[i] = map_entries(R, matrices[i])
      end
      IR.singular_matrices = singular_matrices
      return IR
   end
end

function InvariantRing(matrices::Vector{Singular.smatrix{Singular.spoly{T}}}) where T <: Union{ Singular.n_Q, Singular.n_algExt } # so far just for Singular QQ and Singular number fields
   return InvariantRing{T}(matrices)
end

function InvariantRing(matrices::Vector{T}) where T <: fmpq_mat
   return InvariantRing{fmpq}(matrices)
end

InvariantRing(matrices...) = InvariantRing(collect(matrices))

function Base.show(io::IO, IR::InvariantRing)
   print(io, "Invariant Ring of matrix group generated by ")
   if isdefined(IR, :matrices)
      print(io, IR.matrices)
   else
      print(io, IR.singular_matrices)
   end
end

# Very first interface. We should split the different functions up.
function _compute_invariants(IR::InvariantRing)
   if isdefined(IR, :primary) && isdefined(IR, :secondary) && isdefined(IR, :irreducible_secondary)
      return nothing
   end
   P, S, IS = Singular.LibFinvar.invariant_ring(IR.singular_matrices...)
   p = Vector{elem_type(IR.poly_ring)}()
   for i = 1:ncols(P)
      push!(p, P[1, i])
   end
   s = Vector{elem_type(IR.poly_ring)}()
   for i = 1:ncols(S)
      push!(s, S[1, i])
   end
   is = Vector{elem_type(IR.poly_ring)}()
   for i = 1:ncols(IS)
      push!(is, IS[1, i])
   end
   IR.primary = p
   IR.secondary = s
   IR.irreducible_secondary = is
   return nothing
end

function primary_invariants(IR::InvariantRing)
   if !isdefined(IR, :primary)
      _compute_invariants(IR)
   end
   return IR.primary
end

function secondary_invariants(IR::InvariantRing)
   if !isdefined(IR, :secondary)
      _compute_invariants(IR)
   end
   return IR.secondary
end

function irreducible_secondary_invariants(IR::InvariantRing)
   if !isdefined(IR, :irreducible_secondary)
      _compute_invariants(IR)
   end
   return IR.irreducible_secondary
end
