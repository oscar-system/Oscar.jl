################################################################################
#
#  Relations
#
################################################################################

# Relations between primary and irreducible secondary invariants, see
# [KS99, Section 17.5.5] or [DK15, Section 3.8.3].
function relations(RG::InvRing)

  Rgraded = polynomial_ring(RG)
  R = Rgraded.R
  K = coefficient_ring(R)

  p_invars = [ f.f for f in primary_invariants(RG) ]
  s_invars = [ f.f for f in secondary_invariants(RG) ]
  is_invars = [ f.f for f in irreducible_secondary_invariants(RG) ]
  s_invars_cache = RG.secondary

  np = length(p_invars)

  S, t = grade(PolynomialRing(K, "t" => 1:(np + length(is_invars)))[1], append!([ total_degree(f) for f in p_invars ], [ total_degree(f) for f in is_invars ]))

  RtoS = Vector{elem_type(S)}(undef, np + length(s_invars))
  for i = 1:np
    RtoS[i] = t[i]
  end
  for i = 1:length(s_invars)
    exps = append!(zeros(Int, np), s_invars_cache.sec_in_irred[i])
    g = set_exponent_vector!(one(S), 1, exps)
    RtoS[np + i] = g
  end


  # Build all products g*h of secondary invariants g and irreducible secondary
  # invariants h

  # Assumes that s_invars and is_invars are sorted by degree
  maxd = total_degree(s_invars[end]) + total_degree(is_invars[end])
  products_sorted = Vector{Vector{Tuple{elem_type(R), elem_type(S)}}}(undef, maxd)
  for d = 1:maxd
    products_sorted[d] = Vector{Tuple{elem_type(R), elem_type(S)}}()
  end
  for i = 1:length(s_invars)
    for j = 1:length(s_invars)
      if !s_invars_cache.is_irreducible[j]
        continue
      end
      if s_invars_cache.is_irreducible[i] && i > j
        continue
      end
      m = RtoS[np + i]*RtoS[np + j]
      if m in RtoS
        continue
      end
      f = s_invars[i]*s_invars[j]
      push!(products_sorted[total_degree(f)], (f, m))
    end
  end

  # TODO: In the modular case we need module syzygies!

  # Find relations of the form g*h - f_{g, h} where g*h is one of the products
  # above and f_{g, h} is in the module generated by the secondary invariants
  # over the algebra generated by the primary invariants

  rels = elem_type(S)[]
  C = PowerProductCache(R, p_invars)
  for d = 1:maxd
    if isempty(products_sorted[d])
      continue
    end

    gensd, expsd = generators_for_given_degree!(C, s_invars, d, true)

    monomial_to_column = enumerate_monomials(gensd)

    M = polys_to_smat(gensd, monomial_to_column, copy = false)

    N = polys_to_smat([ t[1] for t in products_sorted[d] ], monomial_to_column, copy = false)
    N.c = M.c
    if d == 10
      return M, N
    end

    # Write the products (in N) in the basis of K[V]^G_d given by the secondary
    # invariants (in M)
    fl, x = can_solve_with_solution(M, N, side = :left)
    @assert fl

    # Translate the relations to the free algebra S
    for i = 1:nrows(x)
      s = -products_sorted[d][i][2]
      for j = 1:length(x.rows[i])
        m = S(x.rows[i].values[j])
        e = expsd[gensd[x.rows[i].pos[j]]]
        for k = 1:np + length(s_invars)
          if iszero(e[k])
            continue
          end
          m *= RtoS[k]^e[k]
        end
        s += m
      end
      push!(rels, s)
    end
  end

  I = ideal(S, rels)
  Q, StoQ = quo(S, I)
  QtoR = hom(Q, Rgraded, append!(primary_invariants(RG), irreducible_secondary_invariants(RG)), check = false)

  return Q, QtoR
end
