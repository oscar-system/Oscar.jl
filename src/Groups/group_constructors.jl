################################################################################
#
#  Some basic constructors
#  
################################################################################

export
    abelian_group,
    alternating_group,
    cyclic_group,
    dihedral_group,
    free_abelian_group,
    free_group,
    isabelian, hasisabelian, setisabelian,
    iscyclic, hasiscyclic, setiscyclic,
    isdihedral_group, hasisdihedral_group, setisdihedral_group,
    isisomorphic_with_alternating_group, hasisisomorphic_with_alternating_group, setisisomorphic_with_alternating_group,
    isisomorphic_with_symmetric_group, hasisisomorphic_with_symmetric_group, setisisomorphic_with_symmetric_group,
    isnatural_alternating_group, hasisnatural_alternating_group, setisnatural_alternating_group,
    isnatural_symmetric_group, hasisnatural_symmetric_group, setisnatural_symmetric_group,
    isquaternion_group, hasisquaternion_group, setisquaternion_group,
    mathieu_group,
    quaternion_group,
    symmetric_group


_gap_filter(::Type{PermGroup}) = GAP.Globals.IsPermGroup
_gap_filter(::Type{PcGroup}) = GAP.Globals.IsPcGroup
_gap_filter(::Type{FPGroup}) = GAP.Globals.IsFpGroup

# TODO: matrix group handling usually is more complex: there usually
# is another extra argument then to specify the base field
# `_gap_filter(::Type{MatrixGroup})` is on the file `matrices/MatGrp.jl`

"""
    symmetric_group(::Type{T} = PermGroup, n::Int)

Return the full symmetric group on the set `{1, 2, ..., n}`,
as an instance of `T`, where `T` is in {`PermGroup`, `PcGroup`}.
"""
symmetric_group(n::Int) = symmetric_group(PermGroup, n)

function symmetric_group(::Type{T}, n::Int) where T <: GAPGroup
  n >= 1 || throw(ArgumentError("n must be a positive integer"))
  return T(GAP.Globals.SymmetricGroup(_gap_filter(T), n)::GapObj)
end

"""
    isnatural_symmetric_group(G::GAPGroup)

Return `true` if `G` is a permutation group acting as the symmetric group
on its moved points, and `false` otherwise.
"""
@gapattribute isnatural_symmetric_group(G::GAPGroup) = GAP.Globals.IsNaturalSymmetricGroup(G.X)::Bool

"""
    isisomorphic_with_symmetric_group(G::GAPGroup)

Return `true` if `G` is isomorphic with a symmetric group,
and `false` otherwise.
"""
@gapattribute isisomorphic_with_symmetric_group(G::GAPGroup) = GAP.Globals.IsSymmetricGroup(G.X)::Bool

"""
    alternating_group(::Type{T} = PermGroup, n::Int)

Return the full alternating group on the set `{1, 2, ..., n}`,
as an instance of `T`, where `T` is in {`PermGroup`, `PcGroup`}.
"""
alternating_group(n::Int) = alternating_group(PermGroup, n)

function alternating_group(::Type{T}, n::Int) where T <: GAPGroup
  n >= 1 || throw(ArgumentError("n must be a positive integer"))
  return T(GAP.Globals.AlternatingGroup(_gap_filter(T), n)::GapObj)
end

"""
    isnatural_alternating_group(G::GAPGroup)

Return `true` if `G` is a permutation group acting as the alternating group
on its moved points, and `false` otherwise.
"""
@gapattribute isnatural_alternating_group(G::GAPGroup) = GAP.Globals.IsNaturalAlternatingGroup(G.X)::Bool

"""
    isisomorphic_with_alternating_group(G::GAPGroup)

Return `true` if `G` is isomorphic with an alternating group,
and `false` otherwise.
"""
@gapattribute isisomorphic_with_alternating_group(G::GAPGroup) = GAP.Globals.IsAlternatingGroup(G.X)::Bool

"""
    cyclic_group(::Type{T} = PcGroup, n::Int) where T <: GAPGroup

Return the cyclic group of order `n`, as an instance of `T`.
"""
cyclic_group(n::Int) = cyclic_group(PcGroup, n)

function cyclic_group(::Type{T}, n::Int) where T <: GAPGroup
  n >= 1 || throw(ArgumentError("n must be a positive integer"))
  return T(GAP.Globals.CyclicGroup(_gap_filter(T), n)::GapObj)
end

"""
    iscyclic(G::GAPGroup)

Return `true` if `G` is cyclic,
i.e., if `G` can be generated by one element.
"""
@gapattribute iscyclic(G::GAPGroup) = GAP.Globals.IsCyclic(G.X)::Bool

# already defined in Hecke
#=
function abelian_group(v::Vector{Int})
  for i = 1:length(v)
    iszero(v[i]) && error("Cannot represent an infinite group as a polycyclic group")
  end
  v1 = GAP.julia_to_gap(v)
  return PcGroup(GAP.Globals.AbelianGroup(v1))
end
=#

@doc Markdown.doc"""
    abelian_group(::Type{T}, v::Vector{Int}) where T <: Group -> PcGroup

Return the direct product of cyclic groups of the orders
`v[1]`, `v[2]`, $\ldots$, `v[n]`, as an instance of `T`.
Here, `T` must be one of `PermGroup`, `FPGroup`, or `PcGroup`.

!!! warning
    The type need to be specified in the input of the function `abelian_group`,
    otherwise a group of type `GrpAbFinGen` is returned,
    which is not a GAP group type.
    In future versions of Oscar, this may change.
"""
function abelian_group(::Type{T}, v::Vector{Int}) where T <: GAPGroup
  return T(GAP.Globals.AbelianGroup(_gap_filter(T), GAP.GapObj(v))::GapObj)
end

function abelian_group(::Type{T}, v::Vector{fmpz}) where T <: GAPGroup
  vgap = GAP.julia_to_gap(v, recursive=true)
  return T(GAP.Globals.AbelianGroup(_gap_filter(T), vgap)::GapObj)
end

@doc Markdown.doc"""
    isabelian(G::Group)

Return `true` if `G` is abelian (commutative),
that is, $x*y = y*x$ holds for all elements $x, y$ in `G`.
"""
@gapattribute isabelian(G::GAPGroup) = GAP.Globals.IsAbelian(G.X)::Bool

function mathieu_group(n::Int)
  9 <= n <= 12 || 21 <= n <= 24 || throw(ArgumentError("n must be a 9-12 or 21-24"))
  return PermGroup(GAP.Globals.MathieuGroup(n), n)
end


################################################################################
#
# begin FpGroups
#
################################################################################

"""
    free_group(n::Int, s::Union{String, Symbol} = "f") -> FPGroup
    free_group(L::Vector{<:Union{String, Symbol}}) -> FPGroup
    free_group(L::Union{String, Symbol}...) -> FPGroup

The first form returns the free group of rank `n`, where the generators are
printed as `s1`, `s2`, ..., the default being `f1`, `f2`, ...

The second form, if `L` has length `n`, returns the free group of rank `n`,
where the `i`-th generator is printed as `L[i]`.

The third form, if there are `n` arguments `L...`,
returns the free group of rank `n`,
where the `i`-th generator is printed as `L[i]`.

!!! warning "Note"
    Variables named like the group generators are *not* created by this function.
"""
function free_group(n::Int, s::Union{String, Symbol} = "f")
   n >= 0 || throw(ArgumentError("n must be a non-negative integer"))
   return FPGroup(GAP.Globals.FreeGroup(n, GAP.GapObj(s))::GapObj)
end

function free_group(L::Vector{<:Union{String, Symbol}})
   J = GAP.GapObj(L, recursive = true)
   return FPGroup(GAP.Globals.FreeGroup(J)::GapObj)
end

function free_group(L::Union{String, Symbol}...)
   J = GAP.GapObj(L, recursive = true)
   return FPGroup(GAP.Globals.FreeGroup(J)::GapObj)
end

# FIXME: a function `free_abelian_group` with the same signature is
# already being defined by Hecke
#function free_abelian_group(n::Int)
#  return FPGroup(GAP.Globals.FreeAbelianGroup(n))
#end

function free_abelian_group(::Type{FPGroup}, n::Int)
 return FPGroup(GAP.Globals.FreeAbelianGroup(n)::GapObj)
end


# for the definition of group modulo relations, see the quo function in the sub.jl section

function free_group(G::FPGroup)
   return FPGroup(GAP.Globals.FreeGroupOfFpGroup(G.X)::GapObj)
end

################################################################################
#
# end FpGroups
#
################################################################################

"""
    dihedral_group(::Type{T} = PcGroup, n::Int)

Return the dihedral group of order `n`,
as an instance of `T`,
where `T` is in {`PcGroup`,`PermGroup`,`FPGroup`}.
An exception is thrown if `n` is odd.
"""
dihedral_group(n::Int) = dihedral_group(PcGroup, n)

function dihedral_group(::Type{T}, n::Int) where T <: GAPGroup
  @assert iseven(n)
  return T(GAP.Globals.DihedralGroup(_gap_filter(T), n)::GapObj)
end

@doc Markdown.doc"""
    isdihedral_group(G::GAPGroup)

Return `true` if `G` is isomorphic with a dihedral group,
and `false` otherwise.
"""
@gapattribute isdihedral_group(G::GAPGroup) = GAP.Globals.IsDihedralGroup(G.X)::Bool

"""
    quaternion_group(::Type{T} = PcGroup, n::Int)

Return the (generalized) quaternion group of order `n`,
as an instance of `T`,
where `n` is a power of 2 and `T` is in {`PcGroup`,`PermGroup`,`FPGroup`}.

# Examples
```jldoctest
julia> g = quaternion_group(8)
<pc group of size 8 with 3 generators>

julia> quaternion_group(PermGroup, 8)
Group([ (1,5,3,7)(2,8,4,6), (1,2,3,4)(5,6,7,8) ])

julia> g = quaternion_group(FPGroup, 8)
<fp group of size 8 on the generators [ r, s ]>

julia> relators(g)
3-element Vector{FPGroupElem}:
 r^2*s^-2
 s^4
 r^-1*s*r*s

```
"""
quaternion_group(n::Int) = quaternion_group(PcGroup, n)

function quaternion_group(::Type{T}, n::Int) where T <: GAPGroup 
   @assert iszero(mod(n, 4))
  return T(GAP.Globals.QuaternionGroup(_gap_filter(T), n)::GapObj)
end

@doc Markdown.doc"""
    isquaternion_group(G::GAPGroup)

Return `true` if `G` is isomorphic with a (generalized) quaternion group
of order $2^{k+1}, k \geq 2$, and `false` otherwise.
"""
@gapattribute isquaternion_group(G::GAPGroup) = GAP.Globals.IsQuaternionGroup(G.X)::Bool
