################################################################################
#
#  Some basic constructors
#
################################################################################

export
    abelian_group,
    alternating_group,
    cyclic_group,
    dihedral_group,
    free_abelian_group,
    free_group,
    is_abelian, has_is_abelian, set_is_abelian,
    is_cyclic, has_is_cyclic, set_is_cyclic,
    is_dihedral_group, has_is_dihedral_group, set_is_dihedral_group,
    is_elementary_abelian, has_is_elementary_abelian, set_is_elementary_abelian,
    is_isomorphic_with_alternating_group, has_is_isomorphic_with_alternating_group, set_is_isomorphic_with_alternating_group,
    is_isomorphic_with_symmetric_group, has_is_isomorphic_with_symmetric_group, set_is_isomorphic_with_symmetric_group,
    is_natural_alternating_group, has_is_natural_alternating_group, set_is_natural_alternating_group,
    is_natural_symmetric_group, has_is_natural_symmetric_group, set_is_natural_symmetric_group,
    is_quaternion_group, has_is_quaternion_group, set_is_quaternion_group,
    mathieu_group,
    quaternion_group,
    symmetric_group


_gap_filter(::Type{PermGroup}) = GAP.Globals.IsPermGroup
_gap_filter(::Type{PcGroup}) = GAP.Globals.IsPcGroupOrPcpGroup
_gap_filter(::Type{FPGroup}) = GAP.Globals.IsFpGroup

# TODO: matrix group handling usually is more complex: there usually
# is another extra argument then to specify the base field
# `_gap_filter(::Type{MatrixGroup})` is on the file `matrices/MatGrp.jl`

"""
    symmetric_group(n::Int)

Return the full symmetric group on the set `{1, 2, ..., n}`.

# Examples
```jldoctest
julia> G = symmetric_group(5)
Sym( [ 1 .. 5 ] )

julia> order(G)
120

```
"""
function symmetric_group(n::Int)
  n >= 1 || throw(ArgumentError("n must be a positive integer"))
  return PermGroup(GAP.Globals.SymmetricGroup(n)::GapObj)
end

"""
    is_natural_symmetric_group(G::GAPGroup)

Return `true` if `G` is a permutation group acting as the symmetric group
on its moved points, and `false` otherwise.
"""
@gapattribute is_natural_symmetric_group(G::GAPGroup) = GAP.Globals.IsNaturalSymmetricGroup(G.X)::Bool

"""
    is_isomorphic_with_symmetric_group(G::GAPGroup)

Return `true` if `G` is isomorphic with a symmetric group,
and `false` otherwise.
"""
@gapattribute is_isomorphic_with_symmetric_group(G::GAPGroup) = GAP.Globals.IsSymmetricGroup(G.X)::Bool

"""
    alternating_group(n::Int)

Return the full alternating group on the set `{1, 2, ..., n}`..

# Examples
```jldoctest
julia> G = alternating_group(5)
Alt( [ 1 .. 5 ] )

julia> order(G)
60

```
"""
function alternating_group(n::Int)
  n >= 1 || throw(ArgumentError("n must be a positive integer"))
  return PermGroup(GAP.Globals.AlternatingGroup(n)::GapObj)
end

"""
    is_natural_alternating_group(G::GAPGroup)

Return `true` if `G` is a permutation group acting as the alternating group
on its moved points, and `false` otherwise.
"""
@gapattribute is_natural_alternating_group(G::GAPGroup) = GAP.Globals.IsNaturalAlternatingGroup(G.X)::Bool

"""
    is_isomorphic_with_alternating_group(G::GAPGroup)

Return `true` if `G` is isomorphic with an alternating group,
and `false` otherwise.
"""
@gapattribute is_isomorphic_with_alternating_group(G::GAPGroup) = GAP.Globals.IsAlternatingGroup(G.X)::Bool

"""
    cyclic_group(::Type{T} = PcGroup, n::IntegerUnion)
    cyclic_group(::Type{T} = PcGroup, n::PosInf)

Return the cyclic group of order `n`, as an instance of type `T`.

# Examples
```jldoctest
julia> G = cyclic_group(5)
<pc group of size 5 with 1 generator>

julia> G = cyclic_group(PermGroup, 5)
Group([ (1,2,3,4,5) ])

julia> G = cyclic_group(PosInf())
Pcp-group with orders [ 0 ]

```
"""
cyclic_group(n::Union{IntegerUnion,PosInf}) = cyclic_group(PcGroup, n)

function cyclic_group(::Type{T}, n::Union{IntegerUnion,PosInf}) where T <: GAPGroup
  n > 0 || throw(ArgumentError("n must be a positive integer or infinity"))
  return T(GAP.Globals.CyclicGroup(_gap_filter(T), GAP.Obj(n))::GapObj)
end

function cyclic_group(::Type{PcGroup}, n::Union{IntegerUnion,PosInf})
  if is_infinite(n)
    return PcGroup(GAP.Globals.AbelianPcpGroup(1, GAP.GapObj([])))
  elseif n > 0
    return PcGroup(GAP.Globals.CyclicGroup(GAP.Globals.IsPcGroup, GAP.Obj(n))::GapObj)
  end
  throw(ArgumentError("n must be a positive even integer or infinity"))
end

"""
    is_cyclic(G::GAPGroup)

Return `true` if `G` is cyclic,
i.e., if `G` can be generated by one element.
"""
@gapattribute is_cyclic(G::GAPGroup) = GAP.Globals.IsCyclic(G.X)::Bool

# already defined in Hecke
#=
function abelian_group(v::Vector{Int})
  for i = 1:length(v)
    iszero(v[i]) && error("Cannot represent an infinite group as a polycyclic group")
  end
  v1 = GAP.Obj(v)
  return PcGroup(GAP.Globals.AbelianGroup(v1))
end
=#

@doc Markdown.doc"""
    abelian_group(::Type{T}, v::Vector{Int}) where T <: Group -> PcGroup

Return the direct product of cyclic groups of the orders
`v[1]`, `v[2]`, $\ldots$, `v[n]`, as an instance of `T`.
Here, `T` must be one of `PermGroup`, `FPGroup`, or `PcGroup`.

!!! warning
    The type need to be specified in the input of the function `abelian_group`,
    otherwise a group of type `GrpAbFinGen` is returned,
    which is not a GAP group type.
    In future versions of Oscar, this may change.
"""
function abelian_group(::Type{T}, v::Vector{S}) where T <: GAPGroup where S <: IntegerUnion
  vgap = GAP.Obj(v, recursive=true)
  return T(GAP.Globals.AbelianGroup(_gap_filter(T), vgap)::GapObj)
end

# Delegating to the GAP constructor via `_gap_filter` does not work here.
function abelian_group(::Type{PcGroup}, v::Vector{T}) where T <: IntegerUnion
  if 0 in v
    return PcGroup(GAP.Globals.AbelianPcpGroup(length(v), GAP.GapObj(v, recursive=true)))
  else
    return PcGroup(GAP.Globals.AbelianGroup(GAP.Globals.PcGroup, GAP.GapObj(v, recursive=true)))
  end
end

@doc Markdown.doc"""
    is_abelian(G::Group)

Return `true` if `G` is abelian (commutative),
that is, $x*y = y*x$ holds for all elements $x, y$ in `G`.
"""
@gapattribute is_abelian(G::GAPGroup) = GAP.Globals.IsAbelian(G.X)::Bool

@doc Markdown.doc"""
    is_elementary_abelian(G::Group)

Return `true` if `G` is a abelian (see [`is_abelian`](@ref))
and if there is a prime `p` such that the order of each element in `G`
divides `p`.

# Examples
```jldoctest
julia> g = alternating_group(5);

julia> is_elementary_abelian(sylow_subgroup(g, 2)[1])
true

julia> g = alternating_group(6);

julia> is_elementary_abelian(sylow_subgroup(g, 2)[1])
false
```
"""
@gapattribute is_elementary_abelian(G::GAPGroup) = GAP.Globals.IsElementaryAbelian(G.X)::Bool

function mathieu_group(n::Int)
  9 <= n <= 12 || 21 <= n <= 24 || throw(ArgumentError("n must be a 9-12 or 21-24"))
  return PermGroup(GAP.Globals.MathieuGroup(n), n)
end


################################################################################
#
# begin FpGroups
#
################################################################################

"""
    free_group(n::Int, s::Union{String, Symbol} = "f") -> FPGroup
    free_group(L::Vector{<:Union{String, Symbol}}) -> FPGroup
    free_group(L::Union{String, Symbol}...) -> FPGroup

The first form returns the free group of rank `n`, where the generators are
printed as `s1`, `s2`, ..., the default being `f1`, `f2`, ...

The second form, if `L` has length `n`, returns the free group of rank `n`,
where the `i`-th generator is printed as `L[i]`.

The third form, if there are `n` arguments `L...`,
returns the free group of rank `n`,
where the `i`-th generator is printed as `L[i]`.

!!! warning "Note"
    Variables named like the group generators are *not* created by this function.
"""
function free_group(n::Int, s::Union{String, Symbol} = "f"; eltype::Symbol = :letter)
   n >= 0 || throw(ArgumentError("n must be a non-negative integer"))
   if eltype == :syllable
     return FPGroup(GAP.Globals.FreeGroup(n, GAP.GapObj(s); FreeGroupFamilyType = GapObj("syllable"))::GapObj)
   else
     return FPGroup(GAP.Globals.FreeGroup(n, GAP.GapObj(s))::GapObj)
   end
end

function free_group(L::Vector{<:Union{String, Symbol}})
   J = GAP.GapObj(L, recursive = true)
   return FPGroup(GAP.Globals.FreeGroup(J)::GapObj)
end

function free_group(L::Union{String, Symbol}...)
   J = GAP.GapObj(L, recursive = true)
   return FPGroup(GAP.Globals.FreeGroup(J)::GapObj)
end

# FIXME: a function `free_abelian_group` with the same signature is
# already being defined by Hecke
#function free_abelian_group(n::Int)
#  return FPGroup(GAPWrap.FreeAbelianGroup(n))
#end

function free_abelian_group(::Type{FPGroup}, n::Int)
 return FPGroup(GAPWrap.FreeAbelianGroup(n)::GapObj)
end


# for the definition of group modulo relations, see the quo function in the sub.jl section

function free_group(G::FPGroup)
   return FPGroup(GAPWrap.FreeGroupOfFpGroup(G.X)::GapObj)
end

################################################################################
#
# end FpGroups
#
################################################################################

"""
    dihedral_group(::Type{T} = PcGroup, n::Union{IntegerUnion,PosInf})

Return the dihedral group of order `n`, as an instance of `T`,
where `T` is in {`PcGroup`,`PermGroup`,`FPGroup`}.

!!! warning

    There are two competing conventions for interpreting the argument `n`:
    In the one we use, the returned group has order `n`, and thus `n` must
    always be even.
    In the other, `n` indicates that the group describes the symmetry of an
    `n`-gon, and thus the group has order `2n`.

# Examples
```jldoctest
julia> dihedral_group(6)
<pc group of size 6 with 2 generators>

julia> dihedral_group(PermGroup, 6)
Group([ (1,2,3), (2,3) ])

julia> dihedral_group(PosInf())
Pcp-group with orders [ 2, 0 ]

julia> dihedral_group(7)
ERROR: ArgumentError: n must be a positive even integer or infinity
```
"""
dihedral_group(n::Union{IntegerUnion,PosInf}) = dihedral_group(PcGroup, n)

function dihedral_group(::Type{T}, n::Union{IntegerUnion,PosInf}) where T <: GAPGroup
  if !is_infinite(n) && !(iseven(n) && n > 0)
    throw(ArgumentError("n must be a positive even integer or infinity"))
  end
  return T(GAP.Globals.DihedralGroup(_gap_filter(T), GAP.Obj(n))::GapObj)
end

# Delegating to the GAP constructor via `_gap_filter` does not work here.
function dihedral_group(::Type{PcGroup}, n::Union{IntegerUnion,PosInf})
  if is_infinite(n)
    return PcGroup(GAP.Globals.DihedralPcpGroup(0))
  elseif iseven(n) && n > 0
    return PcGroup(GAP.Globals.DihedralGroup(GAP.Globals.IsPcGroup, GAP.Obj(n))::GapObj)
  end
  throw(ArgumentError("n must be a positive even integer or infinity"))
end

@doc Markdown.doc"""
    is_dihedral_group(G::GAPGroup)

Return `true` if `G` is isomorphic to a dihedral group,
and `false` otherwise.

# Examples
```jldoctest
julia> is_dihedral_group(small_group(8,3))
true

julia> is_dihedral_group(small_group(8,4))
false

```
"""
@gapattribute is_dihedral_group(G::GAPGroup) = GAP.Globals.IsDihedralGroup(G.X)::Bool

"""
    quaternion_group(::Type{T} = PcGroup, n::IntegerUnion)

Return the (generalized) quaternion group of order `n`,
as an instance of `T`,
where `n` is a power of 2 and `T` is in {`PcGroup`,`PermGroup`,`FPGroup`}.

# Examples
```jldoctest
julia> g = quaternion_group(8)
<pc group of size 8 with 3 generators>

julia> quaternion_group(PermGroup, 8)
Group([ (1,5,3,7)(2,8,4,6), (1,2,3,4)(5,6,7,8) ])

julia> g = quaternion_group(FPGroup, 8)
<fp group of size 8 on the generators [ r, s ]>

julia> relators(g)
3-element Vector{FPGroupElem}:
 r^2*s^-2
 s^4
 r^-1*s*r*s

```
"""
quaternion_group(n::IntegerUnion) = quaternion_group(PcGroup, n)

function quaternion_group(::Type{T}, n::IntegerUnion) where T <: GAPGroup
  # FIXME: resolve naming: dicyclic vs (generalized) quaternion: only the
  # former should be for any n divisible by 4; the latter only for powers of 2.
  # see also debate on the GAP side (https://github.com/gap-system/gap/issues/2725)
  @assert iszero(mod(n, 4))
  return T(GAP.Globals.QuaternionGroup(_gap_filter(T), n)::GapObj)
end

@doc Markdown.doc"""
    is_quaternion_group(G::GAPGroup)

Return `true` if `G` is isomorphic to a (generalized) quaternion group
of order $2^{k+1}, k \geq 2$, and `false` otherwise.

# Examples
```jldoctest
julia> is_quaternion_group(small_group(8, 3))
false

julia> is_quaternion_group(small_group(8, 4))
true

```
"""
@gapattribute is_quaternion_group(G::GAPGroup) = GAP.Globals.IsQuaternionGroup(G.X)::Bool
