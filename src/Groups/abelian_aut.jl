export defines_automorphism

@attributes TorQuadMod   # TODO: remove as soon as Hecke is patched

AutGrpAbTor = Union{AutomorphismGroup{GrpAbFinGen},AutomorphismGroup{TorQuadMod}}
AutGrpAbTorElem = Union{AutomorphismGroupElem{GrpAbFinGen},AutomorphismGroupElem{TorQuadMod}}
AbTorElem = Union{GrpAbFinGenElem,TorQuadModElem}

function _isomorphic_gap_group(A::GrpAbFinGen; T=PcGroup)
  iso = isomorphism(T, A)
  return codomain(iso), iso, inv(iso)
end

"""
    automorphism_group(G::GrpAbFinGen) -> AutomorphismGroup{GrpAbFinGen} 

Return the automorphism group of `G`.
"""
function automorphism_group(G::GrpAbFinGen)
  Ggap, to_gap, to_oscar = _isomorphic_gap_group(G)
  AutGAP = GAP.Globals.AutomorphismGroup(Ggap.X)
  aut = AutomorphismGroup(AutGAP, G)
  set_attribute!(aut, :to_gap => to_gap, :to_oscar => to_oscar)
  return aut
end


function apply_automorphism(f::AutGrpAbTorElem, x::AbTorElem, check=true)
  aut = parent(f)
  if check
    @assert parent(x) == aut.G "Not in the domain of f!"
  end
  to_gap = get_attribute(aut, :to_gap)
  to_oscar = get_attribute(aut, :to_oscar)
  xgap = to_gap(x)
  A = parent(f)
  domGap = parent(xgap)
  imgap = typeof(xgap)(domGap, GAPWrap.Image(f.X,xgap.X))
  return to_oscar(imgap)
end
 
(f::AutGrpAbTorElem)(x::AbTorElem)  = apply_automorphism(f, x, true)
Base.:^(x::AbTorElem,f::AutGrpAbTorElem) = apply_automorphism(f, x, true)

# the _as_subgroup function needs a redefinition
# to pass on the to_gap and to_oscar attributes to the subgroup
function _as_subgroup(aut::AutomorphismGroup{S}, subgrp::GapObj) where S <: Union{TorQuadMod,GrpAbFinGen}
  function img(x::S)
    return group_element(aut, x.X)
  end
  to_gap = get_attribute(aut, :to_gap)
  to_oscar = get_attribute(aut, :to_oscar)
  subgrp1 = AutomorphismGroup{S}(subgrp, aut.G)
  set_attribute!(subgrp1, :to_gap => to_gap, :to_oscar => to_oscar)
  return subgrp1, hom(subgrp1, aut, img)
end

"""
    hom(f::AutomorphismGroupElem{GrpAbFinGen}) -> GrpAbFinGenMap 

Return the element `f` of type `GrpAbFinGenMap`.
"""
function hom(f::AutGrpAbTorElem)
  A = domain(f)
  imgs = elem_type(A)[f(a) for a in gens(A)]
  return hom(A, A, imgs)
end


function (aut::AutGrpAbTor)(f::Union{GrpAbFinGenMap,TorQuadModMor};check=true)
  !check || (domain(f) === codomain(f) === domain(aut) && is_bijective(f)) || error("Map does not define an automorphism of the abelian group.")
  to_gap = get_attribute(aut, :to_gap)
  to_oscar = get_attribute(aut, :to_oscar)
  Agap = domain(to_oscar)
  AA = Agap.X
  function img_gap(x)
    a = to_oscar(group_element(Agap,x))
    b = to_gap(f(a))
    return b.X 
  end
  gene = GAP.Globals.GeneratorsOfGroup(AA)
  img = GAP.julia_to_gap([img_gap(a) for a in gene])
  fgap = GAP.Globals.GroupHomomorphismByImagesNC(AA,AA,img)
  return aut(fgap)
end


function (aut::AutGrpAbTor)(M::fmpz_mat; check=true)
  !check || defines_automorphism(domain(aut),M) || error("Matrix does not define an automorphism of the abelian group.")
  return aut(hom(domain(aut),domain(aut),M); check=check)
end

function (aut::AutGrpAbTor)(g::MatrixGroupElem{fmpq, fmpq_mat}; check=true)
  L = relations(domain(aut))
  if check
    B = basis_matrix(L)
    @assert can_solve(B, B*matrix(g),side=:left)
  end
  T = domain(aut)
  g = hom(T, T, elem_type(T)[T(lift(t)*matrix(g)) for t in gens(T)])
  return aut(g)
end
"""
    matrix(f::AutomorphismGroupElem{GrpAbFinGen}) -> fmpz_mat

Return the underlying matrix of `f` as a module homomorphism.
"""
matrix(f::AutomorphismGroupElem{GrpAbFinGen}) = hom(f).map


"""
    defines_automorphism(G::GrpAbFinGen, M::fmpz_mat) -> Bool

If `M` defines an endomorphism of `G`, return `true` if `M` defines an automorphism of `G`, else `false`.
""" 
defines_automorphism(G::GrpAbFinGen, M::fmpz_mat) = is_bijective(hom(G,G,M))




################################################################################
#
#   Special functions for orthogonal groups of torsion quadratic modules
#
################################################################################


"""
    _orthogonal_group(T::TorQuadMod, gensOT::Vector{fmpz_mat}) -> AutomorphismGroup{TorQuadMod}

Return the subgroup of the orthogonal group of `G` generated by `gensOT`.
"""
function _orthogonal_group(T::TorQuadMod, gensOT::Vector{fmpz_mat}; check=true)
  Ggap, to_gap, to_oscar = _isomorphic_gap_group(abelian_group(T))
  A = abelian_group(T)
  function toA(x)
    return A(x)
  end
  function toT(x)
    return T(x)
  end
  T_to_A = Hecke.map_from_func(toA, T, A )
  A_to_T = Hecke.map_from_func(toT, A, T)
  to_oscar = compose(to_oscar, A_to_T)
  to_gap = compose(T_to_A, to_gap)
  AutGAP = GAP.Globals.AutomorphismGroup(Ggap.X)
  ambient = AutomorphismGroup(AutGAP, T)
  set_attribute!(ambient, :to_gap => to_gap, :to_oscar => to_oscar)
  gens_aut = GapObj([ambient(g, check=check).X for g in gensOT])  # performs the checks
  if check
    # expensive for large groups
    subgrp_gap =GAP.Globals.Subgroup(ambient.X, gens_aut)
  else
    subgrp_gap =GAP.Globals.SubgroupNC(ambient.X, gens_aut)
  end
  aut = AutomorphismGroup(subgrp_gap, T)
  set_attribute!(aut, :to_gap => to_gap, :to_oscar => to_oscar)
  return aut
end

function Base.show(io::IO, aut::AutomorphismGroup{TorQuadMod})
  T = domain(aut)
  print(IOContext(io, :compact => true), "Group of isometries of ", T , " generated by ", length(gens(aut)), " elements")
end


"""
    matrix(f::AutomorphismGroupElem{TorQuadMod}) -> fmpz_mat

Return a matrix inducing `f`.
"""
matrix(f::AutomorphismGroupElem{TorQuadMod}) = hom(f).map_ab.map

"""
    defines_automorphism(G::TorQuadMod, M::fmpz_mat) -> Bool

If `M` defines an endomorphism of `G`, return `true` if `M` defines an automorphism of `G`, else `false`.
"""
function defines_automorphism(G::TorQuadMod, M::fmpz_mat)
  g = hom(G, G, M)
  if !is_bijective(g)
    return false
  end
  # check that the form is preserved
  B = gens(G)
  n = length(B)
  for i in 1:n
    if Hecke.quadratic_product(B[i]) != Hecke.quadratic_product(g(B[i]))
      return false
    end
    for j in 1:i-1
      if B[i]*B[j] != g(B[i])*g(B[j])
        return false
      end
    end
  end
  return true
end

function Base.show(io::IO, ::MIME"text/plain", f::AutomorphismGroupElem{T}) where T<:TorQuadMod
  D = domain(parent(f))
  print(IOContext(io, :compact => true), "Isometry of ", D, " defined by \n")
  print(io, matrix(f))
end

function Base.show(io::IO, f::AutomorphismGroupElem{T}) where T<:TorQuadMod
  print(io, matrix(f))
end


"""
    orthogonal_group(T::TorQuadMod)  -> AutomorphismGroup{TorQuadMod}

Return the full orthogonal group of this torsion quadratic module.
"""
@attr AutomorphismGroup function orthogonal_group(T::TorQuadMod)
  !is_degenerate(T) || error("T must be non-degenerate to compute the full orthogonal group")
  N, i = normal_form(T)
  j = inv(i)
  gensOT = _compute_gens(N)
  gensOT = [hom(N, N, g) for g in gensOT]
  gensOT = [compose(compose(i,g),j).map_ab.map for g in gensOT]
  return _orthogonal_group(T, gensOT, check=false)
end
