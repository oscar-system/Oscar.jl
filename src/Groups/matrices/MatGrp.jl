matrix_group_type(::Type{T}) where T<:RingElement = MatGroup{T, dense_matrix_type(T)}

matrix_group_type(::Type{S}) where S<:Ring = matrix_group_type(elem_type(S))
matrix_group_type(x) = matrix_group_type(typeof(x)) # to stop this method from eternally recursing on itself, we better add ...
matrix_group_type(::Type{T}) where T = throw(ArgumentError("Type `$T` must be subtype of `RingElement`."))

const ZZMatGroup = matrix_group_type(ZZRing)
const QQMatGroup = matrix_group_type(QQField)

# This function (create a matrix group without generators)
# is used in situations where one wants to postpone the creation
# of generators, for example in `general_linear_group`.
# The function is not intended for the user,
# in particular it should not get documented.
matrix_group(F::Ring, m::Int) = matrix_group_type(F)(F, m)

# build a MatGroup given a list of generators, given as array of either MatGroupElem or AbstractAlgebra matrices
"""
    matrix_group([R::Ring, m::Int, ]V::T...; check::Bool=true) where T<:Union{MatElem,MatGroupElem}
    matrix_group([R::Ring, m::Int, ]V::AbstractVector{T}; check::Bool=true) where T<:Union{MatElem,MatGroupElem}

Return the matrix group generated by matrices in `V`.
If `V` is empty then the base ring `R` and the degree `m` must be given.

If `check` is set to `false` then it is not checked whether the given
generators are invertible.

# Examples
```jldoctest
julia> mats = [[0 -1; 1 -1], [0 1; 1 0]]
2-element Vector{Matrix{Int64}}:
 [0 -1; 1 -1]
 [0 1; 1 0]

julia> matelms = map(m -> matrix(ZZ, m), mats)
2-element Vector{ZZMatrix}:
 [0 -1; 1 -1]
 [0 1; 1 0]

julia> g = matrix_group(matelms)
Matrix group of degree 2
  over integer ring

julia> describe(g)
"S3"

julia> t = matrix_group(ZZ, 2, typeof(matelms[1])[])
Matrix group of degree 2
  over integer ring

julia> t == trivial_subgroup(g)[1]
true

julia> F = GF(3); matelms = map(m -> matrix(F, m), mats)
2-element Vector{FqMatrix}:
 [0 2; 1 2]
 [0 1; 1 0]

julia> g = matrix_group(matelms)
Matrix group of degree 2
  over prime field of characteristic 3

julia> describe(g)
"S3"
```
"""
function matrix_group(F::Ring, m::Int, V::AbstractVector{T}; check::Bool=true) where T<:Union{MatElem,AbstractMatGroupElem}
   @req all(v -> size(v) == (m,m), V) "Matrix group generators must all be square and of equal degree"
   @req all(v -> base_ring(v) == F, V) "Matrix group generators must have the same base ring"

   # if T <: MatGroupElem, we can already assume that det(V[i]) != 0
   if T<:MatElem && check
     @req all(v -> is_unit(det(v)), V) "Matrix group generators must be invertible over their base ring"
   end

   G = matrix_group(F, m)
   L = Vector{elem_type(G)}(undef, length(V))
   for i in 1:length(V)
      if T<:MatElem
         L[i] = MatGroupElem(G,V[i])
      else
# TODO: this part of code from here
         if isdefined(V[i],:elm)
            if isdefined(V[i],:X)
               L[i] = MatGroupElem(G,matrix(V[i]),V[i].X)
            else
               L[i] = MatGroupElem(G,matrix(V[i]))
            end
         else
            L[i] = MatGroupElem(G,V[i].X)
         end
# to here

# can be replaced by the following line once deepcopy works for GAP objects
# > L[i] = deepcopy(V[i]); L[i].parent = G;
      end
   end
   G.gens = L

   return G
end

matrix_group(R::Ring, m::Int, V::Union{MatElem,MatGroupElem}...; check::Bool=true) = matrix_group(R, m, collect(V); check)

matrix_group(V::AbstractVector{T}; check::Bool=true) where T<:Union{MatElem,MatGroupElem} = matrix_group(base_ring(V[1]), nrows(V[1]), V; check)

matrix_group(V::Union{MatElem,MatGroupElem}...; check::Bool=true) = matrix_group(collect(V); check)

# For `general_linear_group` etc. the degree comes first, so we should also provide that option
matrix_group(m::Int, R::Ring) = matrix_group(R, m)
matrix_group(m::Int, R::Ring, V; check::Bool = true) = matrix_group(R, m, V, check = check)

# the natural place to set additional information in the `GapObj`
# of a matrix group for which `_isomorphic_group_over_finite_field` works
function Base.setproperty!(G::MatGroup{T, S}, X::Symbol, GapG::GapObj) where {T <: Union{ZZRingElem, QQFieldElem, AbsSimpleNumFieldElem, QQAbFieldElem}, S}
  setfield!(G, X, GapG)
  X === :X || return
  # set the flag and the info in GapG
  GAP.Globals.SetJuliaData(GapG, G)
  GAP.Globals.SetFilterObj(GapG, GAP.Globals.MayBeHandledByNiceMonomorphism)
end

# `MatGroup`: compare types, dimensions, and coefficient rings
function check_parent(G::T, g::GAPGroupElem) where T <: MatGroup
  P = parent(g)
  return T === typeof(P) && degree(G) == degree(P) && base_ring(G) == base_ring(P)
end

function _as_subgroup_bare(G::MatGroup, H::GapObj)
  H1 = typeof(G)(base_ring(G), degree(G))
  H1.ring_iso = _ring_iso(G)
  H1.X = H
  return H1
end

# `has_gens` shall be `true` if the `gens` value is cheap to compute.
# For matrix groups, generators may be stored on the Oscar side
# or on the GAP side.
# If no `GapObj` of the matrix group has been computed yet,
# we regard it as cheap to create this `GapObj` if this is makes sense,
# and then to check whether the `GapObj` stores generators.
function has_gens(G::MatGroup)
  isdefined(G, :gens) && return true   # generators stored in Oscar
  if !isdefined(G, :X)
    # We know how to create `GapObj(G)` only if `G.descr` is bound.
    isdefined(G, :descr) || return false
    F = codomain(_ring_iso(G))
    GAP.Globals.IsBaseRingSupportedForClassicalMatrixGroup(F, GapObj(G.descr)) || return false
  end
  return GAP.Globals.HasGeneratorsOfGroup(GapObj(G))::Bool
end

MatGroupElem(G::MatGroup{RE,T}, x::T, x_gap::GapObj) where {RE,T} = MatGroupElem{RE,T}(G, x, x_gap)

MatGroupElem(G::MatGroup{RE,T}, x::T) where {RE, T} = MatGroupElem{RE,T}(G,x)
MatGroupElem(G::MatGroup{RE,T}, x_gap::GapObj) where {RE, T} = MatGroupElem{RE,T}(G,x_gap)

"""
    ring_elem_type(G::MatGroup{S,T}) where {S,T}
    ring_elem_type(::Type{MatGroup{S,T}}) where {S,T}

Return the type `S` of the entries of the elements of `G`.
One can enter the type of `G` instead of `G`.

# Examples
```jldoctest
julia> g = GL(2, 3);

julia> ring_elem_type(typeof(g)) == elem_type(typeof(base_ring(g)))
true
```
"""
ring_elem_type(::Type{MatGroup{S,T}}) where {S,T} = S
ring_elem_type(::MatGroup{S,T}) where {S,T} = S

"""
    mat_elem_type(G::MatGroup{S,T}) where {S,T}
    mat_elem_type(::Type{MatGroup{S,T}}) where {S,T}

Return the type `T` of `matrix(x)`, for elements `x` of `G`.
One can enter the type of `G` instead of `G`.

# Examples
```jldoctest
julia> g = GL(2, 3);

julia> mat_elem_type(typeof(g)) == typeof(matrix(one(g)))
true
```
"""
mat_elem_type(::Type{MatGroup{S,T}}) where {S,T} = T
mat_elem_type(::MatGroup{S,T}) where {S,T} = T

_gap_filter(::Type{<:MatGroup}) = GAP.Globals.IsMatrixGroup

elem_type(::Type{MatGroup{S,T}}) where {S,T} = MatGroupElem{S,T}
Base.eltype(::Type{MatGroup{S,T}}) where {S,T} = MatGroupElem{S,T}

# `parent_type` is defined and documented in AbstractAlgebra.
parent_type(::Type{MatGroupElem{S,T}}) where {S,T} = MatGroup{S,T}


function Base.deepcopy_internal(x::MatGroupElem, dict::IdDict)
  if isdefined(x, :X)
    X = Base.deepcopy_internal(x.X, dict)
    if isdefined(x, :elm)
      elm = Base.deepcopy_internal(matrix(x), dict)
      return MatGroupElem(parent(x), elm, X)
    else
      return MatGroupElem(parent(x), X)
    end
  elseif isdefined(x, :elm)
    elm = Base.deepcopy_internal(matrix(x), dict)
    return MatGroupElem(parent(x), elm)
  end
  error("$x has neither :X nor :elm")
end

change_base_ring(R::Ring, G::MatGroup) = map_entries(R, G)

########################################################################
#
# Basic
#
########################################################################

function _print_matrix_group_desc(io::IO, G::MatGroup)
  io = pretty(io)
  R = base_ring(G)
  print(io, LowercaseOff(), string(G.descr), "(", degree(G) ,",")
  if G.descr==:GU || G.descr==:SU
    print(io, characteristic(R)^(div(degree(R),2)),")")
  elseif R isa Field && is_finite(R)
    print(io, order(R),")")
  else
    print(terse(io), R)
    print(io ,")")
  end
end

function Base.show(io::IO, ::MIME"text/plain", G::MatGroup)
  isdefined(G, :descr) && return _print_matrix_group_desc(io, G)
  println(io, "Matrix group of degree ", degree(G))
  io = pretty(io)
  print(io, Indent())
  print(io, "over ", Lowercase(), base_ring(G))
  print(io, Dedent())
end

function Base.show(io::IO, G::MatGroup)
  @show_name(io, G)
  @show_special(io, G)
  isdefined(G, :descr) && return _print_matrix_group_desc(io, G)
  print(io, "Matrix group")
  if !is_terse(io)
    print(io, " of degree ", degree(G))
    io = pretty(io)
    print(terse(io), " over ", Lowercase(), base_ring(G))
  end
end

Base.show(io::IO, x::MatGroupElem) = show(io, matrix(x))
Base.show(io::IO, mi::MIME"text/plain", x::MatGroupElem) = show(io, mi, matrix(x))

group_element(G::MatGroup, x::GapObj) = MatGroupElem(G,x)

# Compute and store the component `G.X` if this is possible.
function assign_from_description(G::MatGroup)
   F = codomain(_ring_iso(G))
   GAP.Globals.IsBaseRingSupportedForClassicalMatrixGroup(F, GapObj(G.descr)) || error("no generators are known for the matrix group of type $(G.descr) over $(base_ring(G))")
   if G.descr==:GL G.X=GAP.Globals.GL(degree(G), F)
   elseif G.descr==:SL G.X=GAP.Globals.SL(degree(G), F)
   elseif G.descr==:Sp G.X=GAP.Globals.Sp(degree(G), F)
   elseif G.descr==Symbol("GO+") G.X=GAP.Globals.GO(1, degree(G), F)
   elseif G.descr==Symbol("SO+") G.X=GAP.Globals.SO(1, degree(G), F)
   elseif G.descr==Symbol("Omega+")
      # FIXME/TODO: Work around GAP issue <https://github.com/gap-system/gap/issues/500>
      # using the following inefficient code. In the future, we should use appropriate
      # generators for Omega (e.g. by applying a form change matrix to the Omega
      # generators returned by GAP).
      L = GAP.Globals.SubgroupsOfIndexTwo(GAP.Globals.SO(1, degree(G), F))
      if degree(G) == 4 && order(base_ring(G)) == 2  # this is the only case SO(n,q) has more than one subgroup of index 2
         for y in L
            _ranks = [GAP.Globals.Rank(u) for u in GAPWrap.GeneratorsOfGroup(y)]
            if all(is_even, _ranks)
               G.X=y
               break
            end
         end
      else
         @assert length(L) == 1
         G.X=L[1]
      end
   elseif G.descr==Symbol("GO-") G.X=GAP.Globals.GO(-1, degree(G), F)
   elseif G.descr==Symbol("SO-") G.X=GAP.Globals.SO(-1, degree(G), F)
   elseif G.descr==Symbol("Omega-") G.X=GAP.Globals.SubgroupsOfIndexTwo(GAP.Globals.SO(-1, degree(G), F))[1]
   elseif G.descr==:GO G.X=GAP.Globals.GO(0, degree(G), F)
   elseif G.descr==:SO G.X=GAP.Globals.SO(0, degree(G), F)
   elseif G.descr==:Omega
     # For even q or d = 1, \Omega(d,q) is equal to SO(d,q).
     # Otherwise, \Omega(d,q) has index 2 in SO(d,q).
     # Here d is odd, and we do not get here if d == 1 holds
     # because `omega_group` delegates to `SO` in this case.
     @assert degree(G) > 1
     if iseven(GAPWrap.Size(F))
       G.X = GAP.Globals.SO(0, degree(G), F)
     else
       L = GAP.Globals.SubgroupsOfIndexTwo(GAP.Globals.SO(0, degree(G), F))
       @assert length(L) == 1
       G.X = L[1]
     end
   elseif G.descr==:GU G.X=GAP.Globals.GU(degree(G),Int(characteristic(base_ring(G))^(div(degree(base_ring(G)),2) ) ))
   elseif G.descr==:SU G.X=GAP.Globals.SU(degree(G),Int(characteristic(base_ring(G))^(div(degree(base_ring(G)),2) ) ))
   else error("unsupported description")
   end
end

function _ring_iso(G::MatGroup{T}) where T
  if !isdefined(G, :ring_iso)
    if T === QQBarFieldElem
      # get all matrix entries into one vector
      entries = reduce(vcat, vec(collect(matrix(g))) for g in gens(G))
      # construct a number field over which all matrices are already defined
      nf, nf_to_QQBar = number_field(QQ, entries)
      iso = iso_oscar_gap(nf)
      G.ring_iso = MapFromFunc(base_ring(G), codomain(iso),
                               x -> iso(preimage(nf_to_QQBar, x)),
                               y -> nf_to_QQBar(preimage(iso, y))
                               )
    else
      G.ring_iso = iso_oscar_gap(base_ring(G))::MapFromFunc{parent_type(T), GapObj}
    end
  end
  return G.ring_iso::MapFromFunc{parent_type(T), GapObj}
end

GAP.@install function GapObj(G::MatGroup)
  if !isdefined(G, :X)
    if isdefined(G, :descr)
      assign_from_description(G)
    elseif isdefined(G, :gens)
      V = GapObj(gens(G); recursive = true)
      G.X = isempty(V) ? GAP.Globals.Group(V, GapObj(one(G))) : GAP.Globals.Group(V)
    else
      error("Cannot determine underlying GAP object")
    end
  end
  return G.X
end

GAP.@install function GapObj(x::MatGroupElem)
  if !isdefined(x, :X)
    x.X = map_entries(_ring_iso(parent(x)), x.elm)
  end
  return x.X
end

Base.IteratorSize(::Type{<:MatGroup}) = Base.SizeUnknown()

Base.iterate(G::MatGroup) = iterate(G, GAPWrap.Iterator(GapObj(G)))

function Base.iterate(G::MatGroup, state::GapObj)
  GAPWrap.IsDoneIterator(state) && return nothing
  i = GAPWrap.NextIterator(state)::GapObj
  return MatGroupElem(G, i), state
end

########################################################################
#
# Membership
#
########################################################################


function ==(G::MatGroup,H::MatGroup)
   G === H && return true
   degree(G) == degree(H) || return false
   base_ring(G) == base_ring(H) || return false
   if isdefined(G, :descr) && isdefined(H, :descr)
      return G.descr == H.descr
   end
   if isdefined(G, :gens) && isdefined(H, :gens)
      gens(G)==gens(H) && return true
   end
   return GapObj(G)==GapObj(H)
end


# this saves the value of x.X
# x_gap = x.X if this is already known, x_gap = nothing otherwise
function lies_in(x::MatElem, G::MatGroup, x_gap)
   if base_ring(x) != base_ring(G) || nrows(x) != degree(G) return false, x_gap end
   if isone(x) return true, x_gap end
   if isdefined(G,:gens)
      for g in gens(G)
         if x==matrix(g)
            return true, x_gap
         end
      end
   end
   if isdefined(G,:descr) && G.descr === :GL
      return det(x)!=0, x_gap
   elseif isdefined(G,:descr) && G.descr === :SL
      return det(x)==1, x_gap
   elseif x_gap === nothing
      x_gap = map_entries(_ring_iso(G), x)
   end
   return (x_gap in GapObj(G)), x_gap
end

Base.in(x::MatElem, G::MatGroup) = lies_in(x,G,nothing)[1]

function Base.in(x::MatGroupElem, G::MatGroup)
   isdefined(x,:X) && return lies_in(matrix(x),G,GapObj(x))[1]
   _is_true, x_gap = lies_in(matrix(x),G,nothing)
   if x_gap !== nothing
      x.X = x_gap
   end
   return _is_true
end

# embedding an element of type MatElem into a group G
# if check=false, there are no checks on the condition `x in G`
function (G::MatGroup)(x::MatElem; check::Bool=true)
   if check
      _is_true, x_gap = lies_in(x,G,nothing)
      @req _is_true "Element not in the group"
      x_gap !== nothing && return MatGroupElem(G,x,x_gap)
   end
   return MatGroupElem(G,x)
end

# embedding an element of type MatGroupElem into a group G
# if check=false, there are no checks on the condition `x in G`
function (G::MatGroup)(x::MatGroupElem; check::Bool=true)
   if !check
      z = x
      z.parent = G
      return z
   end
   if isdefined(x,:X)
      if isdefined(x,:elm)
         _is_true = lies_in(matrix(x),G,GapObj(x))[1]
         @req _is_true "Element not in the group"
         return MatGroupElem(G,matrix(x),GapObj(x))
      else
         @req GapObj(x) in GapObj(G) "Element not in the group"
         return MatGroupElem(G,GapObj(x))
      end
   else
      _is_true, x_gap = lies_in(matrix(x),G,nothing)
      @req _is_true "Element not in the group"
      if x_gap === nothing
        return MatGroupElem(G,matrix(x))
      end
      return MatGroupElem(G,matrix(x),x_gap)
   end
end

# embedding a n x n array into a group G
function (G::MatGroup)(L::AbstractVecOrMat; check::Bool=true)
   x = matrix(base_ring(G), degree(G), degree(G), L)
   return G(x; check=check)
end


########################################################################
#
# Methods on elements
#
########################################################################

# we are not currently keeping track of the parent; two elements coincide iff their matrices coincide
function ==(x::MatGroupElem{S,T},y::MatGroupElem{S,T}) where {S,T}
   if isdefined(x,:X) && isdefined(y,:X) return x.X==y.X
   else return matrix(x)==matrix(y)
   end
end

function Base.hash(x::MatGroupElem, h::UInt)
  b = 0x7ff345869aba5d1c  % UInt
  h = hash(matrix(x), h)
  return xor(h, b)
end

function _common_parent_group(x::T, y::T) where T <: MatGroup
   x === y && return x
   @req degree(x) == degree(y) "the groups have different degrees"
   @req base_ring(x) === base_ring(y) "the groups have different base rings"
   return GL(degree(x), base_ring(x))::T
end

# Base.:* is defined in src/Groups/GAPGroups.jl,
# and it calls the function _prod below.
# If the parents are different,
# the parent of the product is set as GL(n, R)
function _prod(x::T,y::T) where {T <: MatGroupElem}
   G = _common_parent_group(parent(x), parent(y))

   # if the underlying GAP matrices are both defined, but not both Oscar matrices,
   # then use the GAP matrices.
   # Otherwise, use the Oscar matrices, which if necessary are implicitly computed
   # by the matrix(::MatGroupElem) method .
   if isdefined(x,:X) && isdefined(y,:X) && !(isdefined(x,:elm) && isdefined(y,:elm))
      return T(G, x.X*y.X)
   else
      return T(G, matrix(x)*matrix(y))
   end
end

Base.:*(x::MatGroupElem, y::MatElem) = matrix(x)*y
Base.:*(x::MatElem, y::MatGroupElem) = x*matrix(y)

function Base.:^(x::MatGroupElem, n::Int)
  m = matrix(x)
  # Raising a `ZZMatrix` to a negative power is not supported.
  mn = (n < 0) ? inv(m)^(-n) : m^n
  return MatGroupElem(parent(x), mn)
end

Base.isone(x::MatGroupElem) = isone(matrix(x))

Base.inv(x::MatGroupElem) = MatGroupElem(parent(x), inv(matrix(x)))

# if the parents are different, the parent of the output is set as GL(n,q)
function Base.:^(x::MatGroupElem, y::MatGroupElem)
   G = parent(x) == parent(y) ? parent(x) : GL(degree(parent(x)), base_ring(parent(x)))
   if isdefined(x,:X) && isdefined(y,:X) && !(isdefined(x,:elm) && isdefined(y,:elm))
      return MatGroupElem(G, inv(y.X)*x.X*y.X)
   else
      return MatGroupElem(G,inv(matrix(y))*matrix(x)*matrix(y))
   end
end

comm(x::MatGroupElem, y::MatGroupElem) = inv(x)*conj(x,y)
#T why needed? GAPGroupElem has x^-1*x^y

"""
    det(x::MatGroupElem)

Return the determinant of the underlying matrix of `x`.

# Examples
```jldoctest
julia> F = GF(4);  g = general_linear_group(2, F);

julia> x = gen(g, 1)
[o   0]
[0   1]

julia> d = det(x)
o

julia> d in F
true
```
"""
det(x::MatGroupElem) = det(matrix(x))

"""
    base_ring(x::MatGroupElem)

Return the base ring of the matrix group to which `x` belongs.
This is also the base ring of the underlying matrix of `x`.

# Examples
```jldoctest
julia> F = GF(4);  g = general_linear_group(2, F);

julia> x = gen(g, 1)
[o   0]
[0   1]

julia> base_ring(x) == F
true

julia> base_ring(x) == base_ring(matrix(x))
true
```
"""
base_ring(x::MatGroupElem) = base_ring(parent(x))

base_ring_type(::Type{<:MatGroupElem{RE}}) where {RE} = parent_type(RE)

parent(x::MatGroupElem) = x.parent

"""
    matrix(x::MatGroupElem)

Return the underlying matrix of `x`.

# Examples
```jldoctest
julia> F = GF(4);  g = general_linear_group(2, F);

julia> x = gen(g, 1)
[o   0]
[0   1]

julia> m = matrix(x)
[o   0]
[0   1]

julia> x == m
false

julia> x == g(m)
true
```
"""
function matrix(x::MatGroupElem)
  if !isdefined(x, :elm)
    x.elm = preimage_matrix(_ring_iso(parent(x)), GapObj(x))
  end
  return x.elm
end

function matrix(x::MatGroupElem{T}) where {T <: Union{ZZRingElem, QQFieldElem}}
  if !isdefined(x, :elm)
    x.elm = matrix(base_ring(x), GapObj(x))
  end
  return x.elm
end

Base.getindex(x::MatGroupElem, i::Int, j::Int) = matrix(x)[i,j]

"""
    number_of_rows(x::MatGroupElem)

Return the number of rows of the underlying matrix of `x`.
"""
number_of_rows(x::MatGroupElem) = number_of_rows(matrix(x))

"""
    number_of_columns(x::MatGroupElem)

Return the number of columns of the underlying matrix of `x`.
"""
number_of_columns(x::MatGroupElem) = number_of_columns(matrix(x))

#
size(x::MatGroupElem) = size(matrix(x))


"""
    tr(x::MatGroupElem)

Return the trace of the underlying matrix of `x`.

# Examples
```jldoctest
julia> F = GF(4);  g = general_linear_group(2, F);

julia> x = gen(g, 1)
[o   0]
[0   1]

julia> t = tr(x)
o + 1

julia> t in F
true
```
"""
tr(x::MatGroupElem) = tr(matrix(x))

#FIXME for the following functions, the output may not belong to the parent group of x
#=
frobenius(x::MatGroupElem, n::Int) = MatGroupElem(parent(x), matrix(base_ring(x), degree(parent(x)), degree(parent(x)), [frobenius(y,n) for y in matrix(x)]))
frobenius(x::MatGroupElem) = frobenius(x,1)

transpose(x::MatGroupElem) = MatGroupElem(parent(x), transpose(matrix(x)))
=#

characteristic_polynomial(R::PolyRing, x::MatGroupElem) = characteristic_polynomial(R, matrix(x))

characteristic_polynomial(x::MatGroupElem) = characteristic_polynomial(matrix(x))

minimal_polynomial(R, x::MatGroupElem) = minimal_polynomial(R, matrix(x))

minimal_polynomial(x::MatGroupElem) = minimal_polynomial(matrix(x))

########################################################################
#
# Methods on groups
#
########################################################################

"""
    base_ring(G::MatGroup)

Return the base ring of the matrix group `G`.

# Examples
```jldoctest
julia> F = GF(4);  g = general_linear_group(2, F);

julia> base_ring(g) == F
true
```
"""
base_ring(G::MatGroup{RE}) where RE <: RingElem = G.ring::parent_type(RE)

base_ring_type(::Type{<:MatGroup{RE}}) where {RE} = parent_type(RE)

"""
    degree(G::MatGroup)

Return the degree of `G`, i.e., the number of rows of its matrices.

# Examples
```jldoctest
julia> degree(GL(4, 2))
4
```
"""
degree(G::MatGroup) = G.deg

Base.one(G::MatGroup) = MatGroupElem(G, identity_matrix(base_ring(G), degree(G)))

function Base.rand(rng::Random.AbstractRNG, G::MatGroup)
   x_gap = GAP.Globals.Random(GAP.wrap_rng(rng), GapObj(G))::GapObj
   return MatGroupElem(G, x_gap)
end

function gens(G::MatGroup)
   if !isdefined(G,:gens)
      L = GAPWrap.GeneratorsOfGroup(GapObj(G))::GapObj
      G.gens = [MatGroupElem(G, a::GapObj) for a in L]
   end
   return G.gens::Vector{elem_type(G)}
end

# Note that the `gen(G::GAPGroup, i::Int)` method cannot be used
# for `MatGroup` because of the `:gens` attribute.
function gen(G::MatGroup, i::Int)
  i == 0 && return one(G)
  L = gens(G)
  0 < i && i <= length(L) && return L[i]
  i < 0 && -i <= length(L) && return inv(L[-i])
  @req false "i must be in the range -$(length(L)):$(length(L))"
end

number_of_generators(G::MatGroup) = length(gens(G))


compute_order(G::GAPGroup) = ZZRingElem(GAPWrap.Size(GapObj(G)))

function compute_order(G::MatGroup{T}) where {T <: Union{AbsSimpleNumFieldElem, QQFieldElem}}
  #=
    - For a matrix group G over the rationals or over a number field,
    the GAP group GapObj(G) does usually not store the flag `IsHandledByNiceMonomorphism`.
    - If we know a reasonable ("nice") faithful permutation action of `G` in advance,
    we can set this flag in `GapObj(G)` to true and store the action homomorphism in `GapObj(G)`,
    and then this information should be used in the computation of the order.
    - If the flag is not known to be true then the Oscar code from
    `isomorphic_group_over_finite_field` shall be preferred.
  =#
  if GAP.Globals.HasIsHandledByNiceMonomorphism(GapObj(G)) && GAPWrap.IsHandledByNiceMonomorphism(GapObj(G))
    # The call to `IsHandledByNiceMonomorphism` triggers an expensive
    # computation of `IsFinite` which we avoid by checking
    # `HasIsHandledByNiceMonomorphism` first.
    return ZZRingElem(GAPWrap.Size(GapObj(G)))
  else
    n = order(isomorphic_group_over_finite_field(G)[1])
    set_order(G, n)
    return n
  end
end

function order(::Type{T}, G::MatGroup) where T <: IntegerUnion
   res = get_attribute!(G, :order) do
     return compute_order(G)
   end::ZZRingElem
   return T(res)::T
end

# Use the reduction to a finite field as a finiteness test.
function is_finite(G::MatGroup{T}) where {T <: Union{AbsSimpleNumFieldElem, QQFieldElem}}
  try
    compute_order(G)
  catch e
    if e isa InfiniteOrderError
      return false
    end
    rethrow()
  end
  return true
end


"""
    map_entries(f, G::MatGroup)

Return the matrix group obtained by applying `f` element-wise to
each generator of `G`.

`f` can be a ring or a field, a suitable map, or a Julia function.

# Examples
```jldoctest
julia> mat = matrix(ZZ, 2, 2, [1, 1, 0, 1]);

julia> G = matrix_group(mat);

julia> G2 = map_entries(x -> -x, G)
Matrix group of degree 2
  over integer ring

julia> is_finite(G2)
false

julia> order(map_entries(GF(3), G))
3
```
"""
function map_entries(f, G::MatGroup)
  Ggens = gens(G)
  if length(Ggens) == 0
    z = f(zero(base_ring(G)))
    return matrix_group(parent(z), degree(G), MatGroupElem[])
  else
    imgs = [map_entries(f, matrix(x)) for x in gens(G)]
    return matrix_group(imgs)
  end
end

function map_entries(R::Ring, G::MatGroup)
  imgs = dense_matrix_type(R)[map_entries(R, matrix(x)) for x in gens(G)]
  return matrix_group(R, degree(G), imgs)
end

function map_entries(mp::Map, G::MatGroup)
  imgs = dense_matrix_type(codomain(mp))[map_entries(mp, matrix(x)) for x in gens(G)]
  return matrix_group(codomain(mp), degree(G), imgs)
end


########################################################################
#
# Constructors
#
########################################################################

function _field_from_q(q::Int)
   flag, n, p = is_prime_power_with_data(q)
   @req flag "The field size must be a prime power"

   return GF(p, n)
end

"""
    general_linear_group(n::Int, q::Int)
    general_linear_group(n::Int, R::Ring)
    GL = general_linear_group

Return the general linear group of dimension `n` over the ring `R` respectively the field `GF(q)`.

Currently `R` must be either a finite field or a residue ring or `ZZ`.

# Examples
```jldoctest
julia> F = GF(7)
Prime field of characteristic 7

julia> H = general_linear_group(2, F)
GL(2,7)

julia> gens(H)
2-element Vector{MatGroupElem{FqFieldElem, FqMatrix}}:
 [3 0; 0 1]
 [6 1; 6 0]

julia> order(general_linear_group(2, residue_ring(ZZ, 6)[1]))
288
```
"""
function general_linear_group(n::Int, R::Ring)
   G = matrix_group(R, n)
   G.descr = :GL
   return G
end

function general_linear_group(n::Int, q::Int)
   return general_linear_group(n, _field_from_q(q))
end

"""
    special_linear_group(n::Int, q::Int)
    special_linear_group(n::Int, R::Ring)
    SL = special_linear_group

Return the special linear group of dimension `n` over the ring `R` respectively the field `GF(q)`.

Currently `R` must be either a finite field or a residue ring or `ZZ`.

# Examples
```jldoctest
julia> F = GF(7)
Prime field of characteristic 7

julia> H = special_linear_group(2, F)
SL(2,7)

julia> gens(H)
2-element Vector{MatGroupElem{FqFieldElem, FqMatrix}}:
 [3 0; 0 5]
 [6 1; 6 0]

julia> order(special_linear_group(2, residue_ring(ZZ, 6)[1]))
144
```
"""
function special_linear_group(n::Int, R::Ring)
   G = matrix_group(R, n)
   G.descr = :SL
   return G
end

function special_linear_group(n::Int, q::Int)
   return special_linear_group(n, _field_from_q(q))
end

"""
    symplectic_group(n::Int, q::Int)
    symplectic_group(n::Int, R::Ring)
    Sp = symplectic_group

Return the symplectic group of dimension `n` over the ring `R` respectively the
field `GF(q)`. The dimension `n` must be even.

Currently `R` must be either a finite field
or a residue ring of prime power order.

# Examples
```jldoctest
julia> F = GF(7)
Prime field of characteristic 7

julia> H = symplectic_group(2, F)
Sp(2,7)

julia> gens(H)
2-element Vector{MatGroupElem{FqFieldElem, FqMatrix}}:
 [3 0; 0 5]
 [6 1; 6 0]

julia> order(symplectic_group(2, residue_ring(ZZ, 4)[1]))
48
```
"""
function symplectic_group(n::Int, R::Ring)
   @req iseven(n) "The dimension must be even"
   G = matrix_group(R, n)
   G.descr = :Sp
   return G
end

function symplectic_group(n::Int, q::Int)
   return symplectic_group(n, _field_from_q(q))
end

"""
    orthogonal_group(e::Int, n::Int, R::Ring)
    orthogonal_group(e::Int, n::Int, q::Int)
    GO = orthogonal_group

Return the orthogonal group of dimension `n` over the ring `R` respectively the
field `GF(q)`, and of type `e`, where `e` in {`+1`,`-1`} for `n` even and `e`=`0`
for `n` odd. If `n` is odd, `e` can be omitted.

Currently `R` must be either a finite field
or a residue ring of odd prime power order.

# Examples
```jldoctest
julia> F = GF(7)
Prime field of characteristic 7

julia> H = orthogonal_group(1, 2, F)
GO+(2,7)

julia> gens(H)
2-element Vector{MatGroupElem{FqFieldElem, FqMatrix}}:
 [3 0; 0 5]
 [0 1; 1 0]

julia> order(orthogonal_group(-1, 2, residue_ring(ZZ, 9)[1]))
24
```
"""
function orthogonal_group(e::Int, n::Int, R::Ring)
   if e==1
      @req iseven(n) "The dimension must be even"
      G = matrix_group(R, n)
      G.descr = Symbol("GO+")
   elseif e==-1
      @req iseven(n) "The dimension must be even"
      G = matrix_group(R, n)
      G.descr = Symbol("GO-")
   elseif e==0
      @req isodd(n) "The dimension must be odd"
      G = matrix_group(R, n)
      G.descr = :GO
   else
      throw(ArgumentError("Invalid description of orthogonal group"))
   end
   return G
end

function orthogonal_group(e::Int, n::Int, q::Int)
   return orthogonal_group(e, n, _field_from_q(q))
end

orthogonal_group(n::Int, R::Ring) = orthogonal_group(0,n,R)
orthogonal_group(n::Int, q::Int) = orthogonal_group(0,n,q)

"""
    special_orthogonal_group(e::Int, n::Int, R::Ring)
    special_orthogonal_group(e::Int, n::Int, q::Int)
    SO = special_orthogonal_group

Return the special orthogonal group of dimension `n` over the ring `R` respectively
the field `GF(q)`, and of type `e`, where `e` in {`+1`,`-1`} for `n` even and
`e`=`0` for `n` odd. If `n` is odd, `e` can be omitted.

Currently `R` must be either a finite field
or a residue ring of odd prime power order.

# Examples
```jldoctest
julia> F = GF(7)
Prime field of characteristic 7

julia> H = special_orthogonal_group(1, 2, F)
SO+(2,7)

julia> gens(H)
3-element Vector{MatGroupElem{FqFieldElem, FqMatrix}}:
 [3 0; 0 5]
 [5 0; 0 3]
 [1 0; 0 1]

julia> order(special_orthogonal_group(-1, 2, residue_ring(ZZ, 9)[1]))
12
```
"""
function special_orthogonal_group(e::Int, n::Int, R::Ring)
   characteristic(R) == 2 && return GO(e,n,R)
   if e==1
      @req iseven(n) "The dimension must be even"
      G = matrix_group(R, n)
      G.descr = Symbol("SO+")
   elseif e==-1
      @req iseven(n) "The dimension must be even"
      G = matrix_group(R, n)
      G.descr = Symbol("SO-")
   elseif e==0
      @req isodd(n) "The dimension must be odd"
      G = matrix_group(R, n)
      G.descr = :SO
   else
      throw(ArgumentError("Invalid description of orthogonal group"))
   end
   return G
end

function special_orthogonal_group(e::Int, n::Int, q::Int)
   return special_orthogonal_group(e, n, _field_from_q(q))
end

special_orthogonal_group(n::Int, R::Ring) = special_orthogonal_group(0,n,R)
special_orthogonal_group(n::Int, q::Int) = special_orthogonal_group(0,n,q)

"""
    omega_group(e::Int, n::Int, R::Ring)
    omega_group(e::Int, n::Int, q::Int)

Return the Omega group of dimension `n` over the ring `R` respectively
the field `GF(q)`, and of type `e`,
where `e` in {`+1`,`-1`} for `n` even and `e`=`0` for `n` odd. If `n` is odd,
`e` can be omitted.

Currently `R` must be either a finite field
or a residue ring of odd prime power order.

# Examples
```jldoctest
julia> F = GF(7)
Prime field of characteristic 7

julia> H = omega_group(1, 2, F)
Omega+(2,7)

julia> gens(H)
1-element Vector{MatGroupElem{FqFieldElem, FqMatrix}}:
 [2 0; 0 4]

julia> order(omega_group(0, 3, residue_ring(ZZ, 9)[1]))
324
```
"""
function omega_group(e::Int, n::Int, R::Ring)
   n==1 && return SO(e,n,R)
   if e==1
      @req iseven(n) "The dimension must be even"
      G = matrix_group(R, n)
      G.descr = Symbol("Omega+")
   elseif e==-1
      @req iseven(n) "The dimension must be even"
      G = matrix_group(R, n)
      G.descr = Symbol("Omega-")
   elseif e==0
      @req isodd(n) "The dimension must be odd"
      G = matrix_group(R, n)
      G.descr = :Omega
   else
      throw(ArgumentError("Invalid description of orthogonal group"))
   end
   return G
end

function omega_group(e::Int, n::Int, q::Int)
   return omega_group(e, n, _field_from_q(q))
end

omega_group(n::Int, q::Int) = omega_group(0,n,q)
omega_group(n::Int, R::Ring) = omega_group(0,n,R)

"""
    unitary_group(n::Int, q::Int)
    GU = unitary_group

Return the unitary group of dimension `n` over the field `GF(q^2)`.

# Examples
```jldoctest
julia> H = unitary_group(2,3)
GU(2,3)

julia> gens(H)
2-element Vector{MatGroupElem{FqFieldElem, FqMatrix}}:
 [o 0; 0 2*o]
 [2 2*o+2; 2*o+2 0]
```
"""
function unitary_group(n::Int, q::Int)
   fl, a, b = is_prime_power_with_data(q)
   @req fl "The field size must be a prime power"
   G = matrix_group(GF(b, 2*a), n)
   G.descr = :GU
   return G
end

"""
    special_unitary_group(n::Int, q::Int)
    SU = special_unitary_group

Return the special unitary group of dimension `n` over the field with `q^2`
elements.

# Examples
```jldoctest
julia> H = special_unitary_group(2,3)
SU(2,3)

julia> gens(H)
2-element Vector{MatGroupElem{FqFieldElem, FqMatrix}}:
 [1 2*o+2; 0 1]
 [0 2*o+2; 2*o+2 0]
```
"""
function special_unitary_group(n::Int, q::Int)
   fl, a, b = is_prime_power_with_data(q)
   @req fl "The field size must be a prime power"
   G = matrix_group(GF(b, 2*a), n)
   G.descr = :SU
   return G
end

const GL = general_linear_group
const SL = special_linear_group
const Sp = symplectic_group
const GO = orthogonal_group
const SO = special_orthogonal_group
const GU = unitary_group
const SU = special_unitary_group

########################################################################
#
# Conjugation
#
########################################################################

function Base.show(io::IO, x::GroupConjClass{T,S}) where T <: MatGroup where S <: MatGroupElem
  show(io, x.repr)
  print(io, " ^ ")
  show(io, x.X)
end

function Base.show(io::IO, x::GroupConjClass{T,S}) where T <: MatGroup where S <: MatGroup
  show(io, x.repr)
  print(io, " ^ ")
  show(io, x.X)
end

function conjugate_group(H::MatGroup, y::MatGroupElem)
   P = Oscar._common_parent_group(H, parent(y))

   if isdefined(H,:gens) && !isdefined(H,:X)
      # define the group using data on the Oscar side
      y = P(y)
      K = matrix_group([P(x)^y for x in H.gens])
   else
      # define the group using data on the GAP side,
      # without creating generators on the Oscar side
      K = _oscar_subgroup(GAP.Globals.ConjugateGroup(GapObj(H), GapObj(y)), P; check = false)
   end

   return K
end
