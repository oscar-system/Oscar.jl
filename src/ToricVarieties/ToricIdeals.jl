@doc Markdown.doc"""
    binomial_exponents_to_ideal(binoms::Union{AbstractMatrix, fmpz_mat})

This function converts the rows of a matrix to binomials. Each row $r$ is
written as $r=u-v$ with $u,v\ge 0$ by splitting into positive and negative
entries. Then the row $r$ corresponds to $x^u-x^v$.  The resulting ideal is
returned.

# Examples
```jldoctest
julia> A = [-1 -1 0 2; 2 3 -2 -1]
2Ã—4 Matrix{Int64}:
 -1  -1   0   2
  2   3  -2  -1

julia> binomial_exponents_to_ideal(A)
ideal(-x[1]*x[2] + x[4]^2, x[1]^2*x[2]^3 - x[3]^2*x[4])
```
"""
function binomial_exponents_to_ideal(binoms::Union{AbstractMatrix, fmpz_mat})
    nvars = ncols(binoms)
    R::FmpqMPolyRing, x = PolynomialRing(QQ, "x" => 1:nvars, cached=false)
    if nrows(binoms) == 0
        return ideal([zero(R)])
    end
    terms = Vector{fmpq_mpoly}(undef, nrows(binoms))
    for i in 1:nrows(binoms)
        binom = binoms[i, :]
        xpos = one(R)
        xneg = one(R)
        for j in 1:nvars
            if binom[j] < 0
                xneg = xneg * x[j]^(-binom[j])
            elseif binom[j] > 0
                xpos = xpos * x[j]^(binom[j])
            end
        end
        terms[i] = xpos-xneg
    end
    return ideal(terms)
end
export binomial_exponents_to_ideal


@doc Markdown.doc"""
    toric_ideal(pts::AbstractMatrix)

Return the toric ideal generated from the linear relations between the points
`pts`. This is the ideal generated by the set of binomials
$$\{x^u-x^v\ |\ u,v\in\mathbb{Z}^n_{\ge 0}\ (pts)^T\cdot(u-v)=0\}$$

# Examples
```jldoctest
julia> C = positive_hull([-2 5; 1 0]);

julia> H = hilbert_basis(C).m;

julia> toric_ideal(H)
ideal(x[2]*x[3] - x[4]^2, -x[1]*x[3] + x[2]^2*x[4], -x[1]*x[4] + x[2]^3, -x[1]*x[3]^2 + x[2]*x[4]^3, -x[1]*x[3]^3 + x[4]^5)
```
"""
function toric_ideal(pts::Union{AbstractMatrix, fmpz_mat})
    intkernel = kernel(matrix(ZZ, pts), side=:left)
    intkernel = intkernel[2]
    presat = binomial_exponents_to_ideal(intkernel)
    J = ideal([prod(gens(base_ring(presat)))])
    return saturation(presat, J)
end


@doc Markdown.doc"""
    toric_ideal(antv::AffineNormalToricVariety)

Return the toric ideal defining the affine normal toric variety.

# Examples
Take the cone over the square at height one. The resulting toric variety has
one defining equation. In projective space this corresponds to
$\mathbb{P}^1\times\mathbb{P}^1$. Note that this cone is self-dual, the toric
ideal comes from the dual cone.
```jldoctest
julia> C = positive_hull([1 0 0; 1 1 0; 1 0 1; 1 1 1])
A polyhedral cone in ambient dimension 3

julia> antv = AffineNormalToricVariety(C)
A normal toric variety corresponding to a polyhedral fan in ambient dimension 3

julia> toric_ideal(antv)
ideal(-x[1]*x[2] + x[3]*x[4])
```
"""
function toric_ideal(antv::AffineNormalToricVariety)
    cone = Cone(pm_object(antv).WEIGHT_CONE)
    return toric_ideal(hilbert_basis(cone).m)
end
export toric_ideal
toric_ideal(ntv::NormalToricVariety) = toric_ideal(AffineNormalToricVariety(ntv))



