################################################################################
#
#  Tropical Groebner bases
#  =======================
#
#  For a definition of tropical Groebner basis see Section 2.4 in:
#    D. Maclagan, B. Sturmfels: Introduction to tropical geometry
#  To see how they can be computed using standard bases see:
#    T. Markwig, Y. Ren: Computing tropical varieties over fields with valuation
#
################################################################################



################################################################################
#
#  Caching of polynomial rings
#
#  Tropical Groebner basis computations are done via standard basis computations
#  in a different polynomial ring (that depends on the valuation). We cache
#  these polynomial rings as a dictionary in the original polynomial ring
#
################################################################################
function get_polynomial_ring_for_groebner_simulation(R::MPolyRing, nu::TropicalSemiringMap)
    @req coefficient_ring(R)==domain(nu) "coefficient ring is not valued field"

    if !has_attribute(R, :tropical_geometry_polynomial_rings_for_groebner)
        set_attribute!(R, :tropical_geometry_polynomial_rings_for_groebner, Dict{TropicalSemiringMap,MPolyRing}())
    end

    polynomialRingsForGroebner = get_attribute(R, :tropical_geometry_polynomial_rings_for_groebner)
    return get!(polynomialRingsForGroebner, nu, first(polynomial_ring(valued_ring(nu),vcat([:tsim],symbols(R)); cached=false)))
end

# special function for trivial valuation to ensure reusing original ring
function get_polynomial_ring_for_groebner_simulation(R::MPolyRing, nu::TropicalSemiringMap{K,Nothing,minOrMax}) where {K<:Field, minOrMax<:Union{typeof(min),typeof(max)}}
    @req coefficient_ring(R)==domain(nu) "coefficient ring is not valued field"
    return R
end

function get_polynomial_ring_for_groebner_desimulation(S::MPolyRing, nu::TropicalSemiringMap)
    @req coefficient_ring(S)==valued_ring(nu) "coefficient ring is not valued ring"

    polynomialRingsForGroebner = get_attribute(S, :tropical_geometry_polynomial_rings_for_groebner)
    R = findfirst(isequal(S), polynomialRingsForGroebner)
    @req !isnothing(R) error("no polynomial ring for groebner basis desimulation cached")
    return R
end

# special function for trivial valuation to ensure reusing original ring
function get_polynomial_ring_for_groebner_desimulation(S::MPolyRing, nu::TropicalSemiringMap{K,Nothing,minOrMax}) where {K<:Field, minOrMax<:Union{typeof(min),typeof(max)}}
    @req coefficient_ring(S)==valued_ring(nu) "coefficient ring is not valued ring"
    return S
end


################################################################################
#
#  Simulating and desimulating valuations
#
################################################################################
@doc raw"""
    simulate_valuation(I::MPolyIdeal, nu::TropicalSemiringMap)

Given an ideal `I` in variables x1, ..., xn over a field with a tropical semiring map `nu`, return an ideal `sI` in variables tsim, x1, ..., xn such that tropical Groebner bases of `I` with respect to a weight vectors `w` correspond to standard bases of `sI` with respect to `(-1,-w)` (min-convention) or `(-1,w)` (max-convention).

# Example ($p$-adic)
```jldoctest
julia> nu_2 = tropical_semiring_map(QQ,2);

julia> Kx,(x1,x2,x3) = polynomial_ring(QQ,3);

julia> I = ideal([x1+2*x2,x2+2*x3]);

julia> simulate_valuation(I,nu_2)
Ideal generated by
  -tsim + 2
  tsim*x2 + x1
  tsim*x3 + x2

```

# Example ($t$-adic)
```jldoctest
julia> K,s = rational_function_field(GF(2),"s");

julia> nu_s = tropical_semiring_map(K,s);

julia> s = Oscar.valued_ring(nu_s)(s);

julia> Kx,(x1,x2,x3) = polynomial_ring(K,3);

julia> I = ideal([x1+s*x2,x2+s*x3]);

julia> simulate_valuation(I,nu_s)
Ideal generated by
  tsim + s
  tsim*x2 + x1
  tsim*x3 + x2

```
"""
function simulate_valuation(I::MPolyIdeal, nu::TropicalSemiringMap)

    G = gens(I)
    @req !isempty(G) "input ideal empty"

    R = base_ring(I)
    S = get_polynomial_ring_for_groebner_simulation(R, nu)
    t = first(gens(S))

    sG = [uniformizer(nu)-t]
    for fR in clear_coefficient_denominators.(G)
        fS = MPolyBuildCtx(S)
        for (cR,expvR) = zip(coefficients(fR),exponents(fR))
            cS = numerator(cR)       # coefficient in R
            expvS = vcat(0,expvR)  # exponent vector in R[t,x1,...,xn]
            push_term!(fS,cS,expvS)
        end
        push!(sG,tighten_simulation(finish(fS),nu))
    end

    return ideal(S,sG)
end
function clear_coefficient_denominators(f::MPolyRingElem)
    return lcm(denominator.(coefficients(f)))*f
end
# if valuation trivial, do nothing
function simulate_valuation(I::MPolyIdeal, ::TropicalSemiringMap{K,Nothing,<:Union{typeof(min),typeof(max)}}) where {K}
    return I
end



@doc raw"""
    tighten_simulation(f::MPolyRingElem, nu::TropicalSemiringMap)

Given a polynomial `f` in the simulation ring, "replace" the uniformizer with the first variable `tsim`, and divide by the gcd of all coefficients and the highest possible power of `tsim`.  The result is a polynomial whose coefficient valuations have been encoded in the exponents of `tsim`.

# Example ($p$-adic)
```jldoctest
julia> nu_2 = tropical_semiring_map(QQ,2)
Map into Min tropical semiring encoding the 2-adic valuation on Rational field

julia> Rtx,(p,x1,x2,x3) = Oscar.valued_ring(nu_2)[:p,:x1,:x2,:x3]
(Multivariate polynomial ring in 4 variables over ZZ, ZZMPolyRingElem[p, x1, x2, x3])

julia> f = x1+p*x1+p^2*x1+2^2*x2+p*x2+p^2*x2+x3
p^2*x1 + p^2*x2 + p*x1 + p*x2 + x1 + 4*x2 + x3

julia> Oscar.tighten_simulation(f,nu_2)
5*p*x2 + 7*x1 + x3

julia> Oscar.tighten_simulation(2^3*f,nu_2)
5*p*x2 + 7*x1 + x3

julia> Oscar.tighten_simulation(p^3*f,nu_2)
5*p*x2 + 7*x1 + x3

```

# Example ($t$-adic)
```jldoctest
julia> K,s = rational_function_field(GF(2),"s");

julia> nu_s = tropical_semiring_map(K,s);

julia> s = Oscar.valued_ring(nu_s)(s);

julia> Rtx,(t,x1,x2,x3) = Oscar.valued_ring(nu_s)["t","x1","x2","x3"];

julia> f = x1+t*x1+t^2*x1+s^2*x2+t*x2+t^2*x2+x3
t^2*x1 + t^2*x2 + t*x1 + t*x2 + x1 + s^2*x2 + x3

julia> Oscar.tighten_simulation(f,nu_s)
t*x2 + (s^2 + s + 1)*x1 + x3

julia> Oscar.tighten_simulation(s^3*f,nu_s)
t*x2 + (s^2 + s + 1)*x1 + x3

julia> Oscar.tighten_simulation(t^3*f,nu_s)
t*x2 + (s^2 + s + 1)*x1 + x3

```
"""
function tighten_simulation(f::MPolyRingElem, nu::TropicalSemiringMap)
    # substitute first variable tsim by uniformizer_ring
    # so that all monomials have distinct x-monomials
    f = evaluate(f,[1],[uniformizer(nu)])

    # divide f by the gcd of its coefficients
    f /= gcd(collect(coefficients(f)))

    # undo previous substitution by replace uniformizer with first variable
    sf = MPolyBuildCtx(parent(f))
    for (c,alpha) in zip(coefficients(f),exponents(f))
        d = Int(nu(c); preserve_ordering=true)
        c /= uniformizer(nu)^d  # divide uniformizer out of coefficient
        alpha[1] += d           # increase exponent in tsim instead
        push_term!(sf,c,alpha)
    end
    return finish(sf)
end
# if valuation trivial, do nothing
function tighten_simulation(f::MPolyRingElem, ::TropicalSemiringMap{K,Nothing,minOrMax}) where {K, minOrMax<:Union{typeof(min),typeof(max)}}
    return f
end



@doc raw"""
    simulate_valuation(w::AbstractVector{<:Union{QQFieldElem,ZZRingElem,Rational,Integer}}, nu::TropicalSemiringMap{K,p,<:Union{typeof(min),typeof(max)}) where {K,p}

Return an integer vector `wSim` so that the (tropical) Groebner basis of an ideal `I` with respect to `w` corresponds to the standard basis of its simulation with respect to `wSim`.  If `perturbation!=nothing`, also returns a corresponding `perturbationSim`.

# Examples
```jldoctest
julia> nuMin = tropical_semiring_map(QQ,2);

julia> nuMax = tropical_semiring_map(QQ,2,max);

julia> w = QQFieldElem[1,1];

julia> simulate_valuation(w,nuMin)
3-element Vector{QQFieldElem}:
 -1
 -1
 -1

julia> simulate_valuation(w,nuMax)
3-element Vector{QQFieldElem}:
 -1
 1
 1

```
"""
function simulate_valuation(w::AbstractVector{QQFieldElem}, ::TropicalSemiringMap{K,p,typeof(min)}) where {K,p}
    sw = vcat(one(QQ),w)          # prepend +1 to the vector
    sw .*= -lcm(denominator.(w))  # scale vector to make entries integral
                                  # negate vector to convert to max convention for Singular
    return sw
end
function simulate_valuation(w::AbstractVector{QQFieldElem}, ::TropicalSemiringMap{K,p,typeof(max)}) where {K,p}
    sw = vcat(-one(QQ),w)        # prepend -1 to the vector
    sw .*= lcm(denominator.(w))  # scale vector to make entries integral
    return sw
end
# if valuation is trivial, just flip sign depending on convention
function simulate_valuation(w::AbstractVector{QQFieldElem}, ::TropicalSemiringMap{K,Nothing,typeof(min)}) where {K}
    return -w
end
function simulate_valuation(w::AbstractVector{QQFieldElem}, ::TropicalSemiringMap{K,Nothing,typeof(max)}) where {K}
    return w
end



@doc raw"""
    desimulate_valuation(sG::AbstractVector{<:MPolyRingElem}, nu::TropicalSemiringMap, R::MPolyRing)

Given a generating set `sG` of the simulation ideal, reconstruct a generating set of the original ideal.  In particular, given a standard basis of the simulation ideal with respect to `wSim`, return the (tropical) Groebner basis of the original ideal with respect to `w`.

# Example ($p$-adic)
```jldoctest
julia> nu_2 = tropical_semiring_map(QQ,2);

julia> Kx,(x1,x2,x3) = polynomial_ring(QQ,3);

julia> I = ideal(Kx,[x1+2*x2,x2+2*x3])
Ideal generated by
  x1 + 2*x2
  x2 + 2*x3

julia> sG = gens(simulate_valuation(I,nu_2))
3-element Vector{ZZMPolyRingElem}:
 -tsim + 2
 tsim*x2 + x1
 tsim*x3 + x2

julia> desimulate_valuation(sG,nu_2,Kx)
2-element Vector{QQMPolyRingElem}:
 x1 + 2*x2
 x2 + 2*x3

```
"""
function desimulate_valuation(sG::AbstractVector{<:MPolyRingElem}, nu::TropicalSemiringMap, R::MPolyRing)
    S = parent(first(sG))

    # map everything from simulation ring to the specified polynomial ring
    # whilst substituting first variable tsim by uniformizer
    desimulation_map = hom(S, R, domain(nu), vcat(uniformizer_field(nu),gens(R)))
    G = desimulation_map.(sG)
    # filter for nonzero elements
    G = filter(!iszero,G)
    return G
end

# if valuation trivial, do nothing
function desimulate_valuation(sG::AbstractVector{<:MPolyRingElem}, ::TropicalSemiringMap{K,Nothing,minOrMax}, R::MPolyRing) where {K,minOrMax<:Union{typeof(min),typeof(max)}}
    return sG
end



@doc raw"""
    desimulate_valuation(sw::AbstractVector, nu::TropicalSemiringMap{K,p,typeof(min)}) where {K,p}

Given a weight vector `wSim` on the simulation ring, return weight vector `w` on the original polynomial ring so that a standard basis with respect to `wSim` corresponds to a (tropical) Groebner basis with respect to `w`.

# Examples
```jldoctest
julia> nuMin = tropical_semiring_map(QQ,2);

julia> nuMax = tropical_semiring_map(QQ,2,max);

julia> w = QQFieldElem[1,1];

julia> sw = simulate_valuation(w,nuMin);

julia> desimulate_valuation(sw, nuMin)
2-element Vector{QQFieldElem}:
 1
 1

julia> sw = simulate_valuation(w,nuMax);

julia> desimulate_valuation(sw, nuMax)
2-element Vector{QQFieldElem}:
 1
 1

```
"""
function desimulate_valuation(sw::AbstractVector{QQFieldElem}, ::TropicalSemiringMap{K,p,typeof(min)}) where {K,p}
    @req sw[1]<0 "invalid simulated weight vector"
    # scale the vector so that first entry is 1, then remove first entry
    w = sw[2:end] ./ sw[1]
    return w
end
function desimulate_valuation(sw::AbstractVector{QQFieldElem}, ::TropicalSemiringMap{K,p,typeof(max)}) where {K,p}
    @req sw[1]<0 "invalid simulated weight vector"
    # scale the vector so that first entry is -1, then remove first entry
    w = sw[2:end] ./ -sw[1]
    return w
end
# if trivial valuation, just flip sign depending on convention
function desimulate_valuation(sw::AbstractVector{QQFieldElem}, ::TropicalSemiringMap{K,Nothing,typeof(min)}) where {K}
    return sw
end
function desimulate_valuation(sw::AbstractVector{QQFieldElem}, ::TropicalSemiringMap{K,Nothing,typeof(max)}) where {K}
    return sw
end



################################################################################
#
#  (Tropical) Groebner bases
#
################################################################################
@doc raw"""
    groebner_basis(I::MPolyIdeal, nu::TropicalSemiringMap, w::AbstractVector{<:Union{QQFieldElem,ZZRingElem,Rational,Integer}})

Return a (tropical) Groebner basis of `I` with respect to the tropical semiring map `nu` and weight vector `w`.

# Examples
```jldoctest
julia> R,(x,y) = QQ[:x, :y];

julia> I = ideal([x^3-5*x^2*y,3*y^3-2*x^2*y]);

julia> nu = tropical_semiring_map(QQ,2);

julia> w = [0,0];

julia> groebner_basis(I,nu,w)
2-element Vector{QQMPolyRingElem}:
 -2*x^2*y + 3*y^3
 2*x^3 - 2*x^2*y - 12*y^3

```
"""
function groebner_basis(I::MPolyIdeal, nu::TropicalSemiringMap, w::AbstractVector{<:Union{QQFieldElem,ZZRingElem,Rational,Integer}})
    @req domain(nu) isa Field "valuation must be defined on a field"
    @req domain(nu)==coefficient_ring(I) "coefficient ring of ideal does not match valued field of valuation"

    G = gens(I)
    if isone(length(G)) # for principal ideals, just return generator
        return G
    end

    requiresHomogenization = !is_trivial(nu) || !all(is_positive,w)
    if requiresHomogenization
        I,_,dehomogenizationMap = homogenize_pre_tropicalization(I)
        w = vcat(0,w)
    end

    Isim = simulate_valuation(I,nu)
    wSim = simulate_valuation(QQ.(w),nu)
    oSim = weight_ordering(Int.(wSim),default_ordering(base_ring(Isim)))
    Gsim = standard_basis(Isim; ordering = oSim)
    G = desimulate_valuation(gens(Gsim),nu,base_ring(I))

    if requiresHomogenization
        G = dehomogenizationMap.(G)
    end

    return G
end
