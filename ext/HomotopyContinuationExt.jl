module HomotopyContinuationExt

using Oscar, HomotopyContinuation

import HomotopyContinuation: HomotopyContinuation, Variable, Expression, System, witness_set

@doc raw"""
    Expression(f::QQMPolyRingElem)

Takes a polynomial `f` an `QQMPolyRingElem` and converts it into a
`HomotopyContinuation.Expression`. The `HomotopyContinuation.Variable`
objects used in the expression have the same names as the generators
in the `parent(f)` (including brackets as in `x[1]`).

# Examples
```julia-repl
julia> Qxy, (x, y) = QQ[:x, :y]
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> p = x* y^2 + x^2
x^2 + x*y^2

julia> Expression(p)
1.0*x*y^2 + 1.0*x^2
```
"""
function Expression(f::QQMPolyRingElem)
  # Get a list of HomotopyContinuation variables whose names are the
  # same as the ones in the Oscar polynomial f.
  v = Variable.(symbols(parent(f)))
  # Make the HomotopyContinuation expression
  return sum(Float64(c) * prod(v[i]^e for (i,e) in enumerate(a)) for (c,a) in coefficients_and_exponents(f))
end

@doc raw"""
    System(I::MPolyIdeal{QQMPolyRingElem}; args...)
    System(I::Vector{QQMPolyRingElem}; args...)

Takes an `MPolyIdeal` and turns it into a `HomotopyContinuation.System`
containing the ideal generators. It forwards all `args` to `HomotopyContinuation.System`.

# Examples
```julia-repl
julia> Qxy, (x, y) = QQ[:x, :y]
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal([x^2 - x * y, y^2 - x])
Ideal generated by
  x^2 - x*y
  -x + y^2

julia> System(I)
System of length 2
 2 variables: x, y

 -1.0*x*y + 1.0*x^2
 -1.0*x + 1.0*y^2

julia> System(gens(I))
System of length 2
 2 variables: x, y

 -1.0*x*y + 1.0*x^2
 -1.0*x + 1.0*y^2
```
"""
System(I::Vector{QQMPolyRingElem}; args...) = System(Expression.(I); args...)
System(I::MPolyIdeal{QQMPolyRingElem}; args...) = System(gens(I); args...)

function Oscar.solve_numerical(I::Vector{QQMPolyRingElem}; show_progress=false, args...)
  return HomotopyContinuation.solve(System(Expression.(I), args...), show_progress=show_progress)
end
                                    
function Oscar.solve_numerical(I::MPolyIdeal{QQMPolyRingElem}; args...)
  return solve_numerical(gens(I); args...)
end

"""
    witness_set(I::Vector{QQMPolyRingElem}; show_progress=false, args...)
    witness_set(I::MPolyIdeal{QQMPolyRingElem}; show_progress=false, args...)

Creates a `HomotopyContinuation.WitnessSet`.

# Examples
```julia-repl
julia> Qxy, (x, y) = QQ[:x, :y]
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal([x^2 - x * y + x * y^3])
Ideal generated by
  x^2 + x*y^3 - x*y

julia> witness_set(I)
Witness set for dimension 1 of degree 4
```
"""
witness_set(I::Vector{QQMPolyRingElem}; show_progress=false, args...) = witness_set(System(I); show_progress, args...)
witness_set(I::MPolyIdeal{QQMPolyRingElem}; show_progress=false, args...) = witness_set(gens(I); show_progress, args...)

function Oscar.dim_numerical(I::Vector{QQMPolyRingElem})
  # This is provided by HomotopyContinuation.jl and computes the
  # dimension based on the Jacobian rank at a random point.
  F = System(I)
  return HomotopyContinuation.nvariables(F) - rank(HomotopyContinuation.fixed(F))
end

Oscar.dim_numerical(I::MPolyIdeal{QQMPolyRingElem}) = Oscar.dim_numerical(gens(I))

end
