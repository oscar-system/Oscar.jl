@testset "Laurent" begin
  for K in [QQ, GF(5)]
    Kx, x = laurent_polynomial_ring(K, 2, :x)
    I = ideal(Kx, [x[1]])
    @test gens(I) == [x[1]]
    @test one(Kx) in I
    @test x[1]^-1 in I
    @test base_ring(I) === Kx
    _Kx, _x = laurent_polynomial_ring(K, 3, :xx)
    @test !(_x[1] in I)

    f = hom(Kx, K, [K(2), K(3)])
    @test domain(f) === Kx
    @test codomain(f) === K
    @test f(x[1]^-1 + x[2]) == K(2)^-1 + K(3)

    @test_throws ArgumentError hom(Kx, ZZ, [ZZ(2), ZZ(3)])

    Ky, y = polynomial_ring(K, 2, :y)
    f = hom(Ky, Kx, gens(Kx))
    @test f(y[1]) == x[1]
    @test preimage(f, I) == ideal(Ky, [one(Ky)])

    f = hom(Ky, Kx, reverse(gens(Kx)))
    @test f(y[1]) == x[2]
    @test preimage(f, I) == ideal(Ky, [one(Ky)])

    Q, = quo(Ky, ideal(Ky, [y[1] * y[2] - 1]))
    f = hom(Kx, Q, gens(Q))
    for q in gens(Q)
      @test f(preimage(f, q)) == q
    end
  end
end


@testset "Laurent quotient" begin
  # Quick test

  # Taken from issue 4814 (suggested by thofman)

  R, (x, y) = laurent_polynomial_ring(GF(2), [:x, :y]);
  f1 = x^2*y^3 + x*y^3 + 1;
  f2 = y + y^2 + x^3;
  f3 = x^9 * y^6 - 1;
  f4 = y^15 - 1;
  I = ideal(R, [f1, f2, f3, f4]);

  Q,phi = quo(R, I); # same as R/ideal(x^2+x+1, y^2+y+1)

  @test parent(phi(x)) == Q;
  @test parent(phi(y)) == Q;
  @test is_one(phi(x^3));
  @test is_one(phi(x)^3);
  @test is_one(phi(y^3));
  @test is_one(phi(y)^3);
  @test in(preimage(phi,phi(x)) - x, I);
  @test preimage(phi,phi(x)) == 1+x^(-1); # would be "more natural" if underlying ring had elim order for the inverses


  # Ideal generated by non-polynomials
  R, (x, y) = laurent_polynomial_ring(QQ, [:x, :y]);
  C10 = x^2 -x +1 -x^(-1) +x^(-2);
  C28 = y^6 -y^4 +y^2 -1 +y^(-2) -y^(-4) +y^(-6);
  J = ideal(R, [C10,C28]);
  Q,phi = quo(R,J);
  u = phi(x^(-1)*y^3);
  @test is_unit(u)
  @test is_unit(u^(-1))
  @test is_one(u^140)
  @test !is_one(u^70)
  @test !is_one(u^28)
  @test !is_one(u^20)
  # Known problems:
  # u^(-1)   # printed form is ugly
  # 1/u      # StackOverflowError
end
