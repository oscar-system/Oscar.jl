```@meta
CurrentModule = Oscar
CollapsedDocStrings = true
DocTestSetup = Oscar.doctestsetup()
```

# Basics

## [Elements of groups](@id elements_of_groups)

Given a group `G`, it is always possible to have access to some particular elements.

```@docs
elem_type(::Type{T}) where T <: GAPGroup
one(x::GAPGroup)
one(x::GAPGroupElem)
is_finite_order(x::GAPGroupElem)
gens(::GAPGroup)
has_gens(::GAPGroup)
number_of_generators(G::GAPGroup)
gen(::GAPGroup, i::Int)
small_generating_set(G::GAPGroup)
minimal_size_generating_set(G::GAPGroup)
Base.rand(G::GAPGroup)
rand_pseudo(G::GAPGroup)
```

It is also possible to obtain the generators of `G` by typing
```julia
f1,f2,f3 = gens(G)
```
This is equivalent to
```julia
f1=G[1]; f2=G[2]; f3=G[3];
```

For a group `G` that has been created as a subgroup of another group,
generated by a list `L` of elements, `gens(G)` is equal to `L`.

## Operations on group elements

OSCAR supports the following operations and functions on group elements.

* `*`, multiplication between two elements in a group.
* `inv(x)` and `x^-1`, the inverse of `x`.
* `x/y`, the element `x y^-1`.
* `x^n`, the `n`-th power of `x`;
  if `n == 0`, the identity of the group is returned;
  if `n < 0`, the `-n`-th power of the inverse of `x` is returned.
* `isone(x)` returns whether `x` is the identity of the group.
* `conj(x,y)` and `x^y`, the conjugate of `x` by `y`,
  i.e., the element `y^-1 x y`.
* `comm(x,y)`, the commutator of `x` and `y`,
  i.e., the element `x^-1 y^-1 x y`.

!!! note
    In OSCAR, the expression `x^y^z` is equivalent to `x^(y^z)`.
    In other words, conjugations are evaluated from the right to the left.

```@docs
comm(x::GAPGroupElem, y::GAPGroupElem)
```

## Properties of groups

```@docs
is_abelian(G::GAPGroup)
is_almost_simple(G::GAPGroup)
is_cyclic(G::GAPGroup)
is_dicyclic_group
is_dihedral_group
is_elementary_abelian(G::GAPGroup)
is_extraspecial_group
is_finite(G::GAPGroup)
is_finitely_generated(G::GAPGroup)
is_nilpotent(G::GAPGroup)
is_perfect(G::GAPGroup)
is_pgroup(G::GAPGroup)
is_pgroup_with_prime(::Type{T}, G::GAPGroup) where T <: IntegerUnion
is_quasisimple(G::GAPGroup)
is_simple(G::GAPGroup)
is_solvable(G::GAPGroup)
is_sporadic_simple(G::GAPGroup)
is_supersolvable(G::GAPGroup)
is_trivial(G::GAPGroup)
```


## Attributes of groups

```@docs
order(::Type{T}, x::Union{GAPGroupElem, GAPGroup}) where T <: IntegerUnion
abelian_invariants(G::GAPGroup)
abelian_invariants_schur_multiplier(G::GAPGroup)
abelian_invariants(v::Vector{S}) where S <: IntegerUnion
elementary_divisors(v::Vector{S}) where S <: IntegerUnion
cyclic_generator(G::GAPGroup)
exponent(G::GAPGroup)
describe(G::GAPGroup)
nilpotency_class(G::GAPGroup)
prime_of_pgroup
derived_length
schur_cover(G::GAPGroup)
schur_multiplier(G::Union{GAPGroup, FinGenAbGroup})
```

## Technicalities

```@docs
GAPGroup
BasicGAPGroupElem{T<:GAPGroup}
```
