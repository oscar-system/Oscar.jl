```@meta
CurrentModule = Oscar
CollapsedDocStrings = true
DocTestSetup = Oscar.doctestsetup()
```

# Localized Rings and Their Ideals

We recall the definition of localization. All rings considered are commutative,  with multiplicative identity 1.
Let ``R`` be a ring, and let ``U \subset R`` be a *multiplicatively closed subset.* That is,
```math
1 \in U  \;\text{ and }\;  u, v \in U \;\Rightarrow \; u\cdot v \in U.
```
Consider the equivalence relation on ``R\times U`` defined by setting
```math
(r,u)\sim (r', u') \;\text{ iff }\; v(r u'-u r')=0 \;{\text{ for some }}\; v\in U.
```
Write ``\frac{r}{u}`` for the equivalence class of ``(r, u)`` and ``R[U^{-1}]`` for the set of all equivalence classes.
Mimicking the standard arithmetic for fractions, ``R[U^{-1}]`` can be made into a ring. This ring is called the
*localization of ``R`` at ``U``*. It comes equipped with  the natural ring homomorphism
```math
\iota : R\to R[U^{-1}],\; r \mapsto \frac{r}{1}.
```
Given an ``R``-module ``M``, the analogous construction yields an ``R[U^{-1}]``-module ``M[U^{-1}]`` which is
called the *localization  of ``M`` at ``U``*. See the section on [modules](@ref modules_multivariate).

Our focus in this section is on localizing both multivariate polynomial rings and quotients of multivariate
polynomial rings by ideals. The starting point for this is to provide functionality for handling (several types of)
multiplicatively closed subsets of multivariate polynomial rings. Given such a polynomial ring `R` and a
multiplicatively closed subset `U` of `R` whose type is supported by OSCAR, entering `localization(R, U)`
creates the localization, say,  `RL` of `R` at `U`.

Given a quotient `RQ` of `R` by an ideal, with projection map `p` : `R` ``\to`` `RQ`, and given a multiplicatively closed
subset `U` of `R`, entering `localization(RQ, U)` creates the localization, say,  `RQL` of `RQ` at `p(U)`: Since
every multiplicatively closed subset of `RQ` is of type `p(U)` for some `U`, there is no need to support an extra
type for multiplicatively closed subsets of quotients.

Since localization commutes with passing to quotients by ideals, there is also no need to support an extra type
for forming quotients of localized rings:
```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);

julia> I = ideal(R, [2*x^2-y^3, 2*x^2-y^5])
Ideal generated by
  2*x^2 - y^3
  2*x^2 - y^5

julia> U = complement_of_point_ideal(R, [0, 0])
Complement
  of maximal ideal corresponding to rational point with coordinates (0, 0)
  in multivariate polynomial ring in 2 variables over QQ

julia> RQ, _ = quo(R, I);

julia> RQL, _ = localization(RQ, U);

julia> RL, iota = localization(R, U);

julia> RLQ, _ = quo(RL, iota(I));

julia> typeof(RLQ) == typeof(RQL)
true

```

!!! note
    Most functions described here rely on the computation of standard bases. Recall that OSCAR
    supports standard bases for multivariate polynomial rings over fields (exact fields supported by OSCAR) and
    for multivariate polynomial rings over the integers.

## Types

The OSCAR types discussed in this section are all parametrized. To simplify the presentation,
details on the parameters are omitted.

All types for multiplicatively closed subsets of rings belong to the abstract type `AbsMultSet`.
For multiplicatively closed subsets of multivariate polynomial rings, there are the abstract subtype
`AbsMPolyMultSet` and its concrete descendants

- `MPolyComplementOfKPointIdeal`, `MPolyComplementOfPrimeIdeal`, `MPolyPowersOfElement`, and
- `MPolyProductOfMultSets` to model products of multiplicatively closed sets already given.

The general abstract type for localizations of rings is `AbsLocalizedRing`. For localizations of multivariate
polynomial rings, there is the concrete subtype `MPolyLocRing`. For localizations of quotients of
multivariate polynomial rings, there is the concrete subtype `MPolyQuoLocRing`.

## Constructors

### Multiplicatively Closed Subsets

In accordance with the above mentioned types, we have the following constructors
for multiplicatively closed subsets of multivariate polynomial rings.

```@docs
complement_of_point_ideal(R::MPolyRing, a::Vector)
complement_of_prime_ideal(P::MPolyIdeal; check::Bool=false)
powers_of_element(f::MPolyRingElem)
product(T::AbsMPolyMultSet, U::AbsMPolyMultSet)
```

### Localized Rings

```@docs
localization(R::MPolyRing, U::AbsMPolyMultSet)
```

```@docs
localization(RQ::MPolyQuoRing, U::AbsMPolyMultSet)
```

## Tests on Multiplicatively Closed Subsets

Being able to check membership in multiplicatively closed subsets is
indispensable to our way of implementing localization:

```@docs
in(f::MPolyRingElem, U::AbsMPolyMultSet)
```

## Data associated to Localized Rings

If `RL` is the localization of a multivariate polynomial ring `R`  at a multiplicatively closed subset
`U` of `R`, then

- `base_ring(RL)` refers to `R`, and
- `inverted_set(RL)` to `U`.

If `RQ` is a quotient of a multivariate polynomial ring `R`, `p` : `R` ``\to`` `RQ` is the projection map, `U`  is a
multiplicatively closed subset of `R`, and `RQL` is the localization of `RQ` at `p(U)`, then

- `base_ring(RQL)` refers to `R`, and
- `inverted_set(RQL)` to `U`.

This reflects the way of creating localizations of quotients of multivariate polynomial rings in OSCAR.

Entering `gens(RL)` and `gens(RQL)`, we get the images of the generators of `R` in `RL` and `RQL`, respectively.
These images print as do the original generators.

Entering `dim(RL)` and `dim(RQL)`, we get the respective Krull dimensions.

##### Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> P = ideal(R, [x])
Ideal generated by
  x

julia> U = complement_of_prime_ideal(P)
Complement
  of prime ideal (x)
  in multivariate polynomial ring in 3 variables over QQ

julia> RL, _ = localization(U);

julia> R === base_ring(RL)
true

julia> U === inverted_set(RL)
true

julia> dim(RL)
1

```

```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);

julia> I = ideal(R, [2*x^2-y^3, 2*x^2-y^5])
Ideal generated by
  2*x^2 - y^3
  2*x^2 - y^5

julia> U = complement_of_point_ideal(R, [0, 0])
Complement
  of maximal ideal corresponding to rational point with coordinates (0, 0)
  in multivariate polynomial ring in 2 variables over QQ

julia> RQ, _ = quo(R, I);

julia> RQL, _ = localization(RQ, U);

julia> R == base_ring(RQL)
true

julia> U == inverted_set(RQL)
true

julia> dim(RQL)
0

```

Furthermore, we have:

```@docs
monomial_basis(A::MPolyQuoLocRing{<:Field, <:Any, <:Any, <:Any, <:MPolyComplementOfKPointIdeal})
```

## Elements of Localized Rings

### Types

The general abstract type for elements of localized rings is `AbsLocalizedRingElem`.
For elements of localizations of multivariate polynomial rings, there is the concrete subtype `MPolyLocRingElem`.
For elements of localizations of quotients of multivariate polynomial rings, there is the concrete subtype `MPolyQuoLocRingElem`.

### Creating Elements of Localized Rings

If `RL` is the localization of a multivariate polynomial ring `R`  at a multiplicatively closed subset
`U` of `R`, then elements of `RL` are created as (fractions of) images of elements of `R` under
the localization map or by coercing (pairs of) elements of `R` into fractions.

If `RQ` is a quotient of a multivariate polynomial ring `R`, `p` : `R` ``\to`` `RQ` is the projection map, `U`  is a
multiplicatively closed subset of `R`, and `RQL` is the localization of `RQ` at `p(U)`, then elements of
`RQL` are created similarly, starting from elements of `R`.

##### Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> P = ideal(R, [x])
Ideal generated by
  x

julia> U = complement_of_prime_ideal(P)
Complement
  of prime ideal (x)
  in multivariate polynomial ring in 3 variables over QQ

julia> RL, iota = localization(U);

julia> iota(x)
x

julia> RL(x)
x

julia> f = iota(y)/iota(z)
y/z

julia> g = RL(y, z)
y/z

julia> X, Y, Z = RL.(gens(R));

julia> h = Y/Z
y/z

julia> f == g == h
true

julia> f+g
2*y/z

julia> f*g
y^2/z^2
```

```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);

julia> I = ideal(R, [2*x^2-y^3, 2*x^2-y^5])
Ideal generated by
  2*x^2 - y^3
  2*x^2 - y^5

julia> U = complement_of_point_ideal(R, [0, 0])
Complement
  of maximal ideal corresponding to rational point with coordinates (0, 0)
  in multivariate polynomial ring in 2 variables over QQ

julia> RQ, p = quo(R, I);

julia> RQL, iota = localization(RQ, U);

julia> phi = compose(p, iota);

julia> phi(x)
x

julia> RQL(x)
x

julia> f = phi(x)/phi(y-1)
x/(y - 1)

julia> g = RQL(x, y-1)
x/(y - 1)

julia> X, Y = gens(RQL);

julia> h = X/(Y-1)
x/(y - 1)

julia> f == g == h
true

julia> f+g
2*x/(y - 1)

julia> f*g
x^2/(y^2 - 2*y + 1)

```

### Data Associated to Elements of Localized Rings

If `RL` is a localization of a multivariate polynomial ring `R`, and `f` is an element of `RL`, internally
represented by a pair `(r, u)` of elements of `R`, then
- `parent(f)` refers to `RL`,
- `numerator(f)` to `r`, and
- `denominator(f)` to `u`.
If `RQL` is a localization of a quotient `RQ` of a multivariate polynomial ring `R`, and `f` is an element of `RQL`,
internally represented by a pair `(r, u)` of elements of `R`, then
- `parent(f)` refers to `RQL`,
- `numerator(f)` to the image of `r` in `RQ`, and
- `denominator(f)` to the image of `u` in `RQ`.
Thus, the behavior of the functions `numerator` and `denominator` reflects the mathematical viewpoint
of representing `f` by pairs of elements of `RQ` and not the internal representation of `f` as pairs of elements of `R`.

##### Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z]);

julia> P = ideal(R, [x])
Ideal generated by
  x

julia> U = complement_of_prime_ideal(P)
Complement
  of prime ideal (x)
  in multivariate polynomial ring in 3 variables over QQ

julia> RL, iota = localization(U);

julia> f = iota(x)/iota(y)
x/y

julia> parent(f)
Localization
  of multivariate polynomial ring in 3 variables x, y, z
    over rational field
  at complement of prime ideal (x)

julia> g = iota(y)/iota(z)
y/z

julia> r = numerator(f*g)
x

julia> u = denominator(f*g)
z

julia> typeof(r) == typeof(u) <: MPolyRingElem
true
```

```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);

julia> I = ideal(R, [2*x^2-y^3, 2*x^2-y^5])
Ideal generated by
  2*x^2 - y^3
  2*x^2 - y^5

julia> U = complement_of_point_ideal(R, [0, 0])
Complement
  of maximal ideal corresponding to rational point with coordinates (0, 0)
  in multivariate polynomial ring in 2 variables over QQ

julia> RQ, p = quo(R, I);

julia> RQL, iota = localization(RQ, U);

julia> phi = compose(p, iota);

julia> f = phi(x)
x

julia> parent(f)
Localization
  of quotient
    of multivariate polynomial ring in 2 variables x, y
      over rational field
    by ideal (2*x^2 - y^3, 2*x^2 - y^5)
  at complement of maximal ideal of point (0, 0)

julia> g = f/phi(y-1)
x/(y - 1)

julia> r = numerator(f*g)
x^2

julia> u = denominator(f*g)
y - 1

julia> typeof(r) == typeof(u) <: MPolyQuoRingElem
true

```

### Tests on Elements of Localized Rings

```@docs
is_unit(f::MPolyLocRingElem)
```

```@docs
is_unit(f::MPolyQuoLocRingElem)
```

## Homomorphisms from Localized Rings

The general abstract type for ring homomorphisms starting from localized rings is `AbsLocalizedRingHom`.
For ring homomorphisms starting from localizations of multivariate polynomial rings, there is the concrete
subtype `MPolyLocalizedRingHom`. For ring homomorphisms starting from quotients of multivariate polynomial
rings, there is the concrete subtype `MPolyQuoLocalizedRingHom`. We describe the construction of such
homomorphisms. Let
- `R` be a multivariate polynomial ring,
- `U` be a multiplicatively closed subset  of `R`,
- `RQ = R/I` be a quotient of `R` with projection map `p` : `R` ``\to`` `RQ`,
- `RL` (`RQL`) be the localization of `R` at `U` (of `RQ` at `p(U)`), and
- `S` be another commutative ring with 1.
Then, to give a ring homomorphism `PHI`  from `RL` to `S` (from`RQL` to `S`) is the same
as to give a ring homomorphism `phi` from `R` to `S` which sends elements of `U` to units
in `S` (and elements of `I` to zero). That is, `PHI` is determined by composing it with the localization map `R` ``\to`` `RL`
(by composing it with the composition of the localization map `RQ` ``\to`` `RQL` and the projection
map `R` ``\to`` `RQ`). The constructors below take this into account.

```@docs
hom(RL::MPolyLocRing, S::Ring, F::Map)
```

Given a ring homomorphism `PHI` from `RL` to `S` (from `RQL` to `S`), `domain(PHI)` and `codomain(PHI)`
refer to `RL` and `S` (`RQL`  and `S`), respectively. The corresponding homomorphism `phi` from `R`
to `S` is recovered as follows:

```@docs
restricted_map(PHI::MPolyLocalizedRingHom)
```

## Ideals in Localized Rings

### Types

The general abstract type for ideals in localized rings is `AbsLocalizedIdeal`. For ideals in  localizations of multivariate polynomial rings,
there is the concrete subtype `MPolyLocalizedIdeal`. For ideals in localizations of quotients of multivariate polynomial rings, there is
the concrete subtype `MPolyQuoLocalizedIdeal`.

### Constructors

Given a localization `RL` of a multivariate polynomial ring `R`, and given a vector `V` of elements of
`RL` (of `R`),  the ideal of `RL` generated by (the images) of the entries of `V`
is created by entering `ideal(RL, V)`.

The construction of ideals in localizations of quotients of multivariate polynomial rings is similar.

##### Examples

```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y]);

julia> f = x^3+y^4
x^3 + y^4

julia> V = [derivative(f, i) for i=1:2]
2-element Vector{QQMPolyRingElem}:
 3*x^2
 4*y^3

julia> U = complement_of_point_ideal(R, [0, 0]);

julia> RL, _ = localization(R, U);

julia> MI = ideal(RL, V)
Ideal generated by
  3*x^2
  4*y^3
```

### Data Associated to Ideals

If `I` is an ideal of a localized multivariate polynomial ring  `RL`, then

- `base_ring(I)` refers to `RL`,
- `gens(I)` to the generators of `I`,
- `number_of_generators(I)` / `ngens(I)` to the number of these generators, and
- `gen(I, k)` as well as `I[k]` to the `k`-th such generator.

We also have:

```@docs
minimal_generating_set(I::MPolyLocalizedIdeal{<:MPolyLocRing{<:Field, <:FieldElem, <:MPolyRing, <:MPolyRingElem, <:MPolyComplementOfKPointIdeal}})
```

Retrieving data as above works similarly if `I` is an ideal of a localized quotient of a multivariate polynomial ring `RQL`.

### Operations on Ideals

If `I`,  `J` are ideals of a localized multivariate polynomial ring  `RL`, then

- `I^k` refers to the `k`-th  power of `I`,
- `I+J`, `I*J`,  and `intersect(I, J)` to the sum, product, and intersection of `I` and  `J`,
- `I:J`  /  `quotient(I, J)` to the ideal quotient of `I` by `J`, and
- `saturation(I)` as well as `saturation_with_index(I)` to the saturation of `I` by `J`.

With respect to the decomposition of ideals, we have

- `radical(I)`,
- `minimal_primes(I)`, and
- `primary_decomposition(I)`.

Similarly, if `I` and `J` are ideals of a localized quotient of a multivariate polynomial ring.

### Tests on Ideals

The usual tests `f in I`  /  `ideal_membership(f, I)`, `issubset(I, J)`, `I == J`, and `is_prime(I)` are available.

### Saturation

If ``RL`` is the localization of a multivariate polynomial ring ``R`` at a multiplicative subset ``U`` of ``R``,
then the ideal theory of ``RL`` is a simplified version of the ideal theory of ``R`` (see, for instance, [Eis95](@cite)).
In particular, each ideal ``I`` of ``RL`` is the extension $J\cdot RL$ of an ideal $J$ of $R$. The ideal

$$\{f\in R \mid uf\in J \text{ for some } u\in U\}$$

is independent of the choice of $J$ and is the largest ideal of ``R`` which extends to ``I``. It is, thus,
the contraction of ``I`` to ``R``,  that is, the preimage of ``I``  under the localization map.
We call this ideal the *saturation of ``I`` over ``R``*.  In OSCAR, it is obtained by entering
`saturated_ideal(I)`.

If ``RQL`` is the localization of a quotient ``RQ`` of a multivariate polynomial ring ``R``, and
``I`` is an ideal of ``RQL``, then the return value of `saturated_ideal(I)` is the preimage of
the saturation of ``I`` over ``RQ`` under the projection map ``R \to RQ`` (and not
the saturation of ``I`` over ``RQ`` itself).

```@docs
saturated_ideal(I::MPolyLocalizedIdeal)
```

