```@meta
CurrentModule = Oscar
```

```@setup oscar
using Oscar
```

```@contents
Pages = ["rings.md"]
```

# Creating Multivariate Rings

In this section, we illustrate by examples how to create multivariate polynomial rings and their elements,
while at the same time introducing and illustrating a special ring type for modelling multivariate polynomial
rings with gradings. For more details on multivariate polynomial rings, their coefficient rings (fields),
and their elements, we refer to the chapters on rings and fields. 

## Types

OSCAR provides types for dense univariate and sparse multivariate polynomials. The univariate
ring types belong to the abstract type `PolyRing{T}`, their elements have abstract type
`PolyRingElem{T}`. The multivariate ring types belong to the abstract type `MPolyRing{T}`,
their elements have abstract type `MPolyRingElem{T}`. Here, `T` is the element type
of the coefficient ring of the polynomial ring.

## Constructors

The basic constructor below allows one to build multivariate polynomial rings:

```@julia
PolynomialRing(C::Ring, V::Vector{String}; ordering=:lex, cached = true)
```

Its return value is a tuple, say `R, vars`, consisting of a polynomial ring `R` with coefficient ring `C` and a vector `vars` of generators (variables) which print according to the strings in the vector `V` .
The input `ordering=:lex` refers to the lexicograpical monomial ordering which specifies the default way of storing and displaying polynomials in OSCAR  (terms are sorted in descending
order). The other possible choices are `:deglex` and `:degrevlex`. Gröbner bases, however, can be computed with respect to any monomial ordering. See the section on Gröbner bases.

!!! note
    Caching is used to ensure that a given ring constructed from given parameters is unique in the system. For example, there is only one ring of multivariate polynomials over  $\mathbb{Z}$ in the variables x, y, z with `ordering=:lex`.

###### Examples

```@repl oscar
R, (x, y, z) = PolynomialRing(ZZ, ["x", "y", "z"])
typeof(R)
typeof(x)
S, (x, y, z) = PolynomialRing(ZZ, ["x", "y", "z"])
R === S
```

```@repl oscar
R1, x = PolynomialRing(QQ, ["x"])
typeof(x)
R2, (x,) = PolynomialRing(QQ, ["x"])
typeof(x)
R3, x = PolynomialRing(QQ, "x")
typeof(x)
```

```@repl oscar
V = ["x[1]", "x[2]"]
T, x = PolynomialRing(GF(3), V)
x
```

The constructor illustrated below allows for the convenient handling of variables with multi-indices:

```@repl oscar
R, x, y, z = PolynomialRing(QQ, "x" => (1:3, 1:4), "y" => 1:2, "z" => (1:1, 1:1, 1:1))
x
y
z
```

## Coefficient Rings 

Gröbner bases are implemented for multivariate polynomial rings over the fields and rings from this list:

###### The field of rational numbers $\mathbb{Q}$

```@repl oscar
QQ
```
###### Finite fields $\mathbb{F_p}$, $p$ a prime

```@repl oscar
GF(3)
GF(ZZ(2)^127 - 1)
```

###### Finite fields $\mathbb{F}_{p^n}$ with $p^n$ elements, $p$ a prime

```@repl oscar
FiniteField(2, 70, "a")
```

###### Simple algebraic extensions of $\mathbb{Q}$ or $\mathbb{F}_p$
  
```@repl oscar
T, t = PolynomialRing(QQ, "t")
K, a = NumberField(t^2 + 1, "a")
F = GF(3)
T, t = PolynomialRing(F, "t")
K, a = FiniteField(t^2 + 1, "a")
```

###### Purely transcendental extensions of $\mathbb{Q}$ or $\mathbb{F}_p$

```@repl oscar
T, t = PolynomialRing(QQ, "t")
QT = FractionField(T)
parent(t)
parent(1//t)
T, (s, t) = PolynomialRing(GF(3), ["s", "t"]);
QT = FractionField(T)
```

###### The ring of integers $\mathbb{Z}$

```@repl oscar
ZZ
```

## Gradings

Given a polynomial ring $R = C[x_1, \dots, x_n]$ and a finitely generated abelian group $G$,
a *(multi)grading* on $R$ by $G$, or a *$G$-grading*, corresponds to a semigroup homomorphism
$\phi: \mathbb N \rightarrow G$: Given $\phi$, the *degree* of a monomial $x^\alpha$
is the image $\deg(x^\alpha):=\phi(\alpha)\in G$; the induced $G$-grading on $R$
is the decomposition $R = \bigoplus_{g\in G} R_g$ satisfying $R_g\cdot R_h\subset R_{g+h}$,
where $R_g$ is the free $C$-module generated by the monomials of degree $g$. This grading is determined by
assigning the *weights* $\deg(x_i)$ to the $x_i$. In other words, it is determined by  the *weight
vector* $W = (\deg(x_1), \dots, \deg(x_n))\in G^n.$ If $G = \mathbb Z^m$ for some $m$, the degrees
are thought of as column vectors in $\mathbb Z^m$, and $W$ as an $m \times n$-matrix with
entries in $\mathbb Z$. In particular, if $G = \mathbb Z$, $W$ is thought of as a row vector
in $\mathbb Z^n$.

### Types


Multivariate rings with gradings are modelled by objects of type
`MPolyRing_dec{T, S}  :< MPolyRing{T}`, with elements of type
`MPolyRingElem_dec{T, S}  :< MPolyRingElem{T}`. Here, `S` is the element type of the
multivariate ring, and  `T` is the element type of its coefficient ring as above.


### Constructors for Graded Rings

There are two basic ways of creating graded polynomial rings:
While the `grade` function allows one to assign a grading to a polynomial ring already constructed,
the `GradedPolynomialRing` function is meant to create a graded polynomial ring all at once.

```@docs
grade(R::MPolyRing, W::Vector{GrpAbFinGenElem})
```

```@docs
grade(R::MPolyRing, W::Union{fmpz_mat, Matrix{<:IntegerUnion}})
```

```@docs
grade(R::MPolyRing, W::Vector{<:IntegerUnion})
```
```@docs
GradedPolynomialRing(C::Ring, V::Vector{String}, W; ordering=:lex)
```

### Tests on Graded Rings

```@docs
is_z_graded(R::MPolyRing_dec)
```

```@docs
is_zm_graded(R::MPolyRing_dec)
```

## Data Associated to Multivariate Rings

Given  a multivariate polynomial ring `R` with coefficient ring `C`, 

- `coefficient_ring(R)` refers to `C`,
- `gens(R)` to the generators (variables) of `R`,
- `ngens(R)` to the number of these generators, and
- `gen(R, i)` as well as `R[i]` to the `i`-th generator.

###### Examples

```@repl oscar
R, (x, y, z) = PolynomialRing(QQ, ["x", "y", "z"])
coefficient_ring(R)
gens(R)
gen(R, 2)
R[3] 
ngens(R)
```

In the graded case, we additionally have:

```@docs
grading_group(R::MPolyRing_dec)
```

```@docs
homogeneous_component(R::MPolyRing_dec, g::GrpAbFinGenElem)
```

## Elements of Multivariate Rings

### Constructors

One way to create elements of a multivariate  polynomial ring is
to build up polynomials from the generators (variables) of the ring using
basic arithmetic as shown below:

###### Examples

```@repl oscar
R, (x, y, z) = PolynomialRing(QQ, ["x", "y", "z"])
f = 3*x^2+y*z
typeof(f)
S, (x, y, z) = grade(R)
g = 3*x^2+y*z
typeof(g)
g == S(f)
```

Alternatively, there is the following constructor:

```@julia
(R::MPolyRing{T})(c::Vector{T}, e::Vector{Vector{Int}}) where T <: RingElem
```

Its return value is the element of  `R`  whose nonzero coefficients are specified by the elements of `c`,
with exponent vectors given by the elements of `e`.

###### Examples

```@repl oscar
R, (x, y, z) = PolynomialRing(QQ, ["x", "y", "z"])
f = 3*x^2+y*z
g = R(QQ.([3, 1]), [[2, 0, 0], [0, 1, 1]])
f == g
```

An often more effective way to create polynomials is to use the `MPoly` build context as indicated below:

```@repl oscar
R, (x, y) = PolynomialRing(QQ, ["x", "y"])
B = MPolyBuildCtx(R)
for i = 1:5 push_term!(B, QQ(i), [i, i-1]) end
finish(B)
```


### Special Elements

Given a multivariate polynomial ring `R`, `zero(R)` and `one(R)` refer to the additive and multiplicative identity of `R`, respectively.
Relevant test calls on an element `f` of `R` are  `iszero(f)` and `isone(f)`.


### Data Associated to Elements of Multivariate Rings

Given an element `f` of a multivariate polynomial ring `R` or a graded version of such a ring, 
- `parent(f)` refers to `R`,
- `total_degree(f)` to the total degree of `f`,
- `monomial(f, i)` to the `i`-th monomial of `f`, 
- `term(f, i)` to the `i`-th term of `f`,
- `coeff(f, i)` to the coefficient of the `i`-th term of `f`, and
- `exponent_vector(f, i)` to the exponent vector of the `i`-th term of `f`.


###### Examples

```@repl oscar
R, (x, y) = PolynomialRing(GF(5), ["x", "y"])
c = map(GF(5), [1, 2, 3])
e = [[3, 2], [1, 0], [0, 1]]
f = R(c, e)
parent(f)
total_degree(f)
coeff(f, 2)
exponent_vector(f, 2)
monomial(f, 2)
term(f, 2)
```

Further functionality is available in the graded case:

```@docs
homogeneous_components(f::MPolyElem_dec{T, S}) where {T, S}
```

```@docs
homogeneous_component(f::MPolyElem_dec, g::GrpAbFinGenElem)
```

```@docs
ishomogeneous(f::MPolyElem_dec)
```

```@docs
degree(f::MPolyElem_dec)
```

## Homomorphisms of Multivariate Rings

How to handle homomorphisms of multivariate polynomial rings and their graded versions is described in
a more general context in the section on affine algebras. 

