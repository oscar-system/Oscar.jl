```@meta
CurrentModule = Oscar
CollapsedDocStrings = true
DocTestSetup = Oscar.doctestsetup()
```

# Ideals in Multivariate Rings

## Types

The OSCAR type for ideals in multivariate polynomial rings is of parametrized form
`MPolyIdeal{T}`, where `T` is the element type of the polynomial ring.

## Constructors

```@docs
ideal(R::MPolyRing, g::Vector)
```

## Data Associated to Ideals

### Basic Data

If `I` is an ideal of a multivariate polynomial ring `R`, then

- `base_ring(I)` refers to `R`,
- `gens(I)` to the generators of `I`,
- `number_of_generators(I)` / `ngens(I)` to the number of these generators, and
- `gen(I, k)` as well as `I[k]` to the `k`-th such generator.

###### Examples

```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia> base_ring(I)
Multivariate polynomial ring in 2 variables x, y
  over rational field

julia> gens(I)
3-element Vector{QQMPolyRingElem}:
 x^2
 x*y
 y^2

julia> number_of_generators(I)
3

julia> gen(I, 2)
x*y

```

### Dimension

```@docs
dim(I::MPolyIdeal)
```

### Codimension

```@docs
codim(I::MPolyIdeal)
```

In the graded case, we additionally have:

### Minimal Sets of Generators

```@docs
minimal_generating_set(I::MPolyIdeal{<:MPolyDecRingElem})
```

### Castelnuovo-Mumford Regularity

```@docs
cm_regularity(I::MPolyIdeal)
```

### Degree

```@docs
degree(I::MPolyIdeal)
```

## Operations on Ideals

### Simple Ideal Operations

#### Common Ideal Operations

If `I` and `J` are ideals of a multivariate polynomial ring `R`, and
`m` a non-negative integer, then
- `I+J` returns the sum of `I` and `J`,
- `I*J` returns the product of `I` and `J`,
- `I^m` returns the `m`-th power of `I`, i.e., the product of `m` copies of `I`.

###### Examples

```jldoctest
julia> R, (x, y, z) = polynomial_ring(QQ, [:x, :y, :z])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia> I = ideal(R, [x, y])
Ideal generated by
  x
  y

julia> J = ideal(R, [z^2])
Ideal generated by
  z^2

julia> I+J
Ideal generated by
  x
  y
  z^2

julia> I*J
Ideal generated by
  x*z^2
  y*z^2

julia> I^3
Ideal generated by
  x^3
  x^2*y
  x*y^2
  y^3
```


### Intersection of Ideals

```@docs
intersect(I::MPolyIdeal{T}, Js::MPolyIdeal{T}...) where T
```

### Ideal Quotients

Given two ideals $I, J$ of a ring $R$, the *ideal quotient* of $I$ by $J$ is the ideal

$I:J= \bigl\{f \in R\:\big|\: f J \subset I\bigr\}\subset R.$

```@docs
quotient(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T
```

### Saturation

Given two ideals $I, J$ of a ring $R$, the *saturation* of $I$ with respect to $J$ is the ideal

$I:J^{\infty} = \bigl\{ f \in R \:\big|\: f J^k \!\subset I {\text{ for some }}k\geq 1 \bigr\} = \textstyle{\bigcup\limits_{k=1}^{\infty} (I:J^k)}.$

```@docs
saturation(I::MPolyIdeal{T}, J::MPolyIdeal{T}; iteration::Bool=false) where T
saturation_with_index(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T
```

### Elimination

```@docs
eliminate(I::MPolyIdeal{T}, V::Vector{T}) where T <: MPolyRingElem
```

### Truncation

```@docs
truncate(I::MPolyIdeal, g::FinGenAbGroupElem)
```

## Tests on Ideals

### Basic Tests

For an ideal `I`, basic predicates include:

Use `is_zero(I)` to test whether `I` is the zero ideal.

```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, y-x^2)
Ideal generated by
  -x^2 + y

julia> is_zero(I)
false
```

Use `is_one(I)` to test whether `I` is the unit ideal.

```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x, x + y, y - 1])
Ideal generated by
  x
  x + y
  y - 1

julia> is_one(I)
true
```

```@docs
is_monomial(f::MPolyRingElem)
```

### Containment of Ideals

Containment is tested with `is_subset(I, J)`, which checks whether `I ⊆ J`.

```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x^2])
Ideal generated by
  x^2

julia> J = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia> is_subset(I, J)
true
```

### Equality of Ideals

Equality is tested with `I == J`.

```jldoctest
julia> R, (x, y) = polynomial_ring(QQ, [:x, :y])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia> I = ideal(R, [x^2])
Ideal generated by
  x^2

julia> J = ideal(R, [x, y])^2
Ideal generated by
  x^2
  x*y
  y^2

julia> I == J
false
```

### Ideal Membership

```@docs
ideal_membership(f::T, I::MPolyIdeal{T}) where T
```

### Radical Membership

```@docs
radical_membership(f::T, I::MPolyIdeal{T}) where T
```

### Primality Test

```@docs
is_prime(I::MPolyIdeal)
```

### Primary Test

```@docs
is_primary(I::MPolyIdeal)
```

## Decomposition of Ideals

We discuss various decomposition techniques. They are implemented for
polynomial rings over fields and, if explicitly mentioned, also for
polynomial rings over the integers. See [DGP99](@cite) for a survey.

!!! note
    In addition to Gröbner (standard) basis methods, functions for computing radicals and primary decompositions require methods for sqarefree decomposition and polynomial factorization, respectively. In the case of fields for which such methods are not implemented, an error will be thrown.
	
### Radical

```@docs
radical(I::MPolyIdeal{T}; eliminate_variables::Bool = true) where {T <: MPolyRingElem}
```

### Primary Decomposition

```@docs
primary_decomposition(I::MPolyIdeal; algorithm::Symbol = :GTZ)
```

### Absolute Primary Decomposition

```@docs
absolute_primary_decomposition(I::MPolyIdeal{QQMPolyRingElem})
```

### Minimal Associated Primes

```@docs
minimal_primes(I::MPolyIdeal; algorithm::Symbol = :GTZ)
```

### Weak Equidimensional Decomposition

```@docs
equidimensional_decomposition_weak(I::MPolyIdeal)
```

### Equidimensional Decomposition of radical

```@docs
equidimensional_decomposition_radical(I::MPolyIdeal)
```

### Equidimensional Hull

```@docs
equidimensional_hull(I::MPolyIdeal)
```

### Radical of the Equidimensional Hull

```@docs
equidimensional_hull_radical(I::MPolyIdeal)
```

### Triangular Decomposition

```@docs
triangular_decomposition(::MPolyIdeal)
```


## Homogenization and Dehomogenization

Referring to [KR05](@cite) for definitions and technical details, we discuss homogenization and dehomogenization in the context of $\mathbb Z^m$-gradings.

```@docs
homogenizer(P::MPolyRing{T}, h::VarName; pos::Int=1+ngens(P))  where T
homogenizer(P::MPolyRing{T}, W::Union{ZZMatrix, Matrix{<:IntegerUnion}}, h::VarName; pos::Int)  where T
dehomogenizer(H::Homogenizer)
```

```jldoctest
julia> P, (x, y) = polynomial_ring(QQ, [:x, :y]);

julia> I = ideal([x^2+y, x*y+y^2]);

julia> H = homogenizer(P, "h");

julia> Ih = H(I)     # homogenization of ideal I
Ideal generated by
  x*y + y^2
  x^2 + y*h
  y^3 + y^2*h

julia> DH = dehomogenizer(H);

julia> DH(Ih) == I   # dehomogenization of Ih
true
```

## Vanishing sets and solving multivariate polynomial systems

```@docs
rational_solutions
```

## Generating Special Ideals

### Katsura-n

These systems appeared in a problem of magnetism in physics.
For a given $n$ `katsura(n)` has $2^n$ solutions and is defined in a
polynomial ring with $n+1$ variables over the rational numbers. For a
given polynomial ring `R` with $n$ variables `katsura(R)` defines the
corresponding system with $2^{n-1}$ solutions.

```@docs
katsura(n::Int)
```

```@docs
katsura(R::MPolyRing)
```
