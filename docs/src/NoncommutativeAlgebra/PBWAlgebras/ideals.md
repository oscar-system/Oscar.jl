```@meta
CurrentModule = Oscar
```

```@setup oscar
using Oscar
```

```@contents
Pages = ["ideals.md"]
```

# Ideals in PBW-algebras

## Types

The OSCAR type for ideals in PBW-algebras is of parametrized form
`PBWAlgIdeal{D, T, S}`, where `D` encodes the direction left, right,
or two-sided, and `T` is the element type of the field over which
the PBW-algebra is defined (the type `S` is added for internal use).

## Constructors

```@docs
left_ideal(g::Vector{<:PBWAlgElem})
right_ideal(g::Vector{<:PBWAlgElem})
two_sided_ideal(g::Vector{<:PBWAlgElem})
```

## Gröbner bases

## Data Associated to Ideals

If `I` is an ideal of a PBW-algebra  `A`, then

- `base_ring(I)` refers to `A`,
- `gens(I)` to the generators of `I`,
- `ngens(I)` to the number of these generators, and
- `gen(I, k)` as well as `I[k]` to the `k`-th such generator.

###### Examples

```@repl oscar
D, (x, y, dx, dy) = weyl_algebra(QQ, ["x", "y"])
I = left_ideal(D, [x, dx])
base_ring(I)
gens(I)
ngens(I)
gen(I, 2)
```

## Operations on Ideals

### Simple Ideal Operations

#### Powers of Ideal

#### Sum of Ideals

```@docs
+(I::PBWAlgIdeal{D, T, S}, J::PBWAlgIdeal{D, T, S}) where {D, T, S}
```

#### Product of Ideals

### Intersection of Ideals

```@docs
intersect(I::PBWAlgIdeal{D, T, S}, Js::PBWAlgIdeal{D, T, S}...) where {D, T, S}
```

### Elimination

Let

```math
A = K\langle x_1, \dots , x_n \mid x_jx_i = c_{ij}x_ix_j+d_{ij},  \ 1\leq i<j \leq n \rangle,
```
be a PBW-algebra. Fix a subset $\sigma\subset \{1,\dots, n\}$, write $x_\sigma$ 
for the set of variables $x_i$ with $i\in\sigma$, and let $A_\sigma$ be the $K$-linear 
subspace of $A$ which is generated by the standard monomials in $\langle x_\sigma \rangle$.
Suppose there exists a global monomial ordering $>$ on $A$ which is both admissible for $A$
and an elimination ordering for $x\smallsetminus x_\sigma$. Then $A_\sigma$ is a subalgebra
of $A$ with $d_{ij}\in A_\sigma$ for each pair of indices $1\leq i<j \leq n$ with $i,j\in\sigma$.
In particular, $A_\sigma$  is a PBW-algebra with admissible ordering $>_\sigma$, where $>_\sigma$
is the restriction of $>$ to the set of standard monomials in  $\langle x_\sigma\rangle$. Moreover,
if $I\subset A$ is a nonzero (left, right, two-sided) ideal, and $\mathcal G$ is a (left, right, two-sided)
Gröbner basis for $I$ with respect to $>$, then $\mathcal G\cap A_\sigma$ is a (left, right, two-sided)
Gröbner basis for $I\cap A_\sigma$ with respect to $>_\sigma$. We refer to computing $I\cap A_\sigma$
as *eliminating the variables in $x\smallsetminus x_\sigma$ from $I.$*

!!! note
    A monomial ordering which is both admissible for $A$ and an elimination ordering for $x\smallsetminus x_\sigma$ may not exist. 

The function below computes $I\cap A_\sigma$ if this is possible.

```@julia
eliminate(I::PBWAlgIdeal{...}, l::Vector{...}) where ...
```

Given an ideal `I` of a PBW-algebra `A`, say, and given a vector `l` of indices which specify
variables, check whether there exists a global monomial ordering which is both admissible
for `A` and an elimination ordering for the specified variables. Throw an error if no such ordering
exists. Otherwise, return the intersection of `l` with the subalgebra of `A` generated by the
variables not specified.


If an appropriate ordering is known a priori, it can be entered as an additional argument:

```@julia
eliminate(I::PBWAlgIdeal{...}, l::Vector{...}, ord::MonomialOrdering) where ...
```

Given an ideal `I` of a PBW-algebra `A`, say, given a vector `l` of indices which specify
variables, and given a monomial ordering `ord`, check whether `ord` is both admissible
for `A` and an elimination ordering for the specified variables. Throw an error if this is
not the case. Otherwise, return the intersection of `l` with the subalgebra of `A`
generated by the variables not specified.


## Tests on Ideals

```@docs
iszero(I:: PBWAlgIdeal)
```

```@docs
isone(I:: PBWAlgIdeal)
```

```@docs
issubset(I::PBWAlgIdeal{D, T, S}, J::PBWAlgIdeal{D, T, S}) where {D, T, S}
```

```@docs
==(I::PBWAlgIdeal{D, T, S}, J::PBWAlgIdeal{D, T, S}) where {D, T, S}
```

```@docs
ideal_membership(f::PBWAlgElem{T, S}, I::PBWAlgIdeal{D, T, S}) where {D, T, S}
```

