<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Groups · Oscar.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" href="../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Oscar.jl</span></div><form action="../../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to Oscar</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li class="is-active"><a class="tocitem" href="">Groups</a><ul class="internal"><li><a class="tocitem" href="#Basics"><span>Basics</span></a></li><li><a class="tocitem" href="#subgroups"><span>Subgroups</span></a></li><li><a class="tocitem" href="#quotient"><span>Quotients</span></a></li><li><a class="tocitem" href="#Permutation-groups"><span>Permutation groups</span></a></li><li><a class="tocitem" href="#Polycyclic-groups"><span>Polycyclic groups</span></a></li><li><a class="tocitem" href="#Homomorphisms"><span>Homomorphisms</span></a></li><li><a class="tocitem" href="#Automorphisms-groups"><span>Automorphisms groups</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Groups</a></li><li class="is-active"><a href="">Groups</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Groups</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/Groups/groups.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#Groups">Groups</a></li><ul><li><a href="#Basics">Basics</a></li><li><a href="#subgroups">Subgroups</a></li><li><a href="#quotient">Quotients</a></li><li><a href="#Permutation-groups">Permutation groups</a></li><li><a href="#Polycyclic-groups">Polycyclic groups</a></li><li><a href="#Homomorphisms">Homomorphisms</a></li><li><a href="#Automorphisms-groups">Automorphisms groups</a></li></ul></ul><h1 id="Groups"><a class="docs-heading-anchor" href="#Groups">Groups</a><a id="Groups-1"></a><a class="docs-heading-anchor-permalink" href="#Groups" title="Permalink"></a></h1><p>Oscar supports the following types of groups:</p><ul><li><code>PermGroup</code> = groups of permutations</li><li><code>MatrixGroup</code> = groups of matrices</li><li><code>FPGroup</code> = finitely presented groups</li><li><code>PcGroup</code> = polycyclic groups</li><li><code>DirectProductOfGroups</code> = direct product of two groups</li><li><code>AutomorphismGroup</code> = group of automorphisms over a group</li></ul><p>If <code>x</code> is an element of the group <code>G</code> of type <code>T</code>, then the type of <code>x</code> is <code>GAPGroupElement{T}</code>.</p><h2 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h2><h3 id="elements_of_groups"><a class="docs-heading-anchor" href="#elements_of_groups">Elements of groups</a><a id="elements_of_groups-1"></a><a class="docs-heading-anchor-permalink" href="#elements_of_groups" title="Permalink"></a></h3><p>Given a group <code>G</code>, it is always possible to have access to some particular elements.</p><article class="docstring"><header><a class="docstring-binding" href="#Base.one-Tuple{Oscar.GAPGroup}" id="Base.one-Tuple{Oscar.GAPGroup}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">one(G::Group) -&gt; x::GAPGroupElem{typeof(G)}</code></pre><p>Return the identity of the group <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L180-L183" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.rand-Tuple{Oscar.GAPGroup}" id="Base.rand-Tuple{Oscar.GAPGroup}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rand(G::Group)</code></pre><p>Return a random element of the group <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L121-L124" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.rand_pseudo-Tuple{Oscar.GAPGroup}" id="Oscar.rand_pseudo-Tuple{Oscar.GAPGroup}"><code>Oscar.rand_pseudo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rand_pseudo(G::Group)</code></pre><p>Return a random element of the group <code>G</code>. It works faster than <code>rand</code>, but the elements are not necessarily equally distributed.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L130-L133" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.gens-Tuple{Oscar.GAPGroup}" id="AbstractAlgebra.gens-Tuple{Oscar.GAPGroup}"><code>AbstractAlgebra.gens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gens(G::Group)</code></pre><p>Return an array of generators of the group <code>G</code>. To access the array, it can be used the shorter notation <code>G[i]</code> instead of <code>gens(G)[i]</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L344-L347" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.gens-Tuple{Oscar.GAPGroup,Int64}" id="AbstractAlgebra.gens-Tuple{Oscar.GAPGroup,Int64}"><code>AbstractAlgebra.gens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gens(G::Group, i::Integer)</code></pre><p>Return the <code>i</code>-th element of the array gens(<code>G</code>). It is equivalent to <code>G[i]</code> and <code>gens(G)[i]</code>. If <code>i</code> is greater than the length of gens(<code>G</code>), an ERROR is returned.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L357-L360" target="_blank">source</a></section></article><p>It is also possible to obtain the generators of <code>G</code> by typing</p><pre><code class="language-julia">f1,f2,f3 = gens(G)</code></pre><p>This is equivalent to</p><pre><code class="language-julia">f1=G[1]; f2=G[2]; f3=G[3];</code></pre><p>If the group <code>G</code> has been created as the subgroup of another group generated by a list of elements <code>L</code>, then the generating set returned by the function <code>gens</code> corresponds to <code>L</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The output of <code>gens(G)</code> is not, in general, the minimal list of generators for <code>G</code>.</p></div></div><h3 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h3><p>Oscar supports the following operations and functions on group elements.</p><ul><li><code>*</code> = multiplication between two elements in a group.</li><li><code>inv(x)</code> = <span>$x^{-1}$</span> the inverse of <code>x</code>.</li><li><code>x/y</code> = the element <span>$xy^{-1}$</span>.</li><li><code>x^n</code> = the <span>$n$</span>-th power of <code>x</code>. If <span>$n = 0$</span>, the identity of the group is returned; if <span>$n &lt; 0$</span>, the <span>$-n$</span>-th power of the inverse of <code>x</code> is returned.</li><li><code>isone(x)</code>: returns whether <code>x</code> is the identity of the group.</li><li><code>conj(x,y)</code> = <code>x^y</code> = the conjugate of <code>x</code> by <code>y</code>, i.e. the element <span>$y^{-1}xy$</span>.</li><li><code>comm(x,y)</code> = the commutator of <code>x</code> and <code>y</code>, i.e. the element <span>$x^{-1}y^{-1}xy$</span>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In Oscar, the expression <code>x^y^z</code> is equivalent to <code>x^(y^z)</code>. In other words, conjugations are evaluated from the right to the left.</p></div></div><h2 id="subgroups"><a class="docs-heading-anchor" href="#subgroups">Subgroups</a><a id="subgroups-1"></a><a class="docs-heading-anchor-permalink" href="#subgroups" title="Permalink"></a></h2><p>The subgroup of a group <code>G</code> generated by the elements <code>x,y,...</code> is defined by the following instruction:</p><ul><li><code>sub(G, [x,y,...])</code> ;</li><li><code>sub(x,y,...)</code>.</li></ul><p>This function returns two objects: a group <code>H</code>, that is the subgroup of <code>G</code> generated by the elements <code>x,y,...</code>, and the embedding homomorphism of <code>H</code> into <code>G</code>. The object <code>H</code> has the same type of <code>G</code>, and it has no memory of the "parent" group <code>G</code>: it is an independent group.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; G = symmetric_group(4); H = sub(G,[cperm([1,2,3]),cperm([2,3,4])]);
julia&gt; H[1] == alternating_group(4)
true</code></pre><p>The following functions are available in Oscar for subgroup properties:</p><article class="docstring"><header><a class="docstring-binding" href="#Hecke.issubgroup" id="Hecke.issubgroup"><code>Hecke.issubgroup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issubgroup(G::T, H::T) where T &lt;: GAPGroup</code></pre><p>Return (<code>true</code>,<code>f</code>) if <code>H</code> is a subgroup of <code>G</code>, where <code>f</code> is the embedding homomorphism of <code>H</code> into <code>G</code>, otherwise return (<code>false</code>,<code>Nothing</code>).</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L63-L66" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.embedding-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" id="Oscar.embedding-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>Oscar.embedding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">embedding(G::T, H::T) where T &lt;: GAPGroup</code></pre><p>Return the embedding morphism of <code>H</code> into <code>G</code>. It throws ERROR if <code>H</code> is not a subgroup of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L75-L78" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Hecke.index-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" id="Hecke.index-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>Hecke.index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">index(G::T, H::T) where T &lt;: GAPGroup</code></pre><p>Return the index of <code>H</code> in <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L100-L103" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Hecke.isnormal-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" id="Hecke.isnormal-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>Hecke.isnormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isnormal(G::T, H::T) where T &lt;: GAPGroup</code></pre><p>Return whether the subgroup <code>H</code> is normal in <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L216-L219" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Hecke.ischaracteristic-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" id="Hecke.ischaracteristic-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>Hecke.ischaracteristic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ischaracteristic(G::T, H::T) where T &lt;: GAPGroup</code></pre><p>Return whether the subgroup <code>H</code> is characteristic in <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L224-L227" target="_blank">source</a></section></article><h3 id="Standard-subgroups"><a class="docs-heading-anchor" href="#Standard-subgroups">Standard subgroups</a><a id="Standard-subgroups-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-subgroups" title="Permalink"></a></h3><p>The following functions are available in Oscar to obtain standard subgroups of a group <code>G</code>. Every such function returns a tuple <code>(H,f)</code>, where <code>H</code> is a group of the same type of <code>G</code> and <code>f</code> is the embedding homomorphism of <code>H</code> into <code>G</code>.</p><article class="docstring"><header><a class="docstring-binding" href="#Oscar.trivial_subgroup" id="Oscar.trivial_subgroup"><code>Oscar.trivial_subgroup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trivial_subgroup(G::GAPGroup)</code></pre><p>Return the trivial subgroup of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L88-L91" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.centre" id="Oscar.centre"><code>Oscar.centre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">centre(G::Group)</code></pre><p>Return the centre of <code>G</code>, i.e. the subgroup of all <code>x</code> in <code>G</code> such that <code>xy</code>=<code>yx</code> for every <code>y</code> in <code>G</code>, together with its embedding morphism into <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L181-L184" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.sylow_subgroup-Tuple{Oscar.GAPGroup,Int64}" id="Oscar.sylow_subgroup-Tuple{Oscar.GAPGroup,Int64}"><code>Oscar.sylow_subgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sylow_subgroup(G::Group, p::Int64)</code></pre><p>Return a Sylow <code>p</code>-subgroup of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L663-L666" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.hall_subgroup-Tuple{Oscar.GAPGroup,AbstractArray{#s263,1} where #s263&lt;:Integer}" id="Oscar.hall_subgroup-Tuple{Oscar.GAPGroup,AbstractArray{#s263,1} where #s263&lt;:Integer}"><code>Oscar.hall_subgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hall_subgroup(G::Group, P::Array{Int64})</code></pre><p>Return a Hall <code>P</code>-subgroup of <code>G</code>. It works only if <code>G</code> is solvable.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L674-L677" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.derived_subgroup" id="Oscar.derived_subgroup"><code>Oscar.derived_subgroup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">derived_subgroup(G::GAPGroup)</code></pre><p>Return the derived subgroup of <code>G</code>, i.e. the subgroup generated by all commutators of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L313-L316" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.fitting_subgroup-Tuple{Oscar.GAPGroup}" id="Oscar.fitting_subgroup-Tuple{Oscar.GAPGroup}"><code>Oscar.fitting_subgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fitting_subgroup(G::GAPGroup)</code></pre><p>Return the Fitting subgroup of <code>G</code>, the largest nilpotent normal subgroup of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L632-L635" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.frattini_subgroup-Tuple{Oscar.GAPGroup}" id="Oscar.frattini_subgroup-Tuple{Oscar.GAPGroup}"><code>Oscar.frattini_subgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">frattini_subgroup(G::GAPGroup)</code></pre><p>Return the Frattini subgroup of <code>G</code>, the intersection of all maximal subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L638-L641" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.radical_subgroup-Tuple{Oscar.GAPGroup}" id="Oscar.radical_subgroup-Tuple{Oscar.GAPGroup}"><code>Oscar.radical_subgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">radical_subgroup(G::GAPGroup)</code></pre><p>Return the radical subgroup of <code>G</code>, the largest solvable normal subgroup of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L644-L647" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.socle-Tuple{Oscar.GAPGroup}" id="Oscar.socle-Tuple{Oscar.GAPGroup}"><code>Oscar.socle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">socle(G::GAPGroup)</code></pre><p>Return the socle of <code>G</code>, the subgroup generated by all minimal normal subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L650-L653" target="_blank">source</a></section></article><p>The following functions return a list of subgroups.</p><article class="docstring"><header><a class="docstring-binding" href="#Hecke.subgroups-Tuple{Oscar.GAPGroup}" id="Hecke.subgroups-Tuple{Oscar.GAPGroup}"><code>Hecke.subgroups</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">subgroups(G::Group)</code></pre><p>Return the list of subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L133-L136" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.normal_subgroups" id="Oscar.normal_subgroups"><code>Oscar.normal_subgroups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normal_subgroups(G::Group)</code></pre><p>Return the list of normal subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L125-L128" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.maximal_subgroups" id="Oscar.maximal_subgroups"><code>Oscar.maximal_subgroups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maximal_subgroups(G::Group)</code></pre><p>Return the list of maximal subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L141-L144" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.maximal_normal_subgroups" id="Oscar.maximal_normal_subgroups"><code>Oscar.maximal_normal_subgroups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maximal_normal_subgroups(G::Group)</code></pre><p>Return the list of maximal normal subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L149-L152" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.minimal_normal_subgroups" id="Oscar.minimal_normal_subgroups"><code>Oscar.minimal_normal_subgroups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minimal_normal_subgroups(G::Group)</code></pre><p>Return the list of minimal normal subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L157-L160" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.characteristic_subgroups" id="Oscar.characteristic_subgroups"><code>Oscar.characteristic_subgroups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">characteristic_subgroups(G::Group)</code></pre><p>Return the list of characteristic subgroups of <code>G</code>, i.e. the subgroups that are invariant under all automorphisms of <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L165-L168" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Hecke.derived_series" id="Hecke.derived_series"><code>Hecke.derived_series</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">derived_series(G::GAPGroup)</code></pre><p>Return the list [<code>G_1</code>, <code>G_2</code>, <code>G_3</code>, ... ], where <code>G_1</code>=<code>G</code> and <code>G_{i+1}</code> = <code>derived_subgroup(G_i)</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L322-L325" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.sylow_system" id="Oscar.sylow_system"><code>Oscar.sylow_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sylow_system(G::Group)</code></pre><p>Return an array of Sylow <span>$p$</span>-subgroups of <code>G</code>, where <span>$p$</span> runs over the prime factors of |<code>G</code>|, such that every two such subgroups commute each other (as subgroups). It works only if <code>G</code> is solvable.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L689-L692" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.hall_system" id="Oscar.hall_system"><code>Oscar.hall_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hall_system(G::Group)</code></pre><p>Return an array of <span>$P$</span>-Hall subgroups of <code>G</code>, where <span>$P$</span> runs over the subsets of prime factors of |<code>G</code>|. It works only if <code>G</code> is solvable.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L707-L710" target="_blank">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When a function returns a list of subgroups, the output consists in the subgroups only; the embeddings are not returned as well. To get the embedding homomorphism of the subgroup <code>H</code> in <code>G</code>, one has to type <code>embedding(G,H)</code></p></div></div><h2 id="quotient"><a class="docs-heading-anchor" href="#quotient">Quotients</a><a id="quotient-1"></a><a class="docs-heading-anchor-permalink" href="#quotient" title="Permalink"></a></h2><p>Quotient groups in Oscar can be defined using the instruction <code>quo</code> in two ways.</p><ul><li>Quotients by normal subgroups.</li></ul><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.quo-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" id="AbstractAlgebra.quo-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>AbstractAlgebra.quo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quo(G::T, H::T)</code></pre><p>Return the quotient group <code>G/H</code> of type <code>PcGroup</code> (if the quotient group is solvable) or <code>PermGroup</code> (otherwise), together with the projection <code>G</code> -&gt; <code>G/H</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L285-L288" target="_blank">source</a></section></article><ul><li>Quotients by elements.</li></ul><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.quo-Union{Tuple{T}, Tuple{S}, Tuple{T,Array{S,1}}} where T&lt;:Oscar.GAPGroup where S&lt;:GAPGroupElem" id="AbstractAlgebra.quo-Union{Tuple{T}, Tuple{S}, Tuple{T,Array{S,1}}} where T&lt;:Oscar.GAPGroup where S&lt;:GAPGroupElem"><code>AbstractAlgebra.quo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quo(G::T, elements::Vector{S})</code></pre><p>Return the quotient group <code>G/H</code> of type <code>FPGroup</code> (if <code>T</code>=<code>FPGroup</code>), <code>PcGroup</code> (if the quotient group is solvable) or <code>PermGroup</code> (otherwise), where <code>H</code> is the normal closure of <code>elements</code> in <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/sub.jl#L272-L275" target="_blank">source</a></section></article><p>This is the typical way to build finitely presented groups.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; F=free_group(2);
julia&gt; (f1,f2)=gens(F);
julia&gt; G=quo(F,[f1^2,f2^3,(f1*f2)^2])[1];
julia&gt; isisomorphic(G,symmetric_group(3))[1]
true</code></pre><p>Similarly to the subgroups, the output consists of a pair (<code>Q</code>,<code>p</code>), where <code>Q</code> is the quotient group and <code>p</code> is the projection homomorphism of <code>G</code> into <code>Q</code>.</p><h2 id="Permutation-groups"><a class="docs-heading-anchor" href="#Permutation-groups">Permutation groups</a><a id="Permutation-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Permutation-groups" title="Permalink"></a></h2><p>Permutation groups can be defined as symmetric groups, alternating groups or their subgroups.</p><article class="docstring"><header><a class="docstring-binding" href="#Oscar.symmetric_group" id="Oscar.symmetric_group"><code>Oscar.symmetric_group</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">symmetric_group(n::Int64)
symmetric_group(::Type{T}, n::Int)</code></pre><p>Return the full symmetric group over a set of <code>n</code> elements. The group is returned of type <code>T</code> for <code>T</code> in {<code>PermGroup</code>, <code>PcGroup</code>}. If <code>T</code> is not specified, then <code>T</code> is set as <code>PermGroup</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/group_constructors.jl#L43-L47" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.alternating_group" id="Oscar.alternating_group"><code>Oscar.alternating_group</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">alternating_group(n::Int64)
alternating_group(::Type{T}, n::Int)</code></pre><p>Return the full alternating group over a set of <code>n</code> elements. The group is returned of type <code>T</code> for <code>T</code> in {<code>PermGroup</code>, <code>PcGroup</code>}. If <code>T</code> is not specified, then <code>T</code> is set as <code>PermGroup</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/group_constructors.jl#L63-L67" target="_blank">source</a></section></article><p>In Oscar, every permutation group has a degree <code>n</code>, that corresponds to the size of the set on which <code>G</code> acts. This can be displayed by typing</p><pre><code class="language-julia">degree(G)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The degree of a group of permutations is not necessarily equal to the largest moved point of the group <code>G</code>. For example, the trivial subgroup of <code>symmetric_group(n)</code> has degree <code>n</code> even though it fixes <code>n</code>.</p></div></div><h3 id="Permutations"><a class="docs-heading-anchor" href="#Permutations">Permutations</a><a id="Permutations-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations" title="Permalink"></a></h3><p>Permutations in Oscar are displayed as products of disjoint cycles, as in GAP. An explicit permutation can be built using the functions <code>perm</code>, <code>gap_perm</code> and <code>cperm</code>.</p><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.perm" id="AbstractAlgebra.Generic.perm"><code>AbstractAlgebra.Generic.perm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">perm(G::PermGroup, L::AbstractVector{&lt;:Integer})
(G::PermGroup)(L::AbstractVector{&lt;:Integer})</code></pre><p>Return the permutation <code>x</code> which maps every <code>i</code> from <code>1</code> to <code>length(L)</code> to <code>L[i]</code>. <code>L</code> must contain every integer from 1 to <code>length(L)</code> exactly, otherwise an exception is thrown. The parent of <code>x</code> is <code>G</code>. If <code>x</code> is not contained in <code>G</code>, an ERROR is returned. For <code>gap_perm</code>, the parent group of <code>x</code> is set as Sym(<code>n</code>), where <code>n</code> is the largest moved point of <code>x</code>. Example:</p><pre><code class="language-julia-repl">julia&gt; perm(symmetric_group(6),[2,4,6,1,3,5])
(1,2,4)(3,6,5)</code></pre></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L270-L279" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.gap_perm" id="Oscar.gap_perm"><code>Oscar.gap_perm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gap_perm(L::AbstractVector{&lt;:Integer})</code></pre><p>Return the permutation <code>x</code> which maps every <code>i</code> from <code>1</code> to <code>length(L)</code> to <code>L[i]</code>. <code>L</code> must contain every integer from 1 to <code>length(L)</code> exactly, otherwise an exception is thrown. The parent of <code>x</code> is set as Sym(<code>n</code>).</p><pre><code class="language-julia-repl">julia&gt; gap_perm([2,4,6,1,3,5])
(1,2,4)(3,6,5)</code></pre></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L256-L264" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.cperm" id="Oscar.cperm"><code>Oscar.cperm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cperm(L::AbstractVector{&lt;:Integer}...)
cperm(G::PermGroup, L::AbstractVector{&lt;:Integer}...)</code></pre><p>For given lists of positive integers <code>[a_1, a_2, ..., a_n],[b_1, b_2, ... , b_m], ...</code> return the permutation <code>x = (a_1,a_2,...,a_n)(b_1,b_2,...,b_m)...</code>. The array <code>[n,n+1,...,n+k]</code> can be replaced by <code>n:n+k</code>.</p><p>If a list is empty or contains duplicates, it fails. The parent of <code>x</code> is <code>G</code>. If <code>x</code> is not contained in <code>G</code>, an ERROR is returned. If <code>G</code> is not specified, then the parent of <code>x</code> is set as Sym(<code>n</code>), where <code>n</code> is the largest moved point of <code>x</code>. Example:</p><pre><code class="language-julia-repl">julia&gt; cperm([1,2,3],4:7)
(1,2,3)(4,5,6,7)

julia&gt; cperm([1,2],[2,3])
(1,3,2)</code></pre></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L298-L313" target="_blank">source</a></section></article><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; perm(symmetric_group(6),[2,4,6,1,3,5])
(1,2,4)(3,6,5)

julia&gt; cperm([1,2,3],4:7)
(1,2,3)(4,5,6,7)

julia&gt; cperm([1,2],[2,3])
(1,3,2)</code></pre><p>At the moment, the input vectors of the function <code>cperm</code> need not to be disjoint.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If the function <code>perm</code> is evaluated in a vector of integers without specifying the group <code>G</code>, then the returned value is an element of the AbstractAlgebra.jl type <code>Perm{Int}</code>. For this reason, if one wants a permutation of type <code>GAPGroupElem{PermGroup}</code> without specifying a parent, one has to use the function <code>gap_perm</code>.</p></div></div><p>Every permutation has always a permutation group as a parent. Two permutations coincide if, and only if, they move the same points and their parent groups have the same degree.</p><pre><code class="language-julia-repl">julia&gt; G=symmetric_group(5);
julia&gt; A=alternating_group(5);
julia&gt; x=cperm(G,[1,2]);
julia&gt; y=cperm(A,[1,2]);
julia&gt; z=cperm([1,2]);
julia&gt; x==y
true

julia&gt; x==z
false</code></pre><p>In the example above, <code>x</code> and <code>y</code> are equal because both act on a set of cardinality <code>5</code>, while <code>x</code> and <code>z</code> are different because <code>x</code> belongs to <code>Sym(5)</code> and <code>z</code> belongs to <code>Sym(2)</code>.</p><p>If <code>G</code> is a group and <code>x</code> is a permutation, it is possible to set <code>G</code> as parent of <code>x</code> simply typing <code>G(x)</code>. This returns the permutation <code>x</code> as element of <code>G</code> (or ERROR if <code>x</code> does not embed into <code>G</code>).</p><pre><code class="language-julia-repl">julia&gt; G=symmetric_group(5);

julia&gt; x=cperm([1,2,3]);

julia&gt; y=G(x);

julia&gt; parent(x)
Sym( [ 1 .. 3 ] )

julia&gt; parent(y)
Sym( [ 1 .. 5 ] )</code></pre><p>The function <code>listperm</code> works in the opposite way with respect to <code>perm</code>:</p><article class="docstring"><header><a class="docstring-binding" href="#Oscar.listperm" id="Oscar.listperm"><code>Oscar.listperm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">listperm(x::PermGroupElem)</code></pre><p>Return the list L defined by L = [ <code>x</code>(i) for i in 1:n ], where <code>n</code> is the degree of <code>parent(x)</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/GAPGroups.jl#L336-L339" target="_blank">source</a></section></article><h4 id="Permutations-as-functions"><a class="docs-heading-anchor" href="#Permutations-as-functions">Permutations as functions</a><a id="Permutations-as-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations-as-functions" title="Permalink"></a></h4><p>A permutation can be viewed as a function on the set <code>{1,...,n}</code>, hence it can be evaluated on integers.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The multiplication between permutations works from the left to the right. So, if <code>x</code> and <code>y</code> are permutations and <code>n</code> is an integer, then <code>(x*y)(n) = (y(x(n))</code>, NOT <code>x(y(n))</code>.</p></div></div><pre><code class="language-julia-repl">julia&gt; x = cperm([1,2,3,4,5]);
julia&gt; x(2)
3</code></pre><p>This works also if the argument is not in the range <code>1:n</code>; in such a case, the output coincides with the input.</p><h2 id="Polycyclic-groups"><a class="docs-heading-anchor" href="#Polycyclic-groups">Polycyclic groups</a><a id="Polycyclic-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Polycyclic-groups" title="Permalink"></a></h2><p>Julia has the following functions that allow to generate polycyclic groups:</p><article class="docstring"><header><a class="docstring-binding" href="#Hecke.abelian_group-Union{Tuple{T}, Tuple{Type{T},Array{Int64,1}}} where T&lt;:Oscar.GAPGroup" id="Hecke.abelian_group-Union{Tuple{T}, Tuple{Type{T},Array{Int64,1}}} where T&lt;:Oscar.GAPGroup"><code>Hecke.abelian_group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abelian_group(::Type{T}, v::Vector{Int}) where T &lt;: Group -&gt; PcGroup</code></pre><p>Return the direct product of cyclic groups of order v[1] x v[2] x ... x v[n], as group of type <code>T</code>. Here, <code>T</code> must be of type <code>PermGroup</code>, <code>FPGroup</code> or <code>PcGroup</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/group_constructors.jl#L108-L111" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.cyclic_group" id="Oscar.cyclic_group"><code>Oscar.cyclic_group</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cyclic_group(::Type{T}, n::Int)</code></pre><p>Return the cyclic group of order <code>n</code> and type <code>T</code>. If the type is not specified, the group is returned of type <code>PcGroup</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/group_constructors.jl#L85-L88" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.dihedral_group" id="Oscar.dihedral_group"><code>Oscar.dihedral_group</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dihedral_group(n::Int)
dihedral_group(::Type{T}, n::Int)</code></pre><p>Return the dihedral group of order <code>n</code> of type <code>T</code>, where <code>T</code> is in {<code>PcGroup</code>,<code>PermGroup</code>,<code>FPGroup</code>}. In the first case, the type is set as <code>PcGroup</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/group_constructors.jl#L190-L194" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.quaternion_group" id="Oscar.quaternion_group"><code>Oscar.quaternion_group</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quaternion_group(n::Int)
quaternion_group(::Type{T}, n::Int)</code></pre><p>Return the quaternion group of order <code>n</code> of type <code>T</code>, where <code>T</code> is in {<code>PcGroup</code>,<code>PermGroup</code>,<code>FPGroup</code>,<code>MatrixGroup</code>}. In the first case, the type is set as <code>PcGroup</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/group_constructors.jl#L202-L206" target="_blank">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The type need to be specified in the input of the function <code>abelian_group</code>, otherwise a group of type <code>GrpAbFinGen</code> is returned, which is not a GAP group type. In future versions of Oscar, this may change.</p></div></div><p>The generators of a polycyclic group are displayed as <code>f1</code>, <code>f2</code>, <code>f3</code>, etc., and every element of a polycyclic group is displayed as product of such generators.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; G=abelian_group(PcGroup, [2,4]);
julia&gt; G[1], G[2]
(f1, f2)
julia&gt; G[2]*G[1]
f1*f2</code></pre><p>Note that this does not define Julia variables named <code>f1</code>, <code>f2</code>, etc.! To get the generators of the group <code>G</code>, use <code>gens(G)</code>; for convenience they can also be accessed as <code>G[1]</code>, <code>G[2]</code>, as shown in Section <a href="#elements_of_groups">Elements of groups</a>.</p><h2 id="Homomorphisms"><a class="docs-heading-anchor" href="#Homomorphisms">Homomorphisms</a><a id="Homomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Homomorphisms" title="Permalink"></a></h2><p>In Oscar, a group homomorphism from <code>G</code> to <code>H</code> is an object of parametric type <code>GAPGroupHomomorphism{S,T}</code>, where <code>S</code> and <code>T</code> are the types of <code>G</code> and <code>H</code> respectively.</p><p>A homomorphism from <code>G</code> to <code>H</code> can be defined in two ways.</p><ul><li>Writing explicitly the images of the generators of <code>G</code>:</li></ul><pre><code class="language-julia">f = hom(G,H,[x1,x2,...],[y1,y2,...])</code></pre><p>Here, <code>[x1,x2,...]</code> must be a generating set for <code>G</code> (not necessarily minimal) and <code>[y1,y2,...]</code> is a vector of elements of <code>H</code> of the same length of <code>[x1,x2,...]</code>. This assigns to <code>f</code> the value of the group homomorphism sending <code>x_i</code> into <code>y_i</code>. If such a homomorphism does not exist, an error is returned.</p><ul><li>Taking an existing function <code>g</code> satisfying the group homomorphism properties:</li></ul><pre><code class="language-julia">f = hom(G,H,g)</code></pre><p>If the function <code>g</code> does not satisfy the group homomorphism properties, an error is returned.</p><p><strong>Example:</strong> The following procedures define the same homomorphism (conjugation by <code>x</code>) in the two ways explained above.</p><pre><code class="language-julia-repl">julia&gt; S=symmetric_group(4);
julia&gt; x=S[1];
julia&gt; f=hom(S,S,gens(S),[S[1]^x,S[2]^x]);
julia&gt; g=hom(S,S,y-&gt;y^x);
julia&gt; f==g
true</code></pre><p>Oscar has also the following standard homomorphism.</p><article class="docstring"><header><a class="docstring-binding" href="#Hecke.id_hom" id="Hecke.id_hom"><code>Hecke.id_hom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">id_hom(G::GAPGroup)</code></pre><p>Return the identity homomorphism on the group <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L68-L71" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.trivial_morphism" id="Oscar.trivial_morphism"><code>Oscar.trivial_morphism</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trivial_morphism(G::GAPGroup, H::GAPGroup)</code></pre><p>Return the homomorphism from <code>G</code> to <code>H</code> sending every element of <code>G</code> into the identity of <code>H</code>. If <code>H</code> is not specified, it is taken equal to <code>G</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L76-L79" target="_blank">source</a></section></article><p>To evaluate the homomorphism <code>f</code> in the element <code>x</code> of <code>G</code>, it is possible to use the instruction</p><pre><code class="language-julia">image(f,x)</code></pre><p>or the more compact notations <code>f(x)</code> and <code>x^f</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; S=symmetric_group(4);
julia&gt; f=hom(S,S,x-&gt;x^S[1]);
julia&gt; x=cperm(S,[1,2]);
julia&gt; image(f,x)
(2,3)
julia&gt; f(x)
(2,3)
julia&gt; x^f
(2,3)</code></pre><p>A sort of "inverse" of the evaluation is the following</p><article class="docstring"><header><a class="docstring-binding" href="#Hecke.haspreimage-Tuple{Oscar.GAPGroupHomomorphism,GAPGroupElem}" id="Hecke.haspreimage-Tuple{Oscar.GAPGroupHomomorphism,GAPGroupElem}"><code>Hecke.haspreimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">haspreimage(f::GAPGroupHomomorphism, x::GAPGroupElem)</code></pre><p>Return (<code>true</code>,<code>y</code>) if there exists <code>y</code> such that <code>f</code>(<code>y</code>) = <code>x</code>; otherwise, return (<code>false</code>,<code>1</code>).</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L251-L254" target="_blank">source</a></section></article><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; S=symmetric_group(4);
julia&gt; f=hom(S,S,x-&gt;x^S[1]);
julia&gt; x=cperm(S,[1,2]);
julia&gt; haspreimage(f,x)
(true,(1,4))</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Do not confuse <code>haspreimage</code> with the function <code>has_preimage</code>, which works on variable of type <code>GrpGenToGrpGenMor</code>.</p></div></div><p>A further function that produces isomorphisms is <code>isisomorphic</code>:</p><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.isisomorphic-Tuple{Oscar.GAPGroup,Oscar.GAPGroup}" id="AbstractAlgebra.Generic.isisomorphic-Tuple{Oscar.GAPGroup,Oscar.GAPGroup}"><code>AbstractAlgebra.Generic.isisomorphic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isisomorphic(G::Group, H::Group)</code></pre><p>Return (<code>true</code>,<code>f</code>) if <code>G</code> and <code>H</code> are isomorphic groups, where <code>f</code> is a group isomorphism. Otherwise, return (<code>false</code>,<code>f</code>), where <code>f</code> is the trivial homomorphism.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L280-L283" target="_blank">source</a></section></article><h3 id="Operations-on-homomorphisms"><a class="docs-heading-anchor" href="#Operations-on-homomorphisms">Operations on homomorphisms</a><a id="Operations-on-homomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-homomorphisms" title="Permalink"></a></h3><p>Oscar supports the following operations on homomorphisms.</p><ul><li><p><code>inv(f)</code> = the inverse of <code>f</code>. An error is returned if <code>f</code> is not bijective.</p></li><li><p><code>f^n</code> = the homomorphism <code>f</code> composed <code>n</code> times with itself. An error is returned if the domain and the codomain of <code>f</code> do not coincide (unless <code>n=1</code>). If <code>n</code> is negative, the result is the inverse of <code>f</code> composed <code>n</code> times with itself.</p></li><li><p><code>compose(g,f)</code> = composition of <code>g</code> and <code>f</code>. This works only if the codomain of <code>g</code> coincide with the domain of <code>f</code>. Shorter equivalent expressions are <code>g*f</code> and <code>f(g)</code>.</p><p><strong>Example:</strong></p></li></ul><pre><code class="language-julia-repl">julia&gt; S=symmetric_group(4);
julia&gt; f=hom(S,S,x-&gt;x^S[1]);
julia&gt; g=hom(S,S,x-&gt;x^S[2]);
julia&gt; f*g==hom(S,S,x-&gt;x^(S[1]*S[2]))
true
julia&gt; f==f^-3
true</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The composition operation <code>*</code> has to be read from the right to the left. So, <code>(f*g)(x)</code> is equivalent to <code>g(f(x))</code>.</p></div></div><h3 id="Properties-of-homomorphisms"><a class="docs-heading-anchor" href="#Properties-of-homomorphisms">Properties of homomorphisms</a><a id="Properties-of-homomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Properties-of-homomorphisms" title="Permalink"></a></h3><p>Oscar implements the following attributes of homomorphisms.</p><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.domain" id="AbstractAlgebra.Generic.domain"><code>AbstractAlgebra.Generic.domain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">domain(f::GAPGroupHomomorphism)</code></pre><p>Return the domain of <code>f</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L122-L125" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.codomain" id="AbstractAlgebra.Generic.codomain"><code>AbstractAlgebra.Generic.codomain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">codomain(f::GAPGroupHomomorphism)</code></pre><p>Return the codomain of <code>f</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L130-L133" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Hecke.isinjective-Tuple{Oscar.GAPGroupHomomorphism}" id="Hecke.isinjective-Tuple{Oscar.GAPGroupHomomorphism}"><code>Hecke.isinjective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinjective(f::GAPGroupHomomorphism)</code></pre><p>Return whether <code>f</code> is injective.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L158-L161" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Hecke.issurjective-Tuple{Oscar.GAPGroupHomomorphism}" id="Hecke.issurjective-Tuple{Oscar.GAPGroupHomomorphism}"><code>Hecke.issurjective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issurjective(f::GAPGroupHomomorphism)</code></pre><p>Return whether <code>f</code> is surjective.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L150-L153" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Hecke.isbijective-Tuple{Oscar.GAPGroupHomomorphism}" id="Hecke.isbijective-Tuple{Oscar.GAPGroupHomomorphism}"><code>Hecke.isbijective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbijective(f::GAPGroupHomomorphism)</code></pre><p>Return whether <code>f</code> is bijective.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L174-L177" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Hecke.isinvertible-Tuple{Oscar.GAPGroupHomomorphism}" id="Hecke.isinvertible-Tuple{Oscar.GAPGroupHomomorphism}"><code>Hecke.isinvertible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinvertible(f::GAPGroupHomomorphism)</code></pre><p>Return whether <code>f</code> is invertible.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L166-L169" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.isinvariant-Tuple{Oscar.GAPGroupHomomorphism,Oscar.GAPGroup}" id="Oscar.isinvariant-Tuple{Oscar.GAPGroupHomomorphism,Oscar.GAPGroup}"><code>Oscar.isinvariant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinvariant(f::GAPGroupHomomorphism, H::Group)
isinvariant(f::GAPGroupElem{AutomorphismGroup{T}}, H::T)</code></pre><p>Return whether <code>f</code>(<code>H</code>) == <code>H</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L183-L187" target="_blank">source</a></section></article><h3 id="Subgroups-described-by-homomorphisms"><a class="docs-heading-anchor" href="#Subgroups-described-by-homomorphisms">Subgroups described by homomorphisms</a><a id="Subgroups-described-by-homomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Subgroups-described-by-homomorphisms" title="Permalink"></a></h3><p>The following functions compute subgroups or quotients of either the domain or the codomain. Analogously to the functions described in Sections <a href="#subgroups">Subgroups</a> and <a href="#quotient">Quotients</a>, the output consists of a pair (<code>H</code>, <code>g</code>), where <code>H</code> is a subgroup (resp. quotient) and <code>g</code> is its embedding (resp. projection) homomorphism.</p><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.kernel-Tuple{Oscar.GAPGroupHomomorphism}" id="AbstractAlgebra.Generic.kernel-Tuple{Oscar.GAPGroupHomomorphism}"><code>AbstractAlgebra.Generic.kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kernel(f::GAPGroupHomomorphism)</code></pre><p>Return the kernel of <code>f</code>, together with its embedding into <code>domain</code>(<code>f</code>).</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L210-L213" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.image-Tuple{Oscar.GAPGroupHomomorphism}" id="AbstractAlgebra.Generic.image-Tuple{Oscar.GAPGroupHomomorphism}"><code>AbstractAlgebra.Generic.image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">image(f::GAPGroupHomomorphism)</code></pre><p>Return the image of <code>f</code> as subgroup of <code>codomain</code>(<code>f</code>), together with the embedding homomorphism.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L219-L222" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.image-Union{Tuple{S}, Tuple{T}, Tuple{Oscar.GAPGroupHomomorphism{S,T},S}} where S&lt;:Oscar.GAPGroup where T&lt;:Oscar.GAPGroup" id="AbstractAlgebra.Generic.image-Union{Tuple{S}, Tuple{T}, Tuple{Oscar.GAPGroupHomomorphism{S,T},S}} where S&lt;:Oscar.GAPGroup where T&lt;:Oscar.GAPGroup"><code>AbstractAlgebra.Generic.image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">image(f::GAPGroupHomomorphism{S, T}, H::S) where S &lt;: GAPGroup where T &lt;: GAPGroup
(f::GAPGroupHomomorphism{S, T})(H::S)</code></pre><p>Return <code>f</code>(<code>H</code>), together with the embedding homomorphism into <code>codomain</code>(<code>f</code>).</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L228-L232" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Hecke.cokernel-Tuple{Oscar.GAPGroupHomomorphism}" id="Hecke.cokernel-Tuple{Oscar.GAPGroupHomomorphism}"><code>Hecke.cokernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cokernel(f::GAPGroupHomomorphism)</code></pre><p>Return the cokernel of <code>f</code>, that is, the quotient of the codomain of <code>f</code> by the normal closure of the image.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L240-L244" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractAlgebra.Generic.preimage-Union{Tuple{S}, Tuple{T}, Tuple{Oscar.GAPGroupHomomorphism{S,T},T}} where S&lt;:Oscar.GAPGroup where T&lt;:Oscar.GAPGroup" id="AbstractAlgebra.Generic.preimage-Union{Tuple{S}, Tuple{T}, Tuple{Oscar.GAPGroupHomomorphism{S,T},T}} where S&lt;:Oscar.GAPGroup where T&lt;:Oscar.GAPGroup"><code>AbstractAlgebra.Generic.preimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">preimage(f::GAPGroupHomomorphism{S, T}, H::T) where S &lt;: GAPGroup where T &lt;: GAPGroup</code></pre><p>If <code>H</code> is a subgroup of the codomain of <code>f</code>, return the subgroup <code>f^-1(H)</code>, together with its embedding homomorphism into the domain of <code>f</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L264-L267" target="_blank">source</a></section></article><h2 id="Automorphisms-groups"><a class="docs-heading-anchor" href="#Automorphisms-groups">Automorphisms groups</a><a id="Automorphisms-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Automorphisms-groups" title="Permalink"></a></h2><p>Groups of automorphisms over a group <code>G</code> have parametric type <code>AutomorphismGroup{T}</code>, where <code>T</code> is the type of <code>G</code>. The group of automorphisms over a group <code>G</code> is defined by the following instruction:</p><pre><code class="language-julia">automorphism_group(G)</code></pre><p>The evaluation of the automorphism <code>f</code> in the element <code>x</code> is analogous to the homomorphism evaluation: it can be obtained by typing either <code>f(x)</code> or <code>x^f</code>.</p><p>It is possible to turn an automorphism <code>f</code> into a homomorphism by typing <code>hom(f)</code>. The viceversa is also possible: if <code>g</code> is a bijective homomorphism from the group <code>G</code> to itself and <code>A</code> is the automorphism group of <code>G</code>, then the instruction <code>A(g)</code> returns <code>g</code> as automorphism of <code>G</code>. This is the standard way to build explicitly an automorphism (another way, available for inner automorphisms, is shown in Section <a href="#inner_automorphisms">Inner_automorphisms</a>).</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; S=symmetric_group(4);
julia&gt; A=automorphism_group(S);
julia&gt; g=hom(S,S,x-&gt;x^S[1]);
julia&gt; g in A
false
julia&gt; au=A(g);
julia&gt; au in A
true
julia&gt; g=hom(au)
true
julia&gt; x=cperm(S,[1,2,3]);
julia&gt; au(x)
(2,3,4)
julia&gt; g(x)==au(x)
true</code></pre><p>In Oscar it is possible to multiply homomorphisms and automorphisms (whenever it makes sense); in such cases, the output is always a variable of type <code>GAPGroupHomomorphism{S,T}</code>.</p><pre><code class="language-julia-repl">julia&gt; S=symmetric_group(4);

julia&gt; A=automorphism_group(S);

julia&gt; g=hom(S,S,x-&gt;x^S[1]);

julia&gt; f=A(g);

julia&gt; typeof(g*f)
Oscar.GAPGroupHomomorphism{PermGroup,PermGroup}</code></pre><p>The following functions are available for automorphisms, some of them similar to the corresponding functions for homomorphisms of groups.</p><article class="docstring"><header><a class="docstring-binding" href="#Oscar.isinvariant-Union{Tuple{T}, Tuple{GAPGroupElem{AutomorphismGroup{T}},T}} where T&lt;:Oscar.GAPGroup" id="Oscar.isinvariant-Union{Tuple{T}, Tuple{GAPGroupElem{AutomorphismGroup{T}},T}} where T&lt;:Oscar.GAPGroup"><code>Oscar.isinvariant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinvariant(f::GAPGroupElem{AutomorphismGroup{T}}, H::T)</code></pre><p>Return whether <code>f</code>(<code>H</code>) == <code>H</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L416-L419" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.restrict_automorphism-Union{Tuple{T}, Tuple{GAPGroupElem{AutomorphismGroup{T}},T}, Tuple{GAPGroupElem{AutomorphismGroup{T}},T,Any}} where T&lt;:Oscar.GAPGroup" id="Oscar.restrict_automorphism-Union{Tuple{T}, Tuple{GAPGroupElem{AutomorphismGroup{T}},T}, Tuple{GAPGroupElem{AutomorphismGroup{T}},T,Any}} where T&lt;:Oscar.GAPGroup"><code>Oscar.restrict_automorphism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">restrict_automorphism(f::GAPGroupElem{AutomorphismGroup{T}}, H::T)</code></pre><p>If <code>H</code> is invariant under <code>f</code>, returns the restriction of <code>f</code> to <code>H</code> as automorphism of <code>H</code>; otherwise it returns ERROR.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L439-L442" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.induced_automorphism-Tuple{Oscar.GAPGroupHomomorphism,Oscar.GAPGroupHomomorphism}" id="Oscar.induced_automorphism-Tuple{Oscar.GAPGroupHomomorphism,Oscar.GAPGroupHomomorphism}"><code>Oscar.induced_automorphism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">induced_automorphism(f::GAPGroupHomomorphism, g::GAPGroupHomomorphism)
induced_automorphism(f::GAPGroupHomomorphism, g::GAPGroupElem{AutomorphismGroup{T}})</code></pre><p>Return the automorphism <code>h</code> of the image of <code>f</code> such that <code>h</code>(<code>f</code>) == <code>f</code>(<code>g</code>), where <code>g</code> is an automorphism of a group <code>G</code> and <code>f</code> is a group homomorphism defined over <code>G</code> such that the kernel of <code>f</code> is invariant under <code>g</code></p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L425-L429" target="_blank">source</a></section></article><h3 id="inner_automorphisms"><a class="docs-heading-anchor" href="#inner_automorphisms">Inner automorphisms</a><a id="inner_automorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#inner_automorphisms" title="Permalink"></a></h3><p>Oscar disposes of the following functions to handle inner automorphisms of a group.</p><article class="docstring"><header><a class="docstring-binding" href="#Oscar.inner_automorphism-Tuple{GAPGroupElem}" id="Oscar.inner_automorphism-Tuple{GAPGroupElem}"><code>Oscar.inner_automorphism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inner_automorphism(g::GAPGroupElem)</code></pre><p>Return the inner automorphism in <code>automorphism_group(parent(g))</code> defined by <code>x</code> -&gt; <code>x^g</code>.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L385-L388" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.isinner_automorphism-Tuple{Oscar.GAPGroupHomomorphism}" id="Oscar.isinner_automorphism-Tuple{Oscar.GAPGroupHomomorphism}"><code>Oscar.isinner_automorphism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinner_automorphism(f::GAPGroupHomomorphism)
isinner_automorphism(f::GAPGroupElem{AutomorphismGroup{T}})</code></pre><p>Return whether <code>f</code> is an inner automorphism.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L393-L397" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Oscar.inner_automorphisms_group-Union{Tuple{AutomorphismGroup{T}}, Tuple{T}} where T&lt;:Oscar.GAPGroup" id="Oscar.inner_automorphisms_group-Union{Tuple{AutomorphismGroup{T}}, Tuple{T}} where T&lt;:Oscar.GAPGroup"><code>Oscar.inner_automorphisms_group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inner_automorphisms_group(A::AutomorphismGroup{T})</code></pre><p>Return the subgroup of <code>A</code> of the inner automorphisms.</p></div><a class="docs-sourcelink" href="https://github.com/oscar-system/Oscar.jl/blob/57984b34e34c5b6b9c919e113befd51b7ab2a10e/src/Groups/homomorphisms.jl#L407-L410" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../Rings/rational/">« Rationals</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 23 September 2020 14:47">Wednesday 23 September 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>