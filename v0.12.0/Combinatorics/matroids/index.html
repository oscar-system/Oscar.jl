<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Matroids Â· Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../Experimental/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/homological_algebra/">Homological Algebra</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">GrÃ¶bner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/groebner_bases/">GrÃ¶bner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/groebner_bases_integers/">GrÃ¶bner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Toric Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/ToricSchemes/intro/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/ToricSchemes/NormalToricSchemes/">Normal Toric Schemes</a></li><li><a class="tocitem" href="../../Experimental/ToricSchemes/AffineToricSchemes/">Affine Toric Schemes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/TropicalGeometry/curve/">Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/K3Surfaces/">Automorphism Groups of  K3 surfaces</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/SurfacesP4/">Nongeneral Type Surfaces in <span>$\mathbb P^4$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-8" type="checkbox"/><label class="tocitem" for="menuitem-11-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Miscellaneous/miscellaneous/">Some Special Ideals</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Noncommutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox" checked/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../graphs/">Graphs</a></li><li class="is-active"><a class="tocitem" href>Matroids</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Construction"><span>Construction</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Properties"><span>Properties</span></a></li><li><a class="tocitem" href="#Matroid-strata-and-realization-spaces"><span>Matroid strata and realization spaces</span></a></li></ul></li><li><a class="tocitem" href="../simplicialcomplexes/">Simplicial Complexes</a></li><li><a class="tocitem" href="../partitions/">Partitions</a></li><li><a class="tocitem" href="../tableaux/">Tableaux</a></li><li><a class="tocitem" href="../schur_polynomials/">Schur polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-7" type="checkbox"/><label class="tocitem" for="menuitem-17-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-18" type="checkbox"/><label class="tocitem" for="menuitem-18"><span class="docs-label">Experimental</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/intro/">Adding new projects to experimental</a></li><li><input class="collapse-toggle" id="menuitem-18-2" type="checkbox"/><label class="tocitem" for="menuitem-18-2"><span class="docs-label">F-Theory Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/FTheoryTools/introduction/">Welcome to FTheoryTools</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/weierstrass/">Global Weierstrass models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/tate/">Global Tate models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-18-3" type="checkbox"/><label class="tocitem" for="menuitem-18-3"><span class="docs-label">Linear Quotients</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/LinearQuotients/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/LinearQuotients/linear_quotients/">Construction and basic functionality</a></li><li><a class="tocitem" href="../../Experimental/LinearQuotients/cox_rings/">Cox rings</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Combinatorics</a></li><li class="is-active"><a href>Matroids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Matroids</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/Combinatorics/matroids.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#Matroids">Matroids</a></li><li class="no-marker"><ul><li><a href="#Introduction">Introduction</a></li><li><a href="#Construction">Construction</a></li><li><a href="#Examples">Examples</a></li><li><a href="#Properties">Properties</a></li><li><a href="#Matroid-strata-and-realization-spaces">Matroid strata and realization spaces</a></li></ul></li></ul><h1 id="Matroids"><a class="docs-heading-anchor" href="#Matroids">Matroids</a><a id="Matroids-1"></a><a class="docs-heading-anchor-permalink" href="#Matroids" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Matroids are a fundamental combinatorial object with connections to various fields of mathematics. It is an abstraction of linear independence in vector spaces and forests in graphs. One way to define a <em>matroid</em> is via the following two sets of data:</p><ul><li>a finite <em>ground set</em> <span>$E := \{1,\ldots,n\}$</span> and</li><li>a nonempty finite set <span>$\mathcal{B} \subseteq \mathcal{P}(E)$</span> of <em>bases</em> satisfying an exchange property.</li></ul><p>There are however many equivalent ways to define a matroid. One can also define a matroid via its <em>circuits</em>, <em>hyperplanes</em>, a <em>graph</em>, or a <em>matrix</em>. For a detailed introduction of matroids we refer to the textbook <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><h2 id="Construction"><a class="docs-heading-anchor" href="#Construction">Construction</a><a id="Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Construction" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="matroid_from_bases-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, ZZRingElem}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}" href="#matroid_from_bases-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, ZZRingElem}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}"><code>matroid_from_bases</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_bases(B, [n, E])</code></pre><p><strong>Arguments</strong></p><ul><li><code>B::AbstractVector</code>: The set of bases of the matroid.</li><li><code>n::InterUnion</code>: The size of the ground set. The ground set will be <code>{1,..n}</code> in this case.</li><li><code>E::AbstractVector</code>: An explicit ground set passed as vector.</li></ul><p>Construct a <code>matroid</code> with bases <code>B</code> on the ground set <code>E</code> (which can be the empty set). The set <code>B</code> is a non-empty collection of subsets of the ground set <code>E</code> satisfying an exchange property, and the default value for <code>E</code> is the set <code>{1,..n}</code> for a non-negative value <code>n</code>.</p><p>See Section 1.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct a rank two matroid with five bases on four elements you can write:</p><pre><code class="language-julia-repl hljs">julia&gt; B = [[1,2],[1,3],[1,4],[2,3],[2,4]];

julia&gt; M = matroid_from_bases(B,4)
Matroid of rank 2 on 4 elements</code></pre><p>To construct the same matroid on the four elements 1,2,i,j you may write:</p><pre><code class="language-julia-repl hljs">julia&gt; M = matroid_from_bases([[1,2],[1,&#39;i&#39;],[1,&#39;j&#39;],[2,&#39;i&#39;],[2,&#39;j&#39;]],[1,2,&#39;i&#39;,&#39;j&#39;])
Matroid of rank 2 on 4 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L55-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matroid_from_nonbases-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, ZZRingElem}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}" href="#matroid_from_nonbases-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, ZZRingElem}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}"><code>matroid_from_nonbases</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_nonbases(N, [n, E])</code></pre><p><strong>Arguments</strong></p><ul><li><code>N::AbstractVector</code>: The set of nonbases of the matroid.</li><li><code>n::InterUnion</code>: The size of the ground set. The ground set will be <code>{1,..n}</code> in this case.</li><li><code>E::AbstractVector</code>: An explicit ground set passed as vector.</li></ul><p>Construct a <code>matroid</code> with nonbases <code>N</code> on the ground set <code>E</code> (which can be the empty set). That means that the matroid has as bases all subsets of the size <code>|N[1]|</code> of the ground set that are not in <code>N</code>. The set <code>N</code> can&#39;t be empty in this function. The described complement of <code>N</code> needs to be a non-empty collection of subsets of the ground set <code>E</code> satisfying an exchange property, and the default value for <code>E</code> is the set <code>{1,..n}</code> for a non-negative value <code>n</code>.</p><p>See Section 1.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the Fano matroid you may write:</p><pre><code class="language-julia-repl hljs">julia&gt; H = [[1,2,4],[2,3,5],[1,3,6],[3,4,7],[1,5,7],[2,6,7],[4,5,6]];

julia&gt; M = matroid_from_nonbases(H,7)
Matroid of rank 3 on 7 elements
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L108-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matroid_from_circuits-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, ZZRingElem}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}" href="#matroid_from_circuits-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, ZZRingElem}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}"><code>matroid_from_circuits</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_circuits(C, [n, E])</code></pre><p><strong>Arguments</strong></p><ul><li><code>C::AbstractVector</code>: The set of circuits of the matroid.</li><li><code>n::InterUnion</code>: The size of the ground set. The ground set will be <code>{1,..n}</code> in this case.</li><li><code>E::AbstractVector</code>: An explicit ground set passed as vector.</li></ul><p>A matroid with circuits <code>C</code> on the ground set <code>E</code> (which can be the empty set). The set <code>C</code> is a collection of subsets of the ground set <code>E</code> satisfying an exchange property, and the default value for <code>E</code> is the set <code>{1,..n}</code> for a non-negative value <code>n</code>. </p><p>See Section 1.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct a rank two matroid with five bases on four elements by its circuits you may write:</p><pre><code class="language-julia-repl hljs">julia&gt; C = [[1,2,3],[1,2,4],[3,4]];

julia&gt; M = matroid_from_circuits(C,4)
Matroid of rank 2 on 4 elements</code></pre><p>To construct the same matroid on the ground set <code>{1,2,i,j}</code> you may write:</p><pre><code class="language-julia-repl hljs">julia&gt; C = [[1,2,&#39;j&#39;],[1,2,&#39;i&#39;],[&#39;i&#39;,&#39;j&#39;]];

julia&gt; M = matroid_from_circuits(C,[1,2,&#39;i&#39;,&#39;j&#39;])
Matroid of rank 2 on 4 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L164-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matroid_from_hyperplanes-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, ZZRingElem}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}" href="#matroid_from_hyperplanes-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, ZZRingElem}}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}"><code>matroid_from_hyperplanes</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_hyperplanes(H, [n, E])</code></pre><p><strong>Arguments</strong></p><ul><li><code>H::AbstractVector</code>: The set of hyperplanes of the matroid.</li><li><code>n::InterUnion</code>: The size of the ground set. The ground set will be <code>{1,..n}</code> in this case.</li><li><code>E::AbstractVector</code>: An explicit ground set passed as vector.</li></ul><p>A matroid with hyperplanes <code>H</code> on the ground set <code>E</code> (which can be the empty set). A hyperplane is a flat of rank <code>r-1</code>. The set <code>H</code> is a collection of subsets of the ground set <code>E</code> satisfying an exchange property, and the default value for <code>E</code> is the set <code>{1,..n}</code> for a non-negative value <code>n</code>. </p><p>See Section 1.4 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the Fano matroid you may write:</p><pre><code class="language-julia-repl hljs">julia&gt; H = [[1,2,4],[2,3,5],[1,3,6],[3,4,7],[1,5,7],[2,6,7],[4,5,6]];

julia&gt; M = matroid_from_hyperplanes(H,7)
Matroid of rank 3 on 7 elements
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L218-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matroid_from_matrix_columns-Tuple{MatrixElem{T} where T}" href="#matroid_from_matrix_columns-Tuple{MatrixElem{T} where T}"><code>matroid_from_matrix_columns</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_matrix_columns(A::MatrixElem)</code></pre><p>A matroid represented by the column vectors of a matrix <code>A</code>.</p><p>See Section 1.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the vector matroid (a.k.a linear matroid) of the matrix <code>A</code> over the field with two elements write:</p><pre><code class="language-julia-repl hljs">julia&gt; A = matrix(GF(2),[[1,0,1,1],[0,1,1,1]]);

julia&gt; M = matroid_from_matrix_columns(A)
Matroid of rank 2 on 4 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L267-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matroid_from_matrix_rows-Tuple{MatrixElem{T} where T}" href="#matroid_from_matrix_rows-Tuple{MatrixElem{T} where T}"><code>matroid_from_matrix_rows</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_matrix_columns(A::MatrixElem)</code></pre><p>A matroid represented by the row vectors of a matrix.</p><p>See Section 1.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the linear matroid of the rows of the matrix <code>A</code> over the field with two elements write:</p><pre><code class="language-julia-repl hljs">julia&gt; A = matrix(GF(2),[[1,0],[0,1],[1,1],[1,1]]);

julia&gt; M = matroid_from_matrix_rows(A)
Matroid of rank 2 on 4 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L303-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cycle_matroid-Tuple{Graph}" href="#cycle_matroid-Tuple{Graph}"><code>cycle_matroid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cycle_matroid(g::Graph)</code></pre><p>The cycle matroid of a graph <code>g</code>.</p><p>See Section 1.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the cycle matroid of the complete graph of 4 vertices write:</p><pre><code class="language-julia-repl hljs">julia&gt; g = complete_graph(4);

julia&gt; M = cycle_matroid(g)
Matroid of rank 3 on 6 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L321-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="bond_matroid-Tuple{Graph}" href="#bond_matroid-Tuple{Graph}"><code>bond_matroid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bond_matroid(g::Graph)</code></pre><p>The &quot;bond matroid&quot; or &quot;cocycle matroid&quot; of a graph which is the dual of a cycle matroid, i.e., cographic.</p><p>See Section 2.3 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the bond or cocycle matroid of the complete graph of 4 vertices write:</p><pre><code class="language-julia-repl hljs">julia&gt; g = complete_graph(4);

julia&gt; M = bond_matroid(g)
Matroid of rank 3 on 6 elements</code></pre><p>or equivalently</p><pre><code class="language-julia-repl hljs">julia&gt; g = complete_graph(4);

julia&gt; M = cocycle_matroid(g)
Matroid of rank 3 on 6 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L345-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cocycle_matroid-Tuple{Graph}" href="#cocycle_matroid-Tuple{Graph}"><code>cocycle_matroid</code></a> â <span class="docstring-category">Method</span></header><section><div><p>See <code>bond_matroid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L372-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Matroid" href="#Matroid"><code>Matroid</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matroid(pm_matroid::Polymake.BigObjectAllocated, [E::GroundsetType])</code></pre><p>Construct a <code>matroid</code> from a <code>polymake</code> matroid <code>M</code> on the default ground set <code>{1,...,n}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matroid_from_revlex_basis_encoding-Tuple{String, Union{Integer, ZZRingElem}, Union{Integer, ZZRingElem}}" href="#matroid_from_revlex_basis_encoding-Tuple{String, Union{Integer, ZZRingElem}, Union{Integer, ZZRingElem}}"><code>matroid_from_revlex_basis_encoding</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_from_revlex_basis_encoding(rvlx::String, r::IntegerUnion, n::IntegerUnion)</code></pre><p>Construct a <code>matroid</code> from a revlex-basis-encoding-string <code>rvlx</code> of rank <code>r</code> and size <code>n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matroid_from_revlex_basis_encoding(&quot;0******0******0***0******0*0**0****&quot;, 3, 7)
Matroid of rank 3 on 7 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L34-L44">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="uniform_matroid-Tuple{Union{Integer, ZZRingElem}, Union{Integer, ZZRingElem}}" href="#uniform_matroid-Tuple{Union{Integer, ZZRingElem}, Union{Integer, ZZRingElem}}"><code>uniform_matroid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uniform_matroid(r,n)</code></pre><p>Construct the uniform matroid of rank <code>r</code> on the <code>n</code> elements <code>{1,...,n}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L709-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fano_matroid-Tuple{}" href="#fano_matroid-Tuple{}"><code>fano_matroid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fano_matroid()</code></pre><p>Construct the Fano matroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L716-L720">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="non_fano_matroid-Tuple{}" href="#non_fano_matroid-Tuple{}"><code>non_fano_matroid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">non_fano_matroid()</code></pre><p>Construct the non-Fano matroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L723-L727">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="non_pappus_matroid-Tuple{}" href="#non_pappus_matroid-Tuple{}"><code>non_pappus_matroid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">non_pappus_matroid()</code></pre><p>Construct the non-Pappus matroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L730-L734">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="pappus_matroid-Tuple{}" href="#pappus_matroid-Tuple{}"><code>pappus_matroid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pappus_matroid()</code></pre><p>Construct the Pappus matroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L737-L741">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="vamos_matroid-Tuple{}" href="#vamos_matroid-Tuple{}"><code>vamos_matroid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vamos_matroid()</code></pre><p>Construct the Vamos matroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L744-L748">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="all_subsets_matroid-Tuple{Int64}" href="#all_subsets_matroid-Tuple{Int64}"><code>all_subsets_matroid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_subsets_matroid(r)</code></pre><p>Construct the all-subsets-matroid of rank <code>r</code>, a.k.a. the matroid underlying the resonance arrangement or rank <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L751-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="projective_plane-Tuple{Int64}" href="#projective_plane-Tuple{Int64}"><code>projective_plane</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projective_plane(q::Int)</code></pre><p>The projective plane of order <code>q</code>. Note that this only works for prime numbers <code>q</code> for now.</p><p>See Section 6.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = projective_plane(3)
Matroid of rank 3 on 13 elements
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L765-L779">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="projective_geometry-Tuple{Int64, Int64}" href="#projective_geometry-Tuple{Int64, Int64}"><code>projective_geometry</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projective_geometry(r::Int, q::Int)</code></pre><p>The projective geometry of order <code>q</code> and rank <code>r+1</code>. Note that this only works for prime numbers <code>q</code> for now.</p><p>See Section 6.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>. Warning: Following the book of Oxley, the rank of the resulting matroid is <code>r+1</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = projective_geometry(2, 3)
Matroid of rank 3 on 13 elements
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L788-L803">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="affine_geometry-Tuple{Int64, Int64}" href="#affine_geometry-Tuple{Int64, Int64}"><code>affine_geometry</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">affine_geometry(r::Int, q::Int)</code></pre><p>The affine geometry of order <code>q</code> and rank <code>r+1</code>. Note that this only works for prime numbers <code>q</code> for now.</p><p>See Section 6.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>. Warning: Following the book of Oxley, the rank of the resulting matroid is <code>r+1</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = affine_geometry(2, 3)
Matroid of rank 3 on 9 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L825-L839">source</a></section></article><h3 id="Modifying-matroids"><a class="docs-heading-anchor" href="#Modifying-matroids">Modifying matroids</a><a id="Modifying-matroids-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-matroids" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="dual_matroid-Tuple{Matroid}" href="#dual_matroid-Tuple{Matroid}"><code>dual_matroid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual_matroid(M::Matroid)</code></pre><p>The <code>dual matroid</code> of a given matroid <code>M</code>.</p><p>See page 65 and Sectrion 2 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To construct the dual of the Fano matroid write:</p><pre><code class="language-julia-repl hljs">julia&gt; M = dual_matroid(fano_matroid())
Matroid of rank 4 on 7 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L378-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="direct_sum-Tuple{Matroid, Matroid}" href="#direct_sum-Tuple{Matroid, Matroid}"><code>direct_sum</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">direct_sum(M::Matroid, N::Matroid)</code></pre><p>The <code>direct sum</code> of the matroids <code>M</code> and <code>N</code>. Optionally one can also pass a vector of matroids.</p><p>See Section 4.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p>To obtain the direct sum of the Fano and a uniform matroid type:</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; direct_sum(fano_matroid(), uniform_matroid(2,4))
Matroid of rank 5 on 11 elements</code></pre><p>To take the sum of three uniform matroids use:</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matroids = Vector([uniform_matroid(2,4), uniform_matroid(1,3), uniform_matroid(3,4)]);

julia&gt; M = direct_sum(matroids)
Matroid of rank 6 on 11 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L423-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="deletion-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#deletion-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>deletion</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deletion(M, [S, e])</code></pre><p><strong>Arguments</strong></p><ul><li><code>M::Matroid</code>: A matroid <code>M</code>.</li><li><code>S::GroundsetType</code>: A subset <code>S</code> of the ground set of <code>M</code>.</li><li><code>e::ElementType</code>: An element <code>e</code> of the ground set of <code>M</code>.</li></ul><p>The <code>deletion M\S</code> of an element <code>e</code> or a subset <code>S</code> of the ground set <code>E</code> of the matroid <code>M</code>.</p><p>See Section 3 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matroid_from_bases([[1,2],[1,&#39;i&#39;],[1,&#39;j&#39;],[2,&#39;i&#39;],[2,&#39;j&#39;]],[1,2,&#39;i&#39;,&#39;j&#39;]);

julia&gt; N = deletion(M,&#39;i&#39;)
Matroid of rank 2 on 3 elements</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matroid_from_bases([[1,2],[1,&#39;i&#39;],[1,&#39;j&#39;],[2,&#39;i&#39;],[2,&#39;j&#39;]],[1,2,&#39;i&#39;,&#39;j&#39;]);

julia&gt; N = deletion(M,[&#39;i&#39;,&#39;j&#39;])
Matroid of rank 2 on 2 elements

julia&gt; matroid_groundset(N)
2-element Vector{Any}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L459-L491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="restriction-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#restriction-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>restriction</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">restriction(M, S)</code></pre><p><strong>Arguments</strong></p><ul><li><code>M::Matroid</code>: A matroid <code>M</code>.</li><li><code>S::GroundSetType</code>: A subset <code>S</code> of the ground set of <code>M</code>.</li></ul><p>The <code>restriction M|S</code> on a subset <code>S</code> of the ground set <code>E</code> of the matroid <code>M</code>.</p><p>See Section 3 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matroid_from_bases([[1,2],[1,&#39;i&#39;],[1,&#39;j&#39;],[2,&#39;i&#39;],[2,&#39;j&#39;]],[1,2,&#39;i&#39;,&#39;j&#39;]);

julia&gt; N = restriction(M,[1,2])
Matroid of rank 2 on 2 elements

julia&gt; matroid_groundset(N)
2-element Vector{Any}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L516-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="contraction-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#contraction-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>contraction</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contraction(M, [S, e])</code></pre><p><strong>Arguments</strong></p><ul><li><code>M::Matroid</code>: A matroid <code>M</code>.</li><li><code>S::GroundSetType</code>: A subset <code>S</code> of the ground set of <code>M</code>.</li><li><code>e::ElementType</code>: An element <code>e</code> of the ground set of <code>M</code>.</li></ul><p>The <code>contraction M/S</code> of an element or a subset <code>S</code> of the ground set <code>E</code> of the matroid <code>M</code>.</p><p>See Section 3 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matroid_from_bases([[1,2],[1,&#39;i&#39;],[1,&#39;j&#39;],[2,&#39;i&#39;],[2,&#39;j&#39;]],[1,2,&#39;i&#39;,&#39;j&#39;]);

julia&gt; N = contraction(M,&#39;i&#39;)
Matroid of rank 1 on 3 elements</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = matroid_from_bases([[1,2],[1,&#39;i&#39;],[1,&#39;j&#39;],[2,&#39;i&#39;],[2,&#39;j&#39;]],[1,2,&#39;i&#39;,&#39;j&#39;]);

julia&gt; N = contraction(M,[&#39;i&#39;,&#39;j&#39;])
Matroid of rank 1 on 2 elements

julia&gt; matroid_groundset(N)
2-element Vector{Any}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L545-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="minor-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{AbstractSet, AbstractVector{T} where T}}" href="#minor-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{AbstractSet, AbstractVector{T} where T}}"><code>minor</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minor(M::Matroid, set_del::GroundsetType, set_cont::GroundsetType)</code></pre><p>The <code>minor M\S/T</code> of disjoint subsets  <code>S</code> and <code>T</code> of the ground set <code>E</code> of the matroid <code>M</code>.</p><p>See also <code>contraction</code> and <code>deletion</code>. You can find more in Section 3 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; S = [1,2,3];

julia&gt; T = [4];

julia&gt;  N = minor(M,S,T) 
Matroid of rank 2 on 3 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L585-L603">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="principal_extension-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, ZZRingElem}}" href="#principal_extension-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, ZZRingElem}}"><code>principal_extension</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">principal_extension(M::Matroid, F::GroundsetType, e::ElementType)</code></pre><p>The <code>principal extension M +_F e</code> of a matroid <code>M</code> where the element <code>e</code> is freely added to the flat <code>F</code>.</p><p>See Section 7.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To add <code>5</code> freely to the flat <code>{1,2}</code> of the uniform matroid <code>U_{3,4}</code> do</p><pre><code class="language-julia-repl hljs">julia&gt; M = uniform_matroid(3,4);

julia&gt; N = principal_extension(M,[1,2],5)
Matroid of rank 3 on 5 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L611-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="free_extension-Tuple{Matroid, Union{Char, Integer, String, ZZRingElem}}" href="#free_extension-Tuple{Matroid, Union{Char, Integer, String, ZZRingElem}}"><code>free_extension</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">free_extension(M::Matroid, e::ElementType)</code></pre><p>The <code>free extension M +_E e</code> of a matroid <code>M</code> where the element <code>e</code>.</p><p>See <span>$principal_extension$</span> and Section 7.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To add <code>5</code> freely to the uniform matroid <code>U_{3,4}</code> do</p><pre><code class="language-julia-repl hljs">julia&gt; M = uniform_matroid(3,4);

julia&gt;  N = free_extension(M,5)
Matroid of rank 3 on 5 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L637-L651">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="series_extension-Tuple{Matroid, Union{Char, Integer, String, ZZRingElem}, Union{Char, Integer, String, ZZRingElem}}" href="#series_extension-Tuple{Matroid, Union{Char, Integer, String, ZZRingElem}, Union{Char, Integer, String, ZZRingElem}}"><code>series_extension</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">series_extension(M::Matroid, f::ElementType, e::ElementType)</code></pre><p>The <code>series extension</code> of a matroid <code>M</code> where the element <code>e</code> is added in series to <code>f</code>.</p><p>This is actually a coextension see also Section 7.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To add <code>e</code> in series to <code>1</code> in the uniform matroid U_{3,4} do</p><pre><code class="language-julia-repl hljs">julia&gt; M = uniform_matroid(1,4);

julia&gt; N = series_extension(M,1,&#39;e&#39;)
Matroid of rank 2 on 5 elements

julia&gt; cocircuits(N)[1]
2-element Vector{Any}:
 1
  &#39;e&#39;: ASCII/Unicode U+0065 (category Ll: Letter, lowercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L654-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="parallel_extension-Tuple{Matroid, Union{Char, Integer, String, ZZRingElem}, Union{Char, Integer, String, ZZRingElem}}" href="#parallel_extension-Tuple{Matroid, Union{Char, Integer, String, ZZRingElem}, Union{Char, Integer, String, ZZRingElem}}"><code>parallel_extension</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parallel_extension(M::Matroid, f::ElementType, e::ElementType)</code></pre><p>The <code>parallel extension M +_{cl(f)} e</code> of a matroid <code>M</code> where the element <code>e</code> is added parallel to (the closure of) <code>f</code>.</p><p>See Section 7.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><p>To add <code>e</code> parallel to <code>1</code> in the uniform matroid <code>U_{3,4}</code> do</p><pre><code class="language-julia-repl hljs">julia&gt; M = uniform_matroid(3,4);

julia&gt; N = parallel_extension(M,1,&#39;e&#39;)
Matroid of rank 3 on 5 elements

julia&gt; circuits(N)[1]
2-element Vector{Any}:
 1
  &#39;e&#39;: ASCII/Unicode U+0065 (category Ll: Letter, lowercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L680-L700">source</a></section></article><h2 id="Properties"><a class="docs-heading-anchor" href="#Properties">Properties</a><a id="Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="matroid_groundset-Tuple{Matroid}" href="#matroid_groundset-Tuple{Matroid}"><code>matroid_groundset</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matroid_groundset(M::Matroid)</code></pre><p>The ground set <code>E</code> of a matroid <code>M</code>.</p><p>To obtain the ground set of the Fano matroid write:</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matroid_groundset(fano_matroid())
7-element Vector{Int64}:
 1
 2
 3
 4
 5
 6
 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L402-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="length-Tuple{Matroid}" href="#length-Tuple{Matroid}"><code>length</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(M::Matroid)</code></pre><p>Return the size of the ground set of the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; length(fano_matroid())
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L26-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="rank-Tuple{Matroid}" href="#rank-Tuple{Matroid}"><code>rank</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rank(M::Matroid)</code></pre><p>Return the rank of the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rank(fano_matroid())
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L238-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="rank-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#rank-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>rank</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rank(M::Matroid, set::GroundsetType)</code></pre><p>Return the rank of <code>set</code> in the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; rank(M, [1,2,3])
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L251-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="bases-Tuple{Matroid}" href="#bases-Tuple{Matroid}"><code>bases</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bases(M::Matroid)</code></pre><p>Return the list of bases of the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bases(uniform_matroid(2, 3))
3-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]
 [2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L40-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="nonbases-Tuple{Matroid}" href="#nonbases-Tuple{Matroid}"><code>nonbases</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonbases(M::Matroid)</code></pre><p>Return the list of nonbases of the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nonbases(fano_matroid())
7-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [1, 4, 5]
 [1, 6, 7]
 [2, 4, 6]
 [2, 5, 7]
 [3, 4, 7]
 [3, 5, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L56-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="circuits-Tuple{Matroid}" href="#circuits-Tuple{Matroid}"><code>circuits</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circuits(M::Matroid)</code></pre><p>Return the list of circuits of the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuits(uniform_matroid(2, 4))
4-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [1, 2, 4]
 [1, 3, 4]
 [2, 3, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L77-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="hyperplanes-Tuple{Matroid}" href="#hyperplanes-Tuple{Matroid}"><code>hyperplanes</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hyperplanes(M::Matroid)</code></pre><p>Return the list of hyperplanes of the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; hyperplanes(fano_matroid())
7-element Vector{Vector{Int64}}:
 [3, 5, 6]
 [3, 4, 7]
 [2, 5, 7]
 [2, 4, 6]
 [1, 6, 7]
 [1, 4, 5]
 [1, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L94-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="flats" href="#flats"><code>flats</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flats(M::Matroid, [r::Int])</code></pre><p>Return the list of flats of the matroid <code>M</code>. By default all flats are returned. One may specify a rank <code>r</code> as the second parameter in which case only the flats of rank <code>r</code> are returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid()
Matroid of rank 3 on 7 elements

julia&gt; flats(M)
16-element Vector{Vector{T} where T}:
 Any[]
 [1]
 [2]
 [3]
 [4]
 [5]
 [6]
 [7]
 [1, 2, 3]
 [1, 4, 5]
 [1, 6, 7]
 [2, 4, 6]
 [2, 5, 7]
 [3, 5, 6]
 [3, 4, 7]
 [1, 2, 3, 4, 5, 6, 7]

julia&gt; flats(M, 2)
7-element Vector{Vector{T} where T}:
 [1, 2, 3]
 [1, 4, 5]
 [1, 6, 7]
 [2, 4, 6]
 [2, 5, 7]
 [3, 5, 6]
 [3, 4, 7]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L114-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cyclic_flats" href="#cyclic_flats"><code>cyclic_flats</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cyclic_flats(M::Matroid, [r::Int])</code></pre><p>Return the list of cyclic flats of the matroid <code>M</code>. These are the flats that are the union of cycles. See Section 2.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p>By default all cyclic flats are returned. One may specify a rank <code>r</code> as the second parameter. In this case only the cyclic flats of this rank are returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid()
Matroid of rank 3 on 7 elements

julia&gt; cyclic_flats(M)
9-element Vector{Vector{T} where T}:
 Any[]
 [1, 2, 3]
 [1, 4, 5]
 [1, 6, 7]
 [2, 4, 6]
 [2, 5, 7]
 [3, 5, 6]
 [3, 4, 7]
 [1, 2, 3, 4, 5, 6, 7]

julia&gt; cyclic_flats(M, 2)
7-element Vector{Vector{T} where T}:
 [1, 2, 3]
 [1, 4, 5]
 [1, 6, 7]
 [2, 4, 6]
 [2, 5, 7]
 [3, 5, 6]
 [3, 4, 7]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L173-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="closure-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#closure-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>closure</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closure(M::Matroid, set::GroundsetType)</code></pre><p>Return the closure of <code>set</code> in the matroid <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; closure(fano_matroid(), [1,2])
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L214-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="nullity-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#nullity-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>nullity</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nullity(M::Matroid, set::GroundsetType)</code></pre><p>Return the nullity of <code>set</code> in the matroid <code>M</code>. This is defined to be <code>|set| - rk(set)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; nullity(M, [1,2,3])
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L272-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fundamental_circuit-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, ZZRingElem}}" href="#fundamental_circuit-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, ZZRingElem}}"><code>fundamental_circuit</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fundamental_circuit(M::Matroid, basis::GroundsetType, elem::ElementType)</code></pre><p>Return the unique circuit contained in the union of <code>basis</code> and <code>elem</code> of the matroid <code>M</code>. See Section 1.2 of <a href="../../references/#Oxl11">James Oxley (2011)</a>. Note that <code>elem</code> needs to be in the complement of the <code>basis</code> in this case.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; fundamental_circuit(M, [1,2,4], 7)
4-element Vector{Int64}:
 1
 2
 4
 7

julia&gt; fundamental_circuit(M, [1,2,4], 3)
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L289-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fundamental_cocircuit-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, ZZRingElem}}" href="#fundamental_cocircuit-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, ZZRingElem}}"><code>fundamental_cocircuit</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fundamental_cocircuit(M::Matroid, cobasis::GroundsetType, elem::ElementType)</code></pre><p>Return the unique circuit of the dual matroid of <code>M</code> in the union of the complement of <code>basis</code> and <code>elem</code>. See Section 2.1 of <a href="../../references/#Oxl11">James Oxley (2011)</a>. Note that <code>elem</code> needs to be an element of the <code>basis</code> in this case.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fundamental_cocircuit(fano_matroid(), [1,2,4], 4)
4-element Vector{Int64}:
 4
 5
 6
 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L328-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="independent_sets-Tuple{Matroid}" href="#independent_sets-Tuple{Matroid}"><code>independent_sets</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">independent_sets(M::Matroid)</code></pre><p>Return the list of independent sets of the matroid <code>M</code>. These are all subsets of the bases.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; independent_sets(uniform_matroid(2, 3))
7-element Vector{Vector{Integer}}:
 []
 [1]
 [2]
 [3]
 [1, 3]
 [2, 3]
 [1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L348-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="spanning_sets-Tuple{Matroid}" href="#spanning_sets-Tuple{Matroid}"><code>spanning_sets</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spanning_sets(M::Matroid)</code></pre><p>Return the list of spanning sets of the matroid <code>M</code>. These are all sets containing a basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; spanning_sets(uniform_matroid(2, 3))
4-element Vector{Vector{Integer}}:
 [1, 2]
 [1, 3]
 [2, 3]
 [1, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L387-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cobases-Tuple{Matroid}" href="#cobases-Tuple{Matroid}"><code>cobases</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cobases(M::Matroid)</code></pre><p>Return the bases of the dual matroid of <code>M</code>. See Section 2 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cobases(uniform_matroid(2, 3))
3-element Vector{Vector{Int64}}:
 [3]
 [2]
 [1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L410-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cocircuits-Tuple{Matroid}" href="#cocircuits-Tuple{Matroid}"><code>cocircuits</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cocircuits(M::Matroid)</code></pre><p>Return the circuits of the dual matroid of <code>M</code>. See Section 2 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cocircuits(uniform_matroid(2, 5))
5-element Vector{Vector{Int64}}:
 [1, 2, 3, 4]
 [1, 2, 3, 5]
 [1, 2, 4, 5]
 [1, 3, 4, 5]
 [2, 3, 4, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L427-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cohyperplanes-Tuple{Matroid}" href="#cohyperplanes-Tuple{Matroid}"><code>cohyperplanes</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cohyperplanes(M::Matroid)</code></pre><p>Return the hyperplanes of the dual matroid of <code>M</code>. See Section 2 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cohyperplanes(fano_matroid())
14-element Vector{Vector{Int64}}:
 [4, 5, 6, 7]
 [2, 3, 6, 7]
 [2, 3, 4, 5]
 [1, 3, 5, 7]
 [1, 3, 4, 6]
 [1, 2, 5, 6]
 [1, 2, 4, 7]
 [3, 5, 6]
 [3, 4, 7]
 [2, 5, 7]
 [2, 4, 6]
 [1, 6, 7]
 [1, 4, 5]
 [1, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L446-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="corank-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#corank-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>corank</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">corank(M::Matroid, set::GroundsetType)</code></pre><p>Return the rank of <code>set</code> in the dual matroid of <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; corank(fano_matroid(), [1,2,3])
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L474-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_clutter-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}" href="#is_clutter-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Union{AbstractSet, AbstractVector{T} where T}"><code>is_clutter</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_clutter(sets::AbstractVector{T}) where T &lt;: GroundsetType</code></pre><p>Checks if the collection of subsets <code>sets</code> is a clutter. A collection of subsets is a clutter if none of the sets is a proper subset of another. See Section 2.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_clutter([[1,2], [1,2,3]])
false

julia&gt; is_clutter(circuits(fano_matroid()))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L487-L502">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_regular-Tuple{Matroid}" href="#is_regular-Tuple{Matroid}"><code>is_regular</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_regular(M::Matroid)</code></pre><p>Checks if the matroid <code>M</code> is regular, that is representable over every field. See Section 6.6 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_regular(uniform_matroid(2, 3))
true

julia&gt; is_regular(fano_matroid())
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L514-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_binary-Tuple{Matroid}" href="#is_binary-Tuple{Matroid}"><code>is_binary</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_binary(M::Matroid)</code></pre><p>Checks if the matroid <code>M</code> is binary, that is representable over the finite field <code>F_2</code>. See Section 6.5 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_binary(uniform_matroid(2, 4))
false

julia&gt; is_binary(fano_matroid())
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L537-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_ternary-Tuple{Matroid}" href="#is_ternary-Tuple{Matroid}"><code>is_ternary</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_ternary(M::Matroid)</code></pre><p>Checks if the matroid <code>M</code> is ternary, that is representable over the finite field <code>F_3</code>. See Section 4.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_ternary(uniform_matroid(2, 4))
true

julia&gt; is_ternary(fano_matroid())
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L554-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="n_connected_components-Tuple{Matroid}" href="#n_connected_components-Tuple{Matroid}"><code>n_connected_components</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_connected_components(M::Matroid)</code></pre><p>Return the number of connected components of <code>M</code>. See Section 4.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n_connected_components(fano_matroid())
1

julia&gt; n_connected_components(uniform_matroid(3, 3))
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L577-L591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="connected_components-Tuple{Matroid}" href="#connected_components-Tuple{Matroid}"><code>connected_components</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connected_components(M::Matroid)</code></pre><p>Return the connected components of <code>M</code>. The function returns a partition of the ground set where each part corresponds to one connected component.  See Section 4.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connected_components(fano_matroid())
1-element Vector{Vector{Int64}}:
 [1, 2, 3, 4, 5, 6, 7]

julia&gt; connected_components(uniform_matroid(3, 3))
3-element Vector{Vector{Int64}}:
 [1]
 [2]
 [3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L594-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_connected-Tuple{Matroid}" href="#is_connected-Tuple{Matroid}"><code>is_connected</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_connected(M::Matroid)</code></pre><p>Check if the matroid <code>M</code> is connected, that is has one connected component See Section 4.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_connected(fano_matroid())
true

julia&gt; is_connected(uniform_matroid(3, 3))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L615-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="loops-Tuple{Matroid}" href="#loops-Tuple{Matroid}"><code>loops</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loops(M::Matroid)</code></pre><p>Return the loops of <code>M</code>. A loop is an element of the ground set that is not contained in any basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; loops(matroid_from_bases([[1,2]], 4))
2-element Vector{Int64}:
 3
 4

julia&gt; loops(fano_matroid())
Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L632-L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="coloops-Tuple{Matroid}" href="#coloops-Tuple{Matroid}"><code>coloops</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coloops(M::Matroid)</code></pre><p>Return the coloops of <code>M</code>. A coloop is an element of the ground set that is contained in every basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; coloops(matroid_from_bases([[1,2]], 4))
2-element Vector{Int64}:
 1
 2

julia&gt; coloops(fano_matroid())
Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L650-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_loopless-Tuple{Matroid}" href="#is_loopless-Tuple{Matroid}"><code>is_loopless</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_loopless(M::Matroid)</code></pre><p>Check if <code>M</code> has a loop. Return <code>true</code> if <code>M</code> does not have a loop. See also <code>loops</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_loopless(matroid_from_bases([[1,2]], 4))
false

julia&gt; is_loopless(fano_matroid())
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L668-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_coloopless-Tuple{Matroid}" href="#is_coloopless-Tuple{Matroid}"><code>is_coloopless</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_coloopless(M::Matroid)</code></pre><p>Check if <code>M</code> has a coloop. Return <code>true</code> if <code>M</code> does not have a coloop. See also <code>coloops</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_coloopless(matroid_from_bases([[1,2]], 4))
false

julia&gt; is_coloopless(fano_matroid())
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L685-L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_simple-Tuple{Matroid}" href="#is_simple-Tuple{Matroid}"><code>is_simple</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_simple(M::Matroid)</code></pre><p>Check if <code>M</code> has is simple. A matroid is simple if it doesn&#39;t have loops and doesn&#39;t have parallel elements. Return <code>true</code> if <code>M</code> is simple. See also <code>loops</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_simple(matroid_from_bases([[1,2]], 4))
false

julia&gt; is_simple(fano_matroid())
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L702-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="direct_sum_components-Tuple{Matroid}" href="#direct_sum_components-Tuple{Matroid}"><code>direct_sum_components</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">direct_sum_components(M::Matroid)</code></pre><p>Return the connected components of <code>M</code> as a list of matroids. See Section 4.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; direct_sum_components(fano_matroid())
1-element Vector{Matroid}:
 Matroid of rank 3 on 7 elements

julia&gt; direct_sum_components(uniform_matroid(3, 3))
3-element Vector{Matroid}:
 Matroid of rank 1 on 1 elements
 Matroid of rank 1 on 1 elements
 Matroid of rank 1 on 1 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L720-L738">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="connectivity_function-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}" href="#connectivity_function-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}"><code>connectivity_function</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connectivity_function(M::Matroid, set::GroundsetType)</code></pre><p>Return the value of the connectivity function of <code>set</code> in the matroid <code>M</code>. See Section 8.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; connectivity_function(fano_matroid(), [1,2,4])
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L747-L759">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_vertical_k_separation-Tuple{Matroid, Union{Integer, ZZRingElem}, Union{AbstractSet, AbstractVector{T} where T}}" href="#is_vertical_k_separation-Tuple{Matroid, Union{Integer, ZZRingElem}, Union{AbstractSet, AbstractVector{T} where T}}"><code>is_vertical_k_separation</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_vertical_k_separation(M::Matroid, k::IntegerUnion, set::GroundsetType)</code></pre><p>Check if <code>set</code> together with its complement defines a <code>k</code> separation in <code>M</code> See Section 8.6 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_vertical_k_separation(fano_matroid(), 2, [1,2,4])
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L764-L776">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_k_separation-Tuple{Matroid, Union{Integer, ZZRingElem}, Union{AbstractSet, AbstractVector{T} where T}}" href="#is_k_separation-Tuple{Matroid, Union{Integer, ZZRingElem}, Union{AbstractSet, AbstractVector{T} where T}}"><code>is_k_separation</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_k_separation(M::Matroid, k::IntegerUnion, set::GroundsetType)</code></pre><p>Check if <code>set</code> together with its complement defines a <code>k</code> separation in <code>M</code> See Section 8.1 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_k_separation(fano_matroid(), 2, [1,2,4])
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L781-L793">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="vertical_connectivity-Tuple{Matroid}" href="#vertical_connectivity-Tuple{Matroid}"><code>vertical_connectivity</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertical_connectivity(M::Matroid)</code></pre><p>If &#39;M&#39; has two disjoint cocircuits, its vertical connectivity is defined to be least positive integer k such that <code>M</code> has a vertical k separation. Otherwise its vertical connectivity is defined to be the rank of <code>M</code>. See Section 8.6 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vertical_connectivity(fano_matroid())
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L798-L810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="girth" href="#girth"><code>girth</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">girth(M::Matroid, set::GroundsetType)</code></pre><p>Return the girth of <code>set</code> in the matroid <code>M</code>. This is the size of the smallest circuit contained in <code>set</code> and infinite otherwise. See Section 8.6 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; girth(fano_matroid(), [1,2,3,4])
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L829-L842">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="tutte_connectivity-Tuple{Matroid}" href="#tutte_connectivity-Tuple{Matroid}"><code>tutte_connectivity</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tutte_connectivity(M::Matroid)</code></pre><p>The Tutte connectivity of <code>M</code> is the least integer k such that <code>M</code> has a k separation. It can be infinite if no k separation exists. See Section 8.6 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tutte_connectivity(fano_matroid())
3

julia&gt; tutte_connectivity(uniform_matroid(2,4))
PosInf()
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L845-L860">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="tutte_polynomial-Tuple{Matroid}" href="#tutte_polynomial-Tuple{Matroid}"><code>tutte_polynomial</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tutte_polynomial(M::Matroid)</code></pre><p>Return the Tutte polynomial of <code>M</code>. This is polynomial in the variables x and y with integral coefficients. See Section 15.3 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tutte_polynomial(fano_matroid())
x^3 + 4*x^2 + 7*x*y + 3*x + y^4 + 3*y^3 + 6*y^2 + 3*y
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L877-L889">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="characteristic_polynomial-Tuple{Matroid}" href="#characteristic_polynomial-Tuple{Matroid}"><code>characteristic_polynomial</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">characteristic_polynomial(M::Matroid)</code></pre><p>Return the characteristic polynomial of <code>M</code>. This is polynomial in the variable q with integral coefficients. It is computed as an evaluation of the Tutte polynmomial. See Section 15.2 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; characteristic_polynomial(fano_matroid())
q^3 - 7*q^2 + 14*q - 8
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L897-L910">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="reduced_characteristic_polynomial-Tuple{Matroid}" href="#reduced_characteristic_polynomial-Tuple{Matroid}"><code>reduced_characteristic_polynomial</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduced_characteristic_polynomial(M::Matroid)</code></pre><p>Return the reduced characteristic polynomial of <code>M</code>. This is the quotient of the characteristic polynomial by (q-1). See Section 15.2 in <a href="../../references/#Oxl11">James Oxley (2011)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reduced_characteristic_polynomial(fano_matroid())
q^2 - 6*q + 8
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L916-L928">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="revlex_basis_encoding-Tuple{Matroid}" href="#revlex_basis_encoding-Tuple{Matroid}"><code>revlex_basis_encoding</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">revlex_basis_encoding(M::Matroid)</code></pre><p>Computes the revlex basis encoding and the minimal revlex basis encoding among isomorphic matroids </p><p><strong>Examples</strong></p><p>To get the revlex basis encoding of the fano matroid and to preduce a matrod form the encoding write:</p><pre><code class="language-julia-repl hljs">julia&gt; string1, string2 = revlex_basis_encoding(fano_matroid())
(&quot;0******0******0***0******0*0**0****&quot;, &quot;0******0******0***0******0*0**0****&quot;)

julia&gt; matroid_from_revlex_basis_encoding(string2, 3, 7)
Matroid of rank 3 on 7 elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L970-L984">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_isomorphic-Tuple{Matroid, Matroid}" href="#is_isomorphic-Tuple{Matroid, Matroid}"><code>is_isomorphic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_isomorphic(M1::Matroid, M2::Matroid)</code></pre><p>Checks if the matroid <code>M1</code> is isomorphic to the matroid <code>M2</code> under the action of the symmetric group that acts on their groundsets.</p><p><strong>Examples</strong></p><p>To compare two matrods write:</p><pre><code class="language-julia-repl hljs">julia&gt; H = [[1,2,4],[2,3,5],[1,3,6],[3,4,7],[1,5,7],[2,6,7],[4,5,6]];

julia&gt; M = matroid_from_hyperplanes(H,7);

julia&gt; is_isomorphic(M,fano_matroid())
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L1003-L1019">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_minor-Tuple{Matroid, Matroid}" href="#is_minor-Tuple{Matroid, Matroid}"><code>is_minor</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_minor(M::Matroid, N::Matroid)</code></pre><p>Checks if the matroid <code>M</code> is isomorphic to a minor of the matroid <code>N</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_minor(direct_sum(uniform_matroid(0,1), uniform_matroid(2,2)), fano_matroid())
false

julia&gt; is_minor(direct_sum(uniform_matroid(0,1), uniform_matroid(2,2)), parallel_extension(uniform_matroid(3,4), 1, 5))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/properties.jl#L1027-L1040">source</a></section></article><h3 id="Chow-Rings"><a class="docs-heading-anchor" href="#Chow-Rings">Chow Rings</a><a id="Chow-Rings-1"></a><a class="docs-heading-anchor-permalink" href="#Chow-Rings" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="chow_ring-Tuple{Matroid}" href="#chow_ring-Tuple{Matroid}"><code>chow_ring</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chow_ring(M::Matroid; ring::MPolyRing=nothing, extended::Bool=false)</code></pre><p>Return the Chow ring of a matroid, optionally also with the simplicial generators and the polynomial ring.</p><p>See <a href="../../references/#AHK18">Karim Adiprasito, June Huh, Eric Katz (2018)</a> and <a href="../../references/#BES19">Spencer Backman, Christopher Eur, Connor Simpson (2019)</a>. </p><p><strong>Examples</strong></p><p>The following computes the Chow ring of the Fano matroid.</p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; R = chow_ring(M);

julia&gt; R[1]*R[8]
-x_{3,4,7}^2</code></pre><p>The following computes the Chow ring of the Fano matroid including variables for the simplicial generators.</p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; R = chow_ring(M, extended=true);

julia&gt; f = R[22] + R[8] - R[29]
x_{1,2,3} + h_{1,2,3} - h_{1,2,3,4,5,6,7}

julia&gt; f==0
true</code></pre><p>The following computes the Chow ring of the free matroid on three elements in a given graded polynomial ring.</p><pre><code class="language-julia-repl hljs">julia&gt; M = uniform_matroid(3,3);

julia&gt; GR, _ = graded_polynomial_ring(QQ,[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]);

julia&gt; R = chow_ring(M, ring=GR);

julia&gt; hilbert_series_reduced(R)
(t^2 + 4*t + 1, 1) 
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/ChowRings.jl#L1-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="augmented_chow_ring-Tuple{Matroid}" href="#augmented_chow_ring-Tuple{Matroid}"><code>augmented_chow_ring</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">augmented_chow_ring(M::Matroid)</code></pre><p>Return an augmented Chow ring of a matroid. As described in <a href="../../references/#BHMPW20">Tom Braden, June Huh, Jacob P. Matherne, Nicholas Proudfoot, Botong Wang (2020)</a>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; R = augmented_chow_ring(M);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/ChowRings.jl#L135-L146">source</a></section></article><h2 id="Matroid-strata-and-realization-spaces"><a class="docs-heading-anchor" href="#Matroid-strata-and-realization-spaces">Matroid strata and realization spaces</a><a id="Matroid-strata-and-realization-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Matroid-strata-and-realization-spaces" title="Permalink"></a></h2><p>For a matroid <span>$M$</span>, of rank <span>$d$</span> on a ground set <span>$E$</span> of size <span>$n$</span> realizable over a ring <span>$K$</span>,  its <em>matroid realization space</em> <span>$\mathsf{Gr}(M)$</span> is the locally closed subscheme of the Grassmannian <span>$\mathsf{Gr}(d,K^n)$</span> of <span>$d$</span>-dimensional subspaces of <span>$K^n$</span> realizing <span>$M$</span>. Precisely, </p><p class="math-container">\[    \mathsf{Gr}(M) = \{F \in \mathsf{Gr}(d,K^n) \, : \, p_{I}(F) \neq 0 \text{ iff } I \in \mathcal{B}(M)\}\]</p><p>where <span>$\mathcal{B}(M)$</span> denotes the set of bases of <span>$M$</span> and  <span>$p_{I}(F)$</span> denotes the <span>$I$</span>th Pl\&quot;ucker  coordinate of the linear subspace <span>$F \subset K^n$</span>. The coordinate ring of <span>$\mathsf{Gr}(M)$</span> can be computed using matrix coordinates, see Construction 2.2 of <a href="../../references/#Cor21">D. Corey (2021)</a>. The following function computes this ring. </p><article class="docstring"><header><a class="docstring-binding" id="matroid_stratum_matrix_coordinates" href="#matroid_stratum_matrix_coordinates"><code>matroid_stratum_matrix_coordinates</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matroid_stratum_matrix_coordinates(M::Matroid, B::GroundsetType, F::AbstractAlgebra.Ring = ZZ)</code></pre><p>Return the data of the coordinate ring of the matroid stratum of M in the Grassmannian with respect to matrix coordinates. Here, <code>B</code> is a basis of <code>M</code><code>and the submatrix with columns indexed by</code>B&#39; is the identity. This function returns a pair <code>(A, W)</code> where <code>A</code> is the coordinate matrix, and <code>W</code> is the coordinate ring of the stratum, in general this is a localized quotient ring. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; (A, W) = matroid_stratum_matrix_coordinates(M, [1,2,4], GF(2));

julia&gt; A # The coordinate matrix with entries in the polynomial ring `R`.
[1   0   x[1, 1]   0   x[1, 2]         0   x[1, 4]]
[0   1   x[2, 1]   0         0   x[2, 3]   x[2, 4]]
[0   0         0   1   x[3, 2]   x[3, 3]   x[3, 4]]

julia&gt; W # The coordinate ring of the stratum; in general a localized quotient ring `(R/I)[Sâ»Â¹]`.
Localization of Quotient of Multivariate Polynomial Ring in 9 variables x[1, 1], x[2, 1], x[1, 2], x[3, 2], ..., x[3, 4] over Galois field with characteristic 2 by ideal(x[2, 3]*x[3, 4] + x[3, 3]*x[2, 4], x[1, 2]*x[3, 4] + x[3, 2]*x[1, 4], x[1, 1]*x[2, 4] + x[2, 1]*x[1, 4], x[1, 1]*x[3, 2]*x[2, 3] + x[2, 1]*x[1, 2]*x[3, 3]) at the multiplicative set powers of fpMPolyRingElem[x[3, 3]*x[1, 4], x[1, 1]*x[2, 3]*x[3, 4] + x[1, 1]*x[3, 3]*x[2, 4] + x[2, 1]*x[3, 3]*x[1, 4], x[2, 3]*x[1, 4], x[1, 2]*x[2, 3]*x[3, 4] + x[1, 2]*x[3, 3]*x[2, 4] + x[3, 2]*x[2, 3]*x[1, 4], x[3, 2]*x[2, 4], x[1, 1]*x[3, 2]*x[2, 4] + x[2, 1]*x[1, 2]*x[3, 4] + x[2, 1]*x[3, 2]*x[1, 4], x[1, 2]*x[2, 4], x[2, 4], x[1, 4], x[2, 1]*x[3, 4], x[1, 1]*x[3, 4], x[3, 4], x[3, 2]*x[2, 3], x[1, 2]*x[3, 3], x[1, 2]*x[2, 3], x[2, 3], x[1, 1]*x[2, 3], x[2, 1]*x[3, 3], x[1, 1]*x[3, 3], x[3, 3], x[1, 2], x[2, 1]*x[1, 2], x[2, 1]*x[3, 2], x[1, 1]*x[3, 2], x[3, 2], x[2, 1], x[1, 1], 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroid_strata_grassmannian.jl#L1-L20">source</a></section></article><p>When the matroid <span>$M$</span> is connected, the diagonal torus of <span>$\mathsf{PGL}(n)$</span> acts freely on  <span>$\mathsf{Gr}(M)$</span> and its quotient is the <em>realization space</em> <span>$R(M)$</span> of <span>$M$</span>. There are two main differences between the coordinate rings <span>$K[\mathsf{Gr}(M)]$</span> and <span>$K[R(M)]$</span>.</p><ul><li>To comupte <span>$K[R(M)]$</span>, we  assume that <span>$d+1$</span> columns <span>$A = \{a_1,\ldots,a_{d+1}\}$</span>  of the reference matrix <span>$X$</span> are the unit vectors <span>$e_1,\ldots,e_n$</span> and <span>$e_1+ \cdots + e_n$</span>. Note that every <span>$d$</span> element subset of <span>$A$</span> must be a basis of <span>$M$</span>. Disconnected matroids do not satisfy this property.</li><li>The columns of the reference matrix <span>$X$</span> may be treated as projective coordinates.</li></ul><p>The coordinate ring of <span>$R(M)$</span> is computed in the following function. </p><article class="docstring"><header><a class="docstring-binding" id="matroid_realization_space" href="#matroid_realization_space"><code>matroid_realization_space</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matroid_realization_space(M::Matroid, A::GroundsetType, F::AbstractAlgebra.Ring=ZZ)</code></pre><p>Returns the data of the coordinate ring of the realization space of the matroid <code>M</code> using matrix coordinates. The matroid <code>M</code> should be a simple and connected matroid, say its rank is <span>$d$</span>, and ground set <span>$[n]$</span>. The vector <code>A</code> is <code>rank(M)+1</code> consists of <span>$d+1$</span> elements (in order) of <span>$[n]$</span> such that each <span>$d$</span>-element subset is a basis of <span>$M$</span>.</p><p>This function returns a pair <code>(X, W)</code> where <code>X</code> is the reduced <span>$dÃn$</span> matrix of variables, and the coordinate ring of the matroid realization space is <code>W</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = fano_matroid();

julia&gt; (X, W) = matroid_realization_space(M, [1,2,4,7], GF(2));

julia&gt; X # The coordinate matrix.
[1   0   x[1, 1]   0   x[1, 2]         0   1]
[0   1         1   0         0   x[2, 3]   1]
[0   0         0   1         1         1   1]

julia&gt; W # The coordinate ring of the stratum.
Localization of Quotient of Multivariate Polynomial Ring in x[1, 1], x[1, 2], x[2, 3] over Galois field with characteristic 2 by ideal(x[2, 3] + 1, x[1, 2] + 1, x[1, 1] + 1, x[1, 1]*x[2, 3] + x[1, 2]) at the multiplicative set powers of fpMPolyRingElem[1, x[1, 1]*x[2, 3] + x[1, 1] + 1, x[2, 3], x[1, 2]*x[2, 3] + x[1, 2] + x[2, 3], x[1, 1] + x[1, 2] + 1, x[1, 2], x[1, 1], x[1, 2]*x[2, 3], x[1, 1]*x[2, 3]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroid_strata_grassmannian.jl#L40-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="automorphism_group-Tuple{Matroid}" href="#automorphism_group-Tuple{Matroid}"><code>automorphism_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">automorphism_group(m::Matroid)</code></pre><p>Given a matroid <code>m</code> return its automorphism group as a <code>PermGroup</code>. The group acts on the elements of <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = uniform_matroid(2, 4)
Matroid of rank 2 on 4 elements

julia&gt; automorphism_group(M)
Group([ (3,4), (1,2), (2,3) ])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Combinatorics/Matroids/matroids.jl#L852-L866">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../graphs/">Â« Graphs</a><a class="docs-footer-nextpage" href="../simplicialcomplexes/">Simplicial Complexes Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 18 April 2023 06:47">Tuesday 18 April 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
