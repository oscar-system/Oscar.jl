<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Permutations and Symmetric groups Â· Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../Experimental/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ModulesOverMultivariateRings/homological_algebra/">Homological Algebra</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">GrÃ¶bner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/groebner_bases/">GrÃ¶bner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/GroebnerBases/groebner_bases_integers/">GrÃ¶bner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Toric Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/ToricSchemes/intro/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/ToricSchemes/NormalToricSchemes/">Normal Toric Schemes</a></li><li><a class="tocitem" href="../../Experimental/ToricSchemes/AffineToricSchemes/">Affine Toric Schemes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/TropicalGeometry/curve/">Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/K3Surfaces/">Automorphism Groups of  K3 surfaces</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/SurfacesP4/">Nongeneral Type Surfaces in <span>$\mathbb P^4$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-8" type="checkbox"/><label class="tocitem" for="menuitem-11-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Miscellaneous/miscellaneous/">Some Special Ideals</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Noncommutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li><li><a class="tocitem" href="../../Combinatorics/partitions/">Partitions</a></li><li><a class="tocitem" href="../../Combinatorics/tableaux/">Tableaux</a></li><li><a class="tocitem" href="../../Combinatorics/schur_polynomials/">Schur polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-7" type="checkbox"/><label class="tocitem" for="menuitem-17-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-18" type="checkbox"/><label class="tocitem" for="menuitem-18"><span class="docs-label">Experimental</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/intro/">Adding new projects to experimental</a></li><li><input class="collapse-toggle" id="menuitem-18-2" type="checkbox"/><label class="tocitem" for="menuitem-18-2"><span class="docs-label">F-Theory Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/FTheoryTools/introduction/">Welcome to FTheoryTools</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/weierstrass/">Global Weierstrass models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/tate/">Global Tate models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-18-3" type="checkbox"/><label class="tocitem" for="menuitem-18-3"><span class="docs-label">Linear Quotients</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/LinearQuotients/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/LinearQuotients/linear_quotients/">Construction and basic functionality</a></li><li><a class="tocitem" href="../../Experimental/LinearQuotients/cox_rings/">Cox rings</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Permutations and Symmetric groups</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Permutations and Symmetric groups</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/AbstractAlgebra/perm.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Permutations-and-Symmetric-groups"><a class="docs-heading-anchor" href="#Permutations-and-Symmetric-groups">Permutations and Symmetric groups</a><a id="Permutations-and-Symmetric-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations-and-Symmetric-groups" title="Permalink"></a></h1><p>AbstractAlgebra.jl provides rudimentary native support for permutation groups (implemented in <code>src/generic/PermGroups.jl</code>). All functionality of permutations is accessible in the <code>Generic</code> submodule.</p><p>Permutations are represented internally via vector of integers, wrapped in type <code>Perm{T}</code>, where <code>T&lt;:Integer</code> carries the information on the type of elements of a permutation. Symmetric groups are singleton parent objects of type <code>SymmetricGroup{T}</code> and are used mostly to store the length of a permutation, since it is not included in the permutation type.</p><p>Symmetric groups are created using the <code>SymmetricGroup</code> (inner) constructor.</p><p>Both <code>SymmetricGroup</code> and <code>Perm</code> and can be parametrized by any type <code>T&lt;:Integer</code> . By default the parameter is the <code>Int</code>-type native to the systems architecture. However, if you are sure that your permutations are small enough to fit into smaller integer type (such as <code>Int32</code>, <code>UInt16</code>, or even <code>Int8</code>), you may choose to change the parametrizing type accordingly. In practice this may result in decreased memory footprint (when storing multiple permutations) and noticeable faster performance, if your workload is heavy in operations on permutations, which e.g. does not fit into cache of your cpu.</p><p>All the permutation group types belong to the <code>Group</code> abstract type and the corresponding permutation element types belong to the <code>GroupElem</code> abstract type.</p><article class="docstring"><header><a class="docstring-binding" id="setpermstyle" href="#setpermstyle"><code>setpermstyle</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setpermstyle(format::Symbol)</code></pre><p>Select the style in which permutations are displayed (in the REPL or in general as strings). This can be either</p><ul><li><code>:array</code> - as vector of integers whose <span>$n$</span>-th position represents the value at <span>$n$</span>), or</li><li><code>:cycles</code> - as, more familiar for mathematicians, decomposition into disjoint cycles, where the value at <span>$n$</span> is represented by the entry immediately following <span>$n$</span> in a cycle (the default).</li></ul><p>The difference is purely esthetical.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; setpermstyle(:array)
:array

julia&gt; Perm([2,3,1,5,4])
[2, 3, 1, 5, 4]

julia&gt; setpermstyle(:cycles)
:cycles

julia&gt; Perm([2,3,1,5,4])
(1,2,3)(4,5)</code></pre></div></section></article><h2 id="Permutations-constructors"><a class="docs-heading-anchor" href="#Permutations-constructors">Permutations constructors</a><a id="Permutations-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations-constructors" title="Permalink"></a></h2><p>There are several methods to construct permutations in AbstractAlgebra.jl.</p><ul><li>The easiest way is to directly call to the <code>Perm</code> (inner) constructor:</li></ul><article class="docstring"><header><a class="docstring-binding" id="Perm" href="#Perm"><code>Perm</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Perm{T&lt;:Integer}</code></pre><p>The type of permutations. Fieldnames:</p><ul><li><code>d::Vector{T}</code> - vector representing the permutation</li><li><code>modified::Bool</code> - bit to check the validity of cycle decomposition</li><li><code>cycles::CycleDec{T}</code> - (cached) cycle decomposition</li></ul><p>A permutation <span>$p$</span> consists of a vector (<code>p.d</code>) of <span>$n$</span> integers from <span>$1$</span> to <span>$n$</span>. If the <span>$i$</span>-th entry of the vector is <span>$j$</span>, this corresponds to <span>$p$</span> sending <span>$i \to j$</span>. The cycle decomposition (<code>p.cycles</code>) is computed on demand and should never be accessed directly. Use <a href="#cycles-Tuple{Perm}"><code>cycles(p)</code></a> instead.</p><p>There are two inner constructors of <code>Perm</code>:</p><ul><li><code>Perm(n::T)</code> constructs the trivial <code>Perm{T}</code>-permutation of length <span>$n$</span>.</li><li><code>Perm(v::AbstractVector{&lt;:Integer} [,check=true])</code> constructs a permutation represented by <code>v</code>. By default <code>Perm</code> constructor checks if the vector constitutes a valid permutation. To skip the check call <code>Perm(v, false)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Perm([1,2,3])
()
   
julia&gt; g = Perm(Int32[2,3,1])
(1,2,3)

julia&gt; typeof(g)
Perm{Int32}</code></pre></div></section></article><p>Since the parent object can be reconstructed from the permutation itself, you can work with permutations without explicitly constructing the parent object.</p><ul><li>The other way is to first construct the permutation group they belong to. This is accomplished with the inner constructor <code>SymmetricGroup(n::Integer)</code> which constructs the permutation group on <span>$n$</span> symbols and returns the parent object representing the group.</li></ul><article class="docstring"><header><a class="docstring-binding" id="SymmetricGroup" href="#SymmetricGroup"><code>SymmetricGroup</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymmetricGroup{T&lt;:Integer}</code></pre><p>The full symmetric group singleton type. <code>SymmetricGroup(n)</code> constructs the full symmetric group <span>$S_n$</span> on <span>$n$</span>-symbols. The type of elements of the group is inferred from the type of <code>n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = SymmetricGroup(5)
Full symmetric group over 5 elements

julia&gt; elem_type(G)
Perm{Int64}

julia&gt; H = SymmetricGroup(UInt16(5))
Full symmetric group over 5 elements

julia&gt; elem_type(H)
Perm{UInt16}</code></pre></div></section></article><p>A vector of integers can be then coerced to a permutation by calling a parent permutation group on it.   The advantage is that the vector is automatically converted to the integer type fixed at the creation of the parent object.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = SymmetricGroup(BigInt(5)); p = G([2,3,1,5,4])
(1,2,3)(4,5)

julia&gt; typeof(p)
Perm{BigInt}

julia&gt; H = SymmetricGroup(UInt16(5)); r = H([2,3,1,5,4])
(1,2,3)(4,5)

julia&gt; typeof(r)
Perm{UInt16}

julia&gt; one(H)
()</code></pre><p>By default the coercion checks for non-unique values in the vector, but this can be switched off with <code>G([2,3,1,5,4], false)</code>.</p><ul><li>Finally there is a <code>perm&quot;...&quot;</code> string macro to construct a permutation from a string input.</li></ul><article class="docstring"><header><a class="docstring-binding" id="@perm_str" href="#@perm_str"><code>@perm_str</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">perm&quot;...&quot;</code></pre><p>String macro to parse disjoint cycles into <code>Perm{Int}</code>.</p><p>Strings for the output of GAP could be copied directly into <code>perm&quot;...&quot;</code>. Cycles of length <span>$1$</span> are not necessary, but can be included. A permutation of the minimal support is constructed, i.e. the maximal <span>$n$</span> in the decomposition determines the parent group <span>$S_n$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = perm&quot;(1,3)(2,4)&quot;
(1,3)(2,4)

julia&gt; typeof(p)
Perm{Int64}

julia&gt; parent(p) == SymmetricGroup(4)
true

julia&gt; p = perm&quot;(1,3)(2,4)(10)&quot;
(1,3)(2,4)

julia&gt; parent(p) == SymmetricGroup(10)
true</code></pre></div></section></article><h2 id="Permutation-interface"><a class="docs-heading-anchor" href="#Permutation-interface">Permutation interface</a><a id="Permutation-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Permutation-interface" title="Permalink"></a></h2><p>The following basic functionality is provided by the default permutation group implementation in AbstractAlgebra.jl, to support construction of other generic constructions over permutation groups. Any custom permutation group implementation in AbstractAlgebra.jl should provide the group element arithmetic and comparison.</p><p>A custom implementation also needs to implement <code>hash(::Perm, ::UInt)</code> and (possibly) <code>deepcopy_internal(::Perm, ::ObjectIdDict)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Permutation group elements are mutable and so returning shallow copies is not sufficient.</p></div></div><pre><code class="language-julia hljs">getindex(a::Perm, n::Integer)</code></pre><p>Allow access to entry <span>$n$</span> of the given permutation via the syntax <code>a[n]</code>. Note that entries are <span>$1$</span>-indexed.</p><pre><code class="language-julia hljs">setindex!(a::Perm, d::Integer, n::Integer)</code></pre><p>Set the <span>$n$</span>-th entry of the given permutation to <span>$d$</span>. This allows Julia to provide the syntax <code>a[n] = d</code> for setting entries of a permutation. Entries are <span>$1$</span>-indexed.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using <code>setindex!</code> invalidates the cycle decomposition cached in a permutation, which will be computed the next time it is needed.</p></div></div><p>Given the parent object <code>G</code> for a permutation group, the following coercion functions are provided to coerce various arguments into the permutation group. Developers provide these by overloading the permutation group parent objects.</p><pre><code class="language-julia hljs">one(G)</code></pre><p>Return the identity permutation.</p><pre><code class="language-julia hljs">G(A::Vector{&lt;:Integer})</code></pre><p>Return the permutation whose entries are given by the elements of the supplied vector.</p><pre><code class="language-julia hljs">G(p::Perm)</code></pre><p>Take a permutation that is already in the permutation group and simply return it. A copy of the original is not made if not necessary.</p><h2 id="Basic-manipulation"><a class="docs-heading-anchor" href="#Basic-manipulation">Basic manipulation</a><a id="Basic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-manipulation" title="Permalink"></a></h2><p>Numerous functions are provided to manipulate permutation group elements.</p><article class="docstring"><header><a class="docstring-binding" id="cycles-Tuple{Perm}" href="#cycles-Tuple{Perm}"><code>cycles</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cycles(g::Perm)</code></pre><p>Decompose permutation <code>g</code> into disjoint cycles.</p><p>Return a <code>CycleDec</code> object which iterates over disjoint cycles of <code>g</code>. The ordering of cycles is not guaranteed, and the order within each cycle is computed up to a cyclic permutation. The cycle decomposition is cached in <code>g</code> and used in future computation of <code>permtype</code>, <code>parity</code>, <code>sign</code>, <code>order</code> and <code>^</code> (powering).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = Perm([3,4,5,2,1,6])
(1,3,5)(2,4)

julia&gt; collect(cycles(g))
3-element Vector{Vector{Int64}}:
 [1, 3, 5]
 [2, 4]
 [6]</code></pre></div></section></article><p>Cycle structure is cached in a permutation, since once available, it provides a convenient shortcut in many other algorithms.</p><article class="docstring"><header><a class="docstring-binding" id="parity-Tuple{Perm}" href="#parity-Tuple{Perm}"><code>parity</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parity(g::Perm)</code></pre><p>Return the parity of the given permutation, i.e. the parity of the number of transpositions in any decomposition of <code>g</code> into transpositions.</p><p><code>parity</code> returns <span>$1$</span> if the number is odd and <span>$0$</span> otherwise. <code>parity</code> uses cycle decomposition of <code>g</code> if already available, but will not compute it on demand. Since cycle structure is cached in <code>g</code> you may call <code>cycles(g)</code> before calling <code>parity</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = Perm([3,4,1,2,5])
(1,3)(2,4)

julia&gt; parity(g)
0

julia&gt; g = Perm([3,4,5,2,1,6])
(1,3,5)(2,4)

julia&gt; parity(g)
1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="sign-Tuple{Perm}" href="#sign-Tuple{Perm}"><code>sign</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sign(g::Perm)</code></pre><p>Return the sign of a permutation.</p><p><code>sign</code> returns <span>$1$</span> if <code>g</code> is even and <span>$-1$</span> if <code>g</code> is odd. <code>sign</code> represents the homomorphism from the permutation group to the unit group of <span>$\mathbb{Z}$</span> whose kernel is the alternating group.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = Perm([3,4,1,2,5])
(1,3)(2,4)

julia&gt; sign(g)
1

julia&gt; g = Perm([3,4,5,2,1,6])
(1,3,5)(2,4)

julia&gt; sign(g)
-1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="permtype-Tuple{Perm}" href="#permtype-Tuple{Perm}"><code>permtype</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permtype(g::Perm)</code></pre><p>Return the type of permutation <code>g</code>, i.e. lengths of disjoint cycles in cycle decomposition of <code>g</code>.</p><p>The lengths are sorted in decreasing order by default. <code>permtype(g)</code> fully determines the conjugacy class of <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = Perm([3,4,5,2,1,6])
(1,3,5)(2,4)

julia&gt; permtype(g)
3-element Vector{Int64}:
 3
 2
 1

julia&gt; e = one(g)
()

julia&gt; permtype(e)
6-element Vector{Int64}:
 1
 1
 1
 1
 1
 1</code></pre></div></section></article><p>Additionally <a href="https://github.com/kalmarek/GroupsCore.jl"><code>GroupsCore.jl</code></a> package provides more functionality, notably functions <code>gens</code> and <code>order</code>. You may consult its <a href="https://kalmarek.github.io/GroupsCore.jl/stable/">documentation</a>. Note that even an <code>Int64</code> can be easily overflowed when computing with symmetric groups. Thus, by default, <code>order</code> returns (always correct) <code>BigInt</code>s. If you are sure that the computation will not overflow, you may use <code>order(::Type{T}, ...)</code> to perform computations with machine integers. Julia&#39;s standard promotion rules apply for the returned value.</p><p>Since <code>SymmetricGroup</code> implements the iterator protocol, you may iterate over all permutations via a simple loop:</p><pre><code class="nohighlight hljs">for p in SymmetricGroup(n)
   ...
end</code></pre><p>Iteration over all permutations in reasonable time, (i.e. in terms of minutes) is possible when <span>$n â¤ 13$</span>.</p><p>You may also use the non-allocating <code>Generic.elements!</code> function for <span>$n â¤ 14$</span> (or even <span>$15$</span> if you are patient enough), which is an order of magnitude faster.</p><article class="docstring"><header><a class="docstring-binding" id="elements!-Tuple{AbstractAlgebra.Generic.SymmetricGroup}" href="#elements!-Tuple{AbstractAlgebra.Generic.SymmetricGroup}"><code>elements!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Generic.elements!(G::SymmetricGroup)</code></pre><p>Return an unsafe iterator over all permutations in <code>G</code>. Only one permutation is allocated and then modified in-place using the non-recursive <a href="https://en.wikipedia.org/wiki/Heap&#39;s_algorithm">Heaps algorithm</a>.</p><p>Note: you need to explicitly copy permutations intended to be stored or modified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; elts = Generic.elements!(SymmetricGroup(5));


julia&gt; length(elts)
120

julia&gt; for p in Generic.elements!(SymmetricGroup(3))
         println(p)
       end
()
(1,2)
(1,3,2)
(2,3)
(1,2,3)
(1,3)

julia&gt; A = collect(Generic.elements!(SymmetricGroup(3))); A
6-element Vector{Perm{Int64}}:
 (1,3)
 (1,3)
 (1,3)
 (1,3)
 (1,3)
 (1,3)

julia&gt; unique(A)
1-element Vector{Perm{Int64}}:
 (1,3)</code></pre></div></section></article><p>However, since all permutations yielded by <code>elements!</code> are aliased (modified &quot;in-place&quot;), <code>collect(Generic.elements!(SymmetricGroup(n)))</code> returns a vector of identical permutations.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you intend to use or store elements yielded by <code>elements!</code> you need to <strong>deepcopy</strong> them explicitly.</p></div></div><h2 id="Arithmetic-operators"><a class="docs-heading-anchor" href="#Arithmetic-operators">Arithmetic operators</a><a id="Arithmetic-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic-operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="*-Union{Tuple{T}, Tuple{Perm{T}, Perm{T}}} where T" href="#*-Union{Tuple{T}, Tuple{Perm{T}, Perm{T}}} where T"><code>*</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(g::Perm, h::Perm)</code></pre><p>Return the composition <span>$h â g$</span> of two permutations.</p><p>This corresponds to the action of permutation group on the set <code>[1..n]</code> <strong>on the right</strong> and follows the convention of GAP.</p><p>If <code>g</code> and <code>h</code> are parametrized by different types, the result is promoted accordingly.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Perm([2,3,1,4])*Perm([1,3,4,2]) # (1,2,3)*(2,3,4)
(1,3)(2,4)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="^-Tuple{Perm, Integer}" href="#^-Tuple{Perm, Integer}"><code>^</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">^(g::Perm, n::Integer)</code></pre><p>Return the <span>$n$</span>-th power of a permutation <code>g</code>.</p><p>By default <code>g^n</code> is computed by cycle decomposition of <code>g</code> if <code>n &gt; 3</code>. <code>Generic.power_by_squaring</code> provides a different method for powering which may or may not be faster, depending on the particular case. Due to caching of the cycle structure, repeated powering of <code>g</code> will be faster with the default method.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = Perm([2,3,4,5,1])
(1,2,3,4,5)

julia&gt; g^3
(1,4,2,5,3)

julia&gt; g^5
()</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="inv-Tuple{Perm}" href="#inv-Tuple{Perm}"><code>inv</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.inv(g::Perm)</code></pre><p>Return the inverse of the given permutation, i.e. the permutation <span>$g^{-1}$</span> such that <span>$g â g^{-1} = g^{-1} â g$</span> is the identity permutation.</p></div></section></article><p>Permutations parametrized by different types can be multiplied, and follow the standard julia integer promotion rules:</p><pre><code class="language-julia hljs">g = rand(SymmetricGroup(Int8(5)));
h = rand(SymmetricGroup(UInt32(5)));
typeof(g*h)

# output
Perm{UInt32}</code></pre><h2 id="Coercion"><a class="docs-heading-anchor" href="#Coercion">Coercion</a><a id="Coercion-1"></a><a class="docs-heading-anchor-permalink" href="#Coercion" title="Permalink"></a></h2><p>The following coercions are available for <code>G::SymmetricGroup</code> parent objects. Each of the methods perform basic sanity checks on the input which can be switched off by the second argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">(G::SymmetricGroup)(::AbstractVector{&lt;:Integer}[, check=true])</code></pre><blockquote><p>Turn a vector of integers into a permutation (performing conversion, if necessary).</p></blockquote><pre><code class="language-julia hljs">(G::SymmetricGroup)(::Perm[, check=true])</code></pre><blockquote><p>Coerce a permutation <code>p</code> into group <code>G</code> (performing the conversion, if necessary). If <code>p</code> is already an element of <code>G</code> no copy is performed.</p></blockquote><pre><code class="language-julia hljs">(G::SymmetricGroup)(::String[, check=true])</code></pre><blockquote><p>Parse the string input e.g. copied from the output of GAP. The method uses the same logic as the <code>perm&quot;...&quot;</code> macro. The string is sanitized and checked for disjoint cycles. Both <code>string(p::Perm)</code> (if <code>setpermstyle(:cycles)</code>) and <code>string(cycles(p::Perm))</code> are valid input for this method.</p></blockquote><pre><code class="language-julia hljs">(G::SymmetricGroup{T})(::CycleDec{T}[, check=true]) where T</code></pre><blockquote><p>Turn a cycle decomposition object into a permutation.</p></blockquote><h2 id="Comparison"><a class="docs-heading-anchor" href="#Comparison">Comparison</a><a id="Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="==-Tuple{Perm, Perm}" href="#==-Tuple{Perm, Perm}"><code>==</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(g::Perm, h::Perm)</code></pre><p>Return <code>true</code> if permutations are equal, otherwise return <code>false</code>.</p><p>Permutations parametrized by different integer types are considered equal if they define the same permutation in the abstract permutation group.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; g = Perm(Int8[2,3,1])
(1,2,3)

julia&gt; h = perm&quot;(3,1,2)&quot;
(1,2,3)

julia&gt; g == h
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="==-Tuple{AbstractAlgebra.Generic.SymmetricGroup, AbstractAlgebra.Generic.SymmetricGroup}" href="#==-Tuple{AbstractAlgebra.Generic.SymmetricGroup, AbstractAlgebra.Generic.SymmetricGroup}"><code>==</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(G::SymmetricGroup, H::SymmetricGroup)</code></pre><p>Return <code>true</code> if permutation groups are equal, otherwise return <code>false</code>.</p><p>Permutation groups on the same number of letters, but parametrized by different integer types are considered different.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; G = SymmetricGroup(UInt(5))
Permutation group over 5 elements

julia&gt; H = SymmetricGroup(5)
Permutation group over 5 elements

julia&gt; G == H
false</code></pre></div></section></article><h2 id="Misc"><a class="docs-heading-anchor" href="#Misc">Misc</a><a id="Misc-1"></a><a class="docs-heading-anchor-permalink" href="#Misc" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="rand-Tuple{AbstractAlgebra.Generic.SymmetricGroup}" href="#rand-Tuple{AbstractAlgebra.Generic.SymmetricGroup}"><code>rand</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand([rng=GLOBAL_RNG,] G::SymmetricGroup)</code></pre><p>Return a random permutation from <code>G</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="matrix_repr-Tuple{Perm}" href="#matrix_repr-Tuple{Perm}"><code>matrix_repr</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_repr(a::Perm)</code></pre><p>Return the permutation matrix as a sparse matrix representing <code>a</code> via natural embedding of the permutation group into the general linear group over <span>$\mathbb{Z}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Perm([2,3,1])
(1,2,3)

julia&gt; matrix_repr(p)
3Ã3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 â  1  â
 â  â  1
 1  â  â

julia&gt; Array(ans)
3Ã3 Matrix{Int64}:
 0  1  0
 0  0  1
 1  0  0</code></pre></div></section><section><div><pre><code class="nohighlight hljs">matrix_repr(Y::YoungTableau)</code></pre><p>Construct sparse integer matrix representing the tableau.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; y = YoungTableau([4,3,1]);


julia&gt; matrix_repr(y)
3Ã4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 8 stored entries:
 1  2  3  4
 5  6  7  â
 8  â  â  â</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="emb-Tuple{AbstractAlgebra.Generic.SymmetricGroup, Vector{Int64}, Bool}" href="#emb-Tuple{AbstractAlgebra.Generic.SymmetricGroup, Vector{Int64}, Bool}"><code>emb</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">emb(G::SymmetricGroup, V::Vector{Int}, check::Bool=true)</code></pre><p>Return the natural embedding of a permutation group into <code>G</code> as the subgroup permuting points indexed by <code>V</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Perm([2,3,1])
(1,2,3)

julia&gt; f = Generic.emb(SymmetricGroup(5), [3,2,5]);


julia&gt; f(p)
(2,5,3)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="emb!-Tuple{Perm, Perm, Any}" href="#emb!-Tuple{Perm, Perm, Any}"><code>emb!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">emb!(result::Perm, p::Perm, V)</code></pre><p>Embed permutation <code>p</code> into permutation <code>result</code> on the indices given by <code>V</code>.</p><p>This corresponds to the natural embedding of <span>$S_k$</span> into <span>$S_n$</span> as the subgroup permuting points indexed by <code>V</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Perm([2,1,4,3])
(1,2)(3,4)

julia&gt; Generic.emb!(Perm(collect(1:5)), p, [3,1,4,5])
(1,3)(4,5)</code></pre></div></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 18 April 2023 06:47">Tuesday 18 April 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
