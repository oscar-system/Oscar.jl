<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Specific topics Â· Oscar.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Oscar.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../padic/">Padics</a></li><li><a class="tocitem" href="../../qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../../Experimental/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li></ul></li><li><a class="tocitem" href="../../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/homological_algebra/">Homological Algebra</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">GrÃ¶bner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/groebner_bases/">GrÃ¶bner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/groebner_bases_integers/">GrÃ¶bner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Toric Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/ToricSchemes/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/ToricSchemes/NormalToricSchemes/">Normal Toric Schemes</a></li><li><a class="tocitem" href="../../../Experimental/ToricSchemes/AffineToricSchemes/">Affine Toric Schemes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/TropicalGeometry/curve/">Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/K3Surfaces/">Automorphism Groups of  K3 surfaces</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/SurfacesP4/">Nongeneral Type Surfaces in <span>$\mathbb P^4$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-8" type="checkbox"/><label class="tocitem" for="menuitem-11-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Miscellaneous/miscellaneous/">Some Special Ideals</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Noncommutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li><li><a class="tocitem" href="../../../Combinatorics/partitions/">Partitions</a></li><li><a class="tocitem" href="../../../Combinatorics/tableaux/">Tableaux</a></li><li><a class="tocitem" href="../../../Combinatorics/schur_polynomials/">Schur polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../../references/">References</a></li><li><a class="tocitem" href="../../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-7" type="checkbox"/><label class="tocitem" for="menuitem-17-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-18" type="checkbox"/><label class="tocitem" for="menuitem-18"><span class="docs-label">Experimental</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/intro/">Adding new projects to experimental</a></li><li><input class="collapse-toggle" id="menuitem-18-2" type="checkbox"/><label class="tocitem" for="menuitem-18-2"><span class="docs-label">F-Theory Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/FTheoryTools/introduction/">Welcome to FTheoryTools</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/weierstrass/">Global Weierstrass models</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/tate/">Global Tate models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-18-3" type="checkbox"/><label class="tocitem" for="menuitem-18-3"><span class="docs-label">Linear Quotients</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/LinearQuotients/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/LinearQuotients/linear_quotients/">Construction and basic functionality</a></li><li><a class="tocitem" href="../../../Experimental/LinearQuotients/cox_rings/">Cox rings</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Specific topics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Specific topics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/Nemo/developer/topics.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Specific-topics"><a class="docs-heading-anchor" href="#Specific-topics">Specific topics</a><a id="Specific-topics-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-topics" title="Permalink"></a></h1><h2 id="Julia-arithmetic"><a class="docs-heading-anchor" href="#Julia-arithmetic">Julia arithmetic</a><a id="Julia-arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-arithmetic" title="Permalink"></a></h2><p>At the console, Julia arithmetic is often defined in a way that a numerical person would expect. For example, <code>3/1</code> returns a floating point number <code>3.0</code>, <code>sqrt(4)</code> returns the floating point number <code>2.0</code> and <code>exp(0)</code> returns the floating point number <code>1.0</code>.</p><p>In each case the ring is changed from the input to the output of the function. Whilst this is often what one expects to happen in a computer algebra system, these are not the definitions one would want for algebraic operations.</p><p>In this section we describe the alternatives we have implemented to allow algebraic computations, particularly for rings and fields.</p><h3 id="divexact-and-divides"><a class="docs-heading-anchor" href="#divexact-and-divides"><code>divexact</code> and <code>divides</code></a><a id="divexact-and-divides-1"></a><a class="docs-heading-anchor-permalink" href="#divexact-and-divides" title="Permalink"></a></h3><p>Nemo implements numerous kinds of division:</p><ul><li>floating point division using the <code>/</code> operator as per Julia</li><li>exact division in a ring using <code>divexact</code> and <code>divides</code></li><li>quotient field element construction using <code>//</code> as per Julia</li><li>Euclidean division using <code>div</code>, <code>rem</code>, <code>divrem</code>, <code>mod</code> and <code>%</code></li></ul><p>The expression <code>divexact(a, b)</code> for <code>a</code> and <code>b</code> in a ring <code>R</code> returns a value <code>c</code> in <code>R</code> such that <code>a = bc</code>. If such an element of <code>R</code> does not exist, an exception is raised.</p><p>To instead test whether such an element exists, <code>divides(a, b)</code> returns a tuple <code>(flag, q)</code> where <code>flag</code> is a boolean saying whether such an exact quotient exists in the ring and if so <code>q</code> is such a quotient.</p><h3 id="Euclidean-division"><a class="docs-heading-anchor" href="#Euclidean-division">Euclidean division</a><a id="Euclidean-division-1"></a><a class="docs-heading-anchor-permalink" href="#Euclidean-division" title="Permalink"></a></h3><p>Nemo must provide Euclidean division, i.e. given <code>a</code> and <code>b</code> in a Euclidean ring <code>R</code> it must be able to find <code>q</code> and <code>r</code> such that <code>a = bq + r</code> with <code>r</code> smaller than <code>a</code> with respect to some fixed Euclidean function on <code>R</code>. There are some restrictions imposed by Julia however.</p><p>Firstly, <code>%</code> is a constant alias of <code>rem</code> in Julia, so these are not actually two independent functions but the same function.</p><p>Julia defines <code>div</code>, <code>rem</code> and <code>divrem</code> for integers as a triple of functions that return Euclidean quotient and remainder, where the remainder has the same sign as the dividend, e.g. <code>rem(1, 3) == 1</code> but <code>rem(-2, 3) == -2</code>. In other words, this triple of functions gives Euclidean division, but without a consistent set of representatives.</p><p>When using Nemo at the console (or indeed inside any other package without importing the internal Nemo definitions) <code>div</code>, <code>rem</code> and <code>divrem</code> return the same values as Julia and these functions follows the Julia convention of making the sign of the remainder the same as the dividend over <code>ZZ</code>, e.g. <code>rem(ZZ(1), ZZ(3)) == 1</code> but <code>rem(ZZ(-2), ZZ(3)) == -2</code>.</p><p>Internally to Nemo however, this is not convenient. For example, Hermite normal form over <code>ZZ</code> will only return a unique result if there is a consistent choice of representatives for the Euclidean division. This applies to the generic HNF code in AbstractAlgebra, but similar problems exist for the generic finitely presented module code in AbstractAlgebra, even when used over Nemo integers. Thus the Julia definition of <code>rem</code> will not suffice.</p><p>Furthermore, as Nemo wraps Flint, it is convenient that Euclidean division inside Nemo should operate the way Flint operates. This is critical if for example one wants the result of a Hermite normal form coming from Flint to be reduced using the same definition of Euclidean remainder as used elsewhere throughout the Nemo module and to return the same answers as the generic HNF code in AbstractAlgebra for example.</p><p>In particular, Flint defines Euclidean remainder over the integers in line with the Julia function <code>mod</code>, namely by returning the smallest remainder with the same sign as the <em>divisor</em>, i.e. <code>mod(1, 3) == 1</code> but <code>mod(1, -3) == -2</code>.</p><p>Therefore internally, Nemo chooses <code>div</code>, <code>mod</code> and <code>divrem</code> to be a consistent triple of functions for Euclidean division, with <code>mod</code> defined as per Julia. Thus in particular, <code>div</code> and <code>divrem</code> behave differently to Julia inside of Nemo itself, viz. <code>Nemo.divrem(-1, 3) == (-1, 2)</code>.</p><p>The same definitions for <code>div</code>, <code>mod</code> and <code>divrem</code> are used internally to AbstractAlgebra as well, even for Julia integers, so that AbstractAlgebra and Nemo are both consistent internally. However, both AbstractAlgebra and Nemo export definitions in line with Julia so that behaviour at the console is consistent.</p><p>The Nemo developers have given considerable thought to this compromise and the current situation has evolved over many iterations to the current state. We do not consider this to be a situation that needs &#39;fixing&#39;, though we are acutely aware that many tickets will be opened complaining about some inconsistency.</p><p>When reflecting on the choice we have made, one must consider the following:</p><ul><li>Nemo must internally behave as Flint does for consistency</li><li>There are also functions such as <code>powmod</code>, <code>invmod</code> that reduce as per mod</li><li>HNF requires a consistent set of representatives for uniqueness over <code>ZZ</code></li></ul><p>Also note that Julia&#39;s <code>rem</code> does not provide symmetric mod, a misconception that often arises. The issues here are independent of the decision to use positive remainder (for positive modulus) in Flint, rather than symmetric mod.</p><p>We are aware that the conventions we have chosen have inconsistencies with Julia and do not have the nice property that <code>div</code>, <code>rem</code> and <code>divrem</code> are a triple of Euclidean functions inside Nemo. However, we are sure that the convention we have chosen is one of only two sensible possibilities, and switching to the other convention (apart from being a huge amount of effort) would only succeed in replacing one kind of inconsistency with another.</p><p>As a consequence of these choices, <code>div</code>, <code>mod</code> and <code>divrem</code> are a triple of functions for <em>all</em> Euclidean division across Nemo, not just for the integers. As generic code must use a consistent set of functions, we ask that developers respect this choice by using these three functions in all generic code. The functions <code>rem</code> and <code>%</code> should only be used for Julia integers, and only when one specifically wants the Julia definition.</p><h3 id="sqrt,-inv-and-exp"><a class="docs-heading-anchor" href="#sqrt,-inv-and-exp"><code>sqrt</code>, <code>inv</code> and <code>exp</code></a><a id="sqrt,-inv-and-exp-1"></a><a class="docs-heading-anchor-permalink" href="#sqrt,-inv-and-exp" title="Permalink"></a></h3><p>As mentioned above, Julia does not perform computations within a given ring, but often returns a numerical result when given an exact input.</p><p>Whilst this is often what a user expects, it makes operations such as power series square root, inversion or exponentiation more tricky over an exact ring.</p><p>Therefore, AbstractAlgebra defines <code>sqrt</code>, <code>inv</code> and <code>exp</code> internally in a strictly algebraic way, returning a result only if it exists in the ring of the input and otherwise raising an exception.</p><p>For example, <code>AbstractAlgebra.sqrt(4) == 2</code>, <code>AbstractAlgebra.inv(-1) == -1</code> and <code>AbstractAlgebra.exp(0) == 1</code>.</p><p>Naturally these definitions are not so terribly useful to a user and are only needed for internal consistency. Therefore, of course these definitions are not exported by <code>AbstractAlgebra</code> so that the behaviour at the console is not affected by these definitions.</p><p>There is currently some inconsistency in that Nemo follows the Julia numerical definitions internally rather than following the algebraic definitions provided internally in AbstractAlgebra. This may or may not change in future.</p><p>It is worth recalling that Julia provides <code>isqrt</code> for integer square root. This is not sufficient to solve our problem as we require square root for all rings, not just integers. We don&#39;t feel that developers will want to type <code>isqrt</code> rather than <code>sqrt</code> internally for all rings.</p><p>A number of changes are expected to be made with regard to the behaviour of root taking and division functions, including the ability to specify high performance alternatives that do not check the exactness of the computation. These changes are being discussed on the Nemo ticket https://github.com/Nemocas/Nemo.jl/issues/862 In particular, the table given there by thofma represents the current consensus on the changes that will be made in the future.</p><p>Note that many of the above issues with exact computations in rings exist for all the Julia transcendental functions, <code>sin</code>, <code>cos</code>, <code>log</code>, etc., of which there are many. If we ever add some kind of generic power series functions for these, we may extend the internal definitions to include exact algebraic versions of all these functions. At least for now this is not a pressing issue.</p><p>The way that AbstractAlgebra deals with functions which must have a different definition inside the module than what it exports is as follows. Firstly, we do not import the functions from Base or export the functions at all. Internally we make our definitions as we want them, but then we overload the Base version explicitly to do what the console version of the function should do. This is done by explicitly defining <code>Base.sqrt(::ZZRingElem)</code> for example without explicitly importing <code>sqrt</code> from Base, etc.</p><p>In the Generic module discussed below, we import the definitions from AbstractAlgebra rather than Base.</p><h3 id="Determinant"><a class="docs-heading-anchor" href="#Determinant">Determinant</a><a id="Determinant-1"></a><a class="docs-heading-anchor-permalink" href="#Determinant" title="Permalink"></a></h3><p>Another function which Nemo handles differently to Julia is <code>det</code> for determinant of matrices. If the input is an integer matrix, Nemo outputs an integer rather than a floating point number for the determinant.</p><p>However, this is not such an acute problem as Julia&#39;s <code>det</code> has now been placed in <code>LinearAlgebra</code> rather than <code>Base</code>. Moreover, Nemo has its own matrices and so does not conflict with the definition of <code>det</code> for Julia matrices.</p><p>It is important for developers to understand this difference however. It is not generally wise to use the Julia linear algebra functionality on the Julia matrices underlying generic Nemo matrices for this reason.</p><h2 id="The-Generic-submodule"><a class="docs-heading-anchor" href="#The-Generic-submodule">The Generic submodule</a><a id="The-Generic-submodule-1"></a><a class="docs-heading-anchor-permalink" href="#The-Generic-submodule" title="Permalink"></a></h2><p>In AbstractAlgebra we define a submodule called Generic. The purpose of this module is to allow generic constructions over a given base ring. For example in Nemo, <code>R, x = Generic.polynomial_ring(ZZ, &quot;x&quot;)</code> will construct a generic polynomial ring over Nemo integers instead of constructing a Flint polynomial ring.</p><p>In other words <code>x</code> will have the type <code>Generic.Poly{ZZRingElem}</code> instead of the usual <code>ZZPolyRingElem</code>.</p><p>The ability to construct generic polynomials and matrices and the like is useful for test code and for tracking down bugs in basic arithmetic. It is also useful for performance comparison of arithmetic defined for generic ring constructions vs the specialised implementations provided by C libraries like Flint.</p><p>Whilst most developers will not need to use the Generic module specifically, unless they have such needs, all Nemo developers need to understand how to define new generic ring constructions and functions for them. They also need to understand some subtleties that arise because of this mechanism.</p><p>Firstly, a generic construction like <code>polynomial_ring</code> must be defined inside the Generic submodule of AbstractAlgebra. All files inside the <code>src/generic</code> directory of AbstractAlgebra exist for this purpose. However, exporting from that submodule will not export the functionality to the Nemo user.</p><p>To do this, one must add a function <code>polynomial_ring</code> for example, in <code>src/Poly.jl</code>, say, which calls <code>Generic.polynomial_ring</code>. Then one needs to export <code>polynomial_ring</code> from AbstractAlgebra (also in that file).</p><p>Similarly, all functions provided for generic polynomial rings are not automatically available, even when exported from the Generic submodule. Two additional things are required, namely an import from Generic into AbstractAlgebra and then an export from AbstractAlgebra to the user.</p><p>An exception to this is if there is a function with the same name in AbstractAlgebra (i.e. in the top level <code>src</code> directory). In this case it is sufficient to simply import that function into <code>Generic</code> in the file <code>src/Generic.jl</code>.</p><p>In the former case, two large lists exist in <code>src/AbstractAlgebra.jl</code> with these imports and exports. These are kept in alphabetical order to prevent duplicate imports/exports being added over time.</p><p>If one wishes to extend a definition provided by Base, one can simply overload <code>Base.blah</code> inside the Generic submodule directly. Exceptions to this include the <code>div</code>, <code>mod</code>, <code>divrem</code>, <code>sqrt</code>, <code>inv</code> and <code>exp</code> functions mentioned above.</p><p>For AbstractAlgebra types, one still defines these exceptions <code>blah</code> by overloading <code>Base.blah</code> directly inside Generic. However, for the versions that would conflict with the Julia definition (e.g. the definition for <code>Int</code>), we instead define <code>AbstractAlgebra.blah</code> for that specific type and a fallback <code>AbstractAlgebra.blah(a) = Base.blah(a)</code> which calls the Base version of the function for all other types. Of course we do not export <code>blah</code> from AbstractAlgebra.</p><p>In order to make the AbstractAlgebra version available in Generic (rather than the Base version), we do not import <code>blah</code> from Base inside Generic, but instead import it from AbstractAlgebra. One can see these imports for the exceptional functions <code>blah</code> in the file <code>src/Generic.jl</code>.</p><h2 id="Unsafe-operations-and-aliasing"><a class="docs-heading-anchor" href="#Unsafe-operations-and-aliasing">Unsafe operations and aliasing</a><a id="Unsafe-operations-and-aliasing-1"></a><a class="docs-heading-anchor-permalink" href="#Unsafe-operations-and-aliasing" title="Permalink"></a></h2><p>As with most object oriented languages that overload arithmetic operators, Julia creates new objects when doing an arithmetic operation. For example, <code>BigInt(3) + BigInt(5)</code> creates a new <code>BigInt</code> object to return the value <code>BigInt(8)</code>. This can be problematic when accumulating many such operations in a single coefficient of a polynomial or entry of a matrix due to the large number of temporary objects the garbage collector must allocate and clean up.</p><p>To speed up such accumulations, Nemo provides numerous unsafe operators, which mutate the existing elements of the polynomial, matrix, etc. These include functions such as <code>add!</code>, <code>addeq!</code>, <code>mul!</code>, <code>zero!</code> and <code>addmul!</code>.</p><p>These functions take as their first argument the object that should be modified with the return value.</p><p>Note that functions such as <code>sub!</code>, <code>submul!</code> and <code>subeq!</code> are not in the official interface and not provided consistently, thus generic code cannot rely on them existing. So far it has always been the case that when doing accumulation where subtraction is needed rather than addition, that a single negation can be performed outside the accumulation loop and then the additive versions of the functions can be called inside the loop where the performance matters.</p><p>If we encounter cases in future where this is not the case, it may be necessary to add the versions that do subtraction to the interface. However, this can only be done if all rings in Nemo support it. One cannot define a fallback which turns a subtraction into a negation and an addition, as then the old performance characteristics of a new object being created per operation will result, meaning that the developer will not be able to reason about the likely performance of unsafe operators.</p><h3 id="Interaction-of-unsafe-operators-and-immutable-types"><a class="docs-heading-anchor" href="#Interaction-of-unsafe-operators-and-immutable-types">Interaction of unsafe operators and immutable types</a><a id="Interaction-of-unsafe-operators-and-immutable-types-1"></a><a class="docs-heading-anchor-permalink" href="#Interaction-of-unsafe-operators-and-immutable-types" title="Permalink"></a></h3><p>Because not all objects in Nemo are mutable, the unsafe operators somehow have to support immutable objects. This is done by also returning the &quot;modified&quot; return value from the unsafe operators. Naturally, this return value is not a mutated version of the original value, as that is not possible. However, it does allow the unsafe operators to accept immutable values in their first argument. Instead of modifying this value, the old value is replaced with the return value of the unsafe operator.</p><p>In order to make this work correctly, every single call to an unsafe operator must assign the return value to the original location. This requires discipline on the part of the developer using unsafe operators.</p><p>For example, to set the existing value <code>a</code> to <code>a + b</code> one must write</p><pre><code class="language-julia hljs">a = addeq!(a, b)</code></pre><p>i.e. one must have an explicit assignment to the left of the <code>addeq!</code> call and indeed all the unsafe operator calls.</p><p>In the case of a mutable type, <code>addeq!</code> will simply modify the original <code>a</code>. The modified object will be returned and assigned to the exact same variable, which has no effect.</p><p>In the case of an immutable type, <code>addeq!</code> does not modify the original object <code>a</code> as this is impossible, but it still returns the new value and assigns it to <code>a</code> which is what one wants.</p><h2 id="Aliasing-rules-and-mutation"><a class="docs-heading-anchor" href="#Aliasing-rules-and-mutation">Aliasing rules and mutation</a><a id="Aliasing-rules-and-mutation-1"></a><a class="docs-heading-anchor-permalink" href="#Aliasing-rules-and-mutation" title="Permalink"></a></h2><p>One must be incredibly careful when mutating an existing value that one owns the value. If the user passes an object to a generic function for example and it changes the object without the user knowing, this can result in incorrect results in user code due to the value of their objects changing from under them.</p><p>In the first instance, functions should never modify their inputs. But further problems can also occur if the output of an unsafe operator happens to alias one of the other inputs. Such cases need to be handled exceptionally carefully.</p><p>A second issue arises as Nemo is based on Flint, which has its own aliasing rules which are distinct from the default expectation in Julia. This leads to some interesting corner cases.</p><p>In particularly, Flint always allows aliasing of inputs and outputs in its polynomial functions but expects matrix functions to have output matrices that are distinct from their inputs, except in a handful of functions that are specially documented to be inplace operations.</p><p>Moreover, when assigning an element to a coefficient of a polynomial or entry of a matrix Flint always makes a copy of the element being assigned to that location. In Julia however, if one assigns an element to some index of an array, the existing object at that location is replaced with the new object. This means that inplace modification of Julia array elements is not safe as it would modify the original object that was assigned to that location, whereas in Flint inplace modification is highly desirable for performance reasons and is completely safe due to the fact that a copy was made when the value was assigned to that location.</p><p>We have developed over a period of many years a set of rules that maximise the performance benefit we get from our unsafe operators, whilst keeping the burden imposed on the programmer to a minimum. It has been a <em>very</em> difficult task to arrive at the set of rules we have whilst respecting correctness of our code, and it would be extremely hard to change any of them.</p><h3 id="Arithmetic-operations-return-a-new-object"><a class="docs-heading-anchor" href="#Arithmetic-operations-return-a-new-object">Arithmetic operations return a new object</a><a id="Arithmetic-operations-return-a-new-object-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic-operations-return-a-new-object" title="Permalink"></a></h3><p>In order to make it easy for the Nemo developer to create a completely new object when one is needed, e.g. for accumulating values using unsafe operators, we developed the following rules.</p><p>Whenever an arithmetic operation is used, i.e. <code>+</code>, <code>-</code>, <code>*</code>, unary minus and <code>^</code>, Nemo always returns a new object, in line with Julia. Naturally, <code>deepcopy</code> also makes a copy of an object which can be used in unsafe functions.</p><p>Note that if <code>R</code> is a type and an element <code>a</code> of that type is passed to it, e.g. <code>R(a)</code> then, the Julia convention is that the original object <code>a</code> will be returned rather than a copy of <code>a</code>. This convention ensures there is not an additional cost when coercing values that are already of the right type, e.g in generic code where coercion may or may not be needed depending on the type.</p><p>We extend this convention to parent objects <code>R</code> and elements <code>a</code> of that parent. In particular, <code>R(a)</code> cannot be used to make a copy of <code>a</code> for use in an unsafe function if <code>R</code> is the parent of <code>a</code>.</p><p>All other functions <em>may</em> also return the input object if they wish. In other words, the return value of all other functions is not suitable for use in an unsafe function. Only return values of arithmetic operations and <code>deepcopy</code> or objects freshly created using inner constructors will be suitable for such use.</p><p>This convention has been chosen to maximise performance of Nemo. Low level operations (where performance matters) make a new object, even if the result is the same arithmetically as one of the inputs. But higher level functions will not necessarily make a new object, meaning that they cannot be used with unsafe functions.</p><h3 id="Aliasing-rules"><a class="docs-heading-anchor" href="#Aliasing-rules">Aliasing rules</a><a id="Aliasing-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Aliasing-rules" title="Permalink"></a></h3><p>We now summarise the aliasing rules used by Nemo and AbstractAlgebra. We are relatively confident by now that following these rules will result in correct code given the constraints mentioned above.</p><ul><li><p>matrices are viewed as containers which may contain elements that alias one another. Other objects, e.g. polynomials, series, etc., are constructed from objects that do not alias one another, <em>even in part</em></p></li><li><p>standard unsafe operators, addeq!, mul!, addmul!, zero!, add! which mutate their outputs are allow to be used iff that output is entirely under the control of the caller, i.e. it was created for the purpose of accumulation, but otherwise must not be used</p></li><li><p>all arithmetic functions i.e. unary minus, <code>+</code>, <code>-</code>, <code>*</code>, <code>^</code>, and deepcopy must return new objects and cannot return one of their inputs</p></li><li><p>all other functions are allowed to return their inputs as outputs</p></li><li><p>matrix functions with an exclamation mark should not mutate the objects that occur as entries of the output matrix, though should be allowed to arbitrarily replace/swap the entries that appear in the matrix. In other words, these functions should be interpreted as inplace operations, rather than operations that are allowed to mutate the actual entries themselves</p></li><li><p><code>R(a)</code> where <code>R</code> is the parent of <code>a</code>, always just returns <code>a</code> and not a copy</p></li><li><p><code>setcoeff!</code> and <code>setindex!</code> and <code>getcoeff</code> and <code>getindex</code> should not make copies. Note that this implies that setcoeff! should not be passed an element that aliases another somewhere else, even in part</p></li><li><p>Constructors for polynomials, series and similar ring element objects (that are not matrices) that take an array as input, must ensure that the coefficients being placed into the object do not alias, even in part</p></li></ul><h2 id="The-SparsePoly-module"><a class="docs-heading-anchor" href="#The-SparsePoly-module">The SparsePoly module</a><a id="The-SparsePoly-module-1"></a><a class="docs-heading-anchor-permalink" href="#The-SparsePoly-module" title="Permalink"></a></h2><p>The SparsePoly module in AbstractAlgebra is a generic module for sparse univariate polynomials over a given base ring.</p><p>This module is used internally, e.g. in the generic multivariate gcd code, however it is not particularly suitable for general use.</p><p>Firstly, whilst the representation is sparse (recursive) the algorithms used generally are not. This is because the amount of time taken by the Jit in Julia is simply too large (upwards of 6s for the first multivariate gcd).</p><p>Secondly, the order of terms in that representation is not the one which a developer would expect for a sparse univariate format.</p><p>If the Julia Jit is ever made orders of magnitude faster, it may be worth cleaning up this module and making it generally available. But for now, it should be considered internal and heavily incomplete.</p><h2 id="Parent-object-caching"><a class="docs-heading-anchor" href="#Parent-object-caching">Parent object caching</a><a id="Parent-object-caching-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-object-caching" title="Permalink"></a></h2><p>Parent objects in Nemo must be unique given the data that is used to create them. For this purpose most parent objects are cached globally and looked up upon creation. If a parent object with that data already exists, it is returned from the cache instead of creating a new one.</p><p>There are two situations where this can be problematic however.</p><p>The first situation is if one is doing some parallel programming. Here global objects are a blight and it may be necessary to turn off caching and simply ensure that that same data is only ever used once when creating parent objects.</p><p>The second situation is when doing multimodular algorithms, where many similar parent objects with different moduli are created. The cache can become overwhelmed slowing the code down or even grinding to a halt.</p><p>In both these situations one can pass <code>false</code> as an additional argument to a parent constructor to avoid caching the parent object it creates. This parameter normally has a default value of <code>true</code> and under normal circumstances doesn&#39;t need to be supplied.</p><p>Note that special light-weight parent constructors, <code>PolyRing</code>, <code>AbsPowerSeriesRing</code>, <code>RelPowerSeriesRing</code>, etc. are also provided which do not cache.</p><h2 id="Throw/nothrow-for-check_parent"><a class="docs-heading-anchor" href="#Throw/nothrow-for-check_parent">Throw/nothrow for <code>check_parent</code></a><a id="Throw/nothrow-for-check_parent-1"></a><a class="docs-heading-anchor-permalink" href="#Throw/nothrow-for-check_parent" title="Permalink"></a></h2><p>By default the <code>check_parent</code> functions throw an exception if parents do not match. However sometimes one would like to know if they match without throwing.</p><p>For this purpose one can pass an additional <code>false</code> argument to <code>check_parent</code>. This suppresses the exception that would be thrown if the parent objects didn&#39;t match. Instead the function simply returns <code>true</code> or <code>false</code> to indicate whether they matched or not.</p><h2 id="Delayed-reduction"><a class="docs-heading-anchor" href="#Delayed-reduction">Delayed reduction</a><a id="Delayed-reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Delayed-reduction" title="Permalink"></a></h2><p>When working in residue rings, various functions will perform an arithmetic operation followed by a reduction modulo the modulus of the residue ring.</p><p>Some accumulations, e.g. in linear algebra or polynomial arithmetic, can be dramatically sped up if one can delay the reductions that would happen after each operation in the accumulation.</p><p>Some of the Generic code in Nemo is designed to allow such delayed reduction if the ring supports it and to simply use fallbacks that do the reduction after every intermediate operation if they don&#39;t.</p><p>To support delayed reduction, a ring must support the delayed reduction interface which we describe here.</p><p>Two additional functions must be supplied for the element type. We give examples for the Nemo <code>nf_elem</code> type:</p><pre><code class="language-julia hljs">mul_red!(z::nf_elem, x::nf_elem, y::nf_elem, red::Bool)</code></pre><p>This function behaves as per <code>mul!</code> but only performs reduction if the additional boolean argument <code>red</code> is set to <code>true</code>. This function can assume that both the inputs are reduced.</p><pre><code class="language-julia hljs">reduce!(x::nf_elem)</code></pre><p>This function must perform reduction on an unreduced element (mutating it). Note that it must return the mutated value as per all unsafe operators.</p><p>Finally, the <code>add!</code> and <code>addeq!</code> operators must be able to add nonreduced values.</p><p>If one wishes to speed up generic code for rings that provide delayed reduction, one makes use of the function <code>addmul_delayed_reduction!</code> in the accumulation loop. Here is an example for accumulation into a two dimensional matrix element in Generic in a matrix multiplication routine:</p><pre><code class="language-julia hljs">A[i, j] = base_ring(X)()
for k = 1:ncols(X)
    A[i, j] = addmul_delayed_reduction!(A[i, j], x[i, k], y[k, j], C)
end
A[i, j] = reduce!(A[i, j])</code></pre><p>Here <code>C</code> is a temporary element of the same type as the other inputs which is used internally in <code>addmul_delayed_reduction!</code> if needed.</p><p>Notice the final call to <code>reduce!</code> to reduce the accumulated value after the accumulation loop has finished.</p><p>Note that <code>mul_red!</code> is never called directly but is called inside the generic implementation of <code>addmul_delayed_reduction!</code> for rings that support delayed reduction. That generic code falls back to a call to <code>addmul!</code> which in turn falls back to <code>mul!</code> and <code>addeq!</code> where delayed reduction or <code>addmul!</code> are not available.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 18 April 2023 06:47">Tuesday 18 April 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
