<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Number field operations Â· Oscar.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Oscar.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox" checked/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Number field operations</a><ul class="internal"><li><a class="tocitem" href="#Creation-of-number-fields"><span>Creation of number fields</span></a></li><li><a class="tocitem" href="#Basic-properties"><span>Basic properties</span></a></li><li><a class="tocitem" href="#Invariants"><span>Invariants</span></a></li><li><a class="tocitem" href="#Predicates"><span>Predicates</span></a></li><li><a class="tocitem" href="#Conversion"><span>Conversion</span></a></li><li><a class="tocitem" href="#Morphisms"><span>Morphisms</span></a></li><li><a class="tocitem" href="#Galois-theory"><span>Galois theory</span></a></li><li><a class="tocitem" href="#Infinite-places"><span>Infinite places</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li></ul></li><li><a class="tocitem" href="../elements/">Element operations</a></li><li><a class="tocitem" href="../internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../orders/orders/">Orders</a></li><li><a class="tocitem" href="../../orders/elements/">Elements</a></li><li><a class="tocitem" href="../../orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../../Experimental/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li></ul></li><li><a class="tocitem" href="../../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/homological_algebra/">Homological Algebra</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">GrÃ¶bner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/groebner_bases/">GrÃ¶bner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/groebner_bases_integers/">GrÃ¶bner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Toric Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/ToricSchemes/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/ToricSchemes/NormalToricSchemes/">Normal Toric Schemes</a></li><li><a class="tocitem" href="../../../Experimental/ToricSchemes/AffineToricSchemes/">Affine Toric Schemes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/TropicalGeometry/curve/">Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/K3Surfaces/">Automorphism Groups of  K3 surfaces</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/SurfacesP4/">Nongeneral Type Surfaces in <span>$\mathbb P^4$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-8" type="checkbox"/><label class="tocitem" for="menuitem-11-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Miscellaneous/miscellaneous/">Some Special Ideals</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Noncommutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li><li><a class="tocitem" href="../../../Combinatorics/partitions/">Partitions</a></li><li><a class="tocitem" href="../../../Combinatorics/tableaux/">Tableaux</a></li><li><a class="tocitem" href="../../../Combinatorics/schur_polynomials/">Schur polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../../references/">References</a></li><li><a class="tocitem" href="../../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-7" type="checkbox"/><label class="tocitem" for="menuitem-17-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-18" type="checkbox"/><label class="tocitem" for="menuitem-18"><span class="docs-label">Experimental</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/intro/">Adding new projects to experimental</a></li><li><input class="collapse-toggle" id="menuitem-18-2" type="checkbox"/><label class="tocitem" for="menuitem-18-2"><span class="docs-label">F-Theory Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/FTheoryTools/introduction/">Welcome to FTheoryTools</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/weierstrass/">Global Weierstrass models</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/tate/">Global Tate models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-18-3" type="checkbox"/><label class="tocitem" for="menuitem-18-3"><span class="docs-label">Linear Quotients</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/LinearQuotients/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/LinearQuotients/linear_quotients/">Construction and basic functionality</a></li><li><a class="tocitem" href="../../../Experimental/LinearQuotients/cox_rings/">Cox rings</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Number Theory</a></li><li><a class="is-disabled">Number Fields</a></li><li class="is-active"><a href>Number field operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Number field operations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/Hecke/number_fields/fields.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Number-field-operations"><a class="docs-heading-anchor" href="#Number-field-operations">Number field operations</a><a id="Number-field-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Number-field-operations" title="Permalink"></a></h1><h2 id="Creation-of-number-fields"><a class="docs-heading-anchor" href="#Creation-of-number-fields">Creation of number fields</a><a id="Creation-of-number-fields-1"></a><a class="docs-heading-anchor-permalink" href="#Creation-of-number-fields" title="Permalink"></a></h2><p>General number fields can be created using the function <code>number_field</code>, of which <code>number_field</code> is an alias. To create a simple number field given by a defining polynomial or a non-simple number field given by defining polynomials, the following functions can be used.</p><article class="docstring"><header><a class="docstring-binding" id="number_field-Tuple{Hecke.DocuDummy}" href="#number_field-Tuple{Hecke.DocuDummy}"><code>number_field</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_field(f::Poly{NumFieldElem}, s::String;
            cached::Bool = false, check::Bool = false) -&gt; NumField, NumFieldElem</code></pre><p>Given an irreducible polynomial <span>$f \in K[x]$</span> over some number field <span>$K$</span>, this function creates the simple number field <span>$L = K[x]/(f)$</span> and returns <span>$(L, b)$</span>, where <span>$b$</span> is the class of <span>$x$</span> in <span>$L$</span>. The string <code>s</code> is used only for printing the primitive element <span>$b$</span>.</p><ul><li><code>check</code>: Controls whether irreducibility of <span>$f$</span> is checked.</li><li><code>cached</code>: Controls whether the result is cached.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; K, a = quadratic_field(5);

julia&gt; Kt, t = K[&quot;t&quot;];

julia&gt; L, b = number_field(t^3 - 3, &quot;b&quot;);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="number_field-Tuple{Hecke.DocuDummy2}" href="#number_field-Tuple{Hecke.DocuDummy2}"><code>number_field</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_field(f::Vector{PolyElem{&lt;:NumFieldElem}}, s::String=&quot;_\$&quot;, check = true)
                                          -&gt; NumField, Vector{NumFieldElem}</code></pre><p>Given a list <span>$f_1, \ldots, f_n$</span> of univariate polynomials in <span>$K[x]$</span> over some number field <span>$K$</span>, constructs the extension <span>$K[x_1, \ldots, x_n]/(f_1(x_1), \ldots, f_n(x_n))$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Qx, x = QQ[&quot;x&quot;];

julia&gt; K, a = number_field([x^2 - 2, x^2 - 3], &quot;a&quot;)
(Non-simple number field with defining polynomials QQMPolyRingElem[x1^2 - 2, x2^2 - 3], NfAbsNSElem[a1, a2])</code></pre></div></section></article><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Many of the constructors have arguments of type <code>Symbol</code> or <code>AbstractString</code>.  If used, they define the appearance in printing, and printing only.  The named parameter <code>check</code> can be <code>true</code> or <code>false</code>, the default being <code>true</code>.  This parameter controls whether the polynomials defining the number field are tested for irreducibility or not. Given that this can be potentially very time consuming if the degree if large, one can disable this test. Note however, that the behaviour of Hecke is undefined if a reducible polynomial is used to define a <em>field</em>.</p><p>The named boolean parameter <code>cached</code> can be used to disable caching. Two number fields defined using the same polynomial from the identical polynomial ring and the same (identical) symbol/string will be identical if <code>cached == true</code> and different if <code>cached == false</code>.</p></div></div><p>For frequently used number fields like quadratic fields, cyclotomic fields or radical extensions, the following functions are provided:</p><article class="docstring"><header><a class="docstring-binding" id="cyclotomic_field-Tuple{Int64}" href="#cyclotomic_field-Tuple{Int64}"><code>cyclotomic_field</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cyclotomic_field(n::Int, s::Union{AbstractString, Char, Symbol} = &quot;z_$n&quot;, t = &quot;_\$&quot;; cached = true)</code></pre><p>Return a tuple <span>$R, x$</span> consisting of the parent object <span>$R$</span> and generator <span>$x$</span> of the <span>$n$</span>-th cyclotomic field, <span>$\mathbb{Q}(\zeta_n)$</span>. The supplied string <code>s</code> specifies how the generator of the number field should be printed. If provided, the string <code>t</code> specifies how the generator of the polynomial ring from which the number field is constructed, should be printed. If it is not supplied, a default dollar sign will be used to represent the variable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="quadratic_field-Tuple{ZZRingElem}" href="#quadratic_field-Tuple{ZZRingElem}"><code>quadratic_field</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quadratic_field(d::IntegerUnion) -&gt; AnticNumberField, nf_elem</code></pre><p>Returns the field with defining polynomial <span>$x^2 - d$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; quadratic_field(5)
(Real quadratic field defined by x^2 - 5, sqrt(5))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="wildanger_field-Tuple{Int64, ZZRingElem}" href="#wildanger_field-Tuple{Int64, ZZRingElem}"><code>wildanger_field</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wildanger_field(n::Int, B::ZZRingElem) -&gt; AnticNumberField, nf_elem</code></pre><p>Returns the field with defining polynomial <span>$x^n + \sum_{i=0}^{n-1} (-1)^{n-i}Bx^i$</span>. These fields tend to have non-trivial class groups.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; wildanger_field(3, ZZ(10), &quot;a&quot;)
(Number field over Rational Field with defining polynomial x^3 - 10*x^2 + 10*x - 10, a)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="radical_extension-Tuple{Int64, NumFieldElem}" href="#radical_extension-Tuple{Int64, NumFieldElem}"><code>radical_extension</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radical_extension(n::Int, a::NumFieldElem, s = &quot;_$&quot;;
               check = true, cached = true) -&gt; NumField, NumFieldElem</code></pre><p>Given an element <span>$a$</span> of a number field <span>$K$</span> and an integer <span>$n$</span>, create the simple extension of <span>$K$</span> with the defining polynomial <span>$x^n - a$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; radical_extension(5, QQ(2), &quot;a&quot;)
(Number field over Rational Field with defining polynomial x^5 - 2, a)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rationals_as_number_field-Tuple{}" href="#rationals_as_number_field-Tuple{}"><code>rationals_as_number_field</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rationals_as_number_field() -&gt; AnticNumberField, nf_elem</code></pre><p>Returns the rational numbers as the number field defined by <span>$x - 1$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rationals_as_number_field()
(Number field over Rational Field with defining polynomial x - 1, 1)</code></pre></div></section></article><h2 id="Basic-properties"><a class="docs-heading-anchor" href="#Basic-properties">Basic properties</a><a id="Basic-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="basis-Tuple{SimpleNumField}" href="#basis-Tuple{SimpleNumField}"><code>basis</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis(L::SimpleNumField) -&gt; Vector{NumFieldElem}</code></pre><p>Return the canonical basis of a simple extension <span>$L/K$</span>, that is, the elements <span>$1,a,\dotsc,a^{d - 1}$</span>, where <span>$d$</span> is the degree of <span>$K$</span> and <span>$a$</span> the primitive element.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Qx, x = QQ[&quot;x&quot;];

julia&gt; K, a = number_field(x^2 - 2, &quot;a&quot;);

julia&gt; basis(K)
2-element Vector{nf_elem}:
 1
 a</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="basis-Tuple{NonSimpleNumField}" href="#basis-Tuple{NonSimpleNumField}"><code>basis</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis(L::NonSimpleNumField) -&gt; Vector{NumFieldElem}</code></pre><p>Returns the canonical basis of a non-simple extension <span>$L/K$</span>. If <span>$L = K(a_1,\dotsc,a_n)$</span> where each <span>$a_i$</span> has degree <span>$d_i$</span>, then the basis will be <span>$a_1^{i_1}\dotsm a_d^{i_d}$</span> with <span>$0 \leq i_j \leq d_j - 1$</span> for <span>$1 \leq j \leq n$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Qx, x = QQ[&quot;x&quot;];

julia&gt; K, (a1, a2) = number_field([x^2 - 2, x^2 - 3], &quot;a&quot;);

julia&gt; basis(K)
4-element Vector{NfAbsNSElem}:
 1
 a1
 a2
 a1*a2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="absolute_basis-Tuple{NumField}" href="#absolute_basis-Tuple{NumField}"><code>absolute_basis</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absolute_basis(K::NumField) -&gt; Vector{NumFieldElem}</code></pre><p>Returns an array of elements that form a basis of <span>$K$</span> (as a vector space) over the rationals.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="defining_polynomial-Tuple{SimpleNumField}" href="#defining_polynomial-Tuple{SimpleNumField}"><code>defining_polynomial</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">defining_polynomial(L::SimpleNumField) -&gt; PolyElem</code></pre><p>Given a simple number field <span>$L/K$</span>, constructed as <span>$L = K[x]/(f)$</span>, this function returns <span>$f$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="defining_polynomials-Tuple{NonSimpleNumField}" href="#defining_polynomials-Tuple{NonSimpleNumField}"><code>defining_polynomials</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">defining_polynomials(L::NonSimpleNumField) -&gt; Vector{PolyElem}</code></pre><p>Given a non-simple number field <span>$L/K$</span>, constructed as <span>$L = K[x]/(f_1,\dotsc,f_r)$</span>, return the vector containing the <span>$f_i$</span>&#39;s.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="absolute_primitive_element-Tuple{NumField}" href="#absolute_primitive_element-Tuple{NumField}"><code>absolute_primitive_element</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absolute_primitive_element(K::NumField) -&gt; NumFieldElem</code></pre><p>Given a number field <span>$K$</span>, this function returns an element <span>$\gamma \in K$</span> such that <span>$K = \mathbf{Q}(\gamma)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="component-Tuple{NonSimpleNumField, Int64}" href="#component-Tuple{NonSimpleNumField, Int64}"><code>component</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">component(L::NonSimpleNumField, i::Int) -&gt; SimpleNumField, Map</code></pre><p>Given a non-simple extension <span>$L/K$</span>, this function returns the simple number field corresponding to the <span>$i$</span>-th component of <span>$L$</span> together with its embedding.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="base_field-Tuple{NumField}" href="#base_field-Tuple{NumField}"><code>base_field</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">base_field(L::NumField) -&gt; NumField</code></pre><p>Given a number field <span>$L/K$</span> this function returns the base field <span>$K$</span>. For absolute extensions this returns <span>$\mathbf{Q}$</span>.</p></div></section></article><h2 id="Invariants"><a class="docs-heading-anchor" href="#Invariants">Invariants</a><a id="Invariants-1"></a><a class="docs-heading-anchor-permalink" href="#Invariants" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="degree-Tuple{NumField}" href="#degree-Tuple{NumField}"><code>degree</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree(L::NumField) -&gt; Int</code></pre><p>Given a number field <span>$L/K$</span>, this function returns the degree of <span>$L$</span> over <span>$K$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Qx, x = QQ[&quot;x&quot;];

julia&gt; K, a = number_field(x^2 - 2, &quot;a&quot;);

julia&gt; degree(K)
2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="absolute_degree-Tuple{NumField}" href="#absolute_degree-Tuple{NumField}"><code>absolute_degree</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absolute_degree(L::NumField) -&gt; Int</code></pre><p>Given a number field <span>$L/K$</span>, this function returns the degree of <span>$L$</span> over <span>$\mathbf Q$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="signature-Tuple{NumField}" href="#signature-Tuple{NumField}"><code>signature</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signature(K::NumField)</code></pre><p>Return the signature of the number field of <span>$K$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Qx, x = QQ[&quot;x&quot;];

julia&gt; K, a = number_field(x^2 - 2, &quot;a&quot;);

julia&gt; signature(K)
(2, 0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="unit_group_rank-Tuple{NumField}" href="#unit_group_rank-Tuple{NumField}"><code>unit_group_rank</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unit_group_rank(K::NumField) -&gt; Int</code></pre><p>Return the rank of the unit group of any order of <span>$K$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="class_number-Tuple{AnticNumberField}" href="#class_number-Tuple{AnticNumberField}"><code>class_number</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">class_number(K::AnticNumberField) -&gt; ZZRingElem</code></pre><p>Returns the class number of <span>$K$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="relative_class_number-Tuple{AnticNumberField}" href="#relative_class_number-Tuple{AnticNumberField}"><code>relative_class_number</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relative_class_number(K::AnticNumberField) -&gt; ZZRingElem</code></pre><p>Returns the relative class number of <span>$K$</span>. The field must be a CM-field.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="regulator-Tuple{AnticNumberField}" href="#regulator-Tuple{AnticNumberField}"><code>regulator</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regulator(K::AnticNumberField)</code></pre><p>Computes the regulator of <span>$K$</span>, i.e. the discriminant of the unit lattice for the maximal order of <span>$K$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="discriminant-Tuple{SimpleNumField}" href="#discriminant-Tuple{SimpleNumField}"><code>discriminant</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">discriminant(L::SimpleNumField) -&gt; NumFieldElem</code></pre><p>The discriminant of the defining polynomial of <span>$L$</span>, <em>not</em> the discriminant of the maximal order of <span>$L$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="absolute_discriminant-Tuple{SimpleNumField}" href="#absolute_discriminant-Tuple{SimpleNumField}"><code>absolute_discriminant</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absolute_discriminant(L::SimpleNumField, QQ) -&gt; QQFieldElem</code></pre><p>The absolute discriminant of the defining polynomial of <span>$L$</span>, <em>not</em> the discriminant of the maximal order of <span>$L$</span>. This is the norm of the discriminant times the <span>$d$</span>-th power of the discriminant of the base field, where <span>$d$</span> is the degree of <span>$L$</span>.</p></div></section></article><h2 id="Predicates"><a class="docs-heading-anchor" href="#Predicates">Predicates</a><a id="Predicates-1"></a><a class="docs-heading-anchor-permalink" href="#Predicates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="is_simple-Tuple{NumField}" href="#is_simple-Tuple{NumField}"><code>is_simple</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_simple(L::NumField) -&gt; Bool</code></pre><p>Given a number field <span>$L/K$</span> this function returns whether <span>$L$</span> is simple, that is, whether <span>$L/K$</span> is defined by a univariate polynomial.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_absolute-Tuple{NumField}" href="#is_absolute-Tuple{NumField}"><code>is_absolute</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_absolute(L::NumField) -&gt; Bool</code></pre><p>Returns whether <span>$L$</span> is an absolute extension, that is, whether the base field of <span>$L$</span> is <span>$\mathbf{Q}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_totally_real-Tuple{NumField}" href="#is_totally_real-Tuple{NumField}"><code>is_totally_real</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_totally_real(K::number_field) -&gt; Bool</code></pre><p>Returns true if and only if <span>$K$</span> is totally real, that is, if all roots of the defining polynomial are real.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_totally_complex-Tuple{NumField}" href="#is_totally_complex-Tuple{NumField}"><code>is_totally_complex</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_totally_complex(K::AnticNumberField) -&gt; Bool</code></pre><p>Returns true if and only if <span>$K$</span> is totally complex, that is, if all roots of the defining polynomial are not real.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_cm_field-Tuple{NumField}" href="#is_cm_field-Tuple{NumField}"><code>is_cm_field</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_cm_field(K::AnticNumberField) -&gt; Bool, NfToNfMor</code></pre><p>Given a number field <span>$K$</span>, this function returns true and the complex conjugation if the field is CM, false and the identity otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_kummer_extension-Tuple{SimpleNumField}" href="#is_kummer_extension-Tuple{SimpleNumField}"><code>is_kummer_extension</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_kummer_extension(L::SimpleNumField) -&gt; Bool</code></pre><p>Tests if <span>$L/K$</span> is a Kummer extension, that is, if the defining polynomial is of the form <span>$x^n - b$</span> for some <span>$b \in K$</span> and if <span>$K$</span> contains the <span>$n$</span>-th roots of unity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_radical_extension-Tuple{SimpleNumField}" href="#is_radical_extension-Tuple{SimpleNumField}"><code>is_radical_extension</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_radical_extension(L::SimpleNumField) -&gt; Bool</code></pre><p>Tests if <span>$L/K$</span> is pure, that is, if the defining polynomial is of the form <span>$x^n - b$</span> for some <span>$b \in K$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_linearly_disjoint-Tuple{SimpleNumField, SimpleNumField}" href="#is_linearly_disjoint-Tuple{SimpleNumField, SimpleNumField}"><code>is_linearly_disjoint</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_linearly_disjoint(K::SimpleNumField, L::SimpleNumField) -&gt; Bool</code></pre><p>Given two number fields <span>$K$</span> and <span>$L$</span> with the same base field <span>$k$</span>, this function returns whether <span>$K$</span> and <span>$L$</span> are linear disjoint over <span>$k$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_weakly_ramified-Tuple{AnticNumberField, NfOrdIdl}" href="#is_weakly_ramified-Tuple{AnticNumberField, NfOrdIdl}"><code>is_weakly_ramified</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_weakly_ramified(K::AnticNumberField, P::NfOrdIdl) -&gt; Bool</code></pre><p>Given a prime ideal <span>$P$</span> of a number field <span>$K$</span>, return whether <span>$P$</span> is weakly ramified, that is, whether the second ramification group is trivial.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_tamely_ramified-Tuple{AnticNumberField}" href="#is_tamely_ramified-Tuple{AnticNumberField}"><code>is_tamely_ramified</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_tamely_ramified(K::AnticNumberField) -&gt; Bool</code></pre><p>Returns whether the number field <span>$K$</span> is tamely ramified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_tamely_ramified-Tuple{AnticNumberField, Int64}" href="#is_tamely_ramified-Tuple{AnticNumberField, Int64}"><code>is_tamely_ramified</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_tamely_ramified(O::NfOrd, p::Union{Int, ZZRingElem}) -&gt; Bool</code></pre><p>Returns whether the integer <span>$p$</span> is tamely ramified in <span>$\mathcal O$</span>. It is assumed that <span>$p$</span> is prime.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_abelian-Tuple{NumField}" href="#is_abelian-Tuple{NumField}"><code>is_abelian</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_abelian(L::NumField) -&gt; Bool</code></pre><p>Check if the number field <span>$L/K$</span> is abelian over <span>$K$</span>.  The function is probabilistic and assumes GRH.</p></div></section></article><h3 id="Subfields"><a class="docs-heading-anchor" href="#Subfields">Subfields</a><a id="Subfields-1"></a><a class="docs-heading-anchor-permalink" href="#Subfields" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="is_subfield-Tuple{SimpleNumField, SimpleNumField}" href="#is_subfield-Tuple{SimpleNumField, SimpleNumField}"><code>is_subfield</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_subfield(K::SimpleNumField, L::SimpleNumField) -&gt; Bool, Map</code></pre><p>Return <code>true</code> and an injection from <span>$K$</span> to <span>$L$</span> if <span>$K$</span> is a subfield of <span>$L$</span>. Otherwise the function returns <code>false</code> and a morphism mapping everything to <span>$0$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="subfields-Tuple{SimpleNumField}" href="#subfields-Tuple{SimpleNumField}"><code>subfields</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subfields(L::SimpleNumField) -&gt; Vector{Tuple{NumField, Map}}</code></pre><p>Given a simple extension <span>$L/K$</span>, returns all subfields of <span>$L$</span> containing <span>$K$</span> as tuples <span>$(k, \iota)$</span> consisting of a simple extension <span>$k$</span> and an embedding <span>$\iota k \to K$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="principal_subfields-Tuple{SimpleNumField}" href="#principal_subfields-Tuple{SimpleNumField}"><code>principal_subfields</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">principal_subfields(L::SimpleNumField) -&gt; Vector{Tuple{NumField, Map}}</code></pre><p>Return the principal subfields of <span>$L$</span> as pairs consisting of a subfield <span>$k$</span> and an embedding <span>$k \to L$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="compositum-Tuple{AnticNumberField, AnticNumberField}" href="#compositum-Tuple{AnticNumberField, AnticNumberField}"><code>compositum</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compositum(K::AnticNumberField, L::AnticNumberField) -&gt; AnticNumberField, Map, Map</code></pre><p>Assuming <span>$L$</span> is normal (which is not checked), compute the compositum <span>$C$</span> of the 2 fields together with the embedding of <span>$K \to C$</span> and <span>$L \to C$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="embedding-Tuple{NumField, NumField}" href="#embedding-Tuple{NumField, NumField}"><code>embedding</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embedding(k::NumField, K::NumField) -&gt; Map</code></pre><p>Assuming <span>$k$</span> is known to be a subfield of <span>$K$</span>, return the embedding map.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="normal_closure-Tuple{AnticNumberField}" href="#normal_closure-Tuple{AnticNumberField}"><code>normal_closure</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normal_closure(K::AnticNumberField) -&gt; AnticNumberField, NfToNfMor</code></pre><p>The normal closure of <span>$K$</span> together with the embedding map.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="relative_simple_extension-Tuple{NumField, NumField}" href="#relative_simple_extension-Tuple{NumField, NumField}"><code>relative_simple_extension</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relative_simple_extension(K::NumField, k::NumField) -&gt; NfRel</code></pre><p>Given two fields <span>$K\supset k$</span>, it returns <span>$K$</span> as a simple relative extension <span>$L$</span> of <span>$k$</span> and an isomorphism <span>$L \to K$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_subfield_normal-Tuple{AnticNumberField, AnticNumberField}" href="#is_subfield_normal-Tuple{AnticNumberField, AnticNumberField}"><code>is_subfield_normal</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">  is_subfield_normal(K::AnticNumberField, L::AnticNumberField) -&gt; Bool, NfToNfMor</code></pre><p>Returns <code>true</code> and an injection from <span>$K$</span> to <span>$L$</span> if <span>$K$</span> is a subfield of <span>$L$</span>. Otherwise the function returns &quot;false&quot; and a morphism mapping everything to 0.</p><p>This function assumes that <span>$K$</span> is normal.</p></div></section></article><h2 id="Conversion"><a class="docs-heading-anchor" href="#Conversion">Conversion</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="simplify-Tuple{AnticNumberField}" href="#simplify-Tuple{AnticNumberField}"><code>simplify</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify(K::AnticNumberField; canonical::Bool = false) -&gt; AnticNumberField, NfToNfMor</code></pre><p>Tries to find an isomorphic field <span>$L$</span> given by a &quot;simpler&quot; defining polynomial. By default, &quot;simple&quot; is defined to be of smaller index, testing is done only using a LLL-basis of the maximal order.</p><p>If <code>canonical</code> is set to <code>true</code>, then a canonical defining polynomial is found, where canonical is using the definition of PARI&#39;s <code>polredabs</code>, which is described in http://beta.lmfdb.org/knowledge/show/nf.polredabs.</p><p>Both versions require a LLL reduced basis for the maximal order.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="absolute_simple_field-Tuple{NumField}" href="#absolute_simple_field-Tuple{NumField}"><code>absolute_simple_field</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absolute_simple_field(K::NumField) -&gt; NumField, Map</code></pre><p>Given a number field <span>$K$</span>, this function returns an absolute simple number field <span>$M/\mathbf{Q}$</span> together with a <span>$\mathbf{Q}$</span>-linear isomorphism <span>$M \to K$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="simple_extension-Tuple{NonSimpleNumField}" href="#simple_extension-Tuple{NonSimpleNumField}"><code>simple_extension</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simple_extension(L::NonSimpleNumField) -&gt; SimpleNumField, Map</code></pre><p>Given a non-simple extension <span>$L/K$</span>, this function computes a simple extension <span>$M/K$</span> and a <span>$K$</span>-linear isomorphism <span>$M \to L$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="simplified_simple_extension-Tuple{NonSimpleNumField}" href="#simplified_simple_extension-Tuple{NonSimpleNumField}"><code>simplified_simple_extension</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplified_simple_extension(L::NonSimpleNumField) -&gt; SimpleNumField, Map</code></pre><p>Given a non-simple extension <span>$L/K$</span>, this function returns an isomorphic simple number field with a &quot;small&quot; defining equation together with the isomorphism.</p></div></section></article><h2 id="Morphisms"><a class="docs-heading-anchor" href="#Morphisms">Morphisms</a><a id="Morphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Morphisms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="is_isomorphic-Tuple{SimpleNumField, SimpleNumField}" href="#is_isomorphic-Tuple{SimpleNumField, SimpleNumField}"><code>is_isomorphic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_isomorphic(K::SimpleNumField, L::SimpleNumField) -&gt; Bool</code></pre><p>Return <code>true</code> if <span>$K$</span> and <span>$L$</span> are isomorphic, otherwise <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_isomorphic_with_map-Tuple{SimpleNumField, SimpleNumField}" href="#is_isomorphic_with_map-Tuple{SimpleNumField, SimpleNumField}"><code>is_isomorphic_with_map</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_isomorphic_with_map(K::SimpleNumField, L::SimpleNumField) -&gt; Bool, Map</code></pre><p>Return <code>true</code> and an isomorphism from <span>$K$</span> to <span>$L$</span> if <span>$K$</span> and <span>$L$</span> are isomorphic. Otherwise the function returns <code>false</code> and a morphism mapping everything to <span>$0$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_involution-Tuple{NfToNfMor}" href="#is_involution-Tuple{NfToNfMor}"><code>is_involution</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_involution(f::NfToNfMor) -&gt; Bool</code></pre><p>Returns true if <span>$f$</span> is an involution, i.e. if <span>$f^2$</span> is the identity, false otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="fixed_field-Tuple{Hecke.NumFieldMor}" href="#fixed_field-Tuple{Hecke.NumFieldMor}"><code>fixed_field</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fixed_field(K::SimpleNumField,
            sigma::Map;
            simplify::Bool = true) -&gt; number_field, NfToNfMor</code></pre><p>Given a number field <span>$K$</span> and an automorphism <span>$\sigma$</span> of <span>$K$</span>, this function returns the fixed field of <span>$\sigma$</span> as a pair <span>$(L, i)$</span> consisting of a number field <span>$L$</span> and an embedding of <span>$L$</span> into <span>$K$</span>.</p><p>By default, the function tries to find a small defining polynomial of <span>$L$</span>. This can be disabled by setting <code>simplify = false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="automorphism_list-Tuple{NumField}" href="#automorphism_list-Tuple{NumField}"><code>automorphism_list</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">automorphism_list(L::NumField) -&gt; Vector{NumFieldMor}</code></pre><p>Given a number field <span>$L/K$</span>, return a list of all <span>$K$</span>-automorphisms of <span>$L$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="automorphism_group-Tuple{AnticNumberField}" href="#automorphism_group-Tuple{AnticNumberField}"><code>automorphism_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">automorphism_group(K::NumField) -&gt; GenGrp, GrpGenToNfMorSet</code></pre><p>Given a number field <span>$K$</span>, this function returns a group <span>$G$</span> and a map from <span>$G$</span> to the automorphisms of <span>$K$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="complex_conjugation-Tuple{AnticNumberField}" href="#complex_conjugation-Tuple{AnticNumberField}"><code>complex_conjugation</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complex_conjugation(K::AnticNumberField)</code></pre><p>Given a totally complex normal number field, this function returns an automorphism which is the restriction of complex conjugation at one embedding.</p></div></section></article><h2 id="Galois-theory"><a class="docs-heading-anchor" href="#Galois-theory">Galois theory</a><a id="Galois-theory-1"></a><a class="docs-heading-anchor-permalink" href="#Galois-theory" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="normal_basis-Tuple{NumField}" href="#normal_basis-Tuple{NumField}"><code>normal_basis</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normal_basis(L::NumField) -&gt; NumFieldElem</code></pre><p>Given a normal number field <span>$L/K$</span>, this function returns an element <span>$a$</span> of <span>$L$</span>, such that the orbit of <span>$a$</span> under the Galois group of <span>$L/K$</span> is an <span>$K$</span>-basis of <span>$L$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="decomposition_group-Tuple{AnticNumberField, NfOrdIdl, Map}" href="#decomposition_group-Tuple{AnticNumberField, NfOrdIdl, Map}"><code>decomposition_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decomposition_group(K::AnticNumberField, P::NfOrdIdl, m::Map)
                                              -&gt; Grp, GrpToGrp</code></pre><p>Given a prime ideal <span>$P$</span> of a number field <span>$K$</span> and a map <code>m</code> return from <code>automorphism_group(K)</code>, return the decomposition group of <span>$P$</span> as a subgroup of the domain of <code>m</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ramification_group-Tuple{AnticNumberField, NfOrdIdl, Int64, Map}" href="#ramification_group-Tuple{AnticNumberField, NfOrdIdl, Int64, Map}"><code>ramification_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ramification_group(K::AnticNumberField, P::NfOrdIdl, m::Map) -&gt; Grp, GrpToGrp</code></pre><p>Given a prime ideal <span>$P$</span> of a number field <span>$K$</span> and a map <code>m</code> return from <code>automorphism_group(K)</code>, return the ramification group of <span>$P$</span> as a subgroup of the domain of <code>m</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="inertia_subgroup-Tuple{AnticNumberField, NfOrdIdl, Map}" href="#inertia_subgroup-Tuple{AnticNumberField, NfOrdIdl, Map}"><code>inertia_subgroup</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inertia_subgroup(K::AnticNumberField, P::NfOrdIdl, m::Map) -&gt; Grp, GrpToGrp</code></pre><p>Given a prime ideal <span>$P$</span> of a number field <span>$K$</span> and a map <code>m</code> return from <code>automorphism_group(K)</code>, return the inertia subgroup of <span>$P$</span> as a subgroup of the domain of <code>m</code>.</p></div></section></article><h2 id="Infinite-places"><a class="docs-heading-anchor" href="#Infinite-places">Infinite places</a><a id="Infinite-places-1"></a><a class="docs-heading-anchor-permalink" href="#Infinite-places" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="infinite_places-Tuple{NumField}" href="#infinite_places-Tuple{NumField}"><code>infinite_places</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">infinite_places(K::NumField) -&gt; Vector{InfPlc}</code></pre><p>Return all infinite places of the number field.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; K,  = quadratic_field(5);

julia&gt; infinite_places(K)
2-element Vector{InfPlc{AnticNumberField, Hecke.NumFieldEmbNfAbs}}:
 Infinite place corresponding to (Embedding corresponding to â -2.24)
 Infinite place corresponding to (Embedding corresponding to â 2.24)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="real_places-Tuple{AnticNumberField}" href="#real_places-Tuple{AnticNumberField}"><code>real_places</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real_places(K::NumField) -&gt; Vector{InfPlc}</code></pre><p>Return all infinite real places of the number field.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; K,  = quadratic_field(5);

julia&gt; infinite_places(K)
2-element Vector{InfPlc{AnticNumberField, Hecke.NumFieldEmbNfAbs}}:
 Infinite place corresponding to (Embedding corresponding to â -2.24)
 Infinite place corresponding to (Embedding corresponding to â 2.24)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="complex_places-Tuple{AnticNumberField}" href="#complex_places-Tuple{AnticNumberField}"><code>complex_places</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complex_places(K::NumField) -&gt; Vector{InfPlc}</code></pre><p>Return all infinite complex places of <span>$K$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; K,  = quadratic_field(-5);

julia&gt; complex_places(K)
1-element Vector{InfPlc{AnticNumberField, Hecke.NumFieldEmbNfAbs}}:
 Infinite place corresponding to (Embedding corresponding to â 0.00 + 2.24 * i)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="isreal-Tuple{Plc}" href="#isreal-Tuple{Plc}"><code>isreal</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isreal(P::Plc)</code></pre><p>Return whether the embedding into <span>$\mathbf{C}$</span> defined by <span>$P$</span> is real or not.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_complex-Tuple{Plc}" href="#is_complex-Tuple{Plc}"><code>is_complex</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_complex(P::Plc) -&gt; Bool</code></pre><p>Return whether the embedding into <span>$\mathbf{C}$</span> defined by <span>$P$</span> is complex or not.</p></div></section></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="norm_equation-Tuple{AnticNumberField, Any}" href="#norm_equation-Tuple{AnticNumberField, Any}"><code>norm_equation</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm_equation(K::AnticNumerField, a) -&gt; nf_elem</code></pre><p>For <span>$a$</span> an integer or rational, try to find <span>$T \in K$</span> s.th. <span>$N(T) = a$</span>. Raises an error if unsuccessful.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="lorenz_module-Tuple{AnticNumberField, Int64}" href="#lorenz_module-Tuple{AnticNumberField, Int64}"><code>lorenz_module</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lorenz_module(k::AnticNumberField, n::Int) -&gt; NfOrdIdl</code></pre><p>Finds an ideal <span>$A$</span> s.th. for all positive units <span>$e = 1 \bmod A$</span> we have that <span>$e$</span> is an <span>$n$</span>-th power. Uses Lorenz, number theory, 9.3.1. If <code>containing</code> is set, it has to be an integral ideal. The resulting ideal will be a multiple of this.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="kummer_failure-Tuple{nf_elem, Int64, Int64}" href="#kummer_failure-Tuple{nf_elem, Int64, Int64}"><code>kummer_failure</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kummer_failure(x::nf_elem, M::Int, N::Int) -&gt; Int</code></pre><p>Computes the quotient of <span>$N$</span> and <span>$[K(\zeta_M, \sqrt[N](x))\colon K(\zeta_M)]$</span>, where <span>$K$</span> is the field containing <span>$x$</span> and <span>$N$</span> divides <span>$M$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_defining_polynomial_nice-Tuple{AnticNumberField}" href="#is_defining_polynomial_nice-Tuple{AnticNumberField}"><code>is_defining_polynomial_nice</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_defining_polynomial_nice(K::AnticNumberField)</code></pre><p>Tests if the defining polynomial of <span>$K$</span> is integral and monic.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">Â« Introduction</a><a class="docs-footer-nextpage" href="../elements/">Element operations Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 18 April 2023 06:47">Tuesday 18 April 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
