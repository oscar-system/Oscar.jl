<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sparse linear algebra Â· Oscar.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Oscar.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../LinearAlgebra/intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Sparse linear algebra</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Sparse-rows"><span>Sparse rows</span></a></li><li><a class="tocitem" href="#Sparse-matrices"><span>Sparse matrices</span></a></li></ul></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../orders/orders/">Orders</a></li><li><a class="tocitem" href="../../orders/elements/">Elements</a></li><li><a class="tocitem" href="../../orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../../Experimental/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li></ul></li><li><a class="tocitem" href="../../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/homological_algebra/">Homological Algebra</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">GrÃ¶bner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/groebner_bases/">GrÃ¶bner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/groebner_bases_integers/">GrÃ¶bner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Toric Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/ToricSchemes/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/ToricSchemes/NormalToricSchemes/">Normal Toric Schemes</a></li><li><a class="tocitem" href="../../../Experimental/ToricSchemes/AffineToricSchemes/">Affine Toric Schemes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/TropicalGeometry/curve/">Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/K3Surfaces/">Automorphism Groups of  K3 surfaces</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/SurfacesP4/">Nongeneral Type Surfaces in <span>$\mathbb P^4$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-8" type="checkbox"/><label class="tocitem" for="menuitem-11-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Miscellaneous/miscellaneous/">Some Special Ideals</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Noncommutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li><li><a class="tocitem" href="../../../Combinatorics/partitions/">Partitions</a></li><li><a class="tocitem" href="../../../Combinatorics/tableaux/">Tableaux</a></li><li><a class="tocitem" href="../../../Combinatorics/schur_polynomials/">Schur polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../../references/">References</a></li><li><a class="tocitem" href="../../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-7" type="checkbox"/><label class="tocitem" for="menuitem-17-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-18" type="checkbox"/><label class="tocitem" for="menuitem-18"><span class="docs-label">Experimental</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/intro/">Adding new projects to experimental</a></li><li><input class="collapse-toggle" id="menuitem-18-2" type="checkbox"/><label class="tocitem" for="menuitem-18-2"><span class="docs-label">F-Theory Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/FTheoryTools/introduction/">Welcome to FTheoryTools</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/weierstrass/">Global Weierstrass models</a></li><li><a class="tocitem" href="../../../Experimental/FTheoryTools/tate/">Global Tate models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-18-3" type="checkbox"/><label class="tocitem" for="menuitem-18-3"><span class="docs-label">Linear Quotients</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Experimental/LinearQuotients/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Experimental/LinearQuotients/linear_quotients/">Construction and basic functionality</a></li><li><a class="tocitem" href="../../../Experimental/LinearQuotients/cox_rings/">Cox rings</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Linear Algebra</a></li><li class="is-active"><a href>Sparse linear algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sparse linear algebra</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/Hecke/sparse/intro.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Sparse-linear-algebra"><a class="docs-heading-anchor" href="#Sparse-linear-algebra">Sparse linear algebra</a><a id="Sparse-linear-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-linear-algebra" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>This chapter deals with sparse linear algebra over commutative rings and fields.</p><p>Sparse linear algebra, that is, linear algebra with sparse matrices, plays an important role in various algorithms in algebraic number theory. For example, it is one of the key ingredients in the computation of class groups and discrete logarithms using index calculus methods.</p><h2 id="Sparse-rows"><a class="docs-heading-anchor" href="#Sparse-rows">Sparse rows</a><a id="Sparse-rows-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-rows" title="Permalink"></a></h2><p>Building blocks for sparse matrices are sparse rows, which are modelled by objects of type \texttt{SRow}. More precisely, the type is of parametrized form objects of type <code>SRow</code>. More precisely, the type is of parametrized form <code>SRow{T}</code>, where <code>T</code> is the element type of the base ring <span>$R$</span>. For example, <code>SRow{ZZRingElem}</code> is the type for sparse rows over the integers.</p><p>It is important to note that sparse rows do not have a fixed number of columns, that is, they represent elements of <span>$\{ (x_i)_i \in R^{\mathbb{N}} \mid x_i = 0 \text{ for almost all }i\}$</span>. In particular any two sparse rows over the same base ring can be added.</p><h3 id="Creation"><a class="docs-heading-anchor" href="#Creation">Creation</a><a id="Creation-1"></a><a class="docs-heading-anchor-permalink" href="#Creation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="sparse_row-Tuple{ZZRing, Vector{Tuple{Int64, ZZRingElem}}}" href="#sparse_row-Tuple{ZZRing, Vector{Tuple{Int64, ZZRingElem}}}"><code>sparse_row</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparse_row(R::Ring, J::Vector{Tuple{Int, T}}) -&gt; SRow{T}</code></pre><p>Constructs the sparse row <span>$(a_i)_i$</span> with <span>$a_{i_j} = x_j$</span>, where <span>$J = (i_j, x_j)_j$</span>. The elements <span>$x_i$</span> must belong to the ring <span>$R$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="sparse_row-Tuple{ZZRing, Vector{Tuple{Int64, Int64}}}" href="#sparse_row-Tuple{ZZRing, Vector{Tuple{Int64, Int64}}}"><code>sparse_row</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparse_row(R::Ring, J::Vector{Tuple{Int, T}}) -&gt; SRow{T}</code></pre><p>Constructs the sparse row <span>$(a_i)_i$</span> with <span>$a_{i_j} = x_j$</span>, where <span>$J = (i_j, x_j)_j$</span>. The elements <span>$x_i$</span> must belong to the ring <span>$R$</span>.</p></div></section><section><div><pre><code class="nohighlight hljs">sparse_row(R::Ring, J::Vector{Tuple{Int, Int}}) -&gt; SRow</code></pre><p>Constructs the sparse row <span>$(a_i)_i$</span> over <span>$R$</span> with <span>$a_{i_j} = x_j$</span>, where <span>$J = (i_j, x_j)_j$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="sparse_row-Tuple{ZZRing, Vector{Int64}, Vector{ZZRingElem}}" href="#sparse_row-Tuple{ZZRing, Vector{Int64}, Vector{ZZRingElem}}"><code>sparse_row</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparse_row(R::Ring, J::Vector{Int}, V::Vector{T}) -&gt; SRow{T}</code></pre><p>Constructs the sparse row <span>$(a_i)_i$</span> over <span>$R$</span> with <span>$a_{i_j} = x_j$</span>, where <span>$J = (i_j)_j$</span> and <span>$V = (x_j)_j$</span>.</p></div></section></article><h3 id="Basic-operations"><a class="docs-heading-anchor" href="#Basic-operations">Basic operations</a><a id="Basic-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-operations" title="Permalink"></a></h3><p>Rows support the usual operations:</p><ul><li><code>+</code>, <code>-</code>, <code>==</code></li><li>multiplication by scalars</li><li><code>div</code>, <code>divexact</code></li></ul><article class="docstring"><header><a class="docstring-binding" id="getindex-Tuple{SRow{ZZRingElem, S} where S, Int64}" href="#getindex-Tuple{SRow{ZZRingElem, S} where S, Int64}"><code>getindex</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(A::SRow, j::Int) -&gt; RingElem</code></pre><p>Given a sparse row <span>$(a_i)_{i}$</span> and an index <span>$j$</span> return <span>$a_j$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="add_scaled_row-Tuple{SRow{ZZRingElem, S} where S, SRow{ZZRingElem, S} where S, ZZRingElem}" href="#add_scaled_row-Tuple{SRow{ZZRingElem, S} where S, SRow{ZZRingElem, S} where S, ZZRingElem}"><code>add_scaled_row</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_scaled_row(A::SRow{T}, B::SRow{T}, c::T) -&gt; SRow{T}</code></pre><p>Returns the row <span>$c A + B$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="add_scaled_row-Union{Tuple{T}, Tuple{SRow{T, S} where S, SRow{T, S} where S, T}} where T" href="#add_scaled_row-Union{Tuple{T}, Tuple{SRow{T, S} where S, SRow{T, S} where S, T}} where T"><code>add_scaled_row</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_scaled_row(A::SRow{T}, B::SRow{T}, c::T) -&gt; SRow{T}</code></pre><p>Returns the row <span>$c A + B$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="transform_row-Union{Tuple{T}, Tuple{SRow{T, S} where S, SRow{T, S} where S, T, T, T, T}} where T" href="#transform_row-Union{Tuple{T}, Tuple{SRow{T, S} where S, SRow{T, S} where S, T, T, T, T}} where T"><code>transform_row</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform_row(A::SRow{T}, B::SRow{T}, i::Int, j::Int, a::T, b::T, c::T, d::T)</code></pre><p>Returns the tuple <span>$(aA + bB, cA + dB)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="length-Tuple{SRow}" href="#length-Tuple{SRow}"><code>length</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(A::SRow)</code></pre><p>Returns the number of nonzero entries of <span>$A$</span>.</p></div></section></article><h3 id="Change-of-base-ring"><a class="docs-heading-anchor" href="#Change-of-base-ring">Change of base ring</a><a id="Change-of-base-ring-1"></a><a class="docs-heading-anchor-permalink" href="#Change-of-base-ring" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="change_base_ring-Tuple{ZZRing, SRow{ZZRingElem, S} where S}" href="#change_base_ring-Tuple{ZZRing, SRow{ZZRingElem, S} where S}"><code>change_base_ring</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_base_ring(R::Ring, A::SRow) -&gt; SRow</code></pre><p>Create a new sparse row by coercing all elements into the ring <span>$R$</span>.</p></div></section></article><h3 id="Maximum,-minimum-and-2-norm"><a class="docs-heading-anchor" href="#Maximum,-minimum-and-2-norm">Maximum, minimum and 2-norm</a><a id="Maximum,-minimum-and-2-norm-1"></a><a class="docs-heading-anchor-permalink" href="#Maximum,-minimum-and-2-norm" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="maximum-Tuple{SRow}" href="#maximum-Tuple{SRow}"><code>maximum</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maximum(A::SRow{T}) -&gt; T</code></pre><p>Returns the largest entry of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="maximum-Tuple{SRow{ZZRingElem, S} where S}" href="#maximum-Tuple{SRow{ZZRingElem, S} where S}"><code>maximum</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maximum(A::SRow{T}) -&gt; T</code></pre><p>Returns the largest entry of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="minimum-Tuple{SRow{ZZRingElem, S} where S}" href="#minimum-Tuple{SRow{ZZRingElem, S} where S}"><code>minimum</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum(A::SRow{T}) -&gt; T</code></pre><p>Returns the smallest entry of <span>$A$</span>.</p></div></section><section><div><pre><code class="language-julia hljs">  minimum(A::NfRelOrdIdl) -&gt; NfOrdIdl
  minimum(A::NfRelOrdIdl) -&gt; NfRelOrdIdl</code></pre><p>Returns the ideal <span>$A \cap O$</span> where <span>$O$</span> is the maximal order of the coefficient ideals of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="minimum-Tuple{SRow}" href="#minimum-Tuple{SRow}"><code>minimum</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum(A::SRow{T}) -&gt; T</code></pre><p>Returns the smallest entry of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="norm2-Tuple{SRow{ZZRingElem, S} where S}" href="#norm2-Tuple{SRow{ZZRingElem, S} where S}"><code>norm2</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm2(A::SRow{T} -&gt; T</code></pre><p>Returns <span>$A \cdot A^t$</span>.</p></div></section></article><h3 id="Functionality-for-integral-sparse-rows"><a class="docs-heading-anchor" href="#Functionality-for-integral-sparse-rows">Functionality for integral sparse rows</a><a id="Functionality-for-integral-sparse-rows-1"></a><a class="docs-heading-anchor-permalink" href="#Functionality-for-integral-sparse-rows" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="lift-Tuple{SRow{zzModRingElem, S} where S}" href="#lift-Tuple{SRow{zzModRingElem, S} where S}"><code>lift</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lift(A::SRow{zzModRingElem}) -&gt; SRow{ZZRingElem}</code></pre><p>Return the sparse row obtained by lifting all entries in <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="mod!-Tuple{SRow{ZZRingElem, S} where S, ZZRingElem}" href="#mod!-Tuple{SRow{ZZRingElem, S} where S, ZZRingElem}"><code>mod!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mod!(A::SRow{ZZRingElem}, n::ZZRingElem) -&gt; SRow{ZZRingElem}</code></pre><p>Inplace reduction of all entries of <span>$A$</span> modulo <span>$n$</span> to the positive residue system.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="mod_sym!-Tuple{SRow{ZZRingElem, S} where S, ZZRingElem}" href="#mod_sym!-Tuple{SRow{ZZRingElem, S} where S, ZZRingElem}"><code>mod_sym!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mod_sym!(A::SRow{ZZRingElem}, n::ZZRingElem) -&gt; SRow{ZZRingElem}</code></pre><p>Inplace reduction of all entries of <span>$A$</span> modulo <span>$n$</span> to the symmetric residue system.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="mod_sym!-Tuple{SRow{ZZRingElem, S} where S, Integer}" href="#mod_sym!-Tuple{SRow{ZZRingElem, S} where S, Integer}"><code>mod_sym!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mod_sym!(A::SRow{ZZRingElem}, n::Integer) -&gt; SRow{ZZRingElem}</code></pre><p>Inplace reduction of all entries of <span>$A$</span> modulo <span>$n$</span> to the symmetric residue system.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="maximum-Tuple{typeof(abs), SRow{ZZRingElem, S} where S}" href="#maximum-Tuple{typeof(abs), SRow{ZZRingElem, S} where S}"><code>maximum</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maximum(abs, A::SRow{ZZRingElem}) -&gt; ZZRingElem</code></pre><p>Returns the largest, in absolute value, entry of <span>$A$</span>.</p></div></section></article><h2 id="Sparse-matrices"><a class="docs-heading-anchor" href="#Sparse-matrices">Sparse matrices</a><a id="Sparse-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-matrices" title="Permalink"></a></h2><p>Let <span>$R$</span> be a commutative ring. Sparse matrices with base ring <span>$R$</span> are modelled by objects of type <code>SMat</code>. More precisely, the type is of parametrized form <code>SRow{T}</code>, where <code>T</code> is the element type of the base ring. For example, <code>SMat{ZZRingElem}</code> is the type for sparse matrices over the integers.</p><p>In contrast to sparse rows, sparse matrices have a fixed number of rows and columns, that is, they represent elements of the matrices space <span>$\mathrm{Mat}_{n\times m}(R)$</span>. Internally, sparse matrices are implemented as an array of sparse rows. As a consequence, unlike their dense counterparts, sparse matrices have a mutable number of rows and it is very performant to add additional rows.</p><h3 id="Construction"><a class="docs-heading-anchor" href="#Construction">Construction</a><a id="Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Construction" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="sparse_matrix-Tuple{Ring}" href="#sparse_matrix-Tuple{Ring}"><code>sparse_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparse_matrix(R::Ring) -&gt; SMat</code></pre><p>Return an empty sparse matrix with base ring <span>$R$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="sparse_matrix-Tuple{Ring, Int64, Int64}" href="#sparse_matrix-Tuple{Ring, Int64, Int64}"><code>sparse_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparse_matrix(R::Ring, n::Int, m::Int) -&gt; SMat</code></pre><p>Return a sparse <span>$n$</span> times <span>$m$</span> zero matrix over <span>$R$</span>.</p></div></section></article><p>Sparse matrices can also be created from dense matrices as well as from julia arrays:</p><article class="docstring"><header><a class="docstring-binding" id="sparse_matrix-Tuple{MatElem}" href="#sparse_matrix-Tuple{MatElem}"><code>sparse_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparse_matrix(A::MatElem; keepzrows::Bool = true)</code></pre><p>Constructs the sparse matrix corresponding to the dense matrix <span>$A$</span>. If <code>keepzrows</code> is false, then the constructor will drop any zero row of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="sparse_matrix-Union{Tuple{Matrix{T}}, Tuple{T}} where T" href="#sparse_matrix-Union{Tuple{Matrix{T}}, Tuple{T}} where T"><code>sparse_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparse_matrix(R::Ring, A::Matrix{T}) -&gt; SMat</code></pre><p>Constructs the sparse matrix over <span>$R$</span> corresponding to <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="sparse_matrix-Union{Tuple{T}, Tuple{Ring, Matrix{T}}} where T" href="#sparse_matrix-Union{Tuple{T}, Tuple{Ring, Matrix{T}}} where T"><code>sparse_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparse_matrix(R::Ring, A::Matrix{T}) -&gt; SMat</code></pre><p>Constructs the sparse matrix over <span>$R$</span> corresponding to <span>$A$</span>.</p></div></section></article><p>The normal way however, is to add rows:</p><article class="docstring"><header><a class="docstring-binding" id="push!-Union{Tuple{T}, Tuple{SMat{T, S} where S, SRow{T, S} where S}} where T" href="#push!-Union{Tuple{T}, Tuple{SMat{T, S} where S, SRow{T, S} where S}} where T"><code>push!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">push!(A::SMat{T}, B::SRow{T}) where T</code></pre><p>Appends the sparse row <code>B</code> to <code>A</code>.</p></div></section></article><p>Sparse matrices can also be concatenated to form larger ones:</p><article class="docstring"><header><a class="docstring-binding" id="vcat!-Union{Tuple{T}, Tuple{SMat{T, S} where S, SMat{T, S} where S}} where T" href="#vcat!-Union{Tuple{T}, Tuple{SMat{T, S} where S, SMat{T, S} where S}} where T"><code>vcat!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vcat!(A::SMat, B::SMat) -&gt; SMat</code></pre><p>Vertically joins <span>$A$</span> and <span>$B$</span> inplace, that is, the rows of <span>$B$</span> are appended to <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="vcat-Union{Tuple{T}, Tuple{SMat{T, S} where S, SMat{T, S} where S}} where T" href="#vcat-Union{Tuple{T}, Tuple{SMat{T, S} where S, SMat{T, S} where S}} where T"><code>vcat</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vcat(A::SMat, B::SMat) -&gt; SMat</code></pre><p>Vertically joins <span>$A$</span> and <span>$B$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="hcat!-Union{Tuple{T}, Tuple{SMat{T, S} where S, SMat{T, S} where S}} where T" href="#hcat!-Union{Tuple{T}, Tuple{SMat{T, S} where S, SMat{T, S} where S}} where T"><code>hcat!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hcat!(A::SMat, B::SMat) -&gt; SMat</code></pre><p>Horizontally concatenates <span>$A$</span> and <span>$B$</span>, inplace, changing <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="hcat-Union{Tuple{T}, Tuple{SMat{T, S} where S, SMat{T, S} where S}} where T" href="#hcat-Union{Tuple{T}, Tuple{SMat{T, S} where S, SMat{T, S} where S}} where T"><code>hcat</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hcat(A::SMat, B::SMat) -&gt; SMat</code></pre><p>Horizontally concatenates <span>$A$</span> and <span>$B$</span>.</p></div></section></article><p>(Normal julia <span>$cat$</span> is also supported)</p><p>There are special constructors:</p><article class="docstring"><header><a class="docstring-binding" id="identity_matrix-Tuple{Type{SMat}, Ring, Int64}" href="#identity_matrix-Tuple{Type{SMat}, Ring, Int64}"><code>identity_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">identity_matrix(::Type{SMat}, R::Ring, n::Int)</code></pre><p>Return a sparse <span>$n$</span> times <span>$n$</span> identity matrix over <span>$R$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="zero_matrix-Tuple{Type{SMat}, Ring, Int64}" href="#zero_matrix-Tuple{Type{SMat}, Ring, Int64}"><code>zero_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_matrix(::Type{SMat}, R::Ring, n::Int)</code></pre><p>Return a sparse <span>$n$</span> times <span>$n$</span> zero matrix over <span>$R$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="zero_matrix-Tuple{Type{SMat}, Ring, Int64, Int64}" href="#zero_matrix-Tuple{Type{SMat}, Ring, Int64, Int64}"><code>zero_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_matrix(::Type{SMat}, R::Ring, n::Int, m::Int)</code></pre><p>Return a sparse <span>$n$</span> times <span>$m$</span> zero matrix over <span>$R$</span>.</p></div></section></article><p>Slices:</p><article class="docstring"><header><a class="docstring-binding" id="sub-Union{Tuple{T}, Tuple{SMat{T, S} where S, UnitRange, UnitRange}} where T" href="#sub-Union{Tuple{T}, Tuple{SMat{T, S} where S, UnitRange, UnitRange}} where T"><code>sub</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sub(A::SMat, r::UnitRange, c::UnitRange) -&gt; SMat</code></pre><p>Return the submatrix of <span>$A$</span>, where the rows correspond to <span>$r$</span> and the columns correspond to <span>$c$</span>.</p></div></section></article><p>Transpose:</p><article class="docstring"><header><a class="docstring-binding" id="transpose-Tuple{SMat}" href="#transpose-Tuple{SMat}"><code>transpose</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transpose(A::SMat) -&gt; SMat</code></pre><p>Returns the transpose of <span>$A$</span>.</p></div></section></article><h3 id="Elementary-Properties"><a class="docs-heading-anchor" href="#Elementary-Properties">Elementary Properties</a><a id="Elementary-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Elementary-Properties" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="sparsity-Tuple{SMat}" href="#sparsity-Tuple{SMat}"><code>sparsity</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparsity(A::SMat) -&gt; Float64</code></pre><p>Return the sparsity of <code>A</code>, that is, the number of zero-valued elements divided by the number of all elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="density-Tuple{SMat}" href="#density-Tuple{SMat}"><code>density</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">density(A::SMat) -&gt; Float64</code></pre><p>Return the density of <code>A</code>, that is, the number of nonzero-valued elements divided by the number of all elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="nnz-Tuple{SMat}" href="#nnz-Tuple{SMat}"><code>nnz</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nnz(A::SMat) -&gt; Int</code></pre><p>Return the number of non-zero entries of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="nrows-Tuple{SMat}" href="#nrows-Tuple{SMat}"><code>nrows</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nrows(A::SMat) -&gt; Int</code></pre><p>Return the number of rows of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ncols-Tuple{SMat}" href="#ncols-Tuple{SMat}"><code>ncols</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ncols(A::SMat) -&gt; Int</code></pre><p>Return the number of columns of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="isone-Tuple{SMat}" href="#isone-Tuple{SMat}"><code>isone</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isone(A::SMat)</code></pre><p>Tests if <span>$A$</span> is an identity matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="iszero-Tuple{SMat}" href="#iszero-Tuple{SMat}"><code>iszero</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iszero(A::SMat)</code></pre><p>Tests if <span>$A$</span> is a zero matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="isupper_triangular-Tuple{SMat}" href="#isupper_triangular-Tuple{SMat}"><code>isupper_triangular</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isupper_triangular(A::SMat)</code></pre><p>Returns true if and only if <span>$A$</span> is upper (right) triangular.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="maximum-Tuple{SMat}" href="#maximum-Tuple{SMat}"><code>maximum</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maximum(A::SMat{T}) -&gt; T</code></pre><p>Finds the largest entry of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="minimum-Tuple{SMat}" href="#minimum-Tuple{SMat}"><code>minimum</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum(A::SMat{T}) -&gt; T</code></pre><p>Finds the smallest entry of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="maximum-Tuple{typeof(abs), SMat{ZZRingElem, S} where S}" href="#maximum-Tuple{typeof(abs), SMat{ZZRingElem, S} where S}"><code>maximum</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maximum(abs, A::SMat{ZZRingElem}) -&gt; ZZRingElem</code></pre><p>Finds the largest, in absolute value, entry of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="elementary_divisors-Tuple{SMat{ZZRingElem, S} where S}" href="#elementary_divisors-Tuple{SMat{ZZRingElem, S} where S}"><code>elementary_divisors</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elementary_divisors(A::SMat{ZZRingElem}) -&gt; Vector{ZZRingElem}</code></pre><p>The elementary divisors of <span>$A$</span>, i.e. the diagonal elements of the Smith normal form of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="solve_dixon_sf-Tuple{SMat{ZZRingElem, S} where S, SRow{ZZRingElem, S} where S}" href="#solve_dixon_sf-Tuple{SMat{ZZRingElem, S} where S, SRow{ZZRingElem, S} where S}"><code>solve_dixon_sf</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_dixon_sf(A::SMat{ZZRingElem}, b::SRow{ZZRingElem}, is_int::Bool = false) -&gt; SRow{ZZRingElem}, ZZRingElem
solve_dixon_sf(A::SMat{ZZRingElem}, B::SMat{ZZRingElem}, is_int::Bool = false) -&gt; SMat{ZZRingElem}, ZZRingElem</code></pre><p>For a sparse square matrix <span>$A$</span> of full rank and a sparse matrix (row), find a sparse matrix (row) <span>$x$</span> and an integer <span>$d$</span> s.th. <span>$x A = bd$</span> holds. The algorithm is a Dixon-based linear p-adic lifting method. If \code{is_int} is given, then <span>$d$</span> is assumed to be <span>$1$</span>. In this case rational reconstruction is avoided.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="hadamard_bound2-Tuple{SMat}" href="#hadamard_bound2-Tuple{SMat}"><code>hadamard_bound2</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hadamard_bound2(A::SMat{T}) -&gt; T</code></pre><p>The square of the product of the norms of the rows of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="echelon_with_transform-Tuple{SMat{zzModRingElem, S} where S}" href="#echelon_with_transform-Tuple{SMat{zzModRingElem, S} where S}"><code>echelon_with_transform</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">echelon_with_transform(A::SMat{zzModRingElem}) -&gt; SMat, SMat</code></pre><p>Find a unimodular matrix <span>$T$</span> and an upper-triangular <span>$E$</span> s.th. <span>$TA = E$</span> holds.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="reduce_full-Tuple{SMat{ZZRingElem, S} where S, SRow{ZZRingElem, S} where S}" href="#reduce_full-Tuple{SMat{ZZRingElem, S} where S, SRow{ZZRingElem, S} where S}"><code>reduce_full</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_full(A::SMat{ZZRingElem}, g::SRow{ZZRingElem},
                      trafo = Val{false}) -&gt; SRow{ZZRingElem}, Vector{Int}</code></pre><p>Reduces <span>$g$</span> modulo <span>$A$</span> and assumes that <span>$A$</span> is upper triangular.</p><p>The second return value is the array of pivot elements of <span>$A$</span> that changed.</p><p>If <code>trafo</code> is set to <code>Val{true}</code>, then additionally an array of transformations is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="hnf!-Tuple{SMat{ZZRingElem, S} where S}" href="#hnf!-Tuple{SMat{ZZRingElem, S} where S}"><code>hnf!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hnf!(A::SMat{ZZRingElem})</code></pre><p>Inplace transform of <span>$A$</span> into upper right Hermite normal form.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="hnf-Tuple{SMat{ZZRingElem, S} where S}" href="#hnf-Tuple{SMat{ZZRingElem, S} where S}"><code>hnf</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hnf(A::SMat{ZZRingElem}) -&gt; SMat{ZZRingElem}</code></pre><p>Return the upper right Hermite normal form of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="snf-Tuple{SMat{ZZRingElem, S} where S}" href="#snf-Tuple{SMat{ZZRingElem, S} where S}"><code>snf</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">snf(A::SMat{ZZRingElem})</code></pre><p>The Smith normal form (snf) of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="hnf_extend!-Tuple{SMat{ZZRingElem, S} where S, SMat{ZZRingElem, S} where S}" href="#hnf_extend!-Tuple{SMat{ZZRingElem, S} where S, SMat{ZZRingElem, S} where S}"><code>hnf_extend!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hnf_extend!(A::SMat{ZZRingElem}, b::SMat{ZZRingElem}, offset::Int = 0) -&gt; SMat{ZZRingElem}</code></pre><p>Given a matrix <span>$A$</span> in HNF, extend this to get the HNF of the concatenation with <span>$b$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="is_diagonal-Tuple{SMat}" href="#is_diagonal-Tuple{SMat}"><code>is_diagonal</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_diagonal(A::SMat) -&gt; Bool</code></pre><p>True iff only the i-th entry in the i-th row is non-zero.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="det-Tuple{SMat{ZZRingElem, S} where S}" href="#det-Tuple{SMat{ZZRingElem, S} where S}"><code>det</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">det(A::SMat{ZZRingElem})</code></pre><p>The determinant of <span>$A$</span> using a modular algorithm. Uses the dense (zzModMatrix) determinant on <span>$A$</span> for various primes <span>$p$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="det_mc-Tuple{SMat{ZZRingElem, S} where S}" href="#det_mc-Tuple{SMat{ZZRingElem, S} where S}"><code>det_mc</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">det_mc(A::SMat{ZZRingElem})</code></pre><p>Computes the determinant of <span>$A$</span> using a LasVegas style algorithm, i.e. the result is not proven to be correct. Uses the dense (zzModMatrix) determinant on <span>$A$</span> for various primes <span>$p$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="valence_mc-Tuple{SMat}" href="#valence_mc-Tuple{SMat}"><code>valence_mc</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">valence_mc{T}(A::SMat{T}; extra_prime = 2, trans = Vector{SMatSLP_add_row{T}}()) -&gt; T</code></pre><p>Uses a Monte-Carlo algorithm to compute the valence of <span>$A$</span>. The valence is the valence of the minimal polynomial <span>$f$</span> of <span>$transpose(A)*A$</span>, thus the last non-zero coefficient, typically <span>$f(0)$</span>.</p><p>The valence is computed modulo various primes until the computation stabilises for <code>extra_prime</code> many.</p><p><code>trans</code>, if given, is  a SLP (straight-line-program) in GL(n, Z). Then the valence of <code>trans</code> * <span>$A$</span>  is computed instead.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="saturate-Tuple{SMat{ZZRingElem, S} where S}" href="#saturate-Tuple{SMat{ZZRingElem, S} where S}"><code>saturate</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saturate(A::SMat{ZZRingElem}) -&gt; SMat{ZZRingElem}</code></pre><p>Computes the saturation of <span>$A$</span>, that is, a basis for <span>$\mathbf{Q}\otimes M \meet \mathbf{Z}^n$</span>, where <span>$M$</span> is the row span of <span>$A$</span> and <span>$n$</span> the number of rows of <span>$A$</span>.</p><p>Equivalently, return <span>$TA$</span> for an invertible rational matrix <span>$T$</span>, such that <span>$TA$</span> is integral and the elementary divisors of <span>$TA$</span> are all trivial.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="hnf_kannan_bachem-Tuple{SMat{ZZRingElem, S} where S}" href="#hnf_kannan_bachem-Tuple{SMat{ZZRingElem, S} where S}"><code>hnf_kannan_bachem</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hnf_kannan_bachem(A::SMat{ZZRingElem}) -&gt; SMat{ZZRingElem}</code></pre><p>Compute the Hermite normal form of <span>$A$</span> using the Kannan-Bachem algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="diagonal_form-Tuple{SMat{ZZRingElem, S} where S}" href="#diagonal_form-Tuple{SMat{ZZRingElem, S} where S}"><code>diagonal_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagonal_form(A::SMat{ZZRingElem}) -&gt; SMat{ZZRingElem}</code></pre><p>A matrix <span>$D$</span> that is diagonal and obtained via unimodular row and column operations. Like a snf without the divisibility condition.</p></div></section></article><h3 id="Manipulation/-Access"><a class="docs-heading-anchor" href="#Manipulation/-Access">Manipulation/ Access</a><a id="Manipulation/-Access-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulation/-Access" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="getindex-Union{Tuple{T}, Tuple{SMat{T, S} where S, Int64, Int64}} where T" href="#getindex-Union{Tuple{T}, Tuple{SMat{T, S} where S, Int64, Int64}} where T"><code>getindex</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(A::SMat, i::Int, j::Int)</code></pre><p>Given a sparse matrix <span>$A = (a_{ij})_{i, j}$</span>, return the entry <span>$a_{ij}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="getindex-Union{Tuple{T}, Tuple{SMat{T, S} where S, Int64}} where T" href="#getindex-Union{Tuple{T}, Tuple{SMat{T, S} where S, Int64}} where T"><code>getindex</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(A::SMat, i::Int) -&gt; SRow</code></pre><p>Given a sparse matrix <span>$A$</span> and an index <span>$i$</span>, return the <span>$i$</span>-th row of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="setindex!-Union{Tuple{T}, Tuple{SMat{T, S} where S, SRow{T, S} where S, Int64}} where T" href="#setindex!-Union{Tuple{T}, Tuple{SMat{T, S} where S, SRow{T, S} where S, Int64}} where T"><code>setindex!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(A::SMat, b::SRow, i::Int)</code></pre><p>Given a sparse matrix <span>$A$</span>, a sparse row <span>$b$</span> and an index <span>$i$</span>, set the <span>$i$</span>-th row of <span>$A$</span> equal to <span>$b$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="swap_rows!-Tuple{SMat, Int64, Int64}" href="#swap_rows!-Tuple{SMat, Int64, Int64}"><code>swap_rows!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap_rows!(A::SMat{T}, i::Int, j::Int)</code></pre><p>Swap the <span>$i$</span>-th and <span>$j$</span>-th row of <span>$A$</span> inplace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="swap_cols!-Tuple{SMat, Int64, Int64}" href="#swap_cols!-Tuple{SMat, Int64, Int64}"><code>swap_cols!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap_cols!(A::SMat, i::Int, j::Int)</code></pre><p>Swap the <span>$i$</span>-th and <span>$j$</span>-th column of <span>$A$</span> inplace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="scale_row!-Union{Tuple{T}, Tuple{SMat{T, S} where S, Int64, T}} where T" href="#scale_row!-Union{Tuple{T}, Tuple{SMat{T, S} where S, Int64, T}} where T"><code>scale_row!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale_row!(A::SMat{T}, i::Int, c::T)</code></pre><p>Multiply the <span>$i$</span>-th row of <span>$A$</span> by <span>$c$</span> inplace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="add_scaled_col!-Union{Tuple{T}, Tuple{SMat{T, S} where S, Int64, Int64, T}} where T" href="#add_scaled_col!-Union{Tuple{T}, Tuple{SMat{T, S} where S, Int64, Int64, T}} where T"><code>add_scaled_col!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_scaled_col!(A::SMat{T}, i::Int, j::Int, c::T)</code></pre><p>Add <span>$c$</span> times the <span>$i$</span>-th column to the <span>$j$</span>-th column of <span>$A$</span> inplace, that is, <span>$A_j \rightarrow A_j + c \cdot A_i$</span>, where <span>$(A_i)_i$</span> denote the columns of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="add_scaled_row!-Union{Tuple{T}, Tuple{SMat{T, S} where S, Int64, Int64, T}} where T" href="#add_scaled_row!-Union{Tuple{T}, Tuple{SMat{T, S} where S, Int64, Int64, T}} where T"><code>add_scaled_row!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_scaled_row!(A::SMat{T}, i::Int, j::Int, c::T)</code></pre><p>Add <span>$c$</span> times the <span>$i$</span>-th row to the <span>$j$</span>-th row of <span>$A$</span> inplace, that is, <span>$A_j \rightarrow A_j + c \cdot A_i$</span>, where <span>$(A_i)_i$</span> denote the rows of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="transform_row!-Union{Tuple{T}, Tuple{SMat{T, S} where S, Int64, Int64, T, T, T, T}} where T" href="#transform_row!-Union{Tuple{T}, Tuple{SMat{T, S} where S, Int64, Int64, T, T, T, T}} where T"><code>transform_row!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform_row!(A::SMat{T}, i::Int, j::Int, a::T, b::T, c::T, d::T)</code></pre><p>Applies the transformation <span>$(A_i, A_j) \rightarrow (aA_i + bA_j, cA_i + dA_j)$</span> to <span>$A$</span>, where <span>$(A_i)_i$</span> are the rows of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="diagonal-Tuple{SMat}" href="#diagonal-Tuple{SMat}"><code>diagonal</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagonal(A::SMat) -&gt; ZZRingElem[]</code></pre><p>The diagonal elements of <span>$A$</span> in an array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="reverse_rows!-Tuple{SMat}" href="#reverse_rows!-Tuple{SMat}"><code>reverse_rows!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reverse_rows!(A::SMat)</code></pre><p>Inplace inversion of the rows of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="mod_sym!-Tuple{SMat{ZZRingElem, S} where S, ZZRingElem}" href="#mod_sym!-Tuple{SMat{ZZRingElem, S} where S, ZZRingElem}"><code>mod_sym!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mod_sym!(A::SMat{ZZRingElem}, n::ZZRingElem)</code></pre><p>Inplace reduction of all entries of <span>$A$</span> modulo <span>$n$</span> to the symmetric residue system.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="find_row_starting_with-Tuple{SMat, Int64}" href="#find_row_starting_with-Tuple{SMat, Int64}"><code>find_row_starting_with</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_row_starting_with(A::SMat, p::Int) -&gt; Int</code></pre><p>Tries to find the index <span>$i$</span> such that <span>$A_{i,p} \neq 0$</span> and <span>$A_{i, p-j} = 0$</span> for all <span>$j &gt; 1$</span>. It is assumed that <span>$A$</span> is upper triangular. If such an index does not exist, find the smallest index larger.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="reduce-Tuple{SMat{ZZRingElem, S} where S, SRow{ZZRingElem, S} where S, ZZRingElem}" href="#reduce-Tuple{SMat{ZZRingElem, S} where S, SRow{ZZRingElem, S} where S, ZZRingElem}"><code>reduce</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(A::SMat{ZZRingElem}, g::SRow{ZZRingElem}, m::ZZRingElem) -&gt; SRow{ZZRingElem}</code></pre><p>Given an upper triangular matrix <span>$A$</span> over the integers, a sparse row <span>$g$</span> and an integer <span>$m$</span>, this function reduces <span>$g$</span> modulo <span>$A$</span> and returns <span>$g$</span> modulo <span>$m$</span> with respect to the symmetric residue system.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="reduce-Tuple{SMat{ZZRingElem, S} where S, SRow{ZZRingElem, S} where S}" href="#reduce-Tuple{SMat{ZZRingElem, S} where S, SRow{ZZRingElem, S} where S}"><code>reduce</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(A::SMat{ZZRingElem}, g::SRow{ZZRingElem}) -&gt; SRow{ZZRingElem}</code></pre><p>Given an upper triangular matrix <span>$A$</span> over a field and a sparse row <span>$g$</span>, this function reduces <span>$g$</span> modulo <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="reduce-Union{Tuple{T}, Tuple{SMat{T, S} where S, SRow{T, S} where S}} where T&lt;:FieldElement" href="#reduce-Union{Tuple{T}, Tuple{SMat{T, S} where S, SRow{T, S} where S}} where T&lt;:FieldElement"><code>reduce</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(A::SMat{T}, g::SRow{T}) -&gt; SRow{T}</code></pre><p>Given an upper triangular matrix <span>$A$</span> over a field and a sparse row <span>$g$</span>, this function reduces <span>$g$</span> modulo <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rand_row-Union{Tuple{SMat{T, S} where S}, Tuple{T}} where T" href="#rand_row-Union{Tuple{SMat{T, S} where S}, Tuple{T}} where T"><code>rand_row</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_row(A::SMat) -&gt; SRow</code></pre><p>Return a random row of the sparse matrix <span>$A$</span>.</p></div></section></article><p>Changing of the ring:</p><article class="docstring"><header><a class="docstring-binding" id="map_entries-Tuple{Any, SMat}" href="#map_entries-Tuple{Any, SMat}"><code>map_entries</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_entries(f, A::SMat) -&gt; SMat</code></pre><p>Given a sparse matrix <span>$A$</span> and a callable object <span>$f$</span>, this function will construct a new sparse matrix by applying <span>$f$</span> to all elements of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="change_base_ring-Tuple{Ring, SMat}" href="#change_base_ring-Tuple{Ring, SMat}"><code>change_base_ring</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_base_ring(R::Ring, A::SMat)</code></pre><p>Create a new sparse matrix by coercing all elements into the ring <span>$R$</span>.</p></div></section></article><h3 id="Arithmetic"><a class="docs-heading-anchor" href="#Arithmetic">Arithmetic</a><a id="Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic" title="Permalink"></a></h3><p>Matrices support the usual operations as well</p><ul><li><code>+</code>, <code>-</code>, <code>==</code></li><li><code>div</code>, <code>divexact</code> by scalars</li><li>multiplication by scalars</li></ul><p>Various products:</p><article class="docstring"><header><a class="docstring-binding" id="mul-Union{Tuple{T}, Tuple{SMat{T, S} where S, AbstractVector{T}}} where T" href="#mul-Union{Tuple{T}, Tuple{SMat{T, S} where S, AbstractVector{T}}} where T"><code>mul</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul(A::SMat{T}, b::AbstractVector{T}) -&gt; Vector{T}</code></pre><p>Return the product <span>$A \cdot b$</span> as a dense vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="mul-Union{Tuple{T}, Tuple{SMat{T, S} where S, AbstractMatrix{T}}} where T" href="#mul-Union{Tuple{T}, Tuple{SMat{T, S} where S, AbstractMatrix{T}}} where T"><code>mul</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul(A::SMat{T}, b::AbstractMatrix{T}) -&gt; Matrix{T}</code></pre><p>Return the product <span>$A \cdot b$</span> as a dense array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="mul-Union{Tuple{T}, Tuple{SMat{T, S} where S, MatElem{T}}} where T" href="#mul-Union{Tuple{T}, Tuple{SMat{T, S} where S, MatElem{T}}} where T"><code>mul</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul(A::SMat{T}, b::MatElem{T}) -&gt; MatElem</code></pre><p>Return the product <span>$A \cdot b$</span> as a dense matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="mul-Union{Tuple{T}, Tuple{SRow{T, S} where S, SMat{T, S} where S}} where T" href="#mul-Union{Tuple{T}, Tuple{SRow{T, S} where S, SMat{T, S} where S}} where T"><code>mul</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul(A::SRow, B::SMat) -&gt; SRow</code></pre><p>Return the product <span>$A\cdot B$</span> as a sparse row.</p></div></section></article><p>Other:</p><article class="docstring"><header><a class="docstring-binding" id="sparse-Tuple{SMat}" href="#sparse-Tuple{SMat}"><code>sparse</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparse(A::SMat) -&gt; SparseMatrixCSC</code></pre><p>The same matrix, but as a sparse matrix of julia type <code>SparseMatrixCSC</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ZZMatrix-Tuple{SMat{ZZRingElem, S} where S}" href="#ZZMatrix-Tuple{SMat{ZZRingElem, S} where S}"><code>ZZMatrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZZMatrix(A::SMat{ZZRingElem})</code></pre><p>The same matrix <span>$A$</span>, but as an <code>ZZMatrix</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ZZMatrix-Union{Tuple{SMat{T, S} where S}, Tuple{T}} where T&lt;:Integer" href="#ZZMatrix-Union{Tuple{SMat{T, S} where S}, Tuple{T}} where T&lt;:Integer"><code>ZZMatrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZZMatrix(A::SMat{T}) where {T &lt;: Integer}</code></pre><p>The same matrix <span>$A$</span>, but as an <code>ZZMatrix</code>. Requires a conversion from the base ring of <span>$A$</span> to <span>$\mathbb ZZ$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Array-Union{Tuple{SMat{T, S} where S}, Tuple{T}} where T" href="#Array-Union{Tuple{SMat{T, S} where S}, Tuple{T}} where T"><code>Array</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Array(A::SMat{T}) -&gt; Matrix{T}</code></pre><p>The same matrix, but as a two-dimensional julia array.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../LinearAlgebra/intro/">Â« Introduction</a><a class="docs-footer-nextpage" href="../../../AbstractAlgebra/matrix/">Matrix functionality Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 18 April 2023 06:47">Tuesday 18 April 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
