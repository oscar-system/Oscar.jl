<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Affine Algebras and Their Ideals Â· Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../Experimental/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox" checked/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../ideals/">Ideals in Multivariate Rings</a></li><li class="is-active"><a class="tocitem" href>Affine Algebras and Their Ideals</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Data-Associated-to-Affine-Algebras"><span>Data Associated to Affine Algebras</span></a></li><li><a class="tocitem" href="#Elements-of-Affine-Algebras"><span>Elements of Affine Algebras</span></a></li><li><a class="tocitem" href="#Ideals-in-Affine-Algebras"><span>Ideals in Affine Algebras</span></a></li><li><a class="tocitem" href="#Homomorphisms-From-Affine-Algebras"><span>Homomorphisms From Affine Algebras</span></a></li><li><a class="tocitem" href="#Homomorphisms-of-Affine-Algebras"><span>Homomorphisms of Affine Algebras</span></a></li><li><a class="tocitem" href="#Subalgebras"><span>Subalgebras</span></a></li><li><a class="tocitem" href="#Noether-Normalization"><span>Noether Normalization</span></a></li><li><a class="tocitem" href="#Normalization"><span>Normalization</span></a></li><li><a class="tocitem" href="#Integral-Bases"><span>Integral Bases</span></a></li><li><a class="tocitem" href="#Tests-on-Affine-Algebras"><span>Tests on Affine Algebras</span></a></li><li><a class="tocitem" href="#Hilbert-Series-and-Hilbert-Polynomial"><span>Hilbert Series and Hilbert Polynomial</span></a></li></ul></li><li><a class="tocitem" href="../localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/homological_algebra/">Homological Algebra</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-7" type="checkbox"/><label class="tocitem" for="menuitem-9-7"><span class="docs-label">GrÃ¶bner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../GroebnerBases/groebner_bases/">GrÃ¶bner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../GroebnerBases/groebner_bases_integers/">GrÃ¶bner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Toric Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/ToricSchemes/intro/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/ToricSchemes/NormalToricSchemes/">Normal Toric Schemes</a></li><li><a class="tocitem" href="../../Experimental/ToricSchemes/AffineToricSchemes/">Affine Toric Schemes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/TropicalGeometry/curve/">Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/K3Surfaces/">Automorphism Groups of  K3 surfaces</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/SurfacesP4/">Nongeneral Type Surfaces in <span>$\mathbb P^4$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-8" type="checkbox"/><label class="tocitem" for="menuitem-11-8"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Miscellaneous/miscellaneous/">Some Special Ideals</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Noncommutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li><li><a class="tocitem" href="../../Combinatorics/partitions/">Partitions</a></li><li><a class="tocitem" href="../../Combinatorics/tableaux/">Tableaux</a></li><li><a class="tocitem" href="../../Combinatorics/schur_polynomials/">Schur polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-7" type="checkbox"/><label class="tocitem" for="menuitem-17-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-18" type="checkbox"/><label class="tocitem" for="menuitem-18"><span class="docs-label">Experimental</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/intro/">Adding new projects to experimental</a></li><li><input class="collapse-toggle" id="menuitem-18-2" type="checkbox"/><label class="tocitem" for="menuitem-18-2"><span class="docs-label">F-Theory Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/FTheoryTools/introduction/">Welcome to FTheoryTools</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/weierstrass/">Global Weierstrass models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/tate/">Global Tate models</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-18-3" type="checkbox"/><label class="tocitem" for="menuitem-18-3"><span class="docs-label">Linear Quotients</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/LinearQuotients/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/LinearQuotients/linear_quotients/">Construction and basic functionality</a></li><li><a class="tocitem" href="../../Experimental/LinearQuotients/cox_rings/">Cox rings</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Commutative Algebra</a></li><li class="is-active"><a href>Affine Algebras and Their Ideals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Affine Algebras and Their Ideals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/CommutativeAlgebra/affine_algebras.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#Affine-Algebras-and-Their-Ideals">Affine Algebras and Their Ideals</a></li><li class="no-marker"><ul><li><a href="#Types">Types</a></li><li><a href="#Constructors">Constructors</a></li><li><a href="#Data-Associated-to-Affine-Algebras">Data Associated to Affine Algebras</a></li><li><a href="#Elements-of-Affine-Algebras">Elements of Affine Algebras</a></li><li><a href="#Ideals-in-Affine-Algebras">Ideals in Affine Algebras</a></li><li><a href="#Homomorphisms-From-Affine-Algebras">Homomorphisms From Affine Algebras</a></li><li><a href="#Homomorphisms-of-Affine-Algebras">Homomorphisms of Affine Algebras</a></li><li><a href="#Subalgebras">Subalgebras</a></li><li><a href="#Noether-Normalization">Noether Normalization</a></li><li><a href="#Normalization">Normalization</a></li><li><a href="#Integral-Bases">Integral Bases</a></li><li><a href="#Tests-on-Affine-Algebras">Tests on Affine Algebras</a></li><li><a href="#Hilbert-Series-and-Hilbert-Polynomial">Hilbert Series and Hilbert Polynomial</a></li></ul></li></ul><h1 id="Affine-Algebras-and-Their-Ideals"><a class="docs-heading-anchor" href="#Affine-Algebras-and-Their-Ideals">Affine Algebras and Their Ideals</a><a id="Affine-Algebras-and-Their-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Affine-Algebras-and-Their-Ideals" title="Permalink"></a></h1><p>With regard to notation, we use <em>affine algebra</em> as a synonym for <em>quotient of a multivariate polynomial ring by an ideal</em>. More specifically, if <span>$R$</span> is a multivariate polynomial ring with coefficient ring <span>$C$</span>, and <span>$A=R/I$</span> is the quotient of <span>$R$</span> by an ideal <span>$I$</span> of <span>$R$</span>, we refer to <span>$A$</span> as an <em>affine algebra over <span>$C$</span></em>, or an <em>affine <span>$C$</span>-algebra</em>. In this section, we discuss functionality for handling such algebras in OSCAR.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To emphasize this point: In this section, we view <span>$R/I$</span> together with its ring structure. Realizing <span>$R/I$</span> as an <span>$R$</span>-module means to implement it as the quotient of a free <span>$R$</span>-module of rank 1. See the section on modules.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Most functions discussed here rely on GrÃ¶bner basis techniques. In particular, they typically make use of a GrÃ¶bner basis for the modulus of the quotient. Nevertheless, the construction of quotients is lazy in the sense that the computation of such a GrÃ¶bner basis is delayed until the user performs an operation that indeed requires it (the GrÃ¶bner basis is then computed with respect to the <code>default_ordering</code> on the underlying polynomial ring; see the section on <em>GrÃ¶bner/Standard Bases</em> for default orderings in OSCAR). Once computed, the GrÃ¶bner basis is cached for later reuse.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Recall that GrÃ¶bner basis methods are implemented for multivariate polynomial rings over fields (exact fields supported by OSCAR) and, where not indicated otherwise, for multivariate polynomial rings over the integers.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In OSCAR, elements of a quotient <span>$A = R/I$</span> are not necessarily represented by polynomials which are reduced with regard to <span>$I$</span>. That is, if <span>$f\in R$</span> is the internal polynomial representative of an element of <span>$A$</span>, then <span>$f$</span> may not be the normal form mod <span>$I$</span> with respect to the default ordering on <span>$R$</span> (see the section on <em>GrÃ¶bner/Standard Bases</em> for normal forms). Operations involving GrÃ¶bner basis computations may lead to (partial) reductions. The function <code>simplify</code> discussed in this section computes fully reduced representatives. </p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Each grading on a multivariate polynomial ring <code>R</code>  in OSCAR  descends to a grading on the affine algebra <code>A = R/I</code> (recall that OSCAR ideals of graded polynomial rings are required to be homogeneous). Functionality for dealing with such gradings and our notation for describing this functionality descend accordingly. This applies, in particular, to the functions <code>Ã¬s_graded</code>, <code>Ã¬s_standard_graded</code>, <code>Ã¬s_z_graded</code>, <code>Ã¬s_zm_graded</code>, and <code>Ã¬s_positively_graded</code> which will not be discussed again here. </p></div></div><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>The OSCAR type for quotients of  multivariate polynomial rings is of parametrized form <code>MPolyQuoRing{T}</code>, with elements of type <code>MPolyQuoRingElem{T}</code>. Here, <code>T</code> is the element type of the polynomial ring.</p><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="quo-Tuple{MPolyRing, MPolyIdeal}" href="#quo-Tuple{MPolyRing, MPolyIdeal}"><code>quo</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quo(R::MPolyRing, I::MPolyIdeal) -&gt; MPolyQuoRing, Map</code></pre><p>Create the quotient ring <code>R/I</code> and return the new ring as well as the projection map <code>R</code> <span>$\to$</span> <code>R/I</code>.</p><pre><code class="nohighlight hljs">quo(R::MPolyRing, V::Vector{MPolyRingElem}) -&gt; MPolyQuoRing, Map</code></pre><p>As above, where <code>I</code> is the ideal of <code>R</code> generated by the polynomials in <code>V</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, p = quo(R, ideal(R, [x^2-y^3, x-y]));

julia&gt; A
Quotient of Multivariate Polynomial Ring in x, y over Rational Field by ideal(x^2 - y^3, x - y)

julia&gt; typeof(A)
MPolyQuoRing{QQMPolyRingElem}

julia&gt; typeof(x)
QQMPolyRingElem

julia&gt; p
Map from
Multivariate Polynomial Ring in x, y over Rational Field to Quotient of Multivariate Polynomial Ring in x, y over Rational Field by ideal(x^2 - y^3, x - y) defined by a julia-function with inverse

julia&gt; p(x)
x

julia&gt; typeof(p(x))
MPolyQuoRingElem{QQMPolyRingElem}</code></pre><pre><code class="language-julia-repl hljs">julia&gt; S, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; B, _ = quo(S, ideal(S, [x^2*z-y^3, x-y]))
(Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field graded by
  x -&gt; [1]
  y -&gt; [1]
  z -&gt; [1] by ideal(x^2*z - y^3, x - y), Map from
Multivariate Polynomial Ring in x, y, z over Rational Field graded by
  x -&gt; [1]
  y -&gt; [1]
  z -&gt; [1] to Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field graded by
  x -&gt; [1]
  y -&gt; [1]
  z -&gt; [1] by ideal(x^2*z - y^3, x - y) defined by a julia-function with inverse)

julia&gt; typeof(B)
MPolyQuoRing{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L799-L853">source</a></section></article><h2 id="Data-Associated-to-Affine-Algebras"><a class="docs-heading-anchor" href="#Data-Associated-to-Affine-Algebras">Data Associated to Affine Algebras</a><a id="Data-Associated-to-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Associated-to-Affine-Algebras" title="Permalink"></a></h2><h3 id="Basic-Data"><a class="docs-heading-anchor" href="#Basic-Data">Basic Data</a><a id="Basic-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Data" title="Permalink"></a></h3><p>If <code>A=R/I</code> is the quotient of a multivariate polynomial ring <code>R</code> modulo an ideal <code>I</code> of <code>R</code>, then</p><ul><li><code>base_ring(A)</code> refers to <code>R</code>,</li><li><code>modulus(A)</code> to <code>I</code>,</li><li><code>gens(A)</code> to the generators of <code>A</code>,</li><li><code>ngens(A)</code> to the number of these generators, and</li><li><code>gen(A, i)</code> as well as <code>A[i]</code> to the <code>i</code>-th such generator.</li></ul><h6 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));

julia&gt; base_ring(A)
Multivariate Polynomial Ring in x, y, z over Rational Field

julia&gt; modulus(A)
ideal(-x^2 + y, -x^3 + z)

julia&gt; gens(A)
3-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:
 x
 y
 z

julia&gt; ngens(A)
3

julia&gt; gen(A, 2)
y
</code></pre><p>In the graded case, we additionally have:</p><article class="docstring"><header><a class="docstring-binding" id="grading_group-Tuple{MPolyQuoRing{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem}" href="#grading_group-Tuple{MPolyQuoRing{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem}"><code>grading_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grading_group(A::MPolyQuoRing{&lt;:MPolyDecRingElem})</code></pre><p>If <code>A</code> is, say, <code>G</code>-graded, return <code>G</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^2*z-y^3, x-y]));

julia&gt; grading_group(A)
GrpAb: Z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L1247-L1261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="homogeneous_component-Tuple{MPolyQuoRing{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem, GrpAbFinGenElem}" href="#homogeneous_component-Tuple{MPolyQuoRing{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem, GrpAbFinGenElem}"><code>homogeneous_component</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">homogeneous_component(A::MPolyQuoRing{&lt;:MPolyDecRingElem}, g::GrpAbFinGenElem)</code></pre><p>Given a graded quotient <code>A</code> of a multivariate polynomial ring over a field,  where the grading group is free of type <code>GrpAbFinGen</code>, and given an element <code>g</code> of  that group, return the homogeneous component of <code>A</code> of degree <code>g</code>. Additionally, return the embedding of the component into <code>A</code>.</p><pre><code class="nohighlight hljs">homogeneous_component(A::MPolyQuoRing{&lt;:MPolyDecRingElem}, g::Vector{&lt;:IntegerUnion})</code></pre><p>Given a <span>$\mathbb  Z^m$</span>-graded quotient <code>A</code> of a multivariate polynomial ring over a field,  and given a vector <code>g</code> of <span>$m$</span> integers, convert <code>g</code> into an element of the grading group of <code>A</code>, and return the homogeneous component of <code>A</code> whose degree  is that element. Additionally, return the embedding of the component into <code>A</code>.</p><pre><code class="nohighlight hljs">homogeneous_component(A::MPolyQuoRing{&lt;:MPolyDecRingElem}, g::IntegerUnion)</code></pre><p>Given a <span>$\mathbb  Z$</span>-graded quotient <code>A</code> of a multivariate polynomial ring over a field,  and given an integer <code>g</code>, convert <code>g</code> into an element of the grading group of <code>A</code>,  and return the homogeneous component of <code>A</code> whose degree is that element. Additionally, return the embedding of the component into <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the component is not finite dimensional, an error message will be thrown.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate Polynomial Ring in w, x, y, z over Rational Field graded by
  w -&gt; [1]
  x -&gt; [1]
  y -&gt; [1]
  z -&gt; [1], MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[w, x, y, z])

julia&gt; L = homogeneous_component(R, 2);

julia&gt; HC = gens(L[1]);

julia&gt; EMB = L[2]
Map from
homogeneous component of Multivariate Polynomial Ring in w, x, y, z over Rational Field graded by
  w -&gt; [1]
  x -&gt; [1]
  y -&gt; [1]
  z -&gt; [1] of degree graded by [2]
 to Multivariate Polynomial Ring in w, x, y, z over Rational Field graded by
  w -&gt; [1]
  x -&gt; [1]
  y -&gt; [1]
  z -&gt; [1] defined by a julia-function with inverse

julia&gt; for i in 1:length(HC) println(EMB(HC[i])) end
z^2
y*z
y^2
x*z
x*y
x^2
w*z
w*y
w*x
w^2

julia&gt; PTC = ideal(R, [-x*z + y^2, -w*z + x*y, -w*y + x^2]);

julia&gt; A, _ = quo(R, PTC);

julia&gt; L = homogeneous_component(A, 2);

julia&gt; HC = gens(L[1]);

julia&gt; EMB = L[2]
Map from
Quotient space over:
Rational Field with 7 generators and no relations to Quotient of Multivariate Polynomial Ring in w, x, y, z over Rational Field graded by
  w -&gt; [1]
  x -&gt; [1]
  y -&gt; [1]
  z -&gt; [1] by ideal(-x*z + y^2, -w*z + x*y, -w*y + x^2) defined by a julia-function with inverse

julia&gt; for i in 1:length(HC) println(EMB(HC[i])) end
z^2
y*z
x*z
w*z
w*y
w*x
w^2</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, x, y = polynomial_ring(QQ, &quot;x&quot; =&gt; 1:2, &quot;y&quot; =&gt; 1:3);

julia&gt; G = abelian_group([0, 0])
GrpAb: Z^2

julia&gt; g = gens(G)
2-element Vector{GrpAbFinGenElem}:
 Element of
GrpAb: Z^2
with components [1 0]
 Element of
GrpAb: Z^2
with components [0 1]

julia&gt; W = [g[1], g[1], g[2], g[2], g[2]];

julia&gt; S, _ = grade(R, W);

julia&gt; L = homogeneous_component(S, [2,1]);

julia&gt; HC = gens(L[1]);

julia&gt; EMB = L[2]
Map from
homogeneous component of Multivariate Polynomial Ring in x[1], x[2], y[1], y[2], y[3] over Rational Field graded by
  x[1] -&gt; [1 0]
  x[2] -&gt; [1 0]
  y[1] -&gt; [0 1]
  y[2] -&gt; [0 1]
  y[3] -&gt; [0 1] of degree Element of
GrpAb: Z^2
with components [2 1]
 to Multivariate Polynomial Ring in x[1], x[2], y[1], y[2], y[3] over Rational Field graded by
  x[1] -&gt; [1 0]
  x[2] -&gt; [1 0]
  y[1] -&gt; [0 1]
  y[2] -&gt; [0 1]
  y[3] -&gt; [0 1] defined by a julia-function with inverse

julia&gt; for i in 1:length(HC) println(EMB(HC[i])) end
x[2]^2*y[3]
x[2]^2*y[2]
x[2]^2*y[1]
x[1]*x[2]*y[3]
x[1]*x[2]*y[2]
x[1]*x[2]*y[1]
x[1]^2*y[3]
x[1]^2*y[2]
x[1]^2*y[1]

julia&gt; I = ideal(S, [x[1]*y[1]-x[2]*y[2]]);

julia&gt; A, = quo(S, I);

julia&gt; L = homogeneous_component(A, [2,1]);

julia&gt; HC = gens(L[1]);

julia&gt; EMB = L[2]
Map from
Quotient space over:
Rational Field with 7 generators and no relations to Quotient of Multivariate Polynomial Ring in x[1], x[2], y[1], y[2], y[3] over Rational Field graded by
  x[1] -&gt; [1 0]
  x[2] -&gt; [1 0]
  y[1] -&gt; [0 1]
  y[2] -&gt; [0 1]
  y[3] -&gt; [0 1] by ideal(x[1]*y[1] - x[2]*y[2]) defined by a julia-function with inverse

julia&gt; for i in 1:length(HC) println(EMB(HC[i])) end
x[2]^2*y[3]
x[2]^2*y[2]
x[2]^2*y[1]
x[1]*x[2]*y[3]
x[1]*x[2]*y[2]
x[1]^2*y[3]
x[1]^2*y[2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L1275-L1443">source</a></section></article><h3 id="Dimension"><a class="docs-heading-anchor" href="#Dimension">Dimension</a><a id="Dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Dimension" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="dim-Tuple{MPolyQuoRing}" href="#dim-Tuple{MPolyQuoRing}"><code>dim</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim(A::MPolyQuoRing)</code></pre><p>Return the Krull dimension of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));

julia&gt; dim(A)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="vdim-Tuple{MPolyQuoRing}" href="#vdim-Tuple{MPolyQuoRing}"><code>vdim</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vdim(A::MPolyQuoRing)</code></pre><p>If, say, <code>A = R/I</code>, where <code>R</code> is a multivariate polynomial ring over a field <code>K</code>, and <code>I</code> is an ideal of <code>R</code>, return the dimension of <code>A</code> as a <code>K</code>-vector space if <code>I</code> is zero-dimensional. Return <code>-1</code>, otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^3+y^3+z^3-1, x^2+y^2+z^2-1, x+y+z-1]));

julia&gt; vdim(A)
6

julia&gt; I = modulus(A)
ideal(x^3 + y^3 + z^3 - 1, x^2 + y^2 + z^2 - 1, x + y + z - 1)

julia&gt; groebner_basis(I, ordering = lex(base_ring(I)))
GrÃ¶bner basis with elements
1 -&gt; z^3 - z^2
2 -&gt; y^2 + y*z - y + z^2 - z
3 -&gt; x + y + z - 1
with respect to the ordering
lex([x, y, z])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L28-L55">source</a></section></article><h2 id="Elements-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Elements-of-Affine-Algebras">Elements of Affine Algebras</a><a id="Elements-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Elements-of-Affine-Algebras" title="Permalink"></a></h2><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><p>The OSCAR type for elements of quotients of  multivariate polynomial rings is of parametrized form <code>MPolyQuoRing{T}</code>, where <code>T</code> is the element type of the polynomial ring.</p><h3 id="Creating-Elements-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Creating-Elements-of-Affine-Algebras">Creating Elements of Affine Algebras</a><a id="Creating-Elements-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Elements-of-Affine-Algebras" title="Permalink"></a></h3><p>Elements of an affine algebra <code>A=R/I</code> are created as images of elements of <code>R</code> under the projection map or by directly coercing elements of <code>R</code> into <code>A</code>.</p><h6 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, p = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));

julia&gt; f = p(x^3*y^2-y^3*x^2+x*y)
x^3*y^2 - x^2*y^3 + x*y

julia&gt; typeof(f)
MPolyQuoRingElem{QQMPolyRingElem}

julia&gt; g = A(x^3*y^2-y^3*x^2+x*y)
x^3*y^2 - x^2*y^3 + x*y

julia&gt; f == g
true
</code></pre><h3 id="Reducing-Polynomial-Representatives"><a class="docs-heading-anchor" href="#Reducing-Polynomial-Representatives">Reducing Polynomial Representatives</a><a id="Reducing-Polynomial-Representatives-1"></a><a class="docs-heading-anchor-permalink" href="#Reducing-Polynomial-Representatives" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="simplify-Union{Tuple{MPolyQuoRingElem{T}}, Tuple{T}, Tuple{S}} where {S&lt;:Union{FieldElem, ZZRingElem}, T&lt;:MPolyRingElem{S}}" href="#simplify-Union{Tuple{MPolyQuoRingElem{T}}, Tuple{T}, Tuple{S}} where {S&lt;:Union{FieldElem, ZZRingElem}, T&lt;:MPolyRingElem{S}}"><code>simplify</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify(f::MPolyQuoRingElem{T}) where {S&lt;:Union{FieldElem, ZZRingElem}, T&lt;:MPolyRingElem{S}}</code></pre><p>If <code>f</code> is an element of the quotient of a multivariate polynomial ring <code>R</code> by an ideal <code>I</code> of <code>R</code>, say, replace the internal polynomial representative of <code>f</code> by its normal form mod <code>I</code> with respect to  the <code>default_ordering</code> on <code>R</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>Since this method only has a computational backend for quotients of polynomial rings  over a field, it is not implemented generically.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x,) = polynomial_ring(QQ, [&quot;x&quot;]);

julia&gt; A, p = quo(R, ideal(R, [x^4]));

julia&gt; f = p(2*x^6 + x^3 + x)
2*x^6 + x^3 + x

julia&gt; simplify(f)
x^3 + x

julia&gt; f
x^3 + x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L693-L719">source</a></section></article><h3 id="Tests-on-Elements-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Tests-on-Elements-of-Affine-Algebras">Tests on Elements of Affine Algebras</a><a id="Tests-on-Elements-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-on-Elements-of-Affine-Algebras" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="==-Union{Tuple{T}, Tuple{MPolyQuoRingElem{T}, MPolyQuoRingElem{T}}} where T" href="#==-Union{Tuple{T}, Tuple{MPolyQuoRingElem{T}, MPolyQuoRingElem{T}}} where T"><code>==</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(f::MPolyQuoRingElem{T}, g::MPolyQuoRingElem{T}) where T</code></pre><p>Return <code>true</code> if <code>f</code> is equal to <code>g</code>, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x,) = polynomial_ring(QQ, [&quot;x&quot;]);

julia&gt; A, p = quo(R, ideal(R, [x^4]));

julia&gt; f = p(x-x^6)
-x^6 + x

julia&gt; g = p(x)
x

julia&gt; f == g
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L771-L791">source</a></section></article><p>In the graded case, we additionally have:</p><article class="docstring"><header><a class="docstring-binding" id="is_homogeneous-Tuple{MPolyQuoRingElem{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem}" href="#is_homogeneous-Tuple{MPolyQuoRingElem{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem}"><code>is_homogeneous</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_homogeneous(f::MPolyQuoRingElem{&lt;:MPolyDecRingElem})</code></pre><p>Given an element <code>f</code> of a graded affine algebra, return <code>true</code> if <code>f</code> is homogeneous, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, p = quo(R, ideal(R, [y-x, z^3-x^3]));

julia&gt; f = p(y^2-x^2+z^4)
-x^2 + y^2 + z^4

julia&gt; is_homogeneous(f)
true

julia&gt; f
z^4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L1221-L1241">source</a></section></article><h3 id="Data-associated-to-Elements-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Data-associated-to-Elements-of-Affine-Algebras">Data associated to Elements of Affine Algebras</a><a id="Data-associated-to-Elements-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Data-associated-to-Elements-of-Affine-Algebras" title="Permalink"></a></h3><p>Given an element <code>f</code> of an affine algebra <code>A</code>, </p><ul><li><code>parent(f)</code> refers to <code>A</code>.</li></ul><p>In the graded case,  we also have:</p><article class="docstring"><header><a class="docstring-binding" id="homogeneous_components-Tuple{MPolyQuoRingElem{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem}" href="#homogeneous_components-Tuple{MPolyQuoRingElem{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem}"><code>homogeneous_components</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">homogeneous_components(f::MPolyQuoRingElem{&lt;:MPolyDecRingElem})</code></pre><p>Given an element <code>f</code> of a graded affine algebra, return the homogeneous components of <code>f</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, p = quo(R, ideal(R, [y-x, z^3-x^3]));

julia&gt; f = p(y^2-x^2+x*y*z+z^4)
-x^2 + x*y*z + y^2 + z^4

julia&gt; homogeneous_components(f)
Dict{GrpAbFinGenElem, MPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}} with 2 entries:
  [4] =&gt; z^4
  [3] =&gt; y^2*z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L1195-L1214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="homogeneous_component-Tuple{MPolyQuoRingElem{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem, GrpAbFinGenElem}" href="#homogeneous_component-Tuple{MPolyQuoRingElem{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem, GrpAbFinGenElem}"><code>homogeneous_component</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">homogeneous_component(f::MPolyQuoRingElem{&lt;:MPolyDecRingElem}, g::GrpAbFinGenElem)</code></pre><p>Given an element <code>f</code> of a graded affine algebra, and given an element <code>g</code> of the grading group of that algebra, return the homogeneous component of <code>f</code> of degree <code>g</code>.</p><pre><code class="nohighlight hljs">homogeneous_component(f::MPolyQuoRingElem{&lt;:MPolyDecRingElem}, g::Vector{&lt;:IntegerUnion})</code></pre><p>Given an element <code>f</code> of a <span>$\mathbb  Z^m$</span>-graded affine algebra <code>A</code>, say, and given a vector <code>g</code> of <span>$m$</span> integers, convert <code>g</code> into an element of the grading group of <code>A</code>, and return the homogeneous component of <code>f</code> whose degree is that element.</p><pre><code class="nohighlight hljs">homogeneous_component(f::MPolyQuoRingElem{&lt;:MPolyDecRingElem}, g::IntegerUnion)</code></pre><p>Given an element <code>f</code> of a <span>$\mathbb  Z$</span>-graded affine algebra <code>A</code>, say, and given an integer <code>g</code>, convert <code>g</code> into an element of the grading group of <code>A</code>, and return the homogeneous component of <code>f</code> whose degree is that element.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, p = quo(R, ideal(R, [y-x, z^3-x^3]));

julia&gt; f = p(y^2-x^2+x*y*z+z^4)
-x^2 + x*y*z + y^2 + z^4

julia&gt; homogeneous_component(f, 4)
z^4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L1149-L1179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="degree-Tuple{MPolyQuoRingElem{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem}" href="#degree-Tuple{MPolyQuoRingElem{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem}"><code>degree</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree(f::MPolyQuoRingElem{&lt;:MPolyDecRingElem})</code></pre><p>Given a homogeneous element <code>f</code> of a graded affine algebra, return the degree of <code>f</code>.</p><pre><code class="nohighlight hljs">degree(::Type{Vector{Int}}, f::MPolyQuoRingElem{&lt;:MPolyDecRingElem})</code></pre><p>Given a homogeneous element <code>f</code> of a <span>$\mathbb Z^m$</span>-graded affine algebra, return the degree of <code>f</code>, converted to a vector of integer numbers.</p><pre><code class="nohighlight hljs">degree(::Type{Int}, f::MPolyQuoRingElem{&lt;:MPolyDecRingElem})</code></pre><p>Given a homogeneous element <code>f</code> of a <span>$\mathbb Z$</span>-graded affine algebra, return the degree of <code>f</code>, converted to an integer number.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] );

julia&gt; A, p = quo(R, ideal(R, [y-x, z^3-x^3]))
(Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field graded by
  x -&gt; [1]
  y -&gt; [1]
  z -&gt; [1] by ideal(-x + y, -x^3 + z^3), Map from
Multivariate Polynomial Ring in x, y, z over Rational Field graded by
  x -&gt; [1]
  y -&gt; [1]
  z -&gt; [1] to Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field graded by
  x -&gt; [1]
  y -&gt; [1]
  z -&gt; [1] by ideal(-x + y, -x^3 + z^3) defined by a julia-function with inverse)

julia&gt; f = p(y^2-x^2+z^4)
-x^2 + y^2 + z^4

julia&gt; degree(f)
graded by [4]

julia&gt; typeof(degree(f))
GrpAbFinGenElem

julia&gt; degree(Int, f)
4

julia&gt; typeof(degree(Int, f))
Int64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L1083-L1128">source</a></section></article><h2 id="Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Ideals-in-Affine-Algebras">Ideals in Affine Algebras</a><a id="Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Ideals-in-Affine-Algebras" title="Permalink"></a></h2><h3 id="Constructors-2"><a class="docs-heading-anchor" href="#Constructors-2">Constructors</a><a class="docs-heading-anchor-permalink" href="#Constructors-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ideal-Union{Tuple{T}, Tuple{MPolyQuoRing{T}, Vector{T}}} where T&lt;:MPolyRingElem" href="#ideal-Union{Tuple{T}, Tuple{MPolyQuoRing{T}, Vector{T}}} where T&lt;:MPolyRingElem"><code>ideal</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ideal(A::MPolyQuoRing{T}, V::Vector{T}) where T &lt;: MPolyRingElem</code></pre><p>Given a (graded) quotient ring <code>A=R/I</code> and a vector <code>V</code> of (homogeneous) polynomials in <code>R</code>, create the ideal of <code>A</code> which is generated by the images of the entries of <code>V</code>.</p><pre><code class="nohighlight hljs">ideal(A::MPolyQuoRing{T}, V::Vector{MPolyQuoRingElem{T}}) where T &lt;: MPolyRingElem</code></pre><p>Given a (graded) quotient ring <code>A</code> and a vector <code>V</code> of (homogeneous) elements of <code>A</code>, create the ideal of <code>A</code> which is generated by the entries of <code>V</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));

julia&gt; I = ideal(A, [x^2-y])
ideal(x^2 - y)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; S, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; B, _ = quo(S, ideal(S, [x^2*z-y^3, x-y]));

julia&gt; J = ideal(B, [x^2-y^2])
ideal(x^2 - y^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L447-L475">source</a></section></article><h3 id="Reducing-Polynomial-Representatives-of-Generators"><a class="docs-heading-anchor" href="#Reducing-Polynomial-Representatives-of-Generators">Reducing Polynomial Representatives of Generators</a><a id="Reducing-Polynomial-Representatives-of-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Reducing-Polynomial-Representatives-of-Generators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="simplify-Tuple{MPolyQuoIdeal}" href="#simplify-Tuple{MPolyQuoIdeal}"><code>simplify</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify(a::MPolyQuoIdeal)</code></pre><p>If <code>a</code> is an ideal of the quotient of a multivariate polynomial ring <code>R</code> by an ideal <code>I</code> of <code>R</code>, say, replace the internal polynomial representative of each generator of <code>a</code> by its normal form  mod <code>I</code> with respect to the <code>default_ordering</code> on <code>R</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));

julia&gt; a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])
ideal(x^3*y^4 - x + y, x*y^2 + x*y)

julia&gt; gens(a)
2-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:
 x^3*y^4 - x + y
 x*y^2 + x*y

julia&gt; simplify(a)
ideal(x^2*y^3 - x + y, x*y^2 + x*y)

julia&gt; gens(a)
2-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:
 x^2*y^3 - x + y
 x*y^2 + x*y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L561-L590">source</a></section></article><h3 id="Data-Associated-to-Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Data-Associated-to-Ideals-in-Affine-Algebras">Data Associated to Ideals in Affine Algebras</a><a id="Data-Associated-to-Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Associated-to-Ideals-in-Affine-Algebras" title="Permalink"></a></h3><h4 id="Basic-Data-2"><a class="docs-heading-anchor" href="#Basic-Data-2">Basic Data</a><a class="docs-heading-anchor-permalink" href="#Basic-Data-2" title="Permalink"></a></h4><p>If <code>a</code> is an ideal of the affine algebra <code>A</code>, then</p><ul><li><code>base_ring(a)</code> refers to <code>A</code>,</li><li><code>gens(a)</code> to the generators of <code>a</code>,</li><li><code>ngens(a)</code> to the number of these generators,  and</li><li><code>gen(a, i)</code> as well as <code>a[i]</code> to the <code>i</code>-th such generator.</li></ul><h6 id="Examples-3"><a class="docs-heading-anchor" href="#Examples-3">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-3" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));

julia&gt; a = ideal(A, [x-y, z^4])
ideal(x - y, z^4)

julia&gt; base_ring(a)
Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x^2 + y, -x^3 + z)

julia&gt; gens(a)
2-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:
 x - y
 z^4

julia&gt; ngens(a)
2

julia&gt; gen(a, 2)
z^4
</code></pre><h4 id="Dimension-of-Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Dimension-of-Ideals-in-Affine-Algebras">Dimension of Ideals in Affine Algebras</a><a id="Dimension-of-Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Dimension-of-Ideals-in-Affine-Algebras" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="dim-Tuple{MPolyQuoIdeal}" href="#dim-Tuple{MPolyQuoIdeal}"><code>dim</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim(a::MPolyQuoIdeal)</code></pre><p>Return the Krull dimension of <code>a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));

julia&gt; a = ideal(A, [x-y])
ideal(x - y)

julia&gt; dim(a)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L1484-L1501">source</a></section></article><h4 id="Minimal-Sets-of-Generators"><a class="docs-heading-anchor" href="#Minimal-Sets-of-Generators">Minimal Sets of Generators</a><a id="Minimal-Sets-of-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-Sets-of-Generators" title="Permalink"></a></h4><p>In the graded case, we have:</p><article class="docstring"><header><a class="docstring-binding" id="minimal_generating_set-Tuple{MPolyQuoIdeal{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem}" href="#minimal_generating_set-Tuple{MPolyQuoIdeal{var&quot;#s262&quot;} where var&quot;#s262&quot;&lt;:MPolyDecRingElem}"><code>minimal_generating_set</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimal_generating_set(I::MPolyQuoIdeal{&lt;:MPolyDecRingElem})</code></pre><p>Given a homogeneous ideal <code>a</code> of a graded affine algebra over a field, return an array containing a minimal set of generators of <code>a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; V = [x, z^2, x^3+y^3, y^4, y*z^5];

julia&gt; I = ideal(R, V)
ideal(x, z^2, x^3 + y^3, y^4, y*z^5)

julia&gt; A, p = quo(R, ideal(R, [x-y]));

julia&gt; a = ideal(A, [p(x) for x in V]);

julia&gt; minimal_generating_set(a)
2-element Vector{MPolyQuoRingElem{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:
 x
 z^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L1533-L1557">source</a></section></article><h3 id="Operations-on-Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Operations-on-Ideals-in-Affine-Algebras">Operations on Ideals in Affine Algebras</a><a id="Operations-on-Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-Ideals-in-Affine-Algebras" title="Permalink"></a></h3><h4 id="Simple-Ideal-Operations-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Simple-Ideal-Operations-in-Affine-Algebras">Simple Ideal Operations in Affine Algebras</a><a id="Simple-Ideal-Operations-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Ideal-Operations-in-Affine-Algebras" title="Permalink"></a></h4><h5 id="Powers-of-Ideal"><a class="docs-heading-anchor" href="#Powers-of-Ideal">Powers of Ideal</a><a id="Powers-of-Ideal-1"></a><a class="docs-heading-anchor-permalink" href="#Powers-of-Ideal" title="Permalink"></a></h5><article class="docstring"><header><a class="docstring-binding" id="^-Tuple{MPolyQuoIdeal, Int64}" href="#^-Tuple{MPolyQuoIdeal, Int64}"><code>^</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:^(a::MPolyQuoIdeal, m::Int)</code></pre><p>Return the <code>m</code>-th power of <code>a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, [x^2-y, y^2-x+y]);

julia&gt; a = ideal(A, [x+y])
ideal(x + y)

julia&gt; a^2
ideal(x^2 + 2*x*y + y^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L256-L273">source</a></section></article><h5 id="Sum-of-Ideals"><a class="docs-heading-anchor" href="#Sum-of-Ideals">Sum of Ideals</a><a id="Sum-of-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Sum-of-Ideals" title="Permalink"></a></h5><article class="docstring"><header><a class="docstring-binding" id="+-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T" href="#+-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T"><code>+</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:+(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T</code></pre><p>Return the sum of <code>a</code> and <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, [x^2-y, y^2-x+y]);

julia&gt; a = ideal(A, [x+y])
ideal(x + y)

julia&gt; b = ideal(A, [x^2+y^2, x+y])
ideal(x^2 + y^2, x + y)

julia&gt; a+b
ideal(x + y, x^2 + y^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L279-L299">source</a></section></article><h5 id="Product-of-Ideals"><a class="docs-heading-anchor" href="#Product-of-Ideals">Product of Ideals</a><a id="Product-of-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Product-of-Ideals" title="Permalink"></a></h5><article class="docstring"><header><a class="docstring-binding" id="*-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T" href="#*-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T"><code>*</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:*(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T</code></pre><p>Return the product of <code>a</code> and <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, [x^2-y, y^2-x+y]);

julia&gt; a = ideal(A, [x+y])
ideal(x + y)

julia&gt; b = ideal(A, [x^2+y^2, x+y])
ideal(x^2 + y^2, x + y)

julia&gt; a*b
ideal(x^3 + x^2*y + x*y^2 + y^3, x^2 + 2*x*y + y^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L307-L327">source</a></section></article><h4 id="Intersection-of-Ideals"><a class="docs-heading-anchor" href="#Intersection-of-Ideals">Intersection of Ideals</a><a id="Intersection-of-Ideals-1"></a><a class="docs-heading-anchor-permalink" href="#Intersection-of-Ideals" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="intersect-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, Vararg{MPolyQuoIdeal{T}, N} where N}} where T" href="#intersect-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, Vararg{MPolyQuoIdeal{T}, N} where N}} where T"><code>intersect</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersect(a::MPolyQuoIdeal{T}, bs::MPolyQuoIdeal{T}...) where T</code></pre><p>Return the intersection of two or more ideals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));

julia&gt; a = ideal(A, [y^2])
ideal(y^2)

julia&gt; b = ideal(A, [x])
ideal(x)

julia&gt; intersect(a,b)
ideal(x*y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L335-L355">source</a></section></article><h4 id="Ideal-Quotients"><a class="docs-heading-anchor" href="#Ideal-Quotients">Ideal Quotients</a><a id="Ideal-Quotients-1"></a><a class="docs-heading-anchor-permalink" href="#Ideal-Quotients" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="quotient-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T" href="#quotient-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T"><code>quotient</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quotient(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T</code></pre><p>Return the ideal quotient of <code>a</code> by <code>b</code>. Alternatively, use <code>a:b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));

julia&gt; a = ideal(A, [y^2])
ideal(y^2)

julia&gt; b = ideal(A, [x])
ideal(x)

julia&gt; a:b
ideal(y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L370-L390">source</a></section></article><h3 id="Tests-on-Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Tests-on-Ideals-in-Affine-Algebras">Tests on Ideals in Affine Algebras</a><a id="Tests-on-Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-on-Ideals-in-Affine-Algebras" title="Permalink"></a></h3><h4 id="Basic-Tests"><a class="docs-heading-anchor" href="#Basic-Tests">Basic Tests</a><a id="Basic-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Tests" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="is_zero-Tuple{MPolyQuoIdeal}" href="#is_zero-Tuple{MPolyQuoIdeal}"><code>is_zero</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_zero(a::MPolyQuoIdeal)</code></pre><p>Return <code>true</code> if <code>a</code> is the zero ideal, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, [x^2-y, y^2-x+y]);

julia&gt; a = ideal(A, [x^2+y^2, x+y])
ideal(x^2 + y^2, x + y)

julia&gt; is_zero(a)
false

julia&gt; b = ideal(A, [x^2-y])
ideal(x^2 - y)

julia&gt; is_zero(b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L417-L440">source</a></section></article><h4 id="Containment-of-Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Containment-of-Ideals-in-Affine-Algebras">Containment of Ideals in Affine Algebras</a><a id="Containment-of-Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Containment-of-Ideals-in-Affine-Algebras" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="is_subset-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T" href="#is_subset-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T"><code>is_subset</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_subset(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T</code></pre><p>Return <code>true</code> if <code>a</code> is contained in <code>b</code>, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));

julia&gt; a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])
ideal(x^3*y^4 - x + y, x*y^2 + x*y)

julia&gt; b = ideal(A, [x^3*y^3-x+y, x^2*y+y^2*x])
ideal(x^3*y^3 - x + y, x^2*y + x*y^2)

julia&gt; is_subset(a,b)
false

julia&gt; is_subset(b,a)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L637-L660">source</a></section></article><h4 id="Equality-of-Ideals-in-Affine-Algebras"><a class="docs-heading-anchor" href="#Equality-of-Ideals-in-Affine-Algebras">Equality of Ideals in Affine Algebras</a><a id="Equality-of-Ideals-in-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Equality-of-Ideals-in-Affine-Algebras" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="==-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T" href="#==-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T"><code>==</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T</code></pre><p>Return <code>true</code> if <code>a</code> is equal to <code>b</code>, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));

julia&gt; a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])
ideal(x^3*y^4 - x + y, x*y^2 + x*y)

julia&gt; b = ideal(A, [x^3*y^3-x+y, x^2*y+y^2*x])
ideal(x^3*y^3 - x + y, x^2*y + x*y^2)

julia&gt; a == b
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L668-L688">source</a></section></article><h4 id="Ideal-Membership"><a class="docs-heading-anchor" href="#Ideal-Membership">Ideal Membership</a><a id="Ideal-Membership-1"></a><a class="docs-heading-anchor-permalink" href="#Ideal-Membership" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="ideal_membership-Union{Tuple{T}, Tuple{MPolyQuoRingElem{T}, MPolyQuoIdeal{T}}} where T" href="#ideal_membership-Union{Tuple{T}, Tuple{MPolyQuoRingElem{T}, MPolyQuoIdeal{T}}} where T"><code>ideal_membership</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ideal_membership(f::MPolyQuoRingElem{T}, a::MPolyQuoIdeal{T}) where T</code></pre><p>Return <code>true</code> if <code>f</code> is contained in <code>a</code>, <code>false</code> otherwise. Alternatively, use <code>f in a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));

julia&gt; a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])
ideal(x^3*y^4 - x + y, x*y^2 + x*y)

julia&gt; f = A(x^2*y^3-x+y)
x^2*y^3 - x + y

julia&gt; f in a
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyQuo.jl#L605-L625">source</a></section></article><h2 id="Homomorphisms-From-Affine-Algebras"><a class="docs-heading-anchor" href="#Homomorphisms-From-Affine-Algebras">Homomorphisms From Affine Algebras</a><a id="Homomorphisms-From-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Homomorphisms-From-Affine-Algebras" title="Permalink"></a></h2><p>If <span>$A=R/I$</span> is an affine <span>$C$</span>-algebra, and <span>$S$</span> is any ring, then defining a ring homomorphism <span>$\overline{\phi}: A \to S$</span> means to define a ring homomorphism <span>$\phi: R \to S$</span> such that <span>$I\subset \ker(\phi)$</span>. Thus, <span>$\overline{\phi} $ is determined by specifying its restriction to $C$</span>, and by assigning an image to each generator of <span>$A$</span>. In OSCAR, such homomorphisms are created as follows:</p><article class="docstring"><header><a class="docstring-binding" id="hom-Tuple{MPolyQuoRing, AbstractAlgebra.NCRing, Any, Vector{T} where T}" href="#hom-Tuple{MPolyQuoRing, AbstractAlgebra.NCRing, Any, Vector{T} where T}"><code>hom</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hom(A::MPolyQuoRing, S::NCRing, coeff_map, images::Vector; check::Bool = true)

hom(A::MPolyQuoRing, S::NCRing, images::Vector; check::Bool = true)</code></pre><p>Given a homomorphism <code>coeff_map</code> from <code>C</code> to <code>S</code>, where <code>C</code> is the  coefficient ring of the base ring of <code>A</code>, and given a vector <code>images</code> of <code>ngens(A)</code>  elements of <code>S</code>, return the homomorphism <code>A</code> <span>$\to$</span> <code>S</code> whose restriction  to <code>C</code> is <code>coeff_map</code>, and which sends the <code>i</code>-th generator of <code>A</code> to the  <code>i</code>-th entry of <code>images</code>.</p><p>If no coefficient map is entered, invoke a canonical homomorphism of <code>C</code> to <code>S</code>, if such a homomorphism exists, and throw an error, otherwise.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function returns a well-defined homomorphism <code>A</code> <span>$\to$</span> <code>S</code> iff the given data defines a homomorphism from the base ring of <code>A</code> to <code>S</code> whose kernel contains the modulus of <code>A</code>. This condition is checked by the  function in case <code>check = true</code> (default).</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In case <code>check = true</code> (default), the function also checks the conditions below:</p><ul><li>If <code>S</code> is graded, the assigned images must be homogeneous with respect to the given grading.</li><li>If <code>S</code> is noncommutative, the assigned images must pairwise commute. </li></ul></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] );

julia&gt; A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));

julia&gt; S, (s, t) = polynomial_ring(QQ, [&quot;s&quot;, &quot;t&quot;]);

julia&gt; F = hom(A, S, [s, s^2, s^3])
Map with following data
Domain:
=======
Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x^2 + y, -x^3 + z)
Codomain:
=========
Multivariate Polynomial Ring in s, t over Rational Field</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyMap/MPolyQuo.jl#L35-L77">source</a></section></article><p>Given a ring homomorphism <code>F</code> : <code>R</code> <span>$\to$</span> <code>S</code> as above, <code>domain(F)</code> and <code>codomain(F)</code> refer to <code>R</code> and <code>S</code>, respectively. Given ring homomorphisms <code>F</code> : <code>R</code> <span>$\to$</span> <code>S</code> and <code>G</code> : <code>S</code> <span>$\to$</span> <code>T</code> as above, <code>compose(F, G)</code> refers to their composition.</p><h2 id="Homomorphisms-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Homomorphisms-of-Affine-Algebras">Homomorphisms of Affine Algebras</a><a id="Homomorphisms-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Homomorphisms-of-Affine-Algebras" title="Permalink"></a></h2><p>The OSCAR homomorphism type <code>AffAlgHom</code> models ring homomorphisms <code>R</code> <span>$\to$</span> <code>S</code> such that the type of both <code>R</code> and <code>S</code>  is a subtype of <code>Union{MPolyRing{T}, MPolyQuoRing{U}}</code>, where <code>T &lt;: FieldElem</code> and <code>U &lt;: MPolyRingElem{T}</code>. Functionality for these homomorphism is discussed in what follows.</p><h3 id="Data-Associated-to-Homomorphisms-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Data-Associated-to-Homomorphisms-of-Affine-Algebras">Data Associated to Homomorphisms of Affine Algebras</a><a id="Data-Associated-to-Homomorphisms-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Associated-to-Homomorphisms-of-Affine-Algebras" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="preimage-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}, MPolyIdeal}" href="#preimage-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}, MPolyIdeal}"><code>preimage</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preimage(F::AffAlgHom, I::U) where U &lt;: Union{MPolyIdeal, MPolyQuoIdeal}</code></pre><p>Return the preimage of the ideal <code>I</code> under <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyMap/AffineAlgebras.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="kernel-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}}" href="#kernel-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}}"><code>kernel</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kernel(F::AffAlgHom)</code></pre><p>Return the kernel of <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyMap/AffineAlgebras.jl#L44-L48">source</a></section></article><h6 id="Examples-4"><a class="docs-heading-anchor" href="#Examples-4">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-4" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; D1, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; C1, (s,t) = graded_polynomial_ring(QQ, [&quot;s&quot;, &quot;t&quot;]);

julia&gt; V1 = [s^3, s^2*t, s*t^2, t^3];

julia&gt; para = hom(D1, C1, V1)
Map with following data
Domain:
=======
Multivariate Polynomial Ring in w, x, y, z over Rational Field graded by
  w -&gt; [1]
  x -&gt; [1]
  y -&gt; [1]
  z -&gt; [1]
Codomain:
=========
Multivariate Polynomial Ring in s, t over Rational Field graded by
  s -&gt; [1]
  t -&gt; [1]

julia&gt; twistedCubic = kernel(para)
ideal(-x*z + y^2, -w*z + x*y, -w*y + x^2)

julia&gt; C2, p2 = quo(D1, twistedCubic);

julia&gt; D2, (a, b, c) = graded_polynomial_ring(QQ, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);

julia&gt; V2 = [p2(w-y), p2(x), p2(z)];

julia&gt; proj = hom(D2, C2, V2)
Map with following data
Domain:
=======
Multivariate Polynomial Ring in a, b, c over Rational Field graded by
  a -&gt; [1]
  b -&gt; [1]
  c -&gt; [1]
Codomain:
=========
Quotient of Multivariate Polynomial Ring in w, x, y, z over Rational Field graded by
  w -&gt; [1]
  x -&gt; [1]
  y -&gt; [1]
  z -&gt; [1] by ideal(-x*z + y^2, -w*z + x*y, -w*y + x^2)

julia&gt; nodalCubic = kernel(proj)
ideal(-a^2*c + b^3 - 2*b^2*c + b*c^2)
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; D3,y = polynomial_ring(QQ, &quot;y&quot; =&gt; 1:3);

julia&gt; C3, x = polynomial_ring(QQ, &quot;x&quot; =&gt; 1:3);

julia&gt; V3 = [x[1]*x[2], x[1]*x[3], x[2]*x[3]];

julia&gt; F3 = hom(D3, C3, V3)
Map with following data
Domain:
=======
Multivariate Polynomial Ring in y[1], y[2], y[3] over Rational Field
Codomain:
=========
Multivariate Polynomial Ring in x[1], x[2], x[3] over Rational Field

julia&gt; sphere = ideal(C3, [x[1]^3 + x[2]^3  + x[3]^3 - 1])
ideal(x[1]^3 + x[2]^3 + x[3]^3 - 1)

julia&gt; steinerRomanSurface = preimage(F3, sphere)
ideal(y[1]^6*y[2]^6 + 2*y[1]^6*y[2]^3*y[3]^3 + y[1]^6*y[3]^6 + 2*y[1]^3*y[2]^6*y[3]^3 + 2*y[1]^3*y[2]^3*y[3]^6 - y[1]^3*y[2]^3*y[3]^3 + y[2]^6*y[3]^6)
</code></pre><h3 id="Tests-on-Homomorphisms-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Tests-on-Homomorphisms-of-Affine-Algebras">Tests on Homomorphisms of Affine Algebras</a><a id="Tests-on-Homomorphisms-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-on-Homomorphisms-of-Affine-Algebras" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="is_injective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}}" href="#is_injective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}}"><code>is_injective</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_injective(F::AffAlgHom)</code></pre><p>Return <code>true</code> if <code>F</code> is injective, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyMap/AffineAlgebras.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_surjective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}}" href="#is_surjective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}}"><code>is_surjective</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_surjective(F::AffAlgHom)</code></pre><p>Return <code>true</code> if <code>F</code> is surjective, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyMap/AffineAlgebras.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_bijective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}}" href="#is_bijective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}}"><code>is_bijective</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_bijective(F::AffAlgHom)</code></pre><p>Return <code>true</code> if <code>F</code> is bijective, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyMap/AffineAlgebras.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="is_finite-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}}" href="#is_finite-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}}"><code>is_finite</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_finite(F::AffAlgHom)</code></pre><p>Return <code>true</code> if <code>F</code> is finite, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyMap/AffineAlgebras.jl#L143-L147">source</a></section></article><h6 id="Examples-5"><a class="docs-heading-anchor" href="#Examples-5">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-5" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; D, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; S, (a, b, c) = polynomial_ring(QQ, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);

julia&gt; C, p = quo(S, ideal(S, [c-b^3]));

julia&gt; V = [p(2*a + b^6), p(7*b - a^2), p(c^2)];

julia&gt; F = hom(D, C, V)
Map with following data
Domain:
=======
Multivariate Polynomial Ring in x, y, z over Rational Field
Codomain:
=========
Quotient of Multivariate Polynomial Ring in a, b, c over Rational Field by ideal(-b^3 + c)

julia&gt; is_surjective(F)
true

julia&gt; D1, _ = quo(D, kernel(F));

julia&gt; F1 = hom(D1, C, V);

julia&gt; is_bijective(F1)
true
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [ &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; C, (s, t) = polynomial_ring(QQ, [&quot;s&quot;, &quot;t&quot;]);

julia&gt; V = [s*t, t, s^2];

julia&gt; paraWhitneyUmbrella = hom(R, C, V)
Map with following data
Domain:
=======
Multivariate Polynomial Ring in x, y, z over Rational Field
Codomain:
=========
Multivariate Polynomial Ring in s, t over Rational Field

julia&gt; D, _ = quo(R, kernel(paraWhitneyUmbrella));

julia&gt; is_finite(hom(D, C, V))
true</code></pre><h3 id="Inverting-Homomorphisms-of-Affine-Algebras"><a class="docs-heading-anchor" href="#Inverting-Homomorphisms-of-Affine-Algebras">Inverting Homomorphisms of Affine Algebras</a><a id="Inverting-Homomorphisms-of-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Inverting-Homomorphisms-of-Affine-Algebras" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="inverse-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}}" href="#inverse-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T&lt;:FieldElem, U&lt;:MPolyRingElem{T}, DT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, CT&lt;:Union{MPolyRing{T}, MPolyQuoRing{U}}, V}}"><code>inverse</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse(F::AffAlgHom)</code></pre><p>If <code>F</code> is bijective, return its inverse.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D1, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; D, _ = quo(D1, [y-x^2, z-x^3]);

julia&gt; C, (t,) = polynomial_ring(QQ, [&quot;t&quot;]);

julia&gt; F = hom(D, C, [t, t^2, t^3]);

julia&gt; is_bijective(F)
true

julia&gt; G = inverse(F)
Map with following data
Domain:
=======
Multivariate Polynomial Ring in t over Rational Field
Codomain:
=========
Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x^2 + y, -x^3 + z)

julia&gt; G(t)
x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/MPolyMap/AffineAlgebras.jl#L174-L204">source</a></section></article><h2 id="Subalgebras"><a class="docs-heading-anchor" href="#Subalgebras">Subalgebras</a><a id="Subalgebras-1"></a><a class="docs-heading-anchor-permalink" href="#Subalgebras" title="Permalink"></a></h2><h3 id="Subalgebra-Membership"><a class="docs-heading-anchor" href="#Subalgebra-Membership">Subalgebra Membership</a><a id="Subalgebra-Membership-1"></a><a class="docs-heading-anchor-permalink" href="#Subalgebra-Membership" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="subalgebra_membership-Union{Tuple{T}, Tuple{T, Vector{T}}} where T&lt;:Union{MPolyRingElem, MPolyQuoRingElem}" href="#subalgebra_membership-Union{Tuple{T}, Tuple{T, Vector{T}}} where T&lt;:Union{MPolyRingElem, MPolyQuoRingElem}"><code>subalgebra_membership</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subalgebra_membership(f::T, V::Vector{T}) where T &lt;: Union{MPolyRingElem, MPolyQuoRingElem}</code></pre><p>Given an element <code>f</code> of a multivariate polynomial ring over a field, or of a quotient of such a ring,  and given a vector <code>V</code> of further elements of that ring, consider the subalgebra generated by the entries  of <code>V</code> in the given ring. If <code>f</code> is contained in the subalgebra, return <code>(true, h)</code>, where <code>h</code> is giving  the polynomial relation. Return, <code>(false, 0)</code>, otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, x = polynomial_ring(QQ, &quot;x&quot; =&gt; 1:3);

julia&gt; f = x[1]^6*x[2]^6-x[1]^6*x[3]^6;

julia&gt; V = [x[1]^3*x[2]^3-x[1]^3*x[3]^3, x[1]^3*x[2]^3+x[1]^3*x[3]^3]
2-element Vector{QQMPolyRingElem}:
 x[1]^3*x[2]^3 - x[1]^3*x[3]^3
 x[1]^3*x[2]^3 + x[1]^3*x[3]^3

julia&gt; subalgebra_membership(f, V)
(true, t_1*t_2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L873-L895">source</a></section></article><h3 id="Minimal-Subalgebra-Generators"><a class="docs-heading-anchor" href="#Minimal-Subalgebra-Generators">Minimal Subalgebra Generators</a><a id="Minimal-Subalgebra-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-Subalgebra-Generators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="minimal_subalgebra_generators-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{MPolyRingElem, MPolyQuoRingElem}" href="#minimal_subalgebra_generators-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{MPolyRingElem, MPolyQuoRingElem}"><code>minimal_subalgebra_generators</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimal_subalgebra_generators(V::Vector{T}) where T &lt;: Union{MPolyRingElem, MPolyQuoRingElem}</code></pre><p>Given a vector <code>V</code> of homogeneous elements of a positively graded multivariate  polynomial ring, or of a quotient of such a ring, return a minimal subset of the  elements in <code>V</code> which, in the given ring, generate  the same subalgebra as all elements in <code>V</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The conditions on <code>V</code> and the given ring are automatically checked.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; V = [x, y, x^2+y^2]
3-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x
 y
 x^2 + y^2

julia&gt; minimal_subalgebra_generators(V)
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x
 y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L994-L1021">source</a></section></article><h2 id="Noether-Normalization"><a class="docs-heading-anchor" href="#Noether-Normalization">Noether Normalization</a><a id="Noether-Normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Noether-Normalization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="noether_normalization-Tuple{MPolyQuoRing}" href="#noether_normalization-Tuple{MPolyQuoRing}"><code>noether_normalization</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noether_normalization(A::MPolyQuoRing)</code></pre><p>Given an affine algebra <span>$A=R/I$</span> over a field <span>$K$</span>, return a triple <span>$(V,F,G)$</span> such that:</p><ul><li><span>$V$</span> is a vector of <span>$d=\dim A$</span> elements of <span>$A$</span>, represented by linear forms <span>$l_i\in R$</span>, and such that <span>$K[V]\hookrightarrow A$</span> is a Noether normalization for <span>$A$</span>; </li><li><span>$F: A=R/I \to B = R/\phi(I)$</span> is an isomorphism, induced by a linear change $ \phi $ of coordinates of <span>$R$</span> which maps the <span>$l_i$</span> to the the last <span>$d$</span> variables of <span>$R$</span>; </li><li><span>$G = F^{-1}.$</span></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The algorithm may not terminate over a small finite field. If it terminates, the result is correct.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L1217-L1228">source</a></section></article><h6 id="Examples-6"><a class="docs-heading-anchor" href="#Examples-6">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-6" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x*y, x*z]));

julia&gt; L = noether_normalization(A);

julia&gt; L[1]
2-element Vector{MPolyQuoRingElem{QQMPolyRingElem}}:
 -2*x + y
 -5*y + z

julia&gt; L[2]
Map with following data
Domain:
=======
Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(x*y, x*z)
Codomain:
=========
Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(2*x^2 + x*y, 10*x^2 + 5*x*y + x*z)

julia&gt; L[3]
Map with following data
Domain:
=======
Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(2*x^2 + x*y, 10*x^2 + 5*x*y + x*z)
Codomain:
=========
Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(x*y, x*z)
</code></pre><h2 id="Normalization"><a class="docs-heading-anchor" href="#Normalization">Normalization</a><a id="Normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Normalization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="normalization-Tuple{MPolyQuoRing}" href="#normalization-Tuple{MPolyQuoRing}"><code>normalization</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalization(A::MPolyQuoRing; alg = :equidimDec)</code></pre><p>Find the normalization of a reduced affine algebra over a perfect field <span>$K$</span>. That is, given the quotient <span>$A=R/I$</span> of a multivariate polynomial ring <span>$R$</span> over <span>$K$</span> modulo a radical ideal <span>$I$</span>, compute the integral closure <span>$\overline{A}$</span>  of <span>$A$</span> in its total ring of fractions <span>$Q(A)$</span>, together with the embedding  <span>$f: A \to \overline{A}$</span>. </p><p><strong>Implemented Algorithms and how to Read the Output</strong></p><p>The function relies on the algorithm  of Greuel, Laplagne, and Seelisch which proceeds by finding a suitable decomposition  <span>$I=I_1\cap\dots\cap I_r$</span> into radical ideals <span>$I_k$</span>, together with maps <span>$A = R/I \to A_k=\overline{R/I_k}$</span> which give rise to the normalization map of <span>$A$</span>:</p><p class="math-container">\[A\hookrightarrow A_1\times \dots\times A_r=\overline{A}\]</p><p>For each <span>$k$</span>, the function specifies two representations of <span>$A_k$</span>: It returns an array of triples <span>$(A_k, f_k, \mathfrak a_k)$</span>, where <span>$A_k$</span> is represented as an affine <span>$K$</span>-algebra, and <span>$f_k$</span> as a map of affine <span>$K$</span>-algebras. The third entry <span>$\mathfrak a_k$</span> is a tuple <span>$(d_k, J_k)$</span>, consisting of an element <span>$d_k\in A$</span> and an ideal <span>$J_k\subset A$</span>, such that <span>$\frac{1}{d_k}J_k = A_k$</span>  as <span>$A$</span>-submodules of the total ring of fractions of <span>$A$</span>.</p><p>By default (<code>alg = :equidimDec</code>), as a first step on its way to find the decomposition <span>$I=I_1\cap\dots\cap I_r$</span>,  the algorithm computes an equidimensional decomposition of the radical ideal <span>$I$</span>. Alternatively, if specified by <code>alg = :primeDec</code>, the algorithm computes <span>$I=I_1\cap\dots\cap I_r$</span> as the prime decomposition of the radical ideal <span>$I$</span>.</p><p>See <a href="../../references/#GLS10">Gert-Martin Greuel, Santiago Laplagne, Frank Seelisch (2010)</a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The function does not check whether <span>$A$</span> is reduced. Use <code>is_reduced(A)</code> in case you are unsure (this may take some time).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [(x^2-y^3)*(x^2+y^2)*x]));

julia&gt; L = normalization(A);

julia&gt; size(L)
(2,)

julia&gt; LL = normalization(A, alg = :primeDec);

julia&gt; size(LL)
(3,)

julia&gt; LL[1][1]
Quotient of Multivariate Polynomial Ring in T(1), x, y over Rational Field by ideal(-T(1)*y + x, -T(1)*x + y^2, T(1)^2 - y, -x^2 + y^3)

julia&gt; LL[1][2]
Map with following data
Domain:
=======
Quotient of Multivariate Polynomial Ring in x, y over Rational Field by ideal(x^5 - x^3*y^3 + x^3*y^2 - x*y^5)
Codomain:
=========
Quotient of Multivariate Polynomial Ring in T(1), x, y over Rational Field by ideal(-T(1)*y + x, -T(1)*x + y^2, T(1)^2 - y, -x^2 + y^3)

julia&gt; LL[1][3]
(y, ideal(x, y))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L1072-L1138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="normalization_with_delta-Tuple{MPolyQuoRing}" href="#normalization_with_delta-Tuple{MPolyQuoRing}"><code>normalization_with_delta</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalization_with_delta(A::MPolyQuoRing; alg = :equidimDec)</code></pre><p>Compute the normalization</p><p class="math-container">\[A\hookrightarrow A_1\times \dots\times A_r=\overline{A}\]</p><p>of <span>$A$</span> as does <code>normalize(A)</code>, but return additionally the <code>delta invariant</code> of <span>$A$</span>, that is, the dimension </p><p class="math-container">\[\dim_K(\overline{A}/A)\]</p><p>. </p><p><strong>How to Read the Output</strong></p><p>The return value is a tuple whose first element is <code>normalize(A)</code>, whose second element is an array containing the delta invariants of the <span>$A_k$</span>, and whose third element is the (total) delta invariant of <span>$A$</span>. The return value -1 in the third element indicates that the delta invariant is infinite.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [(x^2-y^3)*(x^2+y^2)*x]));

julia&gt; L = normalization_with_delta(A);

julia&gt; L[2]
3-element Vector{Int64}:
 1
 1
 0

julia&gt; L[3]
13</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [z^3-x*y^4]));

julia&gt; L = normalization_with_delta(A);

julia&gt; L[3]
-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L1151-L1197">source</a></section></article><h2 id="Integral-Bases"><a class="docs-heading-anchor" href="#Integral-Bases">Integral Bases</a><a id="Integral-Bases-1"></a><a class="docs-heading-anchor-permalink" href="#Integral-Bases" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="integral_basis-Tuple{MPolyRingElem, Int64}" href="#integral_basis-Tuple{MPolyRingElem, Int64}"><code>integral_basis</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integral_basis(f::MPolyRingElem, i::Int; alg = :normal_local)</code></pre><p>Given a polynomial <span>$f$</span> in two variables with coefficients in a perfect field <span>$K$</span>, and given an integer <span>$i\in\{1,2\}$</span> specifying one of the variables, <span>$f$</span> must be irreducible and monic in the specified variable: Say, <span>$f\in\mathbb K[x,y]$</span> is monic in <span>$y$</span>. Then the normalization of <span>$A = K[x,y]/\langle f \rangle$</span>, that is, the integral closure <span>$\overline{A}$</span> of <span>$A$</span> in its quotient field, is a free module over <span>$K[x]$</span> of finite rank, and any set of free generators for <span>$\overline{A}$</span> over <span>$K[x]$</span> is called an <em>integral basis</em> for <span>$\overline{A}$</span> over <span>$K[x]$</span>. The function returns a pair <span>$(d, V)$</span>, where <span>$d$</span> is an element of <span>$A$</span>, and <span>$V$</span> is a vector of elements in <span>$A$</span>, such that the fractions <span>$v/d, v\in V$</span>, form an integral basis for <span>$\overline{A}$</span> over <span>$K[x]$</span>.</p><p>By default (<code>alg = :normal_local</code>), the function relies on the local-to-global approach to normalization presented in <a href="../../references/#BDLPSS13">Janko BÃ¶hm, Wolfram Decker, Santiago Laplagne, Gerhard Pfister, Andreas SteenpaÃ, Stefan Steidel (2013)</a>. Alternatively, if specified by <code>alg = :normal_global</code>, the global normalization algorithm in <a href="../../references/#GLS10">Gert-Martin Greuel, Santiago Laplagne, Frank Seelisch (2010)</a> is used. If <span>$K = \mathbb Q$</span>, it is recommended to apply the algorithm in <a href="../../references/#BDLP19">Janko BÃ¶hm, Wolfram Decker, Santiago Laplagne, Gerhard Pfister (2019)</a>, which makes use of Puiseux expansions and Hensel lifting (<code>alg = :hensel</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The conditions on <span>$f$</span> are automatically checked.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; f = (y^2-2)^2 + x^5
x^5 + y^4 - 4*y^2 + 4

julia&gt; integral_basis(f, 2)
(x^2, MPolyQuoRingElem{QQMPolyRingElem}[x^2, x^2*y, y^2 - 2, y^3 - 2*y])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L1260-L1294">source</a></section></article><h2 id="Tests-on-Affine-Algebras"><a class="docs-heading-anchor" href="#Tests-on-Affine-Algebras">Tests on Affine Algebras</a><a id="Tests-on-Affine-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-on-Affine-Algebras" title="Permalink"></a></h2><h3 id="Reducedness-Test"><a class="docs-heading-anchor" href="#Reducedness-Test">Reducedness Test</a><a id="Reducedness-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Reducedness-Test" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="is_reduced-Tuple{MPolyQuoRing}" href="#is_reduced-Tuple{MPolyQuoRing}"><code>is_reduced</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_reduced(A::MPolyQuoRing)</code></pre><p>Given an affine algebra <code>A</code>, return <code>true</code> if <code>A</code> is reduced, <code>false</code> otherwise.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The function computes the radical of the modulus of <code>A</code>. This may take some time.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x,) = polynomial_ring(QQ, [&quot;x&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [x^4]));

julia&gt; is_reduced(A)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L724-L741">source</a></section></article><h3 id="Normality-Test"><a class="docs-heading-anchor" href="#Normality-Test">Normality Test</a><a id="Normality-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Normality-Test" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="is_normal-Tuple{MPolyQuoRing}" href="#is_normal-Tuple{MPolyQuoRing}"><code>is_normal</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_normal(A::MPolyQuoRing)</code></pre><p>Given an affine algebra <code>A</code> over a perfect field, return <code>true</code> if <code>A</code> is normal, <code>false</code> otherwise.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function performs the first step of the normalization algorithm of Greuel, Laplagne, and Seelisch <a href="../../references/#GLS10">Gert-Martin Greuel, Santiago Laplagne, Frank Seelisch (2010)</a> and may, thus, be more efficient than computing the full normalization of <code>A</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [z^2-x*y]));

julia&gt; is_normal(A)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L747-L765">source</a></section></article><h3 id="Cohen-Macaulayness-Test"><a class="docs-heading-anchor" href="#Cohen-Macaulayness-Test">Cohen-Macaulayness Test</a><a id="Cohen-Macaulayness-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Cohen-Macaulayness-Test" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="is_cohen_macaulay-Tuple{MPolyQuoRing}" href="#is_cohen_macaulay-Tuple{MPolyQuoRing}"><code>is_cohen_macaulay</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> is_cohen_macaulay(A::MPolyQuoRing)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <code>A = R/I</code> over a field, say, <code>K</code>, where the grading  is inherited from the standard <span>$\mathbb Z$</span>-grading on the polynomial ring <code>R</code>, return <code>true</code> if <code>A</code> is a Cohen-Macaulay ring, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; I = ideal(R, [x*z-y^2, w*z-x*y, w*y-x^2]);

julia&gt; A, _ = quo(R, I);

julia&gt; is_cohen_macaulay(A)
true</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; I = ideal(R, [x*z, y*z]);

julia&gt; A, _ = quo(R, I);

julia&gt; is_cohen_macaulay(A)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L782-L811">source</a></section></article><h2 id="Hilbert-Series-and-Hilbert-Polynomial"><a class="docs-heading-anchor" href="#Hilbert-Series-and-Hilbert-Polynomial">Hilbert Series and Hilbert Polynomial</a><a id="Hilbert-Series-and-Hilbert-Polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#Hilbert-Series-and-Hilbert-Polynomial" title="Permalink"></a></h2><p>Given a multivariate polynomial ring <span>$R$</span> over a field <span>$K$</span> together with a (multi)grading on <span>$R$</span> by a finitely generated abelian group <span>$G$</span>, let <span>$I$</span> be an ideal of <span>$R$</span> which is homogeneous with respect to this grading. Then the affine <span>$K-$</span>algebra <span>$A=R/I$</span> inherits the grading: <span>$A = \bigoplus_{g\in G} A_g$</span>. Suppose now that <span>$R$</span> is positively graded by <span>$G$</span>. That is, <span>$G$</span> is free and each graded piece <span>$R_g$</span> has finite dimension. Then also <span>$A_g$</span> is a finite dimensional <span>$K$</span>-vector space for each <span>$g$</span>, and we have the well-defined <em>Hilbert function</em> of <span>$A$</span>,</p><p class="math-container">\[H(A, \underline{\phantom{d}}): G \to \N, \; g\mapsto \dim_K(A_g).\]</p><p>The <em>Hilbert series</em> of <span>$A$</span> is the generating function </p><p class="math-container">\[H_A(\mathbb t)=\sum_{g\in G} H(A, g) \mathbb t^g\]</p><p>(see  Section 8.2 in <a href="../../references/#MS05">Ezra Miller, Bernd Sturmfels (2005)</a> for a formal discussion extending the classical case of <span>$\mathbb Z$</span>-gradings with positive weights to the more general case of multigradings). As in the classical case, the infinitely many values of the Hilbert function can be expressed in finite terms by representing the Hilbert series as a rational function (see Theorem 8.20 in <a href="../../references/#MS05">Ezra Miller, Bernd Sturmfels (2005)</a> for a precise statement).</p><p>By a result of Macaulay, if <span>$A = R/I$</span> is an affine algebra, and <span>$L_{&gt;}(I)$</span> is the leading ideal of <span>$I$</span> with respect to a global monomial ordering <span>$&gt;$</span>, then the Hilbert function of <span>$A$</span> equals that of <span>$R/L_{&gt;}(I)$</span> (see Theorem 15.26 in <a href="../../references/#Eis95">David Eisenbud (1995)</a>). Thus, using GrÃ¶bner bases, the computation of Hilbert series can be reduced to the case where the modulus of the affine algebra is a monomial ideal. In the latter case, we face a problem  of combinatorial nature, and there are various strategies of how to proceed (see <a href="../../references/#KR05">Martin Kreuzer, Lorenzo Robbiano (2005)</a>). The functions <code>hilbert_series</code>, <code>hilbert_series_reduced</code>, <code>hilbert_series_expanded</code>, <code>hilbert_function</code>, <code>hilbert_polynomial</code>, and <code>degree</code> address the case of <span>$\mathbb Z$</span>-gradings with positive weights, relying on corresponding Singular functionality. The functions <code>multi_hilbert_series</code>, <code>multi_hilbert_series_reduced</code>, and <code>multi_hilbert_function</code> offer a variety of different strategies and allow one to handle positive gradings in general.</p><h3 id="\\mathbb-Z-Gradings-With-Positive-Weights"><a class="docs-heading-anchor" href="#\\mathbb-Z-Gradings-With-Positive-Weights"><span>$\mathbb Z$</span>-Gradings With Positive Weights</a><a id="\\mathbb-Z-Gradings-With-Positive-Weights-1"></a><a class="docs-heading-anchor-permalink" href="#\\mathbb-Z-Gradings-With-Positive-Weights" title="Permalink"></a></h3><p>Let <span>$R=K[x_1, \dots x_n]$</span> be a polynomial ring in <span>$n$</span> variables over a field <span>$K$</span>. Assign positive integer weights <span>$w_i$</span> to the variables <span>$x_i$</span>, and grade <span>$R=\bigoplus_{d\in \mathbb Z} R_d=\bigoplus_{d\geq 0} R_d$</span> according to the corresponding weighted degree. Let <span>$I$</span> be an ideal of <span>$R$</span> which is homogeneous with respect to this grading. Then the affine <span>$K$</span>-algebra <span>$A=R/I$</span> inherits the grading: <span>$A = \bigoplus_{d\geq 0} A_d$</span>, where each graded piece <span>$A_d$</span> is a finite dimensional <span>$K$</span>-vector space. In this situation, the <em>Hilbert function</em> of <span>$A$</span> is of type</p><p class="math-container">\[H(A, \underline{\phantom{d}}): \N \to \N, \;d \mapsto \dim_K(d),\]</p><p>and the <em>Hilbert series</em> of <span>$A$</span> is the formal power series</p><p class="math-container">\[H_A(t)=\sum_{d\geq 0} H(A, d) t^d\in\mathbb Z[[t]].\]</p><p>The Hilbert series can be written as a rational function <span>$p(t)/q(t)$</span>, with denominator</p><p class="math-container">\[q(t) = (1-t^{w_1})\cdots (1-t^{w_n}).\]</p><p>In the standard <span>$\mathbb Z$</span>-graded case, where the weights on the variables are all 1, the Hilbert function is of polynomial nature: There exists  a unique polynomial <span>$P_A(t)\in\mathbb{Q}[t]$</span>, the <em>Hilbert polynomial</em>, which satisfies <span>$H(M,d)=P_M(d)$</span> for all <span>$d \gg 0$</span>. Furthermore, the <em>degree</em> of <span>$A$</span> is defined as the dimension of <span>$A$</span> over <span>$K$</span> if this dimension is finite, and as the integer <span>$d$</span> such that the leading term of the Hilbert polynomial has the form <span>$d t^e/e!$</span>, otherwise.</p><article class="docstring"><header><a class="docstring-binding" id="hilbert_series-Tuple{MPolyQuoRing}" href="#hilbert_series-Tuple{MPolyQuoRing}"><code>hilbert_series</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hilbert_series(A::MPolyQuoRing)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <span>$A = R/I$</span> over a field <span>$K$</span>, where the grading  is inherited from a <span>$\mathbb Z$</span>-grading on the polynomial ring <span>$R$</span> defined by assigning  positive integer weights to the variables, return a pair <span>$(p,q)$</span>, say, of univariate  polynomials <span>$p, q\in\mathbb Z[t]$</span> such that <span>$p/q$</span> represents the Hilbert series of <span>$A$</span> as  a rational function with denominator </p><p class="math-container">\[q = (1-t^{w_1})\cdots (1-t^{w_n}),\]</p><p>where <span>$n$</span> is the number of variables of <span>$R$</span>, and <span>$w_1, \dots, w_n$</span> are the assigned weights.</p><p>See also <code>hilbert_series_reduced</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; hilbert_series(A)
(2*t^3 - 3*t^2 + 1, t^4 - 4*t^3 + 6*t^2 - 4*t + 1)

julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [1, 2, 3]);

julia&gt; A, _ = quo(R, ideal(R, [x*y*z]));

julia&gt; hilbert_series(A)
(-t^6 + 1, -t^6 + t^5 + t^4 - t^2 - t + 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L79-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="hilbert_series_reduced-Tuple{MPolyQuoRing}" href="#hilbert_series_reduced-Tuple{MPolyQuoRing}"><code>hilbert_series_reduced</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hilbert_series_reduced(A::MPolyQuoRing)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <span>$A = R/I$</span> over a field <span>$K$</span>, where the grading  is inherited from a <span>$\mathbb Z$</span>-grading on the polynomial ring <span>$R$</span> defined by assigning  positive integer weights to the variables, return a pair <span>$(p,q)$</span>, say, of univariate  polynomials <span>$p, q\in\mathbb Z[t]$</span> such that <span>$p/q$</span> represents the Hilbert series of  <span>$A$</span> as a rational function written in lowest terms. </p><p>See also <code>hilbert_series</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; hilbert_series_reduced(A)
(2*t + 1, t^2 - 2*t + 1)

julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [1, 2, 3]);

julia&gt; A, _ = quo(R, ideal(R, [x*y*z]));

julia&gt; hilbert_series(A)
(-t^6 + 1, -t^6 + t^5 + t^4 - t^2 - t + 1)

julia&gt; hilbert_series_reduced(A)
(t^2 - t + 1, t^2 - 2*t + 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L123-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="hilbert_series_expanded-Tuple{MPolyQuoRing, Int64}" href="#hilbert_series_expanded-Tuple{MPolyQuoRing, Int64}"><code>hilbert_series_expanded</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hilbert_series_expanded(A::MPolyQuoRing, d::Int)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <span>$A = R/I$</span> over a field <span>$K$</span>, where the grading  is inherited from a <span>$\mathbb Z$</span>-grading on the polynomial ring <span>$R$</span> defined by assigning  positive integer weights to the variables, return the Hilbert series of <span>$A$</span> to precision <span>$d$</span>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; hilbert_series_expanded(A, 7)
1 + 4*t + 7*t^2 + 10*t^3 + 13*t^4 + 16*t^5 + 19*t^6 + 22*t^7 + O(t^8)

julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [1, 2, 3]);

julia&gt; A, _ = quo(R, ideal(R, [x*y*z]));

julia&gt; hilbert_series_expanded(A, 5)
1 + t + 2*t^2 + 3*t^3 + 4*t^4 + 5*t^5 + O(t^6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L162-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="hilbert_function-Tuple{MPolyQuoRing, Int64}" href="#hilbert_function-Tuple{MPolyQuoRing, Int64}"><code>hilbert_function</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hilbert_function(A::MPolyQuoRing, d::Int)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <span>$A = R/I$</span> over a field <span>$K$</span>, where the grading  is inherited from a <span>$\mathbb Z$</span>-grading on the polynomial ring <span>$R$</span> defined by assigning  positive integer weights to the variables, return the value <span>$H(A, d),$</span> where </p><p class="math-container">\[H(A, \underline{\phantom{d}}): \N \to \N, \; d  \mapsto \dim_K A_d,\]</p><p>is the Hilbert function of <span>$A$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; hilbert_function(A,7)
22

julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [1, 2, 3]);

julia&gt; A, _ = quo(R, ideal(R, [x*y*z]));

julia&gt; hilbert_function(A, 5)
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L191-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="hilbert_polynomial-Tuple{MPolyQuoRing}" href="#hilbert_polynomial-Tuple{MPolyQuoRing}"><code>hilbert_polynomial</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> hilbert_polynomial(A::MPolyQuoRing)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <span>$A = R/I$</span> over a field <span>$K$</span>, where the grading  is inherited from the standard <span>$\mathbb Z$</span>-grading on the polynomial ring <span>$R$</span>, return the Hilbert polynomial of <span>$A$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; hilbert_polynomial(A)
3*t + 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L228-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="degree-Tuple{MPolyQuoRing}" href="#degree-Tuple{MPolyQuoRing}"><code>degree</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree(A::MPolyQuoRing)</code></pre><p>Given a <span>$\mathbb Z$</span>-graded affine algebra <span>$A = R/I$</span> over a field <span>$K$</span>, where the grading  is inherited from the standard <span>$\mathbb Z$</span>-grading on the polynomial ring <span>$R$</span>, return the degree of <span>$A$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; degree(A)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L260-L276">source</a></section></article><h3 id="Positive-Gradings-in-General"><a class="docs-heading-anchor" href="#Positive-Gradings-in-General">Positive Gradings in General</a><a id="Positive-Gradings-in-General-1"></a><a class="docs-heading-anchor-permalink" href="#Positive-Gradings-in-General" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="multi_hilbert_series-Tuple{MPolyQuoRing}" href="#multi_hilbert_series-Tuple{MPolyQuoRing}"><code>multi_hilbert_series</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multi_hilbert_series(A::MPolyQuoRing; alg::Symbol=:BayerStillmanA)</code></pre><p>Return the Hilbert series of the positively graded affine algebra <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The advanced user can select a <code>alg</code> for the computation;  see the code for details.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W = [1 1 1; 0 0 -1];

julia&gt; R, x = graded_polynomial_ring(QQ, [&quot;x[1]&quot;, &quot;x[2]&quot;, &quot;x[3]&quot;], W)
(Multivariate Polynomial Ring in x[1], x[2], x[3] over Rational Field graded by
  x[1] -&gt; [1 0]
  x[2] -&gt; [1 0]
  x[3] -&gt; [1 -1], MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3]])

julia&gt; I = ideal(R, [x[1]^3*x[2], x[2]*x[3]^2, x[2]^2*x[3], x[3]^4]);

julia&gt; A, _ = quo(R, I);

julia&gt; H = multi_hilbert_series(A);

julia&gt; H[1][1]
-t[1]^7*t[2]^-2 + t[1]^6*t[2]^-1 + t[1]^6*t[2]^-2 + t[1]^5*t[2]^-4 - t[1]^4 + t[1]^4*t[2]^-2 - t[1]^4*t[2]^-4 - t[1]^3*t[2]^-1 - t[1]^3*t[2]^-2 + 1

julia&gt; H[1][2]
-t[1]^3*t[2]^-1 + t[1]^2 + 2*t[1]^2*t[2]^-1 - 2*t[1] - t[1]*t[2]^-1 + 1

julia&gt; H[2][1]
GrpAb: Z^2

julia&gt; H[2][2]
Identity map with

Domain:
=======
GrpAb: Z^2

julia&gt; G = abelian_group(ZZMatrix([1 -1]));

julia&gt; g = gen(G, 1)
Element of
(General) abelian group with relation matrix
[1 -1]
with components [0 1]

julia&gt; W = [g, g, g, g];

julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;], W);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; H = multi_hilbert_series(A);

julia&gt; H[1][1]
2*t^3 - 3*t^2 + 1

julia&gt; H[1][2]
t^4 - 4*t^3 + 6*t^2 - 4*t + 1

julia&gt; H[2][1]
GrpAb: Z

julia&gt; H[2][2]
Map with following data
Domain:
=======
Abelian group with structure: Z
Codomain:
=========
(General) abelian group with relation matrix
[1 -1]
with structure of Abelian group with structure: Z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L333-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="multi_hilbert_series_reduced-Tuple{MPolyQuoRing}" href="#multi_hilbert_series_reduced-Tuple{MPolyQuoRing}"><code>multi_hilbert_series_reduced</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multi_hilbert_series_reduced(A::MPolyQuoRing; alg::Symbol=:BayerStillmanA)</code></pre><p>Return the reduced Hilbert series of the positively graded affine algebra <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The advanced user can select a <code>alg</code> for the computation;  see the code for details.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W = [1 1 1; 0 0 -1];

julia&gt; R, x = graded_polynomial_ring(QQ, [&quot;x[1]&quot;, &quot;x[2]&quot;, &quot;x[3]&quot;], W)
(Multivariate Polynomial Ring in x[1], x[2], x[3] over Rational Field graded by
  x[1] -&gt; [1 0]
  x[2] -&gt; [1 0]
  x[3] -&gt; [1 -1], MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3]])

julia&gt; I = ideal(R, [x[1]^3*x[2], x[2]*x[3]^2, x[2]^2*x[3], x[3]^4]);

julia&gt; A, _ = quo(R, I);

julia&gt; H = multi_hilbert_series_reduced(A);

julia&gt; H[1][1]
-t[1]^5*t[2]^-1 + t[1]^3 + t[1]^3*t[2]^-3 + t[1]^2 + t[1]^2*t[2]^-1 + t[1]^2*t[2]^-2 + t[1] + t[1]*t[2]^-1 + 1

julia&gt; H[1][2]
-t[1] + 1

julia&gt; H[2][1]
GrpAb: Z^2

julia&gt; H[2][2]
Identity map with

Domain:
=======
GrpAb: Z^2

julia&gt; G = abelian_group(ZZMatrix([1 -1]));

julia&gt; g = gen(G, 1)
Element of
(General) abelian group with relation matrix
[1 -1]
with components [0 1]

julia&gt; W = [g, g, g, g];

julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;], W);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; H = multi_hilbert_series_reduced(A);

julia&gt; H[1][1]
2*t + 1

julia&gt; H[1][2]
t^2 - 2*t + 1

julia&gt; H[2][1]
GrpAb: Z

julia&gt; H[2][2]
Map with following data
Domain:
=======
Abelian group with structure: Z
Codomain:
=========
(General) abelian group with relation matrix
[1 -1]
with structure of Abelian group with structure: Z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L525-L602">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="multi_hilbert_function-Tuple{MPolyQuoRing, GrpAbFinGenElem}" href="#multi_hilbert_function-Tuple{MPolyQuoRing, GrpAbFinGenElem}"><code>multi_hilbert_function</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multi_hilbert_function(A::MPolyQuoRing, g::GrpAbFinGenElem)</code></pre><p>Given a positively graded affine algebra <span>$A$</span> over a field <span>$K$</span> with grading group <span>$G$</span>, say, and given an element <span>$g$</span> of <span>$G$</span>, return the value <span>$H(A, g)$</span> of the Hilbert function</p><p class="math-container">\[H(A, \underline{\phantom{d}}): G \to \N, \; g\mapsto \dim_K(A_g).\]</p><pre><code class="nohighlight hljs">multi_hilbert_function(A::MPolyQuoRing, g::Vector{&lt;:IntegerUnion})</code></pre><p>Given a positively <span>$\mathbb  Z^m$</span>-graded affine algebra <span>$A$</span> over a field <span>$K$</span>, and given a vector <span>$g$</span> of <span>$m$</span> integers, convert <span>$g$</span> into an element  of the grading group of <span>$A$</span>, and return the value <span>$H(A, g)$</span> as above.</p><pre><code class="nohighlight hljs">multi_hilbert_function(A::MPolyQuoRing, g::IntegerUnion)</code></pre><p>Given a positively <span>$\mathbb  Z$</span>-graded affine algebra <span>$A$</span> over a field <span>$K$</span>, and given an integer <span>$g$</span>, convert <span>$g$</span> into an element of the grading group  of <span>$A$</span>, and return the value <span>$H(A, g)$</span> as above.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W = [1 1 1; 0 0 -1];

julia&gt; R, x = graded_polynomial_ring(QQ, [&quot;x[1]&quot;, &quot;x[2]&quot;, &quot;x[3]&quot;], W)
(Multivariate Polynomial Ring in x[1], x[2], x[3] over Rational Field graded by 
  x[1] -&gt; [1 0]
  x[2] -&gt; [1 0]
  x[3] -&gt; [1 -1], MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3]])

julia&gt; I = ideal(R, [x[1]^3*x[2], x[2]*x[3]^2, x[2]^2*x[3], x[3]^4]);

julia&gt; A, _ = quo(R, I);

julia&gt; multi_hilbert_function(A::MPolyQuoRing, [1, 0])
2

julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [-1, -1, -1, -1]);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; multi_hilbert_function(A, -7)
22

julia&gt; G = abelian_group(ZZMatrix([1 -1]));

julia&gt; g = gen(G, 1);

julia&gt; W = [g, g, g, g];

julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;], W);

julia&gt; A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));

julia&gt; multi_hilbert_function(A, 7*g)
22</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/11aeb1883c1ff5e5a1e291eb988020f05623642b/src/Rings/mpoly-affine-algebras.jl#L627-L685">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ideals/">Â« Ideals in Multivariate Rings</a><a class="docs-footer-nextpage" href="../localizations/">Localized Rings and Their Ideals Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 18 April 2023 06:47">Tuesday 18 April 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
