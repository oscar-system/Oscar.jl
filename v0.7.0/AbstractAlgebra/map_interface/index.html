<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Map interface · Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to Oscar</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6" type="checkbox"/><label class="tocitem" for="menuitem-3-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../series/">Power series</a></li><li><a class="tocitem" href="../puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../module/">Finitely presented modules</a></li><li><a class="tocitem" href="../free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../submodule/">Submodules</a></li><li><a class="tocitem" href="../quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Basics</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Quadratic and hermitian lattices</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/serialization/">Saving and loading</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/visualization/">Visualization</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/rings/">Creating Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ideals/">Ideals in Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/free_modules/">Free Modules Over Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/modules/">Modules Over Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/affine_algebras/">Affine Algebras</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/binomial_ideals/">Binomial Primary Decomposition</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/localizations/">Localizations of commutative rings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-10-1" type="checkbox"/><label class="tocitem" for="menuitem-10-1"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ToricVarieties/intro/">Toric geometry in Julia</a></li><li><a class="tocitem" href="../../ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisors/">Toric Divisors</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/graphs/">Graphs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Map interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Map interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/AbstractAlgebra/map_interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Map-interface"><a class="docs-heading-anchor" href="#Map-interface">Map interface</a><a id="Map-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Map-interface" title="Permalink"></a></h1><p>Maps in AbstractAlgebra can be constructed from Julia functions, or they can be represented by some other kind of data, e.g. a matrix, or built up from other maps.</p><p>In the following, we will always use the word &quot;function&quot; to mean a Julia function, and reserve the word &quot;map&quot; for a map on sets, whether mathematically, or as an object in the system.</p><h2 id="Parent-objects"><a class="docs-heading-anchor" href="#Parent-objects">Parent objects</a><a id="Parent-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-objects" title="Permalink"></a></h2><p>Maps in AbstractAlgebra currently don&#39;t have parents. This will change later when AbstractAlgebra has a category system, so that the parent of a map can be some sort of Hom set.</p><h2 id="Map-classes"><a class="docs-heading-anchor" href="#Map-classes">Map classes</a><a id="Map-classes-1"></a><a class="docs-heading-anchor-permalink" href="#Map-classes" title="Permalink"></a></h2><p>All maps in AbstractAlgebra belong to a class of maps. The classes are modeled as abstract types that lie in a hierarchy, inheriting from <code>SetMap</code> at the top of the hierarchy. Other classes that inherit from <code>SetMap</code> are <code>FunctionalMap</code> for maps that are constructed from a Julia function (or closure), and <code>IdentityMap</code> for the class of the identity maps within the system.</p><p>One might naturally assume that map types belong directly to these classes in the way that types of other objects in the system belong to abstract types in the AbstractAlgebra type hierarchy. However, in order to provide an extensible system, this is not the case.</p><p>Instead, a map type <code>MyMap</code> will belong to an abstract type of the form <code>Map{D, C, T, MyMap}</code>, where <code>D</code> is the type of the object representing the domain of the map type (this can also be an abstract type, such as <code>Group</code>), <code>C</code> is the type of the object representing the codomain of the map type and <code>T</code> is the map class that <code>MyMap</code> belongs to, e.g. <code>SetMap</code> or <code>FunctionalMap</code>.</p><p>Because a four parameter type system becomes quite cumbersome to use, we provide a number of functions for referring to collections of map types.</p><p>If writing a function that accepts any map type, one makes the type of its argument belong to <code>Map</code>. For example <code>f(M::Map) = 1</code>.</p><p>If writing a function that accepts any map from a domain of type <code>D</code> to a codomain of type <code>C</code>, one makes writes for example <code>f(M::Map{D, C}) = 2</code>. Note that <code>D</code> and <code>C</code> can be abstract types, such as <code>Group</code>, but otherwise must be the types of the parent objects representing the domain and codomain.</p><p>A function that accepts any map belonging to a given map class might be written as <code>f(M::Map(FunctionalMap)) = 3</code> or <code>f(M::Map(FunctionalMap){D, C}) = 4</code> for example, where <code>D</code> and <code>C</code> are the types of the parent objects for the domain and codomain.</p><p>Finally, if a function should only work for a map of a given map type <code>MyMap</code>, say, one writes this <code>f(M::Map(MyMap))</code> or <code>f(M::Map(MyMap){D, C}</code>, where as usual <code>D</code> and <code>C</code> are the types of the domain and codomain parent objects.</p><h2 id="Implementing-new-map-types"><a class="docs-heading-anchor" href="#Implementing-new-map-types">Implementing new map types</a><a id="Implementing-new-map-types-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-new-map-types" title="Permalink"></a></h2><p>There are two common kinds of map type that developers will need to write. The first has a fixed domain and codomain, and the second is a type parameterised by the types of the domain and codomain. We give two simple examples here of how this might look.</p><p>In the case of fixed domain and codomain, e.g. <code>Integers{BigInt}</code>, we would write it as follows:</p><pre><code class="language-julia hljs">mutable struct MyMap &lt;: Map{Integers{BigInt}, Integers{BigInt}, SetMap, MyMap}
   # some data fields
end</code></pre><p>In the case of parameterisation by the type of the domain and codomain:</p><pre><code class="language-julia hljs">mutable struct MyMap{D, C} &lt;: Map{D, C, SetMap, MyMap}
   # some data fields
end</code></pre><p>As mentioned above, to write a function that only accepts maps of type <code>MyMap</code>, one writes the functions as follows:</p><pre><code class="language-julia hljs">function my_fun(M::Map(MyMap))</code></pre><p>The <code>Map</code> function then computes the correct type to use, which is actually not <code>MyMap</code> if all features of the generic Map infrastructure are required. It is bad practice to write functions for <code>MyMap</code> directly instead of <code>Map(MyMap)</code>, since other users will be unable to use generic constructions over the map type <code>MyMap</code>.</p><h2 id="Getters-and-setters"><a class="docs-heading-anchor" href="#Getters-and-setters">Getters and setters</a><a id="Getters-and-setters-1"></a><a class="docs-heading-anchor-permalink" href="#Getters-and-setters" title="Permalink"></a></h2><p>When writing new map types, it is very important to define getters and setters of the fields of the new map type, rather than to access them directly.</p><p>Let us suppose that the <code>MyMap</code> type has a field called <code>foo</code>. Rather than access this field by writing <code>M.foo</code>, one must access it using <code>foo(M)</code> (at least until Julia 1.1).</p><p>If such a getter only needs to access the field <code>foo</code> of <code>M</code>, there is a standard way of defining such a getter and setter when defining a new map type.</p><pre><code class="language-julia hljs">foo(M::Map(MyMap)) = get_field(M, :foo)</code></pre><p>To set a field of a map, one needs a setter, which can be implemented as follows:</p><pre><code class="language-julia hljs">set_foo!(M::Map(MyMap), a) = set_field(M, :foo, a)</code></pre><p>In general, setters should be used rarely for map types.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By providing getter and setter functions, map types need not even contain fields with the given name. For example, for a <code>MyMap</code> map type for maps between integers, one does not wish to explicitly store the domain and codomain in <code>MyMap</code>. Instead, we can define the getter functions <code>domain</code> and <code>codomain</code> to return <code>JuliaZZ</code> for any <code>MyMap</code> object.</p></div></div><pre><code class="language-julia hljs">domain(M::Map(MyMap)) = JuliaZZ
codomain(M::Map(MyMap)) = JuliaZZ</code></pre><h2 id="Required-functionality-for-maps"><a class="docs-heading-anchor" href="#Required-functionality-for-maps">Required functionality for maps</a><a id="Required-functionality-for-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Required-functionality-for-maps" title="Permalink"></a></h2><p>All map types must implement a standard interface, which we specify here.</p><p>We will define this interface for a custom map type <code>MyMap</code> belonging to <code>Map(SetMap)</code>, <code>SetMap</code> being the map class that all maps types belong to.</p><p>Note that map types do not need to contain any specific fields, but must provide accessor functions (getters and setters) in the manner described above.</p><p>The required accessors for map types of class <code>SetMap</code> are as follows.</p><pre><code class="language-julia hljs">domain(M::Map(MyMap))
codomain(M::Map(MyMap))</code></pre><p>Return the domain and codomain parent objects respectively, for the map <span>$M$</span>. It is only necessary to define these functions if the map type <code>MyMap</code> does not contain fields <code>domain</code> and <code>codomain</code> containing these parent objects.</p><p>It is also necessary to be able to apply a map. This amounts to overloading the call method for objects belonging to <code>Map(MyMap)</code>.</p><pre><code class="language-julia hljs">(M::Map(MyMap)(a))</code></pre><p>Apply the map <code>M</code> to the element <code>a</code> of the domain of <code>M</code>. Note that it is usual to add a type assertion to the return value of this function, asserting that the return value has type <code>elem_type(C)</code> where <code>C</code> is the type of the codomain parent object.</p><h2 id="Optional-functionality-for-maps"><a class="docs-heading-anchor" href="#Optional-functionality-for-maps">Optional functionality for maps</a><a id="Optional-functionality-for-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-functionality-for-maps" title="Permalink"></a></h2><p>The Generic module in AbstractAlgebra automatically provides certain functionality for map types, assuming that they satisfy the full interface described above.</p><p>However, certain map types or map classes might like to provide their own implementation of this functionality, overriding the generic functionality.</p><p>We describe this optional functionality here.</p><h3 id="Show-method"><a class="docs-heading-anchor" href="#Show-method">Show method</a><a id="Show-method-1"></a><a class="docs-heading-anchor-permalink" href="#Show-method" title="Permalink"></a></h3><p>Custom map types may like to provide a custom <code>show</code> method if the default of displaying the domain and codomain of the map is not sufficient.</p><pre><code class="language-julia hljs">show(io::IO, M::Map(MyMap))</code></pre><h3 id="Identity-maps"><a class="docs-heading-anchor" href="#Identity-maps">Identity maps</a><a id="Identity-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Identity-maps" title="Permalink"></a></h3><p>There is a concrete map type <code>Generic.IdentityMap{D}</code> for the identity map on a given domain. Here <code>D</code> is the type of the object representing that domain.</p><p><code>Generic.IdentityMap</code> belongs to the supertype <code>Map{D, C, AbstractAlgebra.IdentityMap, IdentityMap}</code>.</p><p>Note that the map class is also called <code>IdentityMap</code>. It is an abstract type, whereas <code>Generic.IdentityMap</code> is a concrete type in the Generic module.</p><p>An identity map has the property that when composed with any map whose domain or codomain is compatible, that map will be returned as the composition. Identity maps can therefore serve as a starting point when building up a composition of maps, starting an identity map.</p><p>We do not cached identity maps in the system, so that if more than one is created on the same domain, there will be more than one such map in the system. This underscores the fact that there is in general no way for the system to know if two maps compose to give an identity map, and therefore the only two maps that can be composed to give an identity map are identity maps on the same domain.</p><p>To construct an identity map for a given domain, specified by a parent object <code>R</code>, say, we have the following function.</p><pre><code class="language-julia hljs">identity_map(R::Set)</code></pre><p>Return an identity map on the domain <span>$R$</span>.</p><p>Of course there is nothing stopping a map type or class from implementing its own identity map type, and defining composition of maps of the same kind with such an identity map. In such a case, the class of such an identity map type must belong to <code>IdentityMap</code> so that composition with other map types still works.</p><h3 id="Composition-of-maps"><a class="docs-heading-anchor" href="#Composition-of-maps">Composition of maps</a><a id="Composition-of-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Composition-of-maps" title="Permalink"></a></h3><p>Any two compatible maps in AbstractAlgebra can be composed and any composition can be applied.</p><p>In order to facilitate this, the Generic module provides a type <code>Generic.CompositeMap{D, C}</code>, which contains two maps <code>map1</code> and <code>map2</code>, corresponding to the two maps to be applied in a composition, in the order they should be applied.</p><p>To construct a composition map from two existing maps, we have the following function:</p><pre><code class="language-julia hljs">compose(f::Map{D, U}, g::Map{U, C}) where {D, U, C}</code></pre><p>Compose the two maps <span>$f$</span> and <span>$g$</span>, i.e. return the map <span>$h$</span> such that <span>$h(x) = g(f(x))$</span>.</p><p>As a shortcut for this function we have the following operator:</p><pre><code class="language-julia hljs">*(f::Map{D, U}, g::Map{U, C}) where {D, U, C} = compose(f, g)</code></pre><p>Note the order of composition. If we have maps <span>$f : X \to Y$</span>, <span>$g : Y \to Z$</span> the correct order of the maps in this operator is <code>f*g</code>, so that <code>(f*g)(x) = g(f(x))</code>.</p><p>This is chosen so that for left <span>$R$</span>-module morphisms represented by a matrix, the order of matrix multiplication will match the order of composition of the corresponding morphisms.</p><p>Of course, a custom map type or class of maps can implement its own composition type and compose function.</p><p>This is the case with the <code>FunctionalMap</code> class for example, which caches the Julia function/closure corresponding to the composition of two functional maps. As this cached function needs to be stored inside the composition, a special type is necessary for the composition of two functional maps.</p><p>By default, <code>compose</code> will check that the two maps are composable, i.e. the codomain of the first map matches the domain of the second map. This is implemented by the following function:</p><pre><code class="language-julia hljs">check_composable(f::Map{D, U}, g::Map{U, C})</code></pre><p>Raise an exception if the codomain of <span>$f$</span> doesn&#39;t match the domain of <span>$g$</span>.</p><p>Note that composite maps should keep track of the two maps they were constructed from. To access these maps, the following functions are provided:</p><pre><code class="language-julia hljs">map1(f::CompositeMap)
map2(f::CompositeMap)</code></pre><p>Any custom composite map type must also provide these functions for that map type, even if there exist fields with those names. This is because there is no common map class for all composite map types. Therefore the Generic system cannot provide fallbacks for all such composite map types.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 24 November 2021 01:11">Wednesday 24 November 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
